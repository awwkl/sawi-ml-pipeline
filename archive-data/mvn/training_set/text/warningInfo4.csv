STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/AbstractCoreMavenComponentTestCase.java,createMavenSession,145-145,[            project = projectBuilder.build( pom, configuration ).getProject();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/AbstractCoreMavenComponentTestCase.java,getLocalRepository,213-213,[        return repositorySystem.createLocalRepository( repoDir );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/AbstractCoreMavenComponentTestCase.java,getRemoteRepositories,199-199,[        return Arrays.asList( repositorySystem.buildArtifactRepository( repository ) );],,
CORRECTNESS,IL_INFINITE_RECURSIVE_LOOP,org/apache/maven/AbstractCoreMavenComponentTestCase.java,addDependency,324-324,[            return addDependency( groupId, artifactId, version, scope, exclusion );            ],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/maven/AbstractCoreMavenComponentTestCase.java,,313-357,[        {,             plugin = new Plugin();,             plugin.setGroupId( groupId );,             plugin.setArtifactId( artifactId );,             plugin.setVersion( version );                         ,         },                 ,         // Dependencies,         //,         public PluginBuilder addDependency( String groupId, String artifactId, String version, String scope, Exclusion exclusion ),         {,             return addDependency( groupId, artifactId, version, scope, exclusion );            ,         }, ,         public PluginBuilder addDependency( String groupId, String artifactId, String version, String scope, String systemPath ),         {,             return addDependency( groupId, artifactId, version, scope, systemPath, null );         ,         },         ,         public PluginBuilder addDependency( String groupId, String artifactId, String version, String scope, String systemPath, Exclusion exclusion ),         {,             Dependency d = new Dependency();,             d.setGroupId( groupId );,             d.setArtifactId( artifactId );,             d.setVersion( version );,             d.setScope( scope );,             ,             if ( systemPath != null && scope.equals(  Artifact.SCOPE_SYSTEM ) ),             {,                 d.setSystemPath( systemPath );,             },             ,             if ( exclusion != null ),             {,                 d.addExclusion( exclusion );,             },             ,             plugin.getDependencies().add( d );,             ,             return this;,         },                 ,         public Plugin get(),         {,             return plugin;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/maven/AbstractCoreMavenComponentTestCase.java,,221-304,[        {,             this.project = project;,         }, ,         public ProjectBuilder( String groupId, String artifactId, String version ),         {,             Model model = new Model();,             model.setModelVersion( "4.0.0" );,             model.setGroupId( groupId );,             model.setArtifactId( artifactId );,             model.setVersion( version );  ,             model.setBuild(  new Build() );,             project = new MavenProject( model );            ,         },         ,         public ProjectBuilder setGroupId( String groupId ),         {,             project.setGroupId( groupId );,             return this;,         }, ,         public ProjectBuilder setArtifactId( String artifactId ),         {,             project.setArtifactId( artifactId );,             return this;,         },         ,         public ProjectBuilder setVersion( String version ),         {,             project.setVersion( version );,             return this;,         },         ,         // Dependencies,         //,         public ProjectBuilder addDependency( String groupId, String artifactId, String version, String scope ),         {,             return addDependency( groupId, artifactId, version, scope, (Exclusion)null );,         },         ,         public ProjectBuilder addDependency( String groupId, String artifactId, String version, String scope, Exclusion exclusion ),         {,             return addDependency( groupId, artifactId, version, scope, null, exclusion );            ,         }, ,         public ProjectBuilder addDependency( String groupId, String artifactId, String version, String scope, String systemPath ),         {,             return addDependency( groupId, artifactId, version, scope, systemPath, null );         ,         },         ,         public ProjectBuilder addDependency( String groupId, String artifactId, String version, String scope, String systemPath, Exclusion exclusion ),         {,             Dependency d = new Dependency();,             d.setGroupId( groupId );,             d.setArtifactId( artifactId );,             d.setVersion( version );,             d.setScope( scope );,             ,             if ( systemPath != null && scope.equals(  Artifact.SCOPE_SYSTEM ) ),             {,                 d.setSystemPath( systemPath );,             },             ,             if ( exclusion != null ),             {,                 d.addExclusion( exclusion );,             },             ,             project.getDependencies().add( d );,             ,             return this;,         },         ,         // Plugins,         //,         public ProjectBuilder addPlugin( Plugin plugin ),         {,             project.getBuildPlugins().add( plugin );            ,             return this;,         },         ,         public MavenProject get(),         {,             return project;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/maven/DefaultMaven.java,getMavenVersion,477-477,[        InputStream is = getClass().getResourceAsStream( "/META-INF/maven/org.apache.maven/maven-core/pom.properties" );],,getMavenVersion,478-478,[        if ( is != null )],,getMavenVersion,482-482,[                props.load( is );],,getMavenVersion,484-484,[            catch ( IOException e )],,getMavenVersion,486-486,[                logger.debug( "Failed to read Maven version", e );],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/DefaultMaven.java,validateLocalRepository,501-501,[        localRepoDir.mkdirs();],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/maven/DefaultMaven.java,getMavenVersion,477-477,[        InputStream is = getClass().getResourceAsStream( "/META-INF/maven/org.apache.maven/maven-core/pom.properties" );],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/maven/MavenTest.java,,36-36,[        exceptionHandler = lookup( ExceptionHandler.class );],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/maven/MavenTest.java,,35-35,[        maven = lookup( Maven.class );],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/maven/ProjectBuildFailureException.java,getMojoFailureException,48-48,[        return (MojoFailureException) getCause();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/ProjectDependenciesResolverTest.java,testSystemScopeDependencies,89-89,[            resolver.resolve( project, Collections.singleton( Artifact.SCOPE_COMPILE ), session );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/ProjectDependenciesResolverTest.java,testSystemScopeDependencyIsPresentInTheCompileClasspathElements,104-104,[        project.setArtifacts( resolver.resolve( project, Collections.singleton( Artifact.SCOPE_COMPILE ), session ) );],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/maven/artifact/AbstractArtifactComponentTestCase.java,createArtifact,292-292,[        Writer writer = new OutputStreamWriter( new FileOutputStream( artifactFile ), "ISO-8859-1" );],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/AbstractArtifactComponentTestCase.java,badLocalRepository,121-121,[        f.createNewFile();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/AbstractArtifactComponentTestCase.java,createArtifact,289-289,[            artifactFile.getParentFile().mkdirs();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/artifact/AbstractArtifactComponentTestCase.java,createArtifact,314-314,[        Artifact a = artifactFactory.createBuildArtifact( groupId, artifactId, version, type );],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/maven/artifact/ArtifactStatus.java,<init>,74-76,[        if ( map == null ),         {,             map = new HashMap<String, ArtifactStatus>();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/artifact/DefaultArtifactTest.java,testGetVersionReturnsResolvedVersionOnSnapshot,60-60,[        assertEquals( snapshotResolvedVersion, snapshotArtifact.getVersion() );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/artifact/deployer/ArtifactDeployerTest.java,testArtifactInstallation,60-60,[        artifactDeployer.deploy( file, artifact, remoteRepository(), localRepository() );],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/maven/artifact/handler/DefaultArtifactHandler.java,,78-78,[        return classifier;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/artifact/installer/ArtifactInstallerTest.java,testArtifactInstallation,57-57,[        artifactInstaller.install( source, artifact, localRepository() );],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/maven/artifact/manager/DefaultWagonManager.java,,46-179,[public class DefaultWagonManager,     extends org.apache.maven.repository.legacy.DefaultWagonManager,     implements WagonManager, {, ,     // NOTE: This must use a different field name than in the super class or IoC has no chance to inject the loggers,     @Requirement,     private Logger log;, ,     @Requirement,     private LegacySupport legacySupport;, ,     @Requirement,     private SettingsDecrypter settingsDecrypter;, ,     @Requirement,     private MirrorSelector mirrorSelector;, ,     @Requirement,     private ArtifactRepositoryFactory artifactRepositoryFactory;, ,     public AuthenticationInfo getAuthenticationInfo( String id ),     {,         MavenSession session = legacySupport.getSession();, ,         if ( session != null && id != null ),         {,             MavenExecutionRequest request = session.getRequest();, ,             if ( request != null ),             {,                 List<Server> servers = request.getServers();, ,                 if ( servers != null ),                 {,                     for ( Server server : servers ),                     {,                         if ( id.equalsIgnoreCase( server.getId() ) ),                         {,                             SettingsDecryptionResult result =,                                 settingsDecrypter.decrypt( new DefaultSettingsDecryptionRequest( server ) );,                             server = result.getServer();, ,                             AuthenticationInfo authInfo = new AuthenticationInfo();,                             authInfo.setUserName( server.getUsername() );,                             authInfo.setPassword( server.getPassword() );,                             authInfo.setPrivateKey( server.getPrivateKey() );,                             authInfo.setPassphrase( server.getPassphrase() );, ,                             return authInfo;,                         },                     },                 },             },         }, ,         // empty one to prevent NPE,        return new AuthenticationInfo();,     }, ,     public ProxyInfo getProxy( String protocol ),     {,         MavenSession session = legacySupport.getSession();, ,         if ( session != null && protocol != null ),         {,             MavenExecutionRequest request = session.getRequest();, ,             if ( request != null ),             {,                 List<Proxy> proxies = request.getProxies();, ,                 if ( proxies != null ),                 {,                     for ( Proxy proxy : proxies ),                     {,                         if ( proxy.isActive() && protocol.equalsIgnoreCase( proxy.getProtocol() ) ),                         {,                             SettingsDecryptionResult result =,                                 settingsDecrypter.decrypt( new DefaultSettingsDecryptionRequest( proxy ) );,                             proxy = result.getProxy();, ,                             ProxyInfo proxyInfo = new ProxyInfo();,                             proxyInfo.setHost( proxy.getHost() );,                             proxyInfo.setType( proxy.getProtocol() );,                             proxyInfo.setPort( proxy.getPort() );,                             proxyInfo.setNonProxyHosts( proxy.getNonProxyHosts() );,                             proxyInfo.setUserName( proxy.getUsername() );,                             proxyInfo.setPassword( proxy.getPassword() );, ,                             return proxyInfo;,                         },                     },                 },             },         }, ,         return null;,     }, ,     public void getArtifact( Artifact artifact, ArtifactRepository repository ),         throws TransferFailedException, ResourceDoesNotExistException,     {,         getArtifact( artifact, repository, null, false );,     }, ,     public void getArtifact( Artifact artifact, List<ArtifactRepository> remoteRepositories ),         throws TransferFailedException, ResourceDoesNotExistException,     {,         getArtifact( artifact, remoteRepositories, null, false );,     }, ,     @Deprecated,     public ArtifactRepository getMirrorRepository( ArtifactRepository repository ),     {, ,         Mirror mirror = mirrorSelector.getMirror( repository, legacySupport.getSession().getSettings().getMirrors() );, ,         if ( mirror != null ),         {,             String id = mirror.getId();,             if ( id == null ),             {,                 // TODO: this should be illegal in settings.xml,                 id = repository.getId();,             }, ,             log.debug( "Using mirror: " + mirror.getUrl() + " (id: " + id + ")" );, ,             repository = artifactRepositoryFactory.createArtifactRepository( id, mirror.getUrl(),,                                                                      repository.getLayout(), repository.getSnapshots(),,                                                                      repository.getReleases() );,         },         return repository;],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/maven/artifact/manager/WagonConfigurationException.java,,31-37,[        super( repositoryId, message, cause );,     }, ,     public WagonConfigurationException( String repositoryId, String message ),     {,         super( repositoryId, message );,     }],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/maven/artifact/metadata/AbstractArtifactMetadata.java,,31-32,[        super( artifact );,     }],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/maven/artifact/metadata/ArtifactMetadataRetrievalException.java,,33-54,[        super( message, null, null );,     }, ,     /** @deprecated use {@link #ArtifactMetadataRetrievalException(String, Throwable, Artifact)} */,     @Deprecated,     public ArtifactMetadataRetrievalException( Throwable cause ),     {,         super( null, cause, null );,     }, ,     /** @deprecated use {@link #ArtifactMetadataRetrievalException(String, Throwable, Artifact)} */,     @Deprecated,     public ArtifactMetadataRetrievalException( String message,,                                                Throwable cause ),     {,         super( message, cause, null );,     }, ,     public ArtifactMetadataRetrievalException( String message, Throwable cause, Artifact artifact ),     {,         super( message, cause, artifact );,     }],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/maven/artifact/metadata/ResolutionGroup.java,,37-44,[        super( pomArtifact, artifacts, resolutionRepositories );,     }, ,     public ResolutionGroup( Artifact pomArtifact, Artifact relocatedArtifact, Set<Artifact> artifacts,,                             Map<String, Artifact> managedVersions, List<ArtifactRepository> resolutionRepositories ),     {,         super( pomArtifact, relocatedArtifact, artifacts, managedVersions, resolutionRepositories );,     }],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/artifact/repository/ArtifactRepositoryPolicy.java,checkOutOfDate,141-141,[            int minutes = Integer.valueOf( s );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/artifact/repository/ArtifactRepositoryPolicy.java,ordinalOfUpdatePolicy,214-214,[            return Integer.valueOf( s );],,
BAD_PRACTICE,NM_CONFUSING,org/apache/maven/artifact/repository/Authentication.java,getUsername,72-72,[        return username;],,getUserName,137-137,[        return userName;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/maven/artifact/repository/Authentication.java,setUsername,82-83,[        this.username = userName;,     }],,setUserName,147-148,[        this.userName = userName;,     }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/maven/artifact/repository/MavenArtifactRepository.java,equals,327-342,[        if ( this == obj ),         {,             return true;,         },         if ( obj == null ),         {,             return false;,         },         if ( getClass() != obj.getClass() ),         {,             return false;,         }, ,         ArtifactRepository other = (ArtifactRepository) obj;, ,         return eq( getId(), other.getId() );],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java,merge,202-202,[        AbstractRepositoryMetadata repoMetadata = (AbstractRepositoryMetadata) metadata;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java,merge,195-195,[        AbstractRepositoryMetadata repoMetadata = (AbstractRepositoryMetadata) metadata;],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java,updateRepositoryMetadata,94-94,[            metadataFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java,updateRepositoryMetadata,140-140,[                metadataFile.getParentFile().mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java,updateRepositoryMetadata,154-154,[            metadataFile.setLastModified( System.currentTimeMillis() );],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java,getArtifactMetadataFromDeploymentRepository,451-451,[                file.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java,resolve,144-144,[                            file.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java,resolve,163-163,[                    file.setLastModified( System.currentTimeMillis() );],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java,updateSnapshotMetadata,228-228,[                Metadata m = previousMetadata.get( repository );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/artifact/repository/metadata/Metadata.java,,13-383,[@SuppressWarnings( "all" ), public class Metadata,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The version of the underlying metadata model.,      */,     private String modelVersion;, ,     /**,      * The groupId that this directory represents, if any.,      */,     private String groupId;, ,     /**,      * The artifactId that this directory represents, if any.,      */,     private String artifactId;, ,     /**,      * The version that this directory represents, if any. It is,      * used for artifact snapshots only.,      */,     private String version;, ,     /**,      * Versioning information for the artifact.,      */,     private Versioning versioning;, ,     /**,      * Field plugins.,      */,     private java.util.List<Plugin> plugins;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addPlugin.,      * ,      * @param plugin,      */,     public void addPlugin( Plugin plugin ),     {,         getPlugins().add( plugin );,     } //-- void addPlugin( Plugin ), ,     /**,      * Method clone.,      * ,      * @return Metadata,      */,     public Metadata clone(),     {,         try,         {,             Metadata copy = (Metadata) super.clone();, ,             if ( this.versioning != null ),             {,                 copy.versioning = (Versioning) this.versioning.clone();,             }, ,             if ( this.plugins != null ),             {,                 copy.plugins = new java.util.ArrayList<Plugin>();,                 for ( Plugin item : this.plugins ),                 {,                     copy.plugins.add( ( (Plugin) item).clone() );,                 },             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Metadata clone(), ,     /**,      * Get the artifactId that this directory represents, if any.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get the groupId that this directory represents, if any.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Get the version of the underlying metadata model.,      * ,      * @return String,      */,     public String getModelVersion(),     {,         return this.modelVersion;,     } //-- String getModelVersion(), ,     /**,      * Method getPlugins.,      * ,      * @return List,      */,     public java.util.List<Plugin> getPlugins(),     {,         if ( this.plugins == null ),         {,             this.plugins = new java.util.ArrayList<Plugin>();,         }, ,         return this.plugins;,     } //-- java.util.List<Plugin> getPlugins(), ,     /**,      * Get the version that this directory represents, if any. It,      * is used for artifact snapshots only.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Get versioning information for the artifact.,      * ,      * @return Versioning,      */,     public Versioning getVersioning(),     {,         return this.versioning;,     } //-- Versioning getVersioning(), ,     /**,      * Method removePlugin.,      * ,      * @param plugin,      */,     public void removePlugin( Plugin plugin ),     {,         getPlugins().remove( plugin );,     } //-- void removePlugin( Plugin ), ,     /**,      * Set the artifactId that this directory represents, if any.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set the groupId that this directory represents, if any.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String ), ,     /**,      * Set the version of the underlying metadata model.,      * ,      * @param modelVersion,      */,     public void setModelVersion( String modelVersion ),     {,         this.modelVersion = modelVersion;,     } //-- void setModelVersion( String ), ,     /**,      * Set the set of plugin mappings for the group represented by,      * this directory.,      * ,      * @param plugins,      */,     public void setPlugins( java.util.List<Plugin> plugins ),     {,         this.plugins = plugins;,     } //-- void setPlugins( java.util.List ), ,     /**,      * Set the version that this directory represents, if any. It,      * is used for artifact snapshots only.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     /**,      * Set versioning information for the artifact.,      * ,      * @param versioning,      */,     public void setVersioning( Versioning versioning ),     {,         this.versioning = versioning;,     } //-- void setVersioning( Versioning ), ,     ,     public boolean merge( Metadata sourceMetadata ),     {,         boolean changed = false;, ,         for ( Plugin plugin : sourceMetadata.getPlugins() ),         {,             boolean found = false;, ,             for ( Plugin preExisting : getPlugins() ),             {,                 if ( preExisting.getPrefix().equals( plugin.getPrefix() ) ),                 {,                     found = true;,                     break;,                 },             }, ,             if ( !found ),             {,                 Plugin mappedPlugin = new Plugin();, ,                 mappedPlugin.setArtifactId( plugin.getArtifactId() );, ,                 mappedPlugin.setPrefix( plugin.getPrefix() );, ,                 mappedPlugin.setName( plugin.getName() );, ,                 addPlugin( mappedPlugin );, ,                 changed = true;,             },         }, ,         Versioning versioning = sourceMetadata.getVersioning();,         if ( versioning != null ),         {,             Versioning v = getVersioning();,             if ( v == null ),             {,                 v = new Versioning();,                 setVersioning( v );,                 changed = true;,             }, ,             for ( String version : versioning.getVersions() ),             {,                 if ( !v.getVersions().contains( version ) ),                 {,                     changed = true;,                     v.getVersions().add( version );,                 },             }, ,             if ( "null".equals( versioning.getLastUpdated() ) ),             {,                 versioning.setLastUpdated( null );,             }, ,             if ( "null".equals( v.getLastUpdated() ) ),             {,                 v.setLastUpdated( null );,             }, ,             if ( versioning.getLastUpdated() == null || versioning.getLastUpdated().length() == 0 ),             {,                 // this should only be for historical reasons - we assume local is newer,                 versioning.setLastUpdated( v.getLastUpdated() );,             }, ,             if ( v.getLastUpdated() == null || v.getLastUpdated().length() == 0,                  || versioning.getLastUpdated().compareTo( v.getLastUpdated() ) >= 0 ),             {,                 changed = true;,                 v.setLastUpdated( versioning.getLastUpdated() );, ,                 if ( versioning.getRelease() != null ),                 {,                     changed = true;,                     v.setRelease( versioning.getRelease() );,                 },                 if ( versioning.getLatest() != null ),                 {,                     changed = true;,                     v.setLatest( versioning.getLatest() );,                 }, ,                 Snapshot s = v.getSnapshot();,                 Snapshot snapshot = versioning.getSnapshot();,                 if ( snapshot != null ),                 {,                     if ( s == null ),                     {,                         s = new Snapshot();,                         v.setSnapshot( s );,                         changed = true;,                     }, ,                     // overwrite,                     if ( s.getTimestamp() == null ? snapshot.getTimestamp() != null,                         : !s.getTimestamp().equals( snapshot.getTimestamp() ) ),                     {,                         s.setTimestamp( snapshot.getTimestamp() );,                         changed = true;,                     },                     if ( s.getBuildNumber() != snapshot.getBuildNumber() ),                     {,                         s.setBuildNumber( snapshot.getBuildNumber() );,                         changed = true;,                     },                     if ( s.isLocalCopy() != snapshot.isLocalCopy() ),                     {,                         s.setLocalCopy( snapshot.isLocalCopy() );,                         changed = true;,                     },                 },             },         },         return changed;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/artifact/repository/metadata/Plugin.java,,13-123,[@SuppressWarnings( "all" ), public class Plugin,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Display name for the plugin.,      */,     private String name;, ,     /**,      * The plugin invocation prefix (i.e. eclipse for,      * eclipse:eclipse).,      */,     private String prefix;, ,     /**,      * The plugin artifactId.,      */,     private String artifactId;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Plugin,      */,     public Plugin clone(),     {,         try,         {,             Plugin copy = (Plugin) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Plugin clone(), ,     /**,      * Get the plugin artifactId.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get display name for the plugin.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the plugin invocation prefix (i.e. eclipse for,      * eclipse:eclipse).,      * ,      * @return String,      */,     public String getPrefix(),     {,         return this.prefix;,     } //-- String getPrefix(), ,     /**,      * Set the plugin artifactId.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set display name for the plugin.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the plugin invocation prefix (i.e. eclipse for,      * eclipse:eclipse).,      * ,      * @param prefix,      */,     public void setPrefix( String prefix ),     {,         this.prefix = prefix;,     } //-- void setPrefix( String )],,
BAD_PRACTICE,NM_CLASS_NOT_EXCEPTION,org/apache/maven/artifact/repository/metadata/RepositoryMetadataDeploymentException.java,,32-39,[        super( message );,     }, ,     public RepositoryMetadataDeploymentException( String message,,                                                   Exception e ),     {,         super( message, e );,     }],,
BAD_PRACTICE,NM_CLASS_NOT_EXCEPTION,org/apache/maven/artifact/repository/metadata/RepositoryMetadataInstallationException.java,,32-39,[        super( message );,     }, ,     public RepositoryMetadataInstallationException( String message,,                                                     Exception e ),     {,         super( message, e );,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/artifact/repository/metadata/Snapshot.java,,13-123,[@SuppressWarnings( "all" ), public class Snapshot,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The time it was deployed.,      */,     private String timestamp;, ,     /**,      * The incremental build number.,      */,     private int buildNumber = 0;, ,     /**,      * Whether to use a local copy instead (with filename that,      * includes the base version).,      */,     private boolean localCopy = false;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Snapshot,      */,     public Snapshot clone(),     {,         try,         {,             Snapshot copy = (Snapshot) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Snapshot clone(), ,     /**,      * Get the incremental build number.,      * ,      * @return int,      */,     public int getBuildNumber(),     {,         return this.buildNumber;,     } //-- int getBuildNumber(), ,     /**,      * Get the time it was deployed.,      * ,      * @return String,      */,     public String getTimestamp(),     {,         return this.timestamp;,     } //-- String getTimestamp(), ,     /**,      * Get whether to use a local copy instead (with filename that,      * includes the base version).,      * ,      * @return boolean,      */,     public boolean isLocalCopy(),     {,         return this.localCopy;,     } //-- boolean isLocalCopy(), ,     /**,      * Set the incremental build number.,      * ,      * @param buildNumber,      */,     public void setBuildNumber( int buildNumber ),     {,         this.buildNumber = buildNumber;,     } //-- void setBuildNumber( int ), ,     /**,      * Set whether to use a local copy instead (with filename that,      * includes the base version).,      * ,      * @param localCopy,      */,     public void setLocalCopy( boolean localCopy ),     {,         this.localCopy = localCopy;,     } //-- void setLocalCopy( boolean ), ,     /**,      * Set the time it was deployed.,      * ,      * @param timestamp,      */,     public void setTimestamp( String timestamp ),     {,         this.timestamp = timestamp;,     } //-- void setTimestamp( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/artifact/repository/metadata/SnapshotVersion.java,,14-152,[@SuppressWarnings( "all" ), public class SnapshotVersion,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The classifier of the sub-artifact.,      */,     private String classifier = "";, ,     /**,      * The file extension of thesub-artifact.,      */,     private String extension;, ,     /**,      * The resolved snapshot version of the sub-artifact.,      */,     private String version;, ,     /**,      * The timestamp when this version information was last,      * updated. The timestamp is expressed using UTC in the format,      * yyyyMMddHHmmss.,      */,     private String updated;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return SnapshotVersion,      */,     public SnapshotVersion clone(),     {,         try,         {,             SnapshotVersion copy = (SnapshotVersion) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- SnapshotVersion clone(), ,     /**,      * Get the classifier of the sub-artifact.,      * ,      * @return String,      */,     public String getClassifier(),     {,         return this.classifier;,     } //-- String getClassifier(), ,     /**,      * Get the file extension of thesub-artifact.,      * ,      * @return String,      */,     public String getExtension(),     {,         return this.extension;,     } //-- String getExtension(), ,     /**,      * Get the timestamp when this version information was last,      * updated. The timestamp is expressed using UTC in the format,      * yyyyMMddHHmmss.,      * ,      * @return String,      */,     public String getUpdated(),     {,         return this.updated;,     } //-- String getUpdated(), ,     /**,      * Get the resolved snapshot version of the sub-artifact.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Set the classifier of the sub-artifact.,      * ,      * @param classifier,      */,     public void setClassifier( String classifier ),     {,         this.classifier = classifier;,     } //-- void setClassifier( String ), ,     /**,      * Set the file extension of thesub-artifact.,      * ,      * @param extension,      */,     public void setExtension( String extension ),     {,         this.extension = extension;,     } //-- void setExtension( String ), ,     /**,      * Set the timestamp when this version information was last,      * updated. The timestamp is expressed using UTC in the format,      * yyyyMMddHHmmss.,      * ,      * @param updated,      */,     public void setUpdated( String updated ),     {,         this.updated = updated;,     } //-- void setUpdated( String ), ,     /**,      * Set the resolved snapshot version of the sub-artifact.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/artifact/repository/metadata/Versioning.java,,14-291,[@SuppressWarnings( "all" ), public class Versioning,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * What the latest version in the directory is, including,      * snapshots.,      */,     private String latest;, ,     /**,      * What the latest version in the directory is, of the releases,      * only.,      */,     private String release;, ,     /**,      * The current snapshot data in use for this version (artifact,      * snapshots only).,      */,     private Snapshot snapshot;, ,     /**,      * Field versions.,      */,     private java.util.List<String> versions;, ,     /**,      * When the metadata was last updated.,      */,     private String lastUpdated;, ,     /**,      * Field snapshotVersions.,      */,     private java.util.List<SnapshotVersion> snapshotVersions;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addSnapshotVersion.,      * ,      * @param snapshotVersion,      */,     public void addSnapshotVersion( SnapshotVersion snapshotVersion ),     {,         getSnapshotVersions().add( snapshotVersion );,     } //-- void addSnapshotVersion( SnapshotVersion ), ,     /**,      * Method addVersion.,      * ,      * @param string,      */,     public void addVersion( String string ),     {,         getVersions().add( string );,     } //-- void addVersion( String ), ,     /**,      * Method clone.,      * ,      * @return Versioning,      */,     public Versioning clone(),     {,         try,         {,             Versioning copy = (Versioning) super.clone();, ,             if ( this.snapshot != null ),             {,                 copy.snapshot = (Snapshot) this.snapshot.clone();,             }, ,             if ( this.versions != null ),             {,                 copy.versions = new java.util.ArrayList<String>();,                 copy.versions.addAll( this.versions );,             }, ,             if ( this.snapshotVersions != null ),             {,                 copy.snapshotVersions = new java.util.ArrayList<SnapshotVersion>();,                 for ( SnapshotVersion item : this.snapshotVersions ),                 {,                     copy.snapshotVersions.add( ( (SnapshotVersion) item).clone() );,                 },             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Versioning clone(), ,     /**,      * Get when the metadata was last updated.,      * ,      * @return String,      */,     public String getLastUpdated(),     {,         return this.lastUpdated;,     } //-- String getLastUpdated(), ,     /**,      * Get what the latest version in the directory is, including,      * snapshots.,      * ,      * @return String,      */,     public String getLatest(),     {,         return this.latest;,     } //-- String getLatest(), ,     /**,      * Get what the latest version in the directory is, of the,      * releases only.,      * ,      * @return String,      */,     public String getRelease(),     {,         return this.release;,     } //-- String getRelease(), ,     /**,      * Get the current snapshot data in use for this version,      * (artifact snapshots only).,      * ,      * @return Snapshot,      */,     public Snapshot getSnapshot(),     {,         return this.snapshot;,     } //-- Snapshot getSnapshot(), ,     /**,      * Method getSnapshotVersions.,      * ,      * @return List,      */,     public java.util.List<SnapshotVersion> getSnapshotVersions(),     {,         if ( this.snapshotVersions == null ),         {,             this.snapshotVersions = new java.util.ArrayList<SnapshotVersion>();,         }, ,         return this.snapshotVersions;,     } //-- java.util.List<SnapshotVersion> getSnapshotVersions(), ,     /**,      * Method getVersions.,      * ,      * @return List,      */,     public java.util.List<String> getVersions(),     {,         if ( this.versions == null ),         {,             this.versions = new java.util.ArrayList<String>();,         }, ,         return this.versions;,     } //-- java.util.List<String> getVersions(), ,     /**,      * Method removeSnapshotVersion.,      * ,      * @param snapshotVersion,      */,     public void removeSnapshotVersion( SnapshotVersion snapshotVersion ),     {,         getSnapshotVersions().remove( snapshotVersion );,     } //-- void removeSnapshotVersion( SnapshotVersion ), ,     /**,      * Method removeVersion.,      * ,      * @param string,      */,     public void removeVersion( String string ),     {,         getVersions().remove( string );,     } //-- void removeVersion( String ), ,     /**,      * Set when the metadata was last updated.,      * ,      * @param lastUpdated,      */,     public void setLastUpdated( String lastUpdated ),     {,         this.lastUpdated = lastUpdated;,     } //-- void setLastUpdated( String ), ,     /**,      * Set what the latest version in the directory is, including,      * snapshots.,      * ,      * @param latest,      */,     public void setLatest( String latest ),     {,         this.latest = latest;,     } //-- void setLatest( String ), ,     /**,      * Set what the latest version in the directory is, of the,      * releases only.,      * ,      * @param release,      */,     public void setRelease( String release ),     {,         this.release = release;,     } //-- void setRelease( String ), ,     /**,      * Set the current snapshot data in use for this version,      * (artifact snapshots only).,      * ,      * @param snapshot,      */,     public void setSnapshot( Snapshot snapshot ),     {,         this.snapshot = snapshot;,     } //-- void setSnapshot( Snapshot ), ,     /**,      * Set information for each sub-artifact available in this,      * artifact snapshot.,      * ,      * @param snapshotVersions,      */,     public void setSnapshotVersions( java.util.List<SnapshotVersion> snapshotVersions ),     {,         this.snapshotVersions = snapshotVersions;,     } //-- void setSnapshotVersions( java.util.List ), ,     /**,      * Set versions available of the artifact (both releases and,      * snapshots).,      * ,      * @param versions,      */,     public void setVersions( java.util.List<String> versions ),     {,         this.versions = versions;,     } //-- void setVersions( java.util.List ), ,     ,     public void updateTimestamp(),     {,         setLastUpdatedTimestamp( new java.util.Date() );,     }, ,     public void setLastUpdatedTimestamp( java.util.Date date ),     {,         java.util.TimeZone timezone = java.util.TimeZone.getTimeZone( "UTC" );,         java.text.DateFormat fmt = new java.text.SimpleDateFormat( "yyyyMMddHHmmss" );,         fmt.setTimeZone( timezone );,         setLastUpdated( fmt.format( date ) );,     }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,parsePlugin,661-661,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,parseSnapshot,712-712,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,parseSnapshotVersion,763-763,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,parseVersioning,818-818,[            String value = parser.getAttributeValue( i );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getIntegerValue,368-368,[                return Integer.valueOf( s ).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getLongValue,398-398,[                return Long.valueOf( s ).longValue();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getBooleanValue,153-153,[        return getBooleanValue( s, attribute, parser, null );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getDateValue,241-241,[        return getDateValue( s, attribute, null, parser );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getByteValue,193-207,[        if ( s != null ),         {,             try,             {,                 return Byte.valueOf( s ).byteValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getCharacterValue,222-226,[        if ( s != null ),         {,             return s.charAt( 0 );,         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getDoubleValue,304-318,[        if ( s != null ),         {,             try,             {,                 return Double.valueOf( s ).doubleValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getFloatValue,334-348,[        if ( s != null ),         {,             try,             {,                 return Float.valueOf( s ).floatValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getLongValue,394-408,[        if ( s != null ),         {,             try,             {,                 return Long.valueOf( s ).longValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getRequiredAttributeValue,424-431,[        if ( s == null ),         {,             if ( strict ),             {,                 throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );,             },         },         return s;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Reader.java,getShortValue,447-461,[        if ( s != null ),         {,             try,             {,                 return Short.valueOf( s ).shortValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );,                 },             },         },         return 0;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Writer.java,writeMetadata,116-116,[        if ( ( metadata.getPlugins() != null ) && ( metadata.getPlugins().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Writer.java,writeVersioning,252-252,[        if ( ( versioning.getSnapshotVersions() != null ) && ( versioning.getSnapshotVersions().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/artifact/repository/metadata/io/xpp3/MetadataXpp3Writer.java,writeVersioning,238-238,[        if ( ( versioning.getVersions() != null ) && ( versioning.getVersions().size() > 0 ) )],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/artifact/resolver/ArtifactResolutionResult.java,getCircularDependencyException,292-292,[        return circularDependencyExceptions.get( i );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/artifact/resolver/ArtifactResolutionResult.java,getMetadataResolutionException,227-227,[        return metadataResolutionExceptions.get( i );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/artifact/resolver/ArtifactResolutionResult.java,getVersionRangeViolation,195-195,[        return (OverConstrainedVersionException) versionRangeViolations.get( i );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/artifact/resolver/ArtifactResolverTest.java,,194-230,[        {,             public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,,                                              List<ArtifactRepository> remoteRepositories ),                 throws ArtifactMetadataRetrievalException,             {,                 Set dependencies = new HashSet();, ,                 return new ResolutionGroup( artifact, dependencies, remoteRepositories );,             }, ,             public List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact,,                                                                     ArtifactRepository localRepository,,                                                                     List<ArtifactRepository> remoteRepositories ),                 throws ArtifactMetadataRetrievalException,             {,                 throw new UnsupportedOperationException( "Cannot get available versions in this test case" );,             }, ,             public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(,                                                                                             Artifact artifact,,                                                                                             ArtifactRepository localRepository,,                                                                                             ArtifactRepository remoteRepository ),                 throws ArtifactMetadataRetrievalException,             {,                 throw new UnsupportedOperationException( "Cannot get available versions in this test case" );,             }, ,             public ResolutionGroup retrieve( MetadataResolutionRequest request ),                 throws ArtifactMetadataRetrievalException,             {,                 return retrieve( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );,             }, ,             public List<ArtifactVersion> retrieveAvailableVersions( MetadataResolutionRequest request ),                 throws ArtifactMetadataRetrievalException,             {,                 return retrieveAvailableVersions( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/artifact/resolver/DefaultArtifactResolver.java,resolve,506-506,[        if ( result.getArtifactResolutionNodes() != null )],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/artifact/resolver/DefaultArtifactResolver.java,,108-112,[            {,                 public void execute( Runnable command ),                 {,                     command.run();,                 }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/artifact/resolver/DefaultArtifactResolverTest.java,testLookup,109-109,[        ArtifactResolver resolver = lookup( ArtifactResolver.class, "default" );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/artifact/resolver/DefaultArtifactResolverTest.java,testMNG4738,66-66,[        artifactResolver.resolveTransitively( Collections.singleton( g ), projectArtifact, remoteRepositories(),],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/maven/artifact/resolver/WarningResolutionListener.java,,38-38,[        this.logger = logger;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/artifact/resolver/filter/AndArtifactFilterTest.java,,40-43,[        {,             public boolean include( Artifact artifact ),             {,                 return false;],,
STYLE,NS_DANGEROUS_NON_SHORT_CIRCUIT,org/apache/maven/artifact/resolver/filter/IncludesArtifactFilter.java,include,50-50,[        for ( Iterator<String> i = patterns.iterator(); i.hasNext() & !matched; )],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/artifact/resolver/filter/OrArtifactFilterTest.java,,40-43,[        {,             public boolean include( Artifact artifact ),             {,                 return false;],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/testutils/TestFileManager.java,cleanUp,153-153,[                    file.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/testutils/TestFileManager.java,createFile,194-194,[        file.getParentFile().mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/artifact/testutils/TestFileManager.java,createTempDir,122-122,[        dir.mkdirs();],,
MT_CORRECTNESS,SWL_SLEEP_WITH_LOCK_HELD,org/apache/maven/artifact/testutils/TestFileManager.java,createTempDir,113-113,[            Thread.sleep( 20 );],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/maven/artifact/versioning/ComparableVersion.java,compareTo,312-312,[                        int result = l == null ? -1 * r.compareTo( l ) : l.compareTo( r );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/artifact/versioning/ComparableVersion.java,,253-339,[    private static class ListItem,         extends ArrayList<Item>,         implements Item,     {,         public int getType(),         {,             return LIST_ITEM;,         }, ,         public boolean isNull(),         {,             return ( size() == 0 );,         }, ,         void normalize(),         {,             for ( ListIterator<Item> iterator = listIterator( size() ); iterator.hasPrevious(); ),             {,                 Item item = iterator.previous();,                 if ( item.isNull() ),                 {,                     iterator.remove(); // remove null trailing items: 0, "", empty list,                 },                 else,                 {,                     break;,                 },             },         }, ,         public int compareTo( Item item ),         {,             if ( item == null ),             {,                 if ( size() == 0 ),                 {,                     return 0; // 1-0 = 1- (normalize) = 1,                 },                 Item first = get( 0 );,                 return first.compareTo( null );,             },             switch ( item.getType() ),             {,                 case INTEGER_ITEM:,                     return -1; // 1-1 < 1.0.x, ,                 case STRING_ITEM:,                     return 1; // 1-1 > 1-sp, ,                 case LIST_ITEM:,                     Iterator<Item> left = iterator();,                     Iterator<Item> right = ( (ListItem) item ).iterator();, ,                     while ( left.hasNext() || right.hasNext() ),                     {,                         Item l = left.hasNext() ? left.next() : null;,                         Item r = right.hasNext() ? right.next() : null;, ,                         // if this is shorter, then invert the compare and mul with -1,                         int result = l == null ? -1 * r.compareTo( l ) : l.compareTo( r );, ,                         if ( result != 0 ),                         {,                             return result;,                         },                     }, ,                     return 0;, ,                 default:,                     throw new RuntimeException( "invalid item: " + item.getClass() );,             },         }, ,         public String toString(),         {,             StringBuilder buffer = new StringBuilder( "(" );,             for ( Iterator<Item> iter = iterator(); iter.hasNext(); ),             {,                 buffer.append( iter.next() );,                 if ( iter.hasNext() ),                 {,                     buffer.append( ',' );,                 },             },             buffer.append( ')' );,             return buffer.toString();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/maven/artifact/versioning/ComparableVersion.java,<init>,175-184,[                switch ( value.charAt( 0 ) ),                 {,                     case 'a':,                         value = "alpha";,                         break;,                     case 'b':,                         value = "beta";,                         break;,                     case 'm':,                         value = "milestone";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/artifact/versioning/ManagedVersionMap.java,,34-54,[        super();,         if ( map != null ),         {,             putAll( map );,         },     }, ,     public String toString(),     {,         StringBuilder buffer = new StringBuilder( "ManagedVersionMap (" + size() + " entries)\n" );,         Iterator<String> iter = keySet().iterator();,         while ( iter.hasNext() ),         {,             String key = iter.next();,             buffer.append( key ).append( "=" ).append( get( key ) );,             if ( iter.hasNext() ),             {,                 buffer.append( "\n" );,             },         },         return buffer.toString();],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/maven/artifact/versioning/ManagedVersionMap.java,toString,48-48,[            buffer.append( key ).append( "=" ).append( get( key ) );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/cli/CLIManager.java,displayHelp,256-256,[        PrintWriter pw = new PrintWriter( stdout );],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/maven/cli/CLIManagerTest.java,,44-49,[    private static class OptionComparator,         implements Comparator<Option>,     {,         public int compare( Option opt1, Option opt2 ),         {,             return opt1.getOpt().compareToIgnoreCase( opt2.getOpt() );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/cli/CLIReportingUtils.java,createMavenVersionString,90-90,[                String ts = fmt.format( new Date( Long.valueOf( timestamp ) ) );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/cli/MavenCli.java,logging,336-336,[                PrintStream ps = new PrintStream( new FileOutputStream( logFile ) );],,
PERFORMANCE,DM_GC,org/apache/maven/cli/event/ExecutionEventLogger.java,logStats,221-221,[        System.gc();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/configuration/DefaultBeanConfiguratorTest.java,testChildConfigurationElement,136-136,[        configurator.configureBean( request );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/configuration/DefaultBeanConfiguratorTest.java,testMinimal,84-84,[        configurator.configureBean( request );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/configuration/DefaultBeanConfiguratorTest.java,testPreAndPostProcessing,121-121,[        configurator.configureBean( request );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/configuration/DefaultBeanConfiguratorTest.java,,97-105,[        {,             public Object preprocessValue( String value, Class<?> type ),                 throws BeanConfigurationException,             {,                 if ( value != null && value.startsWith( "${" ) && value.endsWith( "}" ) ),                 {,                     return value.substring( 2, value.length() - 1 );,                 },                 return value;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/configuration/DefaultBeanConfiguratorTest.java,,110-113,[        {,             public File translatePath( File path ),             {,                 return new File( "base", path.getPath() ).getAbsoluteFile();],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/maven/configuration/DefaultBeanConfiguratorTest.java,,86-86,[        assertEquals( new File( "test" ), bean.file );],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/maven/execution/DefaultMavenExecutionRequest.java,getStartTime,274-274,[        return startTime;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/maven/execution/DefaultMavenExecutionRequest.java,setStartTime,414-414,[        this.startTime = startTime;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/maven/settings/RuntimeInfo.java,,31-51,[    public static final String userHome = System.getProperty( "user.home" );, ,     public static final File userMavenConfigurationHome = new File( userHome, ".m2" );, ,     public static final File DEFAULT_USER_SETTINGS_FILE = new File( userMavenConfigurationHome, "settings.xml" );, ,     private File settings;, ,     public RuntimeInfo(),     {,         this.settings = DEFAULT_USER_SETTINGS_FILE;,     }, ,     public RuntimeInfo( File settings ),     {,         this.settings = settings;,     }, ,     public File getFile(),     {,         return settings;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/execution/SettingsAdapter.java,,51-130,[    {,         this.request = request;, ,         /*,          * NOTE: Plugins like maven-release-plugin query the path to the settings.xml to pass it into a forked Maven and,          * the CLI will fail when called with a non-existing settings, so be sure to only point at actual files. Having,          * a null file should be harmless as this case matches general Maven 2.x behavior...,          */,         File userSettings = request.getUserSettingsFile();,         this.runtimeInfo = new RuntimeInfo( ( userSettings != null && userSettings.isFile() ) ? userSettings : null );,     }, ,     @Override,     public String getLocalRepository(),     {,         if ( request.getLocalRepositoryPath() != null ),         {,             return request.getLocalRepositoryPath().getAbsolutePath();,         }, ,         return null;,     }, ,     @Override,     public boolean isInteractiveMode(),     {,         return request.isInteractiveMode();,     }, ,     @Override,     public boolean isOffline(),     {,         return request.isOffline();,     }, ,     @Override,     public List<Proxy> getProxies(),     {,         return request.getProxies();,     }, ,     @Override,     public List<Server> getServers(),     {,         return request.getServers();,     }, ,     @Override,     public List<Mirror> getMirrors(),     {,         return request.getMirrors();,     }, ,     @Override,     public List<Profile> getProfiles(),     {,         List<Profile> result = new ArrayList<Profile>();,         for ( org.apache.maven.model.Profile profile : request.getProfiles() ),         {,             result.add( SettingsUtils.convertToSettingsProfile( profile ) );,         },         return result;,     }, ,     @Override,     public List<String> getActiveProfiles(),     {,         return request.getActiveProfiles();,     }, ,     @Override,     public List<String> getPluginGroups(),     {,         return request.getPluginGroups();,     }, ,     @Override,     public RuntimeInfo getRuntimeInfo(),     {,         return runtimeInfo;],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/maven/lifecycle/DefaultLifecycles.java,,46-46,[    public static final String[] STANDARD_LIFECYCLES = { "default", "clean", "site" };],,
BAD_PRACTICE,NM_CONFUSING,org/apache/maven/lifecycle/DefaultLifecycles.java,getLifeCycles,114-125,[        Map<String, Lifecycle> lifecycles = new LinkedHashMap<String, Lifecycle>( this.lifecycles );, ,         LinkedHashSet<String> lifecycleNames = new LinkedHashSet<String>( Arrays.asList( STANDARD_LIFECYCLES ) );,         lifecycleNames.addAll( lifecycles.keySet() );, ,         ArrayList<Lifecycle> result = new ArrayList<Lifecycle>();,         for ( String name : lifecycleNames ),         {,             result.add( lifecycles.get( name ) );,         }, ,         return result;],,getLifecycles,54-59,[        if ( this.lifecycles == null ),         {,             this.lifecycles = new java.util.ArrayList<Lifecycle>();,         }, ,         return this.lifecycles;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/lifecycle/DefaultLifecyclesTest.java,testLifecycle,51-51,[        final List<Lifecycle> cycles = defaultLifeCycles.getLifeCycles();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/lifecycle/DefaultSchedulesTest.java,testScheduling,48-48,[        final List<Scheduling> schedulings = defaultSchedules.getSchedules();],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/maven/project/MavenProject.java,,96-2247,[public class MavenProject,     implements Cloneable, {,     public static final String EMPTY_PROJECT_GROUP_ID = "unknown";, ,     public static final String EMPTY_PROJECT_ARTIFACT_ID = "empty-project";, ,     public static final String EMPTY_PROJECT_VERSION = "0";, ,     private static final MavenProject ERROR_BUILDING_PARENT = new MavenProject();, ,     private Model model;, ,     private MavenProject parent;, ,     private File file;, ,     private Set<Artifact> resolvedArtifacts;, ,     private ArtifactFilter artifactFilter;, ,     private Set<Artifact> artifacts;, ,     private Artifact parentArtifact;, ,     private Set<Artifact> pluginArtifacts;, ,     private List<ArtifactRepository> remoteArtifactRepositories;, ,     private List<ArtifactRepository> pluginArtifactRepositories;, ,     private List<RemoteRepository> remoteProjectRepositories;, ,     private List<RemoteRepository> remotePluginRepositories;, ,     private List<Artifact> attachedArtifacts;, ,     private MavenProject executionProject;, ,     private List<MavenProject> collectedProjects;, ,     private List<String> compileSourceRoots = new ArrayList<String>();, ,     private List<String> testCompileSourceRoots = new ArrayList<String>();, ,     private List<String> scriptSourceRoots = new ArrayList<String>();, ,     private ArtifactRepository releaseArtifactRepository;, ,     private ArtifactRepository snapshotArtifactRepository;, ,     private List<Profile> activeProfiles = new ArrayList<Profile>();, ,     private Map<String, List<String>> injectedProfileIds = new LinkedHashMap<String, List<String>>();, ,     private Set<Artifact> dependencyArtifacts;, ,     private Artifact artifact;, ,     // calculated.,     private Map<String, Artifact> artifactMap;, ,     private Model originalModel;, ,     private Map<String, Artifact> pluginArtifactMap;, ,     private Set<Artifact> reportArtifacts;, ,     private Map<String, Artifact> reportArtifactMap;, ,     private Set<Artifact> extensionArtifacts;, ,     private Map<String, Artifact> extensionArtifactMap;, ,     private Map<String, Artifact> managedVersionMap;, ,     private Map<String, MavenProject> projectReferences = new HashMap<String, MavenProject>();, ,     private boolean executionRoot;, ,     private Map<String, String> moduleAdjustments;, ,     private ProjectBuilder mavenProjectBuilder;, ,     private ProjectBuildingRequest projectBuilderConfiguration;, ,     private RepositorySystem repositorySystem;,     ,     private File parentFile;, ,     private Map<String, Object> context;, ,     private ClassRealm classRealm;, ,     private DependencyFilter extensionDependencyFilter;, ,     private final Set<String> lifecyclePhases = Collections.synchronizedSet( new LinkedHashSet<String>() );, ,     private Logger logger;, ,     public MavenProject(),     {,         Model model = new Model();, ,         model.setGroupId( EMPTY_PROJECT_GROUP_ID );,         model.setArtifactId( EMPTY_PROJECT_ARTIFACT_ID );,         model.setVersion( EMPTY_PROJECT_VERSION );, ,         setModel( model );,     }, ,     public MavenProject( Model model ),     {,         setModel( model );,     }, ,     /**,      * @deprecated use {@link #clone()} so subclasses can provide a copy of the same class,      */,     @Deprecated,     public MavenProject( MavenProject project ),     {,         repositorySystem = project.repositorySystem;,         logger = project.logger;,         mavenProjectBuilder = project.mavenProjectBuilder;,         projectBuilderConfiguration = project.projectBuilderConfiguration;,         deepCopy( project );,     },     ,     @Deprecated,     public MavenProject( Model model, RepositorySystem repositorySystem ),     {        ,         this.repositorySystem = repositorySystem;,         setModel( model );,     }, ,     public File getParentFile(),     {,         return parentFile;,     }, ,     public void setParentFile( File parentFile ),     {,         this.parentFile = parentFile;,     }, ,     /**,      * Constructor,      * ,      * @param repositorySystem - may not be null,      * @param mavenProjectBuilder,      * @param projectBuilderConfiguration,      * @throws InvalidRepositoryException,      */,     MavenProject( RepositorySystem repositorySystem, ProjectBuilder mavenProjectBuilder,,                   ProjectBuildingRequest projectBuilderConfiguration, Logger logger ),     {,         if ( repositorySystem == null ),         {,             throw new IllegalArgumentException( "mavenTools: null" );,         }, ,         this.mavenProjectBuilder = mavenProjectBuilder;,         this.projectBuilderConfiguration = projectBuilderConfiguration;,         this.repositorySystem = repositorySystem;,         this.logger = logger;,     }, ,     @Deprecated,     public Set<Artifact> createArtifacts( ArtifactFactory artifactFactory, String inheritedScope, ArtifactFilter filter ),         throws InvalidDependencyVersionException,     {,         return MavenMetadataSource.createArtifacts( artifactFactory, getDependencies(), inheritedScope, filter, this );,     }, ,     // TODO: Find a way to use <relativePath/> here...it's tricky, because the moduleProject,     // usually doesn't have a file associated with it yet.,     public String getModulePathAdjustment( MavenProject moduleProject ),         throws IOException,     {,         // FIXME: This is hacky. What if module directory doesn't match artifactid, and parent,         // is coming from the repository??,         String module = moduleProject.getArtifactId();, ,         File moduleFile = moduleProject.getFile();, ,         if ( moduleFile != null ),         {,             File moduleDir = moduleFile.getCanonicalFile().getParentFile();, ,             module = moduleDir.getName();,         }, ,         if ( moduleAdjustments == null ),         {,             moduleAdjustments = new HashMap<String, String>();, ,             List<String> modules = getModules();,             if ( modules != null ),             {,                 for ( String modulePath : modules ),                 {,                     String moduleName = modulePath;, ,                     if ( moduleName.endsWith( "/" ) || moduleName.endsWith( "\\" ) ),                     {,                         moduleName = moduleName.substring( 0, moduleName.length() - 1 );,                     }, ,                     int lastSlash = moduleName.lastIndexOf( '/' );, ,                     if ( lastSlash < 0 ),                     {,                         lastSlash = moduleName.lastIndexOf( '\\' );,                     }, ,                     String adjustment = null;, ,                     if ( lastSlash > -1 ),                     {,                         moduleName = moduleName.substring( lastSlash + 1 );,                         adjustment = modulePath.substring( 0, lastSlash );,                     }, ,                     moduleAdjustments.put( moduleName, adjustment );,                 },             },         }, ,         return moduleAdjustments.get( module );,     }, ,     // ----------------------------------------------------------------------,     // Accessors,     // ----------------------------------------------------------------------, ,     public Artifact getArtifact(),     {,         return artifact;,     }, ,     public void setArtifact( Artifact artifact ),     {,         this.artifact = artifact;,     }, ,     //@todo I would like to get rid of this. jvz.,     public Model getModel(),     {,         return model;,     }, ,     /**,      * Returns the project corresponding to a declared parent.,      * @return the parent, or null if no parent is declared or there was an error building it,      */,     public MavenProject getParent(),     {,         if ( parent == null ),         {,             /*,              * TODO: This is suboptimal. Without a cache in the project builder, rebuilding the parent chain currently,              * causes O(n^2) parser invocations for an inheritance hierarchy of depth n.,              */,             if ( parentFile != null ),             {,                 checkProjectBuildingRequest();,                 ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );,                 request.setRemoteRepositories( getRemoteArtifactRepositories() );, ,                 try,                 {,                     parent = mavenProjectBuilder.build( parentFile, request ).getProject();,                 },                 catch ( ProjectBuildingException e ),                 {,                     if ( logger != null ),                     {,                         logger.error( "Failed to build parent project for " + getId(), e );,                     },                     parent = ERROR_BUILDING_PARENT;,                 },             },             else if ( model.getParent() != null ),             {,                 checkProjectBuildingRequest();,                 ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );,                 request.setRemoteRepositories( getRemoteArtifactRepositories() );, ,                 try,                 {,                     parent = mavenProjectBuilder.build( getParentArtifact(), request ).getProject();,                 },                 catch ( ProjectBuildingException e ),                 {,                     if ( logger != null ),                     {,                         logger.error( "Failed to build parent project for " + getId(), e );,                     },                     parent = ERROR_BUILDING_PARENT;,                 },             },         },         return parent == ERROR_BUILDING_PARENT ? null : parent;,     }, ,     public void setParent( MavenProject parent ),     {,         this.parent = parent;,     },     ,     public boolean hasParent(),     {,         return getParent() != null;,     }, ,     public File getFile(),     {,         return file;,     }, ,     public void setFile( File file ),     {,         this.file = file;,     }, ,     public File getBasedir(),     {,         if ( getFile() != null ),         {,             return getFile().getParentFile();,         },         else,         {,             // repository based POM,             return null;,         },     }, ,     public void setDependencies( List<Dependency> dependencies ),     {,         getModel().setDependencies( dependencies );,     }, ,     public List<Dependency> getDependencies(),     {,         return getModel().getDependencies();,     }, ,     public DependencyManagement getDependencyManagement(),     {,         return getModel().getDependencyManagement();,     }, ,     // ----------------------------------------------------------------------,     // Test and compile sourceroots.,     // ----------------------------------------------------------------------, ,     private void addPath( List<String> paths, String path ),     {,         if ( path != null ),         {,             path = path.trim();,             if ( path.length() > 0 ),             {,                 File file = new File( path );,                 if ( file.isAbsolute() ),                 {,                     path = file.getAbsolutePath();,                 },                 else,                 {,                     path = new File( getBasedir(), path ).getAbsolutePath();,                 }, ,                 if ( !paths.contains( path ) ),                 {,                     paths.add( path );,                 },             },         },     }, ,     public void addCompileSourceRoot( String path ),     {,         addPath( getCompileSourceRoots(), path );,     }, ,     public void addScriptSourceRoot( String path ),     {,         if ( path != null ),         {,             path = path.trim();,             if ( path.length() != 0 ),             {,                 if ( !getScriptSourceRoots().contains( path ) ),                 {,                     getScriptSourceRoots().add( path );,                 },             },         },     }, ,     public void addTestCompileSourceRoot( String path ),     {,         addPath( getTestCompileSourceRoots(), path );,     }, ,     public List<String> getCompileSourceRoots(),     {,         return compileSourceRoots;,     }, ,     public List<String> getScriptSourceRoots(),     {,         return scriptSourceRoots;,     }, ,     public List<String> getTestCompileSourceRoots(),     {,         return testCompileSourceRoots;,     }, ,     public List<String> getCompileClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );, ,         String d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         for ( Artifact a : getArtifacts() ),         {                        ,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     addArtifactPath( a, list );,                 },             },         }, ,         return list;,     }, ,     @Deprecated,     public List<Artifact> getCompileArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts() ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     list.add( a );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getCompileDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: let the scope handler deal with this,             if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),             {,                 Dependency dependency = new Dependency();, ,                 dependency.setArtifactId( a.getArtifactId() );,                 dependency.setGroupId( a.getGroupId() );,                 dependency.setVersion( a.getVersion() );,                 dependency.setScope( a.getScope() );,                 dependency.setType( a.getType() );,                 dependency.setClassifier( a.getClassifier() );, ,                 list.add( dependency );,             },         },         return list;,     }, ,     //TODO: this checking for file == null happens because the resolver has been confused about the root,     // artifact or not. things like the stupid dummy artifact coming from surefire.,     public List<String> getTestClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() + 2 );, ,         String d = getBuild().getTestOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         },         ,         for ( Artifact a : getArtifacts() ),         {            ,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {                ,                 addArtifactPath( a, list );,             },         }, ,         return list;,     }, ,     @Deprecated,     public List<Artifact> getTestArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts() ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 list.add( a );,             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getTestDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             Dependency dependency = new Dependency();, ,             dependency.setArtifactId( a.getArtifactId() );,             dependency.setGroupId( a.getGroupId() );,             dependency.setVersion( a.getVersion() );,             dependency.setScope( a.getScope() );,             dependency.setType( a.getType() );,             dependency.setClassifier( a.getClassifier() );, ,             list.add( dependency );,         },         return list;,     }, ,     public List<String> getRuntimeClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );, ,         String d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         for ( Artifact a : getArtifacts() ),         {,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ),                 {,                     addArtifactPath( a, list );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Artifact> getRuntimeArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ),                 {,                     list.add( a );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getRuntimeDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: let the scope handler deal with this,             if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ),             {,                 Dependency dependency = new Dependency();, ,                 dependency.setArtifactId( a.getArtifactId() );,                 dependency.setGroupId( a.getGroupId() );,                 dependency.setVersion( a.getVersion() );,                 dependency.setScope( a.getScope() );,                 dependency.setType( a.getType() );,                 dependency.setClassifier( a.getClassifier() );, ,                 list.add( dependency );,             },         },         return list;,     }, ,     public List<String> getSystemClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() );, ,         String d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         for ( Artifact a : getArtifacts() ),         {,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     addArtifactPath( a, list );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Artifact> getSystemArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     list.add( a );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getSystemDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: let the scope handler deal with this,             if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),             {,                 Dependency dependency = new Dependency();, ,                 dependency.setArtifactId( a.getArtifactId() );,                 dependency.setGroupId( a.getGroupId() );,                 dependency.setVersion( a.getVersion() );,                 dependency.setScope( a.getScope() );,                 dependency.setType( a.getType() );,                 dependency.setClassifier( a.getClassifier() );, ,                 list.add( dependency );,             },         },         return list;,     }, ,     // ----------------------------------------------------------------------,     // Delegate to the model,     // ----------------------------------------------------------------------, ,     public void setModelVersion( String pomVersion ),     {,         getModel().setModelVersion( pomVersion );,     }, ,     public String getModelVersion(),     {,         return getModel().getModelVersion();,     }, ,     public String getId(),     {,         return getModel().getId();,     }, ,     public void setGroupId( String groupId ),     {,         getModel().setGroupId( groupId );,     }, ,     public String getGroupId(),     {,         String groupId = getModel().getGroupId();, ,         if ( ( groupId == null ) && ( getModel().getParent() != null ) ),         {,             groupId = getModel().getParent().getGroupId();,         }, ,         return groupId;,     }, ,     public void setArtifactId( String artifactId ),     {,         getModel().setArtifactId( artifactId );,     }, ,     public String getArtifactId(),     {,         return getModel().getArtifactId();,     }, ,     public void setName( String name ),     {,         getModel().setName( name );,     }, ,     public String getName(),     {,         // TODO: this should not be allowed to be null.,         if ( getModel().getName() != null ),         {,             return getModel().getName();,         },         else,         {,             return getArtifactId();,         },     }, ,     public void setVersion( String version ),     {,         getModel().setVersion( version );,     }, ,     public String getVersion(),     {,         String version = getModel().getVersion();, ,         if ( ( version == null ) && ( getModel().getParent() != null ) ),         {,             version = getModel().getParent().getVersion();,         }, ,         return version;,     }, ,     public String getPackaging(),     {,         return getModel().getPackaging();,     }, ,     public void setPackaging( String packaging ),     {,         getModel().setPackaging( packaging );,     }, ,     public void setInceptionYear( String inceptionYear ),     {,         getModel().setInceptionYear( inceptionYear );,     }, ,     public String getInceptionYear(),     {,         return getModel().getInceptionYear();,     }, ,     public void setUrl( String url ),     {,         getModel().setUrl( url );,     }, ,     public String getUrl(),     {,         return getModel().getUrl();,     }, ,     public Prerequisites getPrerequisites(),     {,         return getModel().getPrerequisites();,     }, ,     public void setIssueManagement( IssueManagement issueManagement ),     {,         getModel().setIssueManagement( issueManagement );,     }, ,     public CiManagement getCiManagement(),     {,         return getModel().getCiManagement();,     }, ,     public void setCiManagement( CiManagement ciManagement ),     {,         getModel().setCiManagement( ciManagement );,     }, ,     public IssueManagement getIssueManagement(),     {,         return getModel().getIssueManagement();,     }, ,     public void setDistributionManagement( DistributionManagement distributionManagement ),     {,         getModel().setDistributionManagement( distributionManagement );,     }, ,     public DistributionManagement getDistributionManagement(),     {,         return getModel().getDistributionManagement();,     }, ,     public void setDescription( String description ),     {,         getModel().setDescription( description );,     }, ,     public String getDescription(),     {,         return getModel().getDescription();,     }, ,     public void setOrganization( Organization organization ),     {,         getModel().setOrganization( organization );,     }, ,     public Organization getOrganization(),     {,         return getModel().getOrganization();,     }, ,     public void setScm( Scm scm ),     {,         getModel().setScm( scm );,     }, ,     public Scm getScm(),     {,         return getModel().getScm();,     }, ,     public void setMailingLists( List<MailingList> mailingLists ),     {,         getModel().setMailingLists( mailingLists );,     }, ,     public List<MailingList> getMailingLists(),     {,         return getModel().getMailingLists();,     }, ,     public void addMailingList( MailingList mailingList ),     {,         getModel().addMailingList( mailingList );,     }, ,     public void setDevelopers( List<Developer> developers ),     {,         getModel().setDevelopers( developers );,     }, ,     public List<Developer> getDevelopers(),     {,         return getModel().getDevelopers();,     }, ,     public void addDeveloper( Developer developer ),     {,         getModel().addDeveloper( developer );,     }, ,     public void setContributors( List<Contributor> contributors ),     {,         getModel().setContributors( contributors );,     }, ,     public List<Contributor> getContributors(),     {,         return getModel().getContributors();,     }, ,     public void addContributor( Contributor contributor ),     {,         getModel().addContributor( contributor );,     }, ,     public void setBuild( Build build ),     {,         getModel().setBuild( build );,     }, ,     public Build getBuild(),     {,         return getModelBuild();,     }, ,     public List<Resource> getResources(),     {,         return getBuild().getResources();,     }, ,     public List<Resource> getTestResources(),     {,         return getBuild().getTestResources();,     }, ,     public void addResource( Resource resource ),     {,         getBuild().addResource( resource );,     }, ,     public void addTestResource( Resource testResource ),     {,         getBuild().addTestResource( testResource );,     }, ,     @Deprecated,     public void setReporting( Reporting reporting ),     {,         getModel().setReporting( reporting );,     }, ,     @Deprecated,     public Reporting getReporting(),     {,         return getModel().getReporting();,     }, ,     public void setLicenses( List<License> licenses ),     {,         getModel().setLicenses( licenses );,     }, ,     public List<License> getLicenses(),     {,         return getModel().getLicenses();,     }, ,     public void addLicense( License license ),     {,         getModel().addLicense( license );,     }, ,     public void setArtifacts( Set<Artifact> artifacts ),     {,         this.artifacts = artifacts;, ,         // flush the calculated artifactMap,         artifactMap = null;,     }, ,     /**,      * All dependencies that this project has, including transitive ones. Contents are lazily,      * populated, so depending on what phases have run dependencies in some scopes won't be,      * included. eg. if only compile phase has run, dependencies with scope test won't be included.,      * ,      * @return {@link Set} &lt; {@link Artifact} >,      * @see #getDependencyArtifacts() to get only direct dependencies,      */,     public Set<Artifact> getArtifacts(),     {,         if ( artifacts == null ),         {,             if ( artifactFilter == null || resolvedArtifacts == null ),             {,                 artifacts = new LinkedHashSet<Artifact>();,             },             else,             {,                 artifacts = new LinkedHashSet<Artifact>( resolvedArtifacts.size() * 2 );,                 for ( Artifact artifact : resolvedArtifacts ),                 {,                     if ( artifactFilter.include( artifact ) ),                     {,                         artifacts.add( artifact );,                     },                 },             },         },         return artifacts;,     }, ,     public Map<String, Artifact> getArtifactMap(),     {,         if ( artifactMap == null ),         {,             artifactMap = ArtifactUtils.artifactMapByVersionlessId( getArtifacts() );,         },         return artifactMap;,     }, ,     public void setPluginArtifacts( Set<Artifact> pluginArtifacts ),     {,         this.pluginArtifacts = pluginArtifacts;, ,         this.pluginArtifactMap = null;,     }, ,     public Set<Artifact> getPluginArtifacts(),     {,         if ( pluginArtifacts != null ),         {,             return pluginArtifacts;,         }, ,         pluginArtifacts = new HashSet<Artifact>();, ,         if ( repositorySystem != null ),         {,             for ( Plugin p : getBuildPlugins() ),             {,                 Artifact artifact = repositorySystem.createPluginArtifact( p );, ,                 if ( artifact != null ),                 {,                     pluginArtifacts.add( artifact );,                 },             },         }, ,         pluginArtifactMap = null;, ,         return pluginArtifacts;,     }, ,     public Map<String, Artifact> getPluginArtifactMap(),     {,         if ( pluginArtifactMap == null ),         {,             pluginArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getPluginArtifacts() );,         }, ,         return pluginArtifactMap;,     }, ,     @Deprecated,     public void setReportArtifacts( Set<Artifact> reportArtifacts ),     {,         this.reportArtifacts = reportArtifacts;, ,         reportArtifactMap = null;,     }, ,     @Deprecated,     public Set<Artifact> getReportArtifacts(),     {,         if ( reportArtifacts != null ),         {,             return reportArtifacts;,         }, ,         reportArtifacts = new HashSet<Artifact>();, ,         if ( repositorySystem != null ),         {,             for ( ReportPlugin p : getReportPlugins() ),             {,                 Plugin pp = new Plugin();,                 pp.setGroupId( p.getGroupId() );,                 pp.setArtifactId( p.getArtifactId() );,                 pp.setVersion( p.getVersion() );, ,                 Artifact artifact = repositorySystem.createPluginArtifact( pp );, ,                 if ( artifact != null ),                 {,                     reportArtifacts.add( artifact );,                 },             },         }, ,         reportArtifactMap = null;, ,         return reportArtifacts;,     }, ,     @Deprecated,     public Map<String, Artifact> getReportArtifactMap(),     {,         if ( reportArtifactMap == null ),         {,             reportArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getReportArtifacts() );,         }, ,         return reportArtifactMap;,     }, ,     public void setExtensionArtifacts( Set<Artifact> extensionArtifacts ),     {,         this.extensionArtifacts = extensionArtifacts;, ,         extensionArtifactMap = null;,     }, ,     public Set<Artifact> getExtensionArtifacts(),     {,         if ( extensionArtifacts != null ),         {,             return extensionArtifacts;,         },         extensionArtifacts = new HashSet<Artifact>();,         List<Extension> extensions = getBuildExtensions();,         if ( extensions != null ),         {,             for ( Extension ext : extensions ),             {,                 String version;,                 if ( StringUtils.isEmpty( ext.getVersion() ) ),                 {,                     version = "RELEASE";,                 },                 else,                 {,                     version = ext.getVersion();,                 }, ,                 Artifact artifact =,                     repositorySystem.createArtifact( ext.getGroupId(), ext.getArtifactId(), version, null, "jar" );, ,                 if ( artifact != null ),                 {,                     extensionArtifacts.add( artifact );,                 },             },         },         extensionArtifactMap = null;,         return extensionArtifacts;,     }, ,     public Map<String, Artifact> getExtensionArtifactMap(),     {,         if ( extensionArtifactMap == null ),         {,             extensionArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getExtensionArtifacts() );,         }, ,         return extensionArtifactMap;,     }, ,     public void setParentArtifact( Artifact parentArtifact ),     {,         this.parentArtifact = parentArtifact;,     }, ,     public Artifact getParentArtifact(),     {,         if ( parentArtifact == null && model.getParent() != null ),         {,             Parent p = model.getParent();,             parentArtifact = repositorySystem.createProjectArtifact( p.getGroupId(), p.getArtifactId(), p.getVersion() );,         },         return parentArtifact;,     }, ,     public List<Repository> getRepositories(),     {,         return getModel().getRepositories();,     }, ,     // ----------------------------------------------------------------------,     // Plugins,     // ----------------------------------------------------------------------, ,     @Deprecated,     public List<ReportPlugin> getReportPlugins(),     {,         if ( getModel().getReporting() == null ),         {,             return Collections.emptyList();,         },         return getModel().getReporting().getPlugins();, ,     }, ,     public List<Plugin> getBuildPlugins(),     {,         if ( getModel().getBuild() == null ),         {,             return Collections.emptyList();,         },         return getModel().getBuild().getPlugins();,     }, ,     public List<String> getModules(),     {,         return getModel().getModules();,     }, ,     public PluginManagement getPluginManagement(),     {,         PluginManagement pluginMgmt = null;, ,         Build build = getModel().getBuild();,         if ( build != null ),         {,             pluginMgmt = build.getPluginManagement();,         }, ,         return pluginMgmt;,     }, ,     private Build getModelBuild(),     {,         Build build = getModel().getBuild();, ,         if ( build == null ),         {,             build = new Build();, ,             getModel().setBuild( build );,         }, ,         return build;,     }, ,     public void setRemoteArtifactRepositories( List<ArtifactRepository> remoteArtifactRepositories ),     {,         this.remoteArtifactRepositories = remoteArtifactRepositories;,         this.remoteProjectRepositories = RepositoryUtils.toRepos( getRemoteArtifactRepositories() );,     }, ,     public List<ArtifactRepository> getRemoteArtifactRepositories(),     {,         if ( remoteArtifactRepositories == null ),         {,             remoteArtifactRepositories = new ArrayList<ArtifactRepository>();,         }, ,         return remoteArtifactRepositories;,     }, ,     public void setPluginArtifactRepositories( List<ArtifactRepository> pluginArtifactRepositories ),     {,         this.pluginArtifactRepositories = pluginArtifactRepositories;,         this.remotePluginRepositories = RepositoryUtils.toRepos( getPluginArtifactRepositories() );,     }, ,     /**,      * @return a list of ArtifactRepository objects constructed from the Repository objects returned,      *         by getPluginRepositories.,      */,     public List<ArtifactRepository> getPluginArtifactRepositories(),     {,         if ( pluginArtifactRepositories == null ),         {,             pluginArtifactRepositories = new ArrayList<ArtifactRepository>();,         }, ,         return pluginArtifactRepositories;,     }, ,     public ArtifactRepository getDistributionManagementArtifactRepository(),     {,         return getArtifact().isSnapshot() && ( getSnapshotArtifactRepository() != null ) ? getSnapshotArtifactRepository() : getReleaseArtifactRepository();,     }, ,     public List<Repository> getPluginRepositories(),     {,         return getModel().getPluginRepositories();,     }, ,     public List<RemoteRepository> getRemoteProjectRepositories(),     {,         return remoteProjectRepositories;,     }, ,     public List<RemoteRepository> getRemotePluginRepositories(),     {,         return remotePluginRepositories;,     }, ,     public void setActiveProfiles( List<Profile> activeProfiles ),     {,         this.activeProfiles = activeProfiles;,     }, ,     public List<Profile> getActiveProfiles(),     {,         return activeProfiles;,     }, ,     public void setInjectedProfileIds( String source, List<String> injectedProfileIds ),     {,         if ( injectedProfileIds != null ),         {,             this.injectedProfileIds.put( source, new ArrayList<String>( injectedProfileIds ) );,         },         else,         {,             this.injectedProfileIds.remove( source );,         },     }, ,     /**,      * Gets the identifiers of all profiles that contributed to this project's effective model. This includes active,      * profiles from the project's POM and all its parent POMs as well as from external sources like the {@code,      * settings.xml}. The profile identifiers are grouped by the identifier of their source, e.g. {@code,      * <groupId>:<artifactId>:<version>} for a POM profile or {@code external} for profiles from the {@code,      * settings.xml}.,      * ,      * @return The identifiers of all injected profiles, indexed by the source from which the profiles originated, never,      *         {@code null}.,      */,     public Map<String, List<String>> getInjectedProfileIds(),     {,         return this.injectedProfileIds;,     }, ,     private String logStringForArtifactFile( Artifact a ),     {,         if ( a.getFile() != null ),         {,             return a.getFile().getAbsolutePath();,         },         else,         {,             return "(no path)";,         },     }, ,     /**,      * Add or replace an artifact.,      * In spite of the 'throws' declaration on this API, this method has never thrown an exception since Maven 3.0.x.,      * Historically, it logged and ignored a second addition of the same g/a/v/c/t. Now it replaces the file for,      * the artifact, so that plugins (e.g. shade) can change the pathname of the file for a particular set of,      * coordinates.,      * @param artifact the artifact to add or replace.,      * @throws DuplicateArtifactAttachmentException,      */,     public void addAttachedArtifact( Artifact artifact ),         throws DuplicateArtifactAttachmentException,     {,         List<Artifact> attachedArtifacts = getAttachedArtifacts();,         for ( int ax = 0; ax < attachedArtifacts.size(); ax++ ),         {,             Artifact a = attachedArtifacts.get( ax );,             if ( a.equals( artifact ) ),             {,                 if ( logger != null ),                 {,                     logger.debug( String.format( "Replacing attached artifact %s. Old path %s, new path %s. ",,                                                  a,,                                                  logStringForArtifactFile( a ),,                                                  logStringForArtifactFile( artifact ) ) );,                 },                 attachedArtifacts.set( ax, artifact );,                 return;,             },         }, ,         getAttachedArtifacts().add( artifact );,     }, ,     public List<Artifact> getAttachedArtifacts(),     {,         if ( attachedArtifacts == null ),         {,             attachedArtifacts = new ArrayList<Artifact>();,         },         return attachedArtifacts;,     }, ,     public Xpp3Dom getGoalConfiguration( String pluginGroupId, String pluginArtifactId, String executionId,,                                          String goalId ),     {,         Xpp3Dom dom = null;, ,         if ( getBuildPlugins() != null ),         {,             for ( Plugin plugin : getBuildPlugins() ),             {,                 if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) ),                 {,                     dom = (Xpp3Dom) plugin.getConfiguration();, ,                     if ( executionId != null ),                     {,                         PluginExecution execution = plugin.getExecutionsAsMap().get( executionId );,                         if ( execution != null ),                         {,                             // NOTE: The PluginConfigurationExpander already merged the plugin-level config in,                             dom = (Xpp3Dom) execution.getConfiguration();,                         },                     },                     break;,                 },             },         }, ,         if ( dom != null ),         {,             // make a copy so the original in the POM doesn't get messed with,             dom = new Xpp3Dom( dom );,         }, ,         return dom;,     }, ,     @Deprecated,     public Xpp3Dom getReportConfiguration( String pluginGroupId, String pluginArtifactId, String reportSetId ),     {,         Xpp3Dom dom = null;, ,         // ----------------------------------------------------------------------,         // I would like to be able to lookup the Mojo object using a key but,         // we have a limitation in modello that will be remedied shortly. So,         // for now I have to iterate through and see what we have.,         // ----------------------------------------------------------------------, ,         if ( getReportPlugins() != null ),         {,             for ( ReportPlugin plugin : getReportPlugins() ),             {,                 if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) ),                 {,                     dom = (Xpp3Dom) plugin.getConfiguration();, ,                     if ( reportSetId != null ),                     {,                         ReportSet reportSet = plugin.getReportSetsAsMap().get( reportSetId );,                         if ( reportSet != null ),                         {,                             Xpp3Dom executionConfiguration = (Xpp3Dom) reportSet.getConfiguration();,                             if ( executionConfiguration != null ),                             {,                                 Xpp3Dom newDom = new Xpp3Dom( executionConfiguration );,                                 dom = Xpp3Dom.mergeXpp3Dom( newDom, dom );,                             },                         },                     },                     break;,                 },             },         }, ,         if ( dom != null ),         {,             // make a copy so the original in the POM doesn't get messed with,             dom = new Xpp3Dom( dom );,         }, ,         return dom;,     }, ,     public MavenProject getExecutionProject(),     {,         return ( executionProject == null ? this : executionProject );,     }, ,     public void setExecutionProject( MavenProject executionProject ),     {,         this.executionProject = executionProject;,     }, ,     public List<MavenProject> getCollectedProjects(),     {,         return collectedProjects;,     }, ,     public void setCollectedProjects( List<MavenProject> collectedProjects ),     {,         this.collectedProjects = collectedProjects;,     }, ,     /**,      * Direct dependencies that this project has.,      * ,      * @return {@link Set} &lt; {@link Artifact} >,      * @see #getArtifacts() to get all transitive dependencies,      */,     public Set<Artifact> getDependencyArtifacts(),     {,         return dependencyArtifacts;,     }, ,     public void setDependencyArtifacts( Set<Artifact> dependencyArtifacts ),     {,         this.dependencyArtifacts = dependencyArtifacts;,     }, ,     public void setReleaseArtifactRepository( ArtifactRepository releaseArtifactRepository ),     {,         this.releaseArtifactRepository = releaseArtifactRepository;,     }, ,     public void setSnapshotArtifactRepository( ArtifactRepository snapshotArtifactRepository ),     {,         this.snapshotArtifactRepository = snapshotArtifactRepository;,     }, ,     public void setOriginalModel( Model originalModel ),     {,         this.originalModel = originalModel;,     }, ,     public Model getOriginalModel(),     {,         return originalModel;,     }, ,     public void setManagedVersionMap( Map<String, Artifact> map ),     {,         managedVersionMap = map;,     }, ,     public Map<String, Artifact> getManagedVersionMap(),     {,         if ( managedVersionMap != null ),         {,             return managedVersionMap;,         }, ,         Map<String, Artifact> map = null;,         if ( repositorySystem != null ),         {, ,             List<Dependency> deps;,             DependencyManagement dependencyManagement = getDependencyManagement();,             if ( ( dependencyManagement != null ) && ( ( deps = dependencyManagement.getDependencies() ) != null ) && ( deps.size() > 0 ) ),             {,                 map = new HashMap<String, Artifact>();,                 for ( Dependency d : dependencyManagement.getDependencies() ),                 {,                     Artifact artifact = repositorySystem.createDependencyArtifact( d );, ,                     if ( artifact == null ),                     {,                         map = Collections.emptyMap();,                     }, ,                     map.put( d.getManagementKey(), artifact );,                 },             },             else,             {,                 map = Collections.emptyMap();,             },         },         managedVersionMap = map;,         return managedVersionMap;,     }, ,     @Override,     public boolean equals( Object other ),     {,         if ( other == this ),         {,             return true;,         },         else if ( !( other instanceof MavenProject ) ),         {,             return false;,         }, ,         MavenProject that = (MavenProject) other;, ,         return eq( getArtifactId(), that.getArtifactId() ),             && eq( getGroupId(), that.getGroupId() ),             && eq( getVersion(), that.getVersion() );,     }, ,     private static <T> boolean eq( T s1, T s2 ),     {,         return ( s1 != null ) ? s1.equals( s2 ) : s2 == null;,     }, ,     @Override,     public int hashCode(),     {,         int hash = 17;,         hash = 31 * hash + getGroupId().hashCode();,         hash = 31 * hash + getArtifactId().hashCode();,         hash = 31 * hash + getVersion().hashCode();,         return hash;,     }, ,     public List<Extension> getBuildExtensions(),     {,         Build build = getBuild();,         if ( ( build == null ) || ( build.getExtensions() == null ) ),         {,             return Collections.emptyList();,         },         else,         {,             return build.getExtensions();,         },     }, ,     public void addProjectReference( MavenProject project ),     {,         projectReferences.put( getProjectReferenceId( project.getGroupId(), project.getArtifactId(), project.getVersion() ), project );,     }, ,     /**,      * @deprecated Use MavenProjectHelper.attachArtifact(..) instead.,      */,     @Deprecated,     public void attachArtifact( String type, String classifier, File file ),     {,     }, ,     public Properties getProperties(),     {,         return getModel().getProperties();,     }, ,     public List<String> getFilters(),     {,         return getBuild().getFilters();,     }, ,     public Map<String, MavenProject> getProjectReferences(),     {,         return projectReferences;,     }, ,     public boolean isExecutionRoot(),     {,         return executionRoot;,     }, ,     public void setExecutionRoot( boolean executionRoot ),     {,         this.executionRoot = executionRoot;,     }, ,     public String getDefaultGoal(),     {,         return getBuild() != null ? getBuild().getDefaultGoal() : null;,     }, ,     public Plugin getPlugin( String pluginKey ),     {,         return getBuild().getPluginsAsMap().get( pluginKey );,     }, ,     /**,      * Default toString,      */,     @Override,     public String toString(),     {,         StringBuilder sb = new StringBuilder( 128 );,         sb.append( "MavenProject: " );,         sb.append( getGroupId() );,         sb.append( ":" );,         sb.append( getArtifactId() );,         sb.append( ":" );,         sb.append( getVersion() );,         sb.append( " @ " );, ,         try,         {,             sb.append( getFile().getPath() );,         },         catch ( NullPointerException e ),         {,             //don't log it.,         }, ,         return sb.toString();,     }, ,     /**,      * @deprecated Use {@link org.apache.maven.model.io.ModelWriter}.,      */,     @Deprecated,     public void writeModel( Writer writer ),         throws IOException,     {,         MavenXpp3Writer pomWriter = new MavenXpp3Writer();,         pomWriter.write( writer, getModel() );,     }, ,     /**,      * @deprecated Use {@link org.apache.maven.model.io.ModelWriter}.,      */,     @Deprecated,     public void writeOriginalModel( Writer writer ),         throws IOException,     {,         MavenXpp3Writer pomWriter = new MavenXpp3Writer();,         pomWriter.write( writer, getOriginalModel() );,     }, ,     /**,      * @throws CloneNotSupportedException,      * @since 2.0.9,      */,     @Override,     public MavenProject clone(),     {,         MavenProject clone;,         try,         {,             clone = (MavenProject) super.clone();,         },         catch ( CloneNotSupportedException e ),         {,             throw new UnsupportedOperationException( e );,         }, ,         clone.deepCopy( this );, ,         return clone;,     }, ,     protected void setModel( Model model ),     {,         this.model = model;,     }, ,     protected void setAttachedArtifacts( List<Artifact> attachedArtifacts ),     {,         this.attachedArtifacts = attachedArtifacts;,     }, ,     protected void setCompileSourceRoots( List<String> compileSourceRoots ),     {,         this.compileSourceRoots = compileSourceRoots;,     }, ,     protected void setTestCompileSourceRoots( List<String> testCompileSourceRoots ),     {,         this.testCompileSourceRoots = testCompileSourceRoots;,     }, ,     protected void setScriptSourceRoots( List<String> scriptSourceRoots ),     {,         this.scriptSourceRoots = scriptSourceRoots;,     }, ,     protected ArtifactRepository getReleaseArtifactRepository(),     {,         if ( releaseArtifactRepository == null ),         {,             if ( getDistributionManagement() != null && getDistributionManagement().getRepository() != null ),             {,                 checkProjectBuildingRequest();,                 try,                 {,                     ArtifactRepository repo =,                         repositorySystem.buildArtifactRepository( getDistributionManagement().getRepository() );,                     repositorySystem.injectProxy( projectBuilderConfiguration.getRepositorySession(),,                                                   Arrays.asList( repo ) );,                     repositorySystem.injectAuthentication( projectBuilderConfiguration.getRepositorySession(),,                                                            Arrays.asList( repo ) );,                     setReleaseArtifactRepository( repo );,                 },                 catch ( InvalidRepositoryException e ),                 {,                     throw new IllegalStateException( "Failed to create release distribution repository for " + getId(),,                                                      e );,                 },             },         }, ,         return releaseArtifactRepository;,     }, ,     protected ArtifactRepository getSnapshotArtifactRepository(),     {,         if ( snapshotArtifactRepository == null ),         {,             if ( getDistributionManagement() != null && getDistributionManagement().getSnapshotRepository() != null ),             {,                 checkProjectBuildingRequest();,                 try,                 {,                     ArtifactRepository repo =,                         repositorySystem.buildArtifactRepository( getDistributionManagement().getSnapshotRepository() );,                     repositorySystem.injectProxy( projectBuilderConfiguration.getRepositorySession(),,                                                   Arrays.asList( repo ) );,                     repositorySystem.injectAuthentication( projectBuilderConfiguration.getRepositorySession(),,                                                            Arrays.asList( repo ) );,                     setSnapshotArtifactRepository( repo );,                 },                 catch ( InvalidRepositoryException e ),                 {,                     throw new IllegalStateException(,                                                      "Failed to create snapshot distribution repository for " + getId(),,                                                      e );,                 },             },         }, ,         return snapshotArtifactRepository;,     }, ,     @Deprecated,     public Artifact replaceWithActiveArtifact( Artifact pluginArtifact ),     {,         return pluginArtifact;,     }, ,     private void deepCopy( MavenProject project ),     {,         // disown the parent, ,         // copy fields,         setFile( project.getFile() );, ,         // don't need a deep copy, they don't get modified or added/removed to/from - but make them unmodifiable to be,         // sure!,         if ( project.getDependencyArtifacts() != null ),         {,             setDependencyArtifacts( Collections.unmodifiableSet( project.getDependencyArtifacts() ) );,         }, ,         if ( project.getArtifacts() != null ),         {,             setArtifacts( Collections.unmodifiableSet( project.getArtifacts() ) );,         }, ,         if ( project.getParentFile() != null ),         {,             parentFile = new File( project.getParentFile().getAbsolutePath() );,         }, ,         if ( project.getPluginArtifacts() != null ),         {,             setPluginArtifacts( Collections.unmodifiableSet( project.getPluginArtifacts() ) );,         }, ,         if ( project.getReportArtifacts() != null ),         {,             setReportArtifacts( Collections.unmodifiableSet( project.getReportArtifacts() ) );,         }, ,         if ( project.getExtensionArtifacts() != null ),         {,             setExtensionArtifacts( Collections.unmodifiableSet( project.getExtensionArtifacts() ) );,         }, ,         setParentArtifact( ( project.getParentArtifact() ) );, ,         if ( project.getRemoteArtifactRepositories() != null ),         {,             setRemoteArtifactRepositories( Collections.unmodifiableList( project.getRemoteArtifactRepositories() ) );,         }, ,         if ( project.getPluginArtifactRepositories() != null ),         {,             setPluginArtifactRepositories( ( Collections.unmodifiableList( project.getPluginArtifactRepositories() ) ) );,         }, ,         if ( project.getActiveProfiles() != null ),         {,             setActiveProfiles( ( Collections.unmodifiableList( project.getActiveProfiles() ) ) );,         }, ,         if ( project.getAttachedArtifacts() != null ),         {,             // clone properties modifyable by plugins in a forked lifecycle,             setAttachedArtifacts( new ArrayList<Artifact>( project.getAttachedArtifacts() ) );,         }, ,         if ( project.getCompileSourceRoots() != null ),         {,             // clone source roots,             setCompileSourceRoots( ( new ArrayList<String>( project.getCompileSourceRoots() ) ) );,         }, ,         if ( project.getTestCompileSourceRoots() != null ),         {,             setTestCompileSourceRoots( ( new ArrayList<String>( project.getTestCompileSourceRoots() ) ) );,         }, ,         if ( project.getScriptSourceRoots() != null ),         {,             setScriptSourceRoots( ( new ArrayList<String>( project.getScriptSourceRoots() ) ) );,         }, ,         if ( project.getModel() != null ),         {,             setModel( project.getModel().clone() );,         }, ,         if ( project.getOriginalModel() != null ),         {,             setOriginalModel( project.getOriginalModel() );,         }, ,         setExecutionRoot( project.isExecutionRoot() );, ,         if ( project.getArtifact() != null ),         {,             setArtifact( ArtifactUtils.copyArtifact( project.getArtifact() ) );,         }, ,         if ( project.getManagedVersionMap() != null ),         {,             setManagedVersionMap( new HashMap<String, Artifact>( project.getManagedVersionMap() ) );,         }, ,         lifecyclePhases.addAll( project.lifecyclePhases );,     }, ,     private void addArtifactPath( Artifact artifact, List<String> classpath ),     {,         File file = artifact.getFile();,         if ( file != null ),         {,             classpath.add( file.getPath() );,         },     }, ,     private static String getProjectReferenceId( String groupId, String artifactId, String version ),     {,         StringBuilder buffer = new StringBuilder( 128 );,         buffer.append( groupId ).append( ':' ).append( artifactId ).append( ':' ).append( version );,         return buffer.toString();,     }, ,     /**,      * Sets the value of the context value of this project identified,      * by the given key. If the supplied value is <code>null</code>,,      * the context value is removed from this project.,      * ,      * Context values are intended to allow core extensions to associate,      * derived state with project instances. ,      */,     public void setContextValue( String key, Object value ),     {,         if ( context == null ),         {,             context = new HashMap<String, Object>();,         },         if ( value != null ),         {,             context.put( key, value );,         },         else,         {,             context.remove( key );,         },     }, ,     /**,      * Returns context value of this project associated with the given key ,      * or null if this project has no such value. ,      */,     public Object getContextValue( String key ),     {,         if ( context == null ),         {,             return null;,         },         return context.get( key );,     }, ,     /**,      * Sets the project's class realm. <strong>Warning:</strong> This is an internal utility method that is only public,      * for technical reasons, it is not part of the public API. In particular, this method can be changed or deleted,      * without prior notice and must not be used by plugins.,      * ,      * @param classRealm The class realm hosting the build extensions of this project, may be {@code null}.,      */,     public void setClassRealm( ClassRealm classRealm ),     {,         this.classRealm = classRealm;,     }, ,     /**,      * Gets the project's class realm. This class realm hosts the build extensions of the project.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @return The project's class realm or {@code null}.,      */,     public ClassRealm getClassRealm(),     {,         return classRealm;,     }, ,     /**,      * Sets the artifact filter used to exclude shared extension artifacts from plugin realms. <strong>Warning:</strong>,      * This is an internal utility method that is only public for technical reasons, it is not part of the public API.,      * In particular, this method can be changed or deleted without prior notice and must not be used by plugins.,      * ,      * @param extensionDependencyFilter The dependency filter to apply to plugins, may be {@code null}.,      */,     public void setExtensionDependencyFilter( DependencyFilter extensionDependencyFilter ),     {,         this.extensionDependencyFilter = extensionDependencyFilter;,     }, ,     /**,      * Gets the dependency filter used to exclude shared extension artifacts from plugin realms.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @return The dependency filter or {@code null}.,      */,     public DependencyFilter getExtensionDependencyFilter(),     {,         return extensionDependencyFilter;,     }, ,     /**,      * Sets the transitive dependency artifacts that have been resolved/collected for this project.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param artifacts The set of artifacts, may be {@code null}.,      */,     public void setResolvedArtifacts( Set<Artifact> artifacts ),     {,         this.resolvedArtifacts = ( artifacts != null ) ? artifacts : Collections.<Artifact> emptySet();,         this.artifacts = null;,         this.artifactMap = null;,     }, ,     /**,      * Sets the scope filter to select the artifacts being exposed to the currently executed mojo.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param artifactFilter The artifact filter, may be {@code null} to exclude all artifacts.,      */,     public void setArtifactFilter( ArtifactFilter artifactFilter ),     {,         this.artifactFilter = artifactFilter;,         this.artifacts = null;,         this.artifactMap = null;,     }, ,     /**,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param phase The phase to check for, must not be {@code null}.,      * @return {@code true} if the phase has been seen.,      */,     public boolean hasLifecyclePhase( String phase ),     {,         return lifecyclePhases.contains( phase );,     }, ,     /**,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param lifecyclePhase The lifecycle phase to add, must not be {@code null}.,      */,     public void addLifecyclePhase( String lifecyclePhase ),     {,         lifecyclePhases.add( lifecyclePhase );,     }, ,     /**,      * Gets the project building request from which this project instance was created. <strong>Warning:</strong> This is,      * an utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.,      * ,      * @return The project building request or {@code null}.,      * @since 2.1,      */,     public ProjectBuildingRequest getProjectBuildingRequest(),     {,         return projectBuilderConfiguration;,     }, ,     /**,      * Sets the project building request from which this project instance was created. <strong>Warning:</strong> This is,      * an utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.,      * ,      * @param projectBuildingRequest The project building request, may be {@code null}.,      * @since 2.1,      */,     public void setProjectBuildingRequest( ProjectBuildingRequest projectBuildingRequest ),     {,         projectBuilderConfiguration = projectBuildingRequest;,     }, ,     private void checkProjectBuildingRequest(),     {,         if ( projectBuilderConfiguration == null ),         {,             throw new IllegalStateException( "project building request missing" );,         },     }],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/maven/lifecycle/LifecycleExecutorTest.java,getExecutions,329-329,[            getExecutions( calculateExecutionPlan( session, "resources:" ) );],,getExecutions,339-339,[            getExecutions( calculateExecutionPlan( session, "org.apache.maven.plugins:maven-resources-plugin:0.1:resources:toomany" ) );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/lifecycle/LifecycleExecutorTest.java,,397-410,[        {,             public List<MavenProject> getUpstreamProjects( MavenProject project, boolean transitive ),             {,                 return Collections.emptyList();,             }, ,             public List<MavenProject> getSortedProjects(),             {,                 return Collections.singletonList( session.getCurrentProject() );,             }, ,             public List<MavenProject> getDownstreamProjects( MavenProject project, boolean transitive ),             {,                 return Collections.emptyList();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/lifecycle/LifecycleExecutorTest.java,,417-454,[        {,             public void beforeMojoExecution( MojoExecutionEvent event ),                 throws MojoExecutionException,             {,                 assertNotNull( event.getSession() );,                 assertNotNull( event.getProject() );,                 assertNotNull( event.getExecution() );,                 assertNotNull( event.getMojo() );,                 assertNull( event.getCause() );, ,                 log.add( "beforeMojoExecution " + event.getProject().getArtifactId() + ":",                     + event.getExecution().getExecutionId() );,             }, ,             public void afterMojoExecutionSuccess( MojoExecutionEvent event ),                 throws MojoExecutionException,             {,                 assertNotNull( event.getSession() );,                 assertNotNull( event.getProject() );,                 assertNotNull( event.getExecution() );,                 assertNotNull( event.getMojo() );,                 assertNull( event.getCause() );, ,                 log.add( "afterMojoExecutionSuccess " + event.getProject().getArtifactId() + ":",                     + event.getExecution().getExecutionId() );,             }, ,             public void afterExecutionFailure( MojoExecutionEvent event ),             {,                 assertNotNull( event.getSession() );,                 assertNotNull( event.getProject() );,                 assertNotNull( event.getExecution() );,                 assertNotNull( event.getMojo() );,                 assertNotNull( event.getCause() );, ,                 log.add( "afterExecutionFailure " + event.getProject().getArtifactId() + ":",                     + event.getExecution().getExecutionId() );,             }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/lifecycle/LifecycleExecutorTest.java,,457-499,[        {,             public void beforeProjectExecution( ProjectExecutionEvent event ),                 throws LifecycleExecutionException,             {,                 assertNotNull( event.getSession() );,                 assertNotNull( event.getProject() );,                 assertNull( event.getExecutionPlan() );,                 assertNull( event.getCause() );, ,                 log.add( "beforeProjectExecution " + event.getProject().getArtifactId() );,             }, ,             public void beforeProjectLifecycleExecution( ProjectExecutionEvent event ),                 throws LifecycleExecutionException,             {,                 assertNotNull( event.getSession() );,                 assertNotNull( event.getProject() );,                 assertNotNull( event.getExecutionPlan() );,                 assertNull( event.getCause() );, ,                 log.add( "beforeProjectLifecycleExecution " + event.getProject().getArtifactId() );,             }, ,             public void afterProjectExecutionSuccess( ProjectExecutionEvent event ),                 throws LifecycleExecutionException,             {,                 assertNotNull( event.getSession() );,                 assertNotNull( event.getProject() );,                 assertNotNull( event.getExecutionPlan() );,                 assertNull( event.getCause() );, ,                 log.add( "afterProjectExecutionSuccess " + event.getProject().getArtifactId() );,             }, ,             public void afterProjectExecutionFailure( ProjectExecutionEvent event ),             {,                 assertNotNull( event.getSession() );,                 assertNotNull( event.getProject() );,                 assertNull( event.getExecutionPlan() );,                 assertNotNull( event.getCause() );, ,                 log.add( "afterProjectExecutionFailure " + event.getProject().getArtifactId() );,             }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/maven/lifecycle/internal/BuildLogItem.java,,163-216,[        {,             this.upstreamProject = upstreamProject;,             this.executionPlanItem = executionPlanItem;,             this.start = start;,             this.stop = stop;,             this.message = message;,         }, ,         DependencyLogEntry( MavenProject upstreamProject, String message ),         {,             this( upstreamProject, null, null, null, message );,         }, ,         public String toString(),         {,             return upstreamProject.getName() + ":" + getExecutionPlanItem() + getElapsed() + getMessage();,         }, ,         public String toNodeKey(),         {,             return nodeKey( upstreamProject, executionPlanItem );,         }, ,         public String toNodeDescription( long rootStart ),         {,             return "";,         }, , ,         private String getMessage(),         {,             return message != null ? message : "";,         }, ,         private String getExecutionPlanItem(),         {,             if ( executionPlanItem != null ),             {,                 return getMojoExecutionDescription( executionPlanItem );,             },             else,             {,                 return "";,             },         }, ,         private String getElapsed(),         {,             if ( start != null && stop != null ),             {,                 long elapsed = stop - start;,                 return elapsed > 0 ? ", wait=" + elapsed : "";,             },             return "";],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/maven/lifecycle/internal/ConcurrentBuildLogger.java,toGraph,106-106,[            final Collection<BuildLogItem> builtLogItems = multiMap.get( mavenProject );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/lifecycle/internal/ConcurrentBuildLoggerTest.java,testToGraph,59-59,[        final BuildLogItem a1 = concurrentBuildLogger.createBuildLogItem( A, planItemIterator.next() );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/lifecycle/internal/ConcurrentBuildLoggerTest.java,testToGraph,61-61,[        final BuildLogItem a2 = concurrentBuildLogger.createBuildLogItem( A, planItemIterator.next() );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/lifecycle/internal/ConcurrentBuildLoggerTest.java,testToGraph,56-56,[            lifecycleExecutionPlanCalculator.calculateExecutionPlan( session1, B, taskSegment1.getTasks() );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/lifecycle/internal/DefaultLifecyclePluginAnalyzer.java,,140-144,[        {, ,             public int compare( Lifecycle l1, Lifecycle l2 ),             {,                 return l1.getId().compareTo( l2.getId() );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/lifecycle/internal/ExecutionPlanItemTest.java,,45-49,[        {,             public void run(),             {,                 item.setComplete();,             }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/maven/lifecycle/internal/LifecycleModuleBuilder.java,buildProject,119-119,[        catch ( Exception e )],,
STYLE,REC_CATCH_EXCEPTION,org/apache/maven/lifecycle/internal/LifecycleStarter.java,execute,165-165,[        catch ( Exception e )],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/maven/lifecycle/internal/LifecycleThreadedBuilder.java,build,72-72,[                multiThreadedProjectTaskSegmentBuild( analyzer, reactorContext, session, service, taskSegment,],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/maven/lifecycle/internal/LifecycleWeaveBuilder.java,build,145-145,[                    executionPlans.put( projectSegment.getProject(), plans.get( projectSegment ).get() );],,
STYLE,REC_CATCH_EXCEPTION,org/apache/maven/lifecycle/internal/LifecycleWeaveBuilder.java,call,279-279,[                catch ( Exception e )],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/lifecycle/internal/LifecycleWeaveBuilderTest.java,testBuildProjectThreaded,66-66,[        ExecutorCompletionService<ProjectSegment> service = new ExecutorCompletionService<ProjectSegment>( executor );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/lifecycle/internal/LifecycleWeaveBuilderTest.java,testBuildProjectThreadedAggressive,76-76,[        ExecutorCompletionService<ProjectSegment> service = new ExecutorCompletionService<ProjectSegment>( executor );],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/maven/lifecycle/internal/MojoDescriptorCreator.java,getMojoDescriptor,228-228,[        if ( plugin.getVersion() == null )],,getMojoDescriptor,148-148,[        Plugin plugin = null;],,getMojoDescriptor,193-193,[        else if ( numTokens <= 2 )],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/maven/lifecycle/internal/MojoDescriptorCreator.java,getMojoDescriptor,174-174,[                goal += ":" + tok.nextToken();],,
STYLE,UC_USELESS_CONDITION,org/apache/maven/lifecycle/internal/MojoDescriptorCreator.java,getMojoDescriptor,193-193,[        else if ( numTokens <= 2 )],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/maven/lifecycle/internal/ThreadLockedArtifact.java,compareTo,41-41,[class ThreadLockedArtifact],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/lifecycle/internal/ThreadOutputMuxer.java,<init>,54-54,[    private final PrintStream defaultPringStream = new PrintStream( defaultOutputStreamForUnknownData );],,<init>,144-144,[            printStreams.put( segmentChunk, new PrintStream( value ) );],,
MT_CORRECTNESS,NN_NAKED_NOTIFY,org/apache/maven/lifecycle/internal/ThreadOutputMuxer.java,setThisModuleComplete,195-195,[            stream.notifyAll();],,
MT_CORRECTNESS,SC_START_IN_CTOR,org/apache/maven/lifecycle/internal/ThreadOutputMuxer.java,<init>,150-150,[        new Thread( printer ).start();],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/maven/lifecycle/internal/ThreadOutputMuxer.java,run,94-94,[                            projectStream.wait( 100 );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/lifecycle/internal/ThreadOutputMuxer.java,<init>,211-211,[            super( systemOutStream );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/lifecycle/internal/ThreadOutputMuxerTest.java,testMultiThreaded,91-91,[        PrintStream systemOut = new PrintStream( byteArrayOutputStream );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/lifecycle/internal/ThreadOutputMuxerTest.java,testMultiThreaded,122-122,[        String result = new String( bytes );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/lifecycle/internal/ThreadOutputMuxerTest.java,testSingleThreaded,65-65,[        PrintStream systemOut = new PrintStream( byteArrayOutputStream );],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/maven/lifecycle/internal/ThreadOutputMuxerTest.java,,55-55,[    final String full = "Full";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/maven/lifecycle/internal/ThreadOutputMuxerTest.java,,53-53,[    final String in = "In";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/maven/lifecycle/internal/ThreadOutputMuxerTest.java,,51-51,[    final String paid = "Paid";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/maven/lifecycle/internal/ThreadOutputMuxerTest.java,,128-150,[    class Outputter,         implements Callable<ProjectSegment>,     {,         private final ThreadOutputMuxer threadOutputMuxer;, ,         private final ProjectSegment item;, ,         private final String response;, ,         Outputter( ThreadOutputMuxer threadOutputMuxer, ProjectSegment item, String response ),         {,             this.threadOutputMuxer = threadOutputMuxer;,             this.item = item;,             this.response = response;,         }, ,         public ProjectSegment call(),             throws Exception,         {,             threadOutputMuxer.associateThreadWithProjectSegment( item );,             System.out.print( response );,             threadOutputMuxer.setThisModuleComplete( item );,             return item;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/lifecycle/internal/stub/PluginPrefixResolverStub.java,,35-48,[        {,             public String getGroupId(),             {,                 return "com.foobar";,             }, ,             public String getArtifactId(),             {,                 return "bazbaz";,             }, ,             public ArtifactRepository getRepository(),             {,                 return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/lifecycle/internal/stub/PluginVersionResolverStub.java,,36-44,[        {,             public String getVersion(),             {,                 return "0.42";,             }, ,             public ArtifactRepository getRepository(),             {,                 return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/lifecycle/internal/stub/ProjectDependenciesResolverStub.java,,75-104,[        {, ,             public List<Dependency> getUnresolvedDependencies(),             {,                 return Collections.emptyList();,             }, ,             public List<Dependency> getResolvedDependencies(),             {,                 return Collections.emptyList();,             }, ,             public List<Exception> getResolutionErrors( Dependency dependency ),             {,                 return Collections.emptyList();,             }, ,             public DependencyNode getDependencyGraph(),             {,                 return new DefaultDependencyNode( (Dependency) null );,             }, ,             public List<Dependency> getDependencies(),             {,                 return Collections.emptyList();,             }, ,             public List<Exception> getCollectionErrors(),             {,                 return Collections.emptyList();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/maven/lifecycle/internal/stub/ProjectDependencyGraphStub.java,,138-157,[        {,             this.dependant = dependant;,             this.dependency = dependency;,         }, ,         void addIfDownstream( MavenProject mavenProject, List<MavenProject> result ),         {,             if ( dependency == mavenProject ),             {,                 result.add( dependant );,             },         }, ,         void addIfUpstreamOf( MavenProject mavenProject, List<MavenProject> result ),         {,             if ( dependant == mavenProject ),             {,                 result.add( dependency ); // All projects are the statics from this class,             },         }],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/maven/lifecycle/mapping/DefaultLifecycleMapping.java,,46-46,[            if ( lifecycles != null )],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/maven/lifecycle/mapping/DefaultLifecycleMapping.java,,103-103,[            return phases;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Activation.java,,15-272,[@SuppressWarnings( "all" ), public class Activation,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * If set to true, this profile will be active unless another,      * profile in this,      *             pom is activated using the command line -P,      * option or by one of that profile's,      *             activators.,      */,     private boolean activeByDefault = false;, ,     /**,      * ,      *             ,      *             Specifies that this profile will be activated,      * when a matching JDK is detected.,      *             For example, <code>1.4</code> only activates on,      * JDKs versioned 1.4,,      *             while <code>!1.4</code> matches any JDK that is,      * not version 1.4.,      *             ,      *           ,      */,     private String jdk;, ,     /**,      * Specifies that this profile will be activated when matching,      * operating system,      *             attributes are detected.,      */,     private ActivationOS os;, ,     /**,      * Specifies that this profile will be activated when this,      * system property is,      *             specified.,      */,     private ActivationProperty property;, ,     /**,      * Specifies that this profile will be activated based on,      * existence of a file.,      */,     private ActivationFile file;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Activation,      */,     public Activation clone(),     {,         try,         {,             Activation copy = (Activation) super.clone();, ,             if ( this.os != null ),             {,                 copy.os = (ActivationOS) this.os.clone();,             }, ,             if ( this.property != null ),             {,                 copy.property = (ActivationProperty) this.property.clone();,             }, ,             if ( this.file != null ),             {,                 copy.file = (ActivationFile) this.file.clone();,             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Activation clone(), ,     /**,      * Get specifies that this profile will be activated based on,      * existence of a file.,      * ,      * @return ActivationFile,      */,     public ActivationFile getFile(),     {,         return this.file;,     } //-- ActivationFile getFile(), ,     /**,      * Get specifies that this profile will be activated when a,      * matching JDK is detected.,      *             For example, <code>1.4</code> only activates on,      * JDKs versioned 1.4,,      *             while <code>!1.4</code> matches any JDK that is,      * not version 1.4.,      * ,      * @return String,      */,     public String getJdk(),     {,         return this.jdk;,     } //-- String getJdk(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get specifies that this profile will be activated when,      * matching operating system,      *             attributes are detected.,      * ,      * @return ActivationOS,      */,     public ActivationOS getOs(),     {,         return this.os;,     } //-- ActivationOS getOs(), ,     /**,      * Get specifies that this profile will be activated when this,      * system property is,      *             specified.,      * ,      * @return ActivationProperty,      */,     public ActivationProperty getProperty(),     {,         return this.property;,     } //-- ActivationProperty getProperty(), ,     /**,      * Get if set to true, this profile will be active unless,      * another profile in this,      *             pom is activated using the command line -P,      * option or by one of that profile's,      *             activators.,      * ,      * @return boolean,      */,     public boolean isActiveByDefault(),     {,         return this.activeByDefault;,     } //-- boolean isActiveByDefault(), ,     /**,      * Set if set to true, this profile will be active unless,      * another profile in this,      *             pom is activated using the command line -P,      * option or by one of that profile's,      *             activators.,      * ,      * @param activeByDefault,      */,     public void setActiveByDefault( boolean activeByDefault ),     {,         this.activeByDefault = activeByDefault;,     } //-- void setActiveByDefault( boolean ), ,     /**,      * Set specifies that this profile will be activated based on,      * existence of a file.,      * ,      * @param file,      */,     public void setFile( ActivationFile file ),     {,         this.file = file;,     } //-- void setFile( ActivationFile ), ,     /**,      * Set specifies that this profile will be activated when a,      * matching JDK is detected.,      *             For example, <code>1.4</code> only activates on,      * JDKs versioned 1.4,,      *             while <code>!1.4</code> matches any JDK that is,      * not version 1.4.,      * ,      * @param jdk,      */,     public void setJdk( String jdk ),     {,         this.jdk = jdk;,     } //-- void setJdk( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set specifies that this profile will be activated when,      * matching operating system,      *             attributes are detected.,      * ,      * @param os,      */,     public void setOs( ActivationOS os ),     {,         this.os = os;,     } //-- void setOs( ActivationOS ), ,     /**,      * Set specifies that this profile will be activated when this,      * system property is,      *             specified.,      * ,      * @param property,      */,     public void setProperty( ActivationProperty property ),     {,         this.property = property;,     } //-- void setProperty( ActivationProperty )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/ActivationFile.java,,19-147,[@SuppressWarnings( "all" ), public class ActivationFile,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The name of the file that must be missing to activate the,      *           profile.,      */,     private String missing;, ,     /**,      * The name of the file that must exist to activate the profile.,      */,     private String exists;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return ActivationFile,      */,     public ActivationFile clone(),     {,         try,         {,             ActivationFile copy = (ActivationFile) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ActivationFile clone(), ,     /**,      * Get the name of the file that must exist to activate the,      * profile.,      * ,      * @return String,      */,     public String getExists(),     {,         return this.exists;,     } //-- String getExists(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the name of the file that must be missing to activate,      * the,      *           profile.,      * ,      * @return String,      */,     public String getMissing(),     {,         return this.missing;,     } //-- String getMissing(), ,     /**,      * Set the name of the file that must exist to activate the,      * profile.,      * ,      * @param exists,      */,     public void setExists( String exists ),     {,         this.exists = exists;,     } //-- void setExists( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the name of the file that must be missing to activate,      * the,      *           profile.,      * ,      * @param missing,      */,     public void setMissing( String missing ),     {,         this.missing = missing;,     } //-- void setMissing( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ActivationFileTest.java,testEqualsNullSafe,42-42,[        new ActivationFile().equals( new ActivationFile() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/ActivationOS.java,,15-221,[@SuppressWarnings( "all" ), public class ActivationOS,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The name of the operating system to be used to,      * activate the profile. This must be an exact match,      *             of the <code>${os.name}</code> Java property,,      * such as <code>Windows XP</code>.,      *             ,      *           ,      */,     private String name;, ,     /**,      * ,      *             ,      *             The general family of the OS to be used to,      * activate the profile, such as,      *             <code>windows</code> or <code>unix</code>.,      *             ,      *           ,      */,     private String family;, ,     /**,      * The architecture of the operating system to be used to,      * activate the,      *           profile.,      */,     private String arch;, ,     /**,      * The version of the operating system to be used to activate,      * the,      *           profile.,      */,     private String version;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return ActivationOS,      */,     public ActivationOS clone(),     {,         try,         {,             ActivationOS copy = (ActivationOS) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ActivationOS clone(), ,     /**,      * Get the architecture of the operating system to be used to,      * activate the,      *           profile.,      * ,      * @return String,      */,     public String getArch(),     {,         return this.arch;,     } //-- String getArch(), ,     /**,      * Get the general family of the OS to be used to activate the,      * profile, such as,      *             <code>windows</code> or <code>unix</code>.,      * ,      * @return String,      */,     public String getFamily(),     {,         return this.family;,     } //-- String getFamily(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the name of the operating system to be used to activate,      * the profile. This must be an exact match,      *             of the <code>${os.name}</code> Java property,,      * such as <code>Windows XP</code>.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the version of the operating system to be used to,      * activate the,      *           profile.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Set the architecture of the operating system to be used to,      * activate the,      *           profile.,      * ,      * @param arch,      */,     public void setArch( String arch ),     {,         this.arch = arch;,     } //-- void setArch( String ), ,     /**,      * Set the general family of the OS to be used to activate the,      * profile, such as,      *             <code>windows</code> or <code>unix</code>.,      * ,      * @param family,      */,     public void setFamily( String family ),     {,         this.family = family;,     } //-- void setFamily( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the name of the operating system to be used to activate,      * the profile. This must be an exact match,      *             of the <code>${os.name}</code> Java property,,      * such as <code>Windows XP</code>.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the version of the operating system to be used to,      * activate the,      *           profile.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ActivationOSTest.java,testEqualsNullSafe,42-42,[        new ActivationOS().equals( new ActivationOS() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/ActivationProperty.java,,18-143,[@SuppressWarnings( "all" ), public class ActivationProperty,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The name of the property to be used to activate a profile.,      */,     private String name;, ,     /**,      * The value of the property required to activate a profile.,      */,     private String value;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return ActivationProperty,      */,     public ActivationProperty clone(),     {,         try,         {,             ActivationProperty copy = (ActivationProperty) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ActivationProperty clone(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the name of the property to be used to activate a,      * profile.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the value of the property required to activate a,      * profile.,      * ,      * @return String,      */,     public String getValue(),     {,         return this.value;,     } //-- String getValue(), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the name of the property to be used to activate a,      * profile.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the value of the property required to activate a,      * profile.,      * ,      * @param value,      */,     public void setValue( String value ),     {,         this.value = value;,     } //-- void setValue( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ActivationPropertyTest.java,testEqualsNullSafe,42-42,[        new ActivationProperty().equals( new ActivationProperty() );],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ActivationTest.java,testEqualsNullSafe,42-42,[        new Activation().equals( new Activation() );],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/Build.java,,18-285,[@SuppressWarnings( "all" ), public class Build,     extends BuildBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * This element specifies a directory containing the source of,      * the project. The,      *             generated build system will compile the source,      * in this directory when the project is,      *             built. The path given is relative to the project,      * descriptor.,      */,     private String sourceDirectory;, ,     /**,      * This element specifies a directory containing the script,      * sources of the,      *             project. This directory is meant to be different,      * from the sourceDirectory, in that its,      *             contents will be copied to the output directory,      * in most cases (since scripts are,      *             interpreted rather than compiled).,      */,     private String scriptSourceDirectory;, ,     /**,      * This element specifies a directory containing the unit test,      * source of the,      *             project. The generated build system will compile,      * these directories when the project is,      *             being tested. The path given is relative to the,      * project descriptor.,      */,     private String testSourceDirectory;, ,     /**,      * The directory where compiled application classes are placed.,      */,     private String outputDirectory;, ,     /**,      * The directory where compiled test classes are placed.,      */,     private String testOutputDirectory;, ,     /**,      * Field extensions.,      */,     private java.util.List<Extension> extensions;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addExtension.,      * ,      * @param extension,      */,     public void addExtension( Extension extension ),     {,         getExtensions().add( extension );,     } //-- void addExtension( Extension ), ,     /**,      * Method clone.,      * ,      * @return Build,      */,     public Build clone(),     {,         try,         {,             Build copy = (Build) super.clone();, ,             if ( this.extensions != null ),             {,                 copy.extensions = new java.util.ArrayList<Extension>();,                 for ( Extension item : this.extensions ),                 {,                     copy.extensions.add( ( (Extension) item).clone() );,                 },             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Build clone(), ,     /**,      * Method getExtensions.,      * ,      * @return List,      */,     public java.util.List<Extension> getExtensions(),     {,         if ( this.extensions == null ),         {,             this.extensions = new java.util.ArrayList<Extension>();,         }, ,         return this.extensions;,     } //-- java.util.List<Extension> getExtensions(), ,     /**,      * Get the directory where compiled application classes are,      * placed.,      * ,      * @return String,      */,     public String getOutputDirectory(),     {,         return this.outputDirectory;,     } //-- String getOutputDirectory(), ,     /**,      * Get this element specifies a directory containing the script,      * sources of the,      *             project. This directory is meant to be different,      * from the sourceDirectory, in that its,      *             contents will be copied to the output directory,      * in most cases (since scripts are,      *             interpreted rather than compiled).,      * ,      * @return String,      */,     public String getScriptSourceDirectory(),     {,         return this.scriptSourceDirectory;,     } //-- String getScriptSourceDirectory(), ,     /**,      * Get this element specifies a directory containing the source,      * of the project. The,      *             generated build system will compile the source,      * in this directory when the project is,      *             built. The path given is relative to the project,      * descriptor.,      * ,      * @return String,      */,     public String getSourceDirectory(),     {,         return this.sourceDirectory;,     } //-- String getSourceDirectory(), ,     /**,      * Get the directory where compiled test classes are placed.,      * ,      * @return String,      */,     public String getTestOutputDirectory(),     {,         return this.testOutputDirectory;,     } //-- String getTestOutputDirectory(), ,     /**,      * Get this element specifies a directory containing the unit,      * test source of the,      *             project. The generated build system will compile,      * these directories when the project is,      *             being tested. The path given is relative to the,      * project descriptor.,      * ,      * @return String,      */,     public String getTestSourceDirectory(),     {,         return this.testSourceDirectory;,     } //-- String getTestSourceDirectory(), ,     /**,      * Method removeExtension.,      * ,      * @param extension,      */,     public void removeExtension( Extension extension ),     {,         getExtensions().remove( extension );,     } //-- void removeExtension( Extension ), ,     /**,      * Set a set of build extensions to use from this project.,      * ,      * @param extensions,      */,     public void setExtensions( java.util.List<Extension> extensions ),     {,         this.extensions = extensions;,     } //-- void setExtensions( java.util.List ), ,     /**,      * Set the directory where compiled application classes are,      * placed.,      * ,      * @param outputDirectory,      */,     public void setOutputDirectory( String outputDirectory ),     {,         this.outputDirectory = outputDirectory;,     } //-- void setOutputDirectory( String ), ,     /**,      * Set this element specifies a directory containing the script,      * sources of the,      *             project. This directory is meant to be different,      * from the sourceDirectory, in that its,      *             contents will be copied to the output directory,      * in most cases (since scripts are,      *             interpreted rather than compiled).,      * ,      * @param scriptSourceDirectory,      */,     public void setScriptSourceDirectory( String scriptSourceDirectory ),     {,         this.scriptSourceDirectory = scriptSourceDirectory;,     } //-- void setScriptSourceDirectory( String ), ,     /**,      * Set this element specifies a directory containing the source,      * of the project. The,      *             generated build system will compile the source,      * in this directory when the project is,      *             built. The path given is relative to the project,      * descriptor.,      * ,      * @param sourceDirectory,      */,     public void setSourceDirectory( String sourceDirectory ),     {,         this.sourceDirectory = sourceDirectory;,     } //-- void setSourceDirectory( String ), ,     /**,      * Set the directory where compiled test classes are placed.,      * ,      * @param testOutputDirectory,      */,     public void setTestOutputDirectory( String testOutputDirectory ),     {,         this.testOutputDirectory = testOutputDirectory;,     } //-- void setTestOutputDirectory( String ), ,     /**,      * Set this element specifies a directory containing the unit,      * test source of the,      *             project. The generated build system will compile,      * these directories when the project is,      *             being tested. The path given is relative to the,      * project descriptor.,      * ,      * @param testSourceDirectory,      */,     public void setTestSourceDirectory( String testSourceDirectory ),     {,         this.testSourceDirectory = testSourceDirectory;,     } //-- void setTestSourceDirectory( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Build.java,,18-285,[@SuppressWarnings( "all" ), public class Build,     extends BuildBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * This element specifies a directory containing the source of,      * the project. The,      *             generated build system will compile the source,      * in this directory when the project is,      *             built. The path given is relative to the project,      * descriptor.,      */,     private String sourceDirectory;, ,     /**,      * This element specifies a directory containing the script,      * sources of the,      *             project. This directory is meant to be different,      * from the sourceDirectory, in that its,      *             contents will be copied to the output directory,      * in most cases (since scripts are,      *             interpreted rather than compiled).,      */,     private String scriptSourceDirectory;, ,     /**,      * This element specifies a directory containing the unit test,      * source of the,      *             project. The generated build system will compile,      * these directories when the project is,      *             being tested. The path given is relative to the,      * project descriptor.,      */,     private String testSourceDirectory;, ,     /**,      * The directory where compiled application classes are placed.,      */,     private String outputDirectory;, ,     /**,      * The directory where compiled test classes are placed.,      */,     private String testOutputDirectory;, ,     /**,      * Field extensions.,      */,     private java.util.List<Extension> extensions;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addExtension.,      * ,      * @param extension,      */,     public void addExtension( Extension extension ),     {,         getExtensions().add( extension );,     } //-- void addExtension( Extension ), ,     /**,      * Method clone.,      * ,      * @return Build,      */,     public Build clone(),     {,         try,         {,             Build copy = (Build) super.clone();, ,             if ( this.extensions != null ),             {,                 copy.extensions = new java.util.ArrayList<Extension>();,                 for ( Extension item : this.extensions ),                 {,                     copy.extensions.add( ( (Extension) item).clone() );,                 },             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Build clone(), ,     /**,      * Method getExtensions.,      * ,      * @return List,      */,     public java.util.List<Extension> getExtensions(),     {,         if ( this.extensions == null ),         {,             this.extensions = new java.util.ArrayList<Extension>();,         }, ,         return this.extensions;,     } //-- java.util.List<Extension> getExtensions(), ,     /**,      * Get the directory where compiled application classes are,      * placed.,      * ,      * @return String,      */,     public String getOutputDirectory(),     {,         return this.outputDirectory;,     } //-- String getOutputDirectory(), ,     /**,      * Get this element specifies a directory containing the script,      * sources of the,      *             project. This directory is meant to be different,      * from the sourceDirectory, in that its,      *             contents will be copied to the output directory,      * in most cases (since scripts are,      *             interpreted rather than compiled).,      * ,      * @return String,      */,     public String getScriptSourceDirectory(),     {,         return this.scriptSourceDirectory;,     } //-- String getScriptSourceDirectory(), ,     /**,      * Get this element specifies a directory containing the source,      * of the project. The,      *             generated build system will compile the source,      * in this directory when the project is,      *             built. The path given is relative to the project,      * descriptor.,      * ,      * @return String,      */,     public String getSourceDirectory(),     {,         return this.sourceDirectory;,     } //-- String getSourceDirectory(), ,     /**,      * Get the directory where compiled test classes are placed.,      * ,      * @return String,      */,     public String getTestOutputDirectory(),     {,         return this.testOutputDirectory;,     } //-- String getTestOutputDirectory(), ,     /**,      * Get this element specifies a directory containing the unit,      * test source of the,      *             project. The generated build system will compile,      * these directories when the project is,      *             being tested. The path given is relative to the,      * project descriptor.,      * ,      * @return String,      */,     public String getTestSourceDirectory(),     {,         return this.testSourceDirectory;,     } //-- String getTestSourceDirectory(), ,     /**,      * Method removeExtension.,      * ,      * @param extension,      */,     public void removeExtension( Extension extension ),     {,         getExtensions().remove( extension );,     } //-- void removeExtension( Extension ), ,     /**,      * Set a set of build extensions to use from this project.,      * ,      * @param extensions,      */,     public void setExtensions( java.util.List<Extension> extensions ),     {,         this.extensions = extensions;,     } //-- void setExtensions( java.util.List ), ,     /**,      * Set the directory where compiled application classes are,      * placed.,      * ,      * @param outputDirectory,      */,     public void setOutputDirectory( String outputDirectory ),     {,         this.outputDirectory = outputDirectory;,     } //-- void setOutputDirectory( String ), ,     /**,      * Set this element specifies a directory containing the script,      * sources of the,      *             project. This directory is meant to be different,      * from the sourceDirectory, in that its,      *             contents will be copied to the output directory,      * in most cases (since scripts are,      *             interpreted rather than compiled).,      * ,      * @param scriptSourceDirectory,      */,     public void setScriptSourceDirectory( String scriptSourceDirectory ),     {,         this.scriptSourceDirectory = scriptSourceDirectory;,     } //-- void setScriptSourceDirectory( String ), ,     /**,      * Set this element specifies a directory containing the source,      * of the project. The,      *             generated build system will compile the source,      * in this directory when the project is,      *             built. The path given is relative to the project,      * descriptor.,      * ,      * @param sourceDirectory,      */,     public void setSourceDirectory( String sourceDirectory ),     {,         this.sourceDirectory = sourceDirectory;,     } //-- void setSourceDirectory( String ), ,     /**,      * Set the directory where compiled test classes are placed.,      * ,      * @param testOutputDirectory,      */,     public void setTestOutputDirectory( String testOutputDirectory ),     {,         this.testOutputDirectory = testOutputDirectory;,     } //-- void setTestOutputDirectory( String ), ,     /**,      * Set this element specifies a directory containing the unit,      * test source of the,      *             project. The generated build system will compile,      * these directories when the project is,      *             being tested. The path given is relative to the,      * project descriptor.,      * ,      * @param testSourceDirectory,      */,     public void setTestSourceDirectory( String testSourceDirectory ),     {,         this.testSourceDirectory = testSourceDirectory;,     } //-- void setTestSourceDirectory( String )],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/BuildBase.java,,13-342,[@SuppressWarnings( "all" ), public class BuildBase,     extends PluginConfiguration,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The default goal (or phase in Maven 2) to execute when none,      * is specified for,      *             the project. Note that in case of a multi-module,      * build, only the default goal of the top-level,      *             project is relevant, i.e. the default goals of,      * child modules are ignored. Since Maven 3,,      *             multiple goals/phases can be separated by,      * whitespace.,      */,     private String defaultGoal;, ,     /**,      * Field resources.,      */,     private java.util.List<Resource> resources;, ,     /**,      * Field testResources.,      */,     private java.util.List<Resource> testResources;, ,     /**,      * The directory where all files generated by the build are,      * placed.,      */,     private String directory;, ,     /**,      * ,      *             ,      *             The filename (excluding the extension, and with,      * no path information) that,      *             the produced artifact will be called.,      *             The default value is,      * <code>${artifactId}-${version}</code>.,      *             ,      *           ,      */,     private String finalName;, ,     /**,      * Field filters.,      */,     private java.util.List<String> filters;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addFilter.,      * ,      * @param string,      */,     public void addFilter( String string ),     {,         getFilters().add( string );,     } //-- void addFilter( String ), ,     /**,      * Method addResource.,      * ,      * @param resource,      */,     public void addResource( Resource resource ),     {,         getResources().add( resource );,     } //-- void addResource( Resource ), ,     /**,      * Method addTestResource.,      * ,      * @param resource,      */,     public void addTestResource( Resource resource ),     {,         getTestResources().add( resource );,     } //-- void addTestResource( Resource ), ,     /**,      * Method clone.,      * ,      * @return BuildBase,      */,     public BuildBase clone(),     {,         try,         {,             BuildBase copy = (BuildBase) super.clone();, ,             if ( this.resources != null ),             {,                 copy.resources = new java.util.ArrayList<Resource>();,                 for ( Resource item : this.resources ),                 {,                     copy.resources.add( ( (Resource) item).clone() );,                 },             }, ,             if ( this.testResources != null ),             {,                 copy.testResources = new java.util.ArrayList<Resource>();,                 for ( Resource item : this.testResources ),                 {,                     copy.testResources.add( ( (Resource) item).clone() );,                 },             }, ,             if ( this.filters != null ),             {,                 copy.filters = new java.util.ArrayList<String>();,                 copy.filters.addAll( this.filters );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- BuildBase clone(), ,     /**,      * Get the default goal (or phase in Maven 2) to execute when,      * none is specified for,      *             the project. Note that in case of a multi-module,      * build, only the default goal of the top-level,      *             project is relevant, i.e. the default goals of,      * child modules are ignored. Since Maven 3,,      *             multiple goals/phases can be separated by,      * whitespace.,      * ,      * @return String,      */,     public String getDefaultGoal(),     {,         return this.defaultGoal;,     } //-- String getDefaultGoal(), ,     /**,      * Get the directory where all files generated by the build are,      * placed.,      * ,      * @return String,      */,     public String getDirectory(),     {,         return this.directory;,     } //-- String getDirectory(), ,     /**,      * Method getFilters.,      * ,      * @return List,      */,     public java.util.List<String> getFilters(),     {,         if ( this.filters == null ),         {,             this.filters = new java.util.ArrayList<String>();,         }, ,         return this.filters;,     } //-- java.util.List<String> getFilters(), ,     /**,      * Get the filename (excluding the extension, and with no path,      * information) that,      *             the produced artifact will be called.,      *             The default value is,      * <code>${artifactId}-${version}</code>.,      * ,      * @return String,      */,     public String getFinalName(),     {,         return this.finalName;,     } //-- String getFinalName(), ,     /**,      * Method getResources.,      * ,      * @return List,      */,     public java.util.List<Resource> getResources(),     {,         if ( this.resources == null ),         {,             this.resources = new java.util.ArrayList<Resource>();,         }, ,         return this.resources;,     } //-- java.util.List<Resource> getResources(), ,     /**,      * Method getTestResources.,      * ,      * @return List,      */,     public java.util.List<Resource> getTestResources(),     {,         if ( this.testResources == null ),         {,             this.testResources = new java.util.ArrayList<Resource>();,         }, ,         return this.testResources;,     } //-- java.util.List<Resource> getTestResources(), ,     /**,      * Method removeFilter.,      * ,      * @param string,      */,     public void removeFilter( String string ),     {,         getFilters().remove( string );,     } //-- void removeFilter( String ), ,     /**,      * Method removeResource.,      * ,      * @param resource,      */,     public void removeResource( Resource resource ),     {,         getResources().remove( resource );,     } //-- void removeResource( Resource ), ,     /**,      * Method removeTestResource.,      * ,      * @param resource,      */,     public void removeTestResource( Resource resource ),     {,         getTestResources().remove( resource );,     } //-- void removeTestResource( Resource ), ,     /**,      * Set the default goal (or phase in Maven 2) to execute when,      * none is specified for,      *             the project. Note that in case of a multi-module,      * build, only the default goal of the top-level,      *             project is relevant, i.e. the default goals of,      * child modules are ignored. Since Maven 3,,      *             multiple goals/phases can be separated by,      * whitespace.,      * ,      * @param defaultGoal,      */,     public void setDefaultGoal( String defaultGoal ),     {,         this.defaultGoal = defaultGoal;,     } //-- void setDefaultGoal( String ), ,     /**,      * Set the directory where all files generated by the build are,      * placed.,      * ,      * @param directory,      */,     public void setDirectory( String directory ),     {,         this.directory = directory;,     } //-- void setDirectory( String ), ,     /**,      * Set the list of filter properties files that are used when,      * filtering is enabled.,      * ,      * @param filters,      */,     public void setFilters( java.util.List<String> filters ),     {,         this.filters = filters;,     } //-- void setFilters( java.util.List ), ,     /**,      * Set the filename (excluding the extension, and with no path,      * information) that,      *             the produced artifact will be called.,      *             The default value is,      * <code>${artifactId}-${version}</code>.,      * ,      * @param finalName,      */,     public void setFinalName( String finalName ),     {,         this.finalName = finalName;,     } //-- void setFinalName( String ), ,     /**,      * Set this element describes all of the classpath resources,      * such as properties,      *             files associated with a project. These resources,      * are often included in the final,      *             package.,      * ,      * @param resources,      */,     public void setResources( java.util.List<Resource> resources ),     {,         this.resources = resources;,     } //-- void setResources( java.util.List ), ,     /**,      * Set this element describes all of the classpath resources,      * such as properties,      *             files associated with a project's unit tests.,      * ,      * @param testResources,      */,     public void setTestResources( java.util.List<Resource> testResources ),     {,         this.testResources = testResources;,     } //-- void setTestResources( java.util.List )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/BuildBase.java,,13-342,[@SuppressWarnings( "all" ), public class BuildBase,     extends PluginConfiguration,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The default goal (or phase in Maven 2) to execute when none,      * is specified for,      *             the project. Note that in case of a multi-module,      * build, only the default goal of the top-level,      *             project is relevant, i.e. the default goals of,      * child modules are ignored. Since Maven 3,,      *             multiple goals/phases can be separated by,      * whitespace.,      */,     private String defaultGoal;, ,     /**,      * Field resources.,      */,     private java.util.List<Resource> resources;, ,     /**,      * Field testResources.,      */,     private java.util.List<Resource> testResources;, ,     /**,      * The directory where all files generated by the build are,      * placed.,      */,     private String directory;, ,     /**,      * ,      *             ,      *             The filename (excluding the extension, and with,      * no path information) that,      *             the produced artifact will be called.,      *             The default value is,      * <code>${artifactId}-${version}</code>.,      *             ,      *           ,      */,     private String finalName;, ,     /**,      * Field filters.,      */,     private java.util.List<String> filters;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addFilter.,      * ,      * @param string,      */,     public void addFilter( String string ),     {,         getFilters().add( string );,     } //-- void addFilter( String ), ,     /**,      * Method addResource.,      * ,      * @param resource,      */,     public void addResource( Resource resource ),     {,         getResources().add( resource );,     } //-- void addResource( Resource ), ,     /**,      * Method addTestResource.,      * ,      * @param resource,      */,     public void addTestResource( Resource resource ),     {,         getTestResources().add( resource );,     } //-- void addTestResource( Resource ), ,     /**,      * Method clone.,      * ,      * @return BuildBase,      */,     public BuildBase clone(),     {,         try,         {,             BuildBase copy = (BuildBase) super.clone();, ,             if ( this.resources != null ),             {,                 copy.resources = new java.util.ArrayList<Resource>();,                 for ( Resource item : this.resources ),                 {,                     copy.resources.add( ( (Resource) item).clone() );,                 },             }, ,             if ( this.testResources != null ),             {,                 copy.testResources = new java.util.ArrayList<Resource>();,                 for ( Resource item : this.testResources ),                 {,                     copy.testResources.add( ( (Resource) item).clone() );,                 },             }, ,             if ( this.filters != null ),             {,                 copy.filters = new java.util.ArrayList<String>();,                 copy.filters.addAll( this.filters );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- BuildBase clone(), ,     /**,      * Get the default goal (or phase in Maven 2) to execute when,      * none is specified for,      *             the project. Note that in case of a multi-module,      * build, only the default goal of the top-level,      *             project is relevant, i.e. the default goals of,      * child modules are ignored. Since Maven 3,,      *             multiple goals/phases can be separated by,      * whitespace.,      * ,      * @return String,      */,     public String getDefaultGoal(),     {,         return this.defaultGoal;,     } //-- String getDefaultGoal(), ,     /**,      * Get the directory where all files generated by the build are,      * placed.,      * ,      * @return String,      */,     public String getDirectory(),     {,         return this.directory;,     } //-- String getDirectory(), ,     /**,      * Method getFilters.,      * ,      * @return List,      */,     public java.util.List<String> getFilters(),     {,         if ( this.filters == null ),         {,             this.filters = new java.util.ArrayList<String>();,         }, ,         return this.filters;,     } //-- java.util.List<String> getFilters(), ,     /**,      * Get the filename (excluding the extension, and with no path,      * information) that,      *             the produced artifact will be called.,      *             The default value is,      * <code>${artifactId}-${version}</code>.,      * ,      * @return String,      */,     public String getFinalName(),     {,         return this.finalName;,     } //-- String getFinalName(), ,     /**,      * Method getResources.,      * ,      * @return List,      */,     public java.util.List<Resource> getResources(),     {,         if ( this.resources == null ),         {,             this.resources = new java.util.ArrayList<Resource>();,         }, ,         return this.resources;,     } //-- java.util.List<Resource> getResources(), ,     /**,      * Method getTestResources.,      * ,      * @return List,      */,     public java.util.List<Resource> getTestResources(),     {,         if ( this.testResources == null ),         {,             this.testResources = new java.util.ArrayList<Resource>();,         }, ,         return this.testResources;,     } //-- java.util.List<Resource> getTestResources(), ,     /**,      * Method removeFilter.,      * ,      * @param string,      */,     public void removeFilter( String string ),     {,         getFilters().remove( string );,     } //-- void removeFilter( String ), ,     /**,      * Method removeResource.,      * ,      * @param resource,      */,     public void removeResource( Resource resource ),     {,         getResources().remove( resource );,     } //-- void removeResource( Resource ), ,     /**,      * Method removeTestResource.,      * ,      * @param resource,      */,     public void removeTestResource( Resource resource ),     {,         getTestResources().remove( resource );,     } //-- void removeTestResource( Resource ), ,     /**,      * Set the default goal (or phase in Maven 2) to execute when,      * none is specified for,      *             the project. Note that in case of a multi-module,      * build, only the default goal of the top-level,      *             project is relevant, i.e. the default goals of,      * child modules are ignored. Since Maven 3,,      *             multiple goals/phases can be separated by,      * whitespace.,      * ,      * @param defaultGoal,      */,     public void setDefaultGoal( String defaultGoal ),     {,         this.defaultGoal = defaultGoal;,     } //-- void setDefaultGoal( String ), ,     /**,      * Set the directory where all files generated by the build are,      * placed.,      * ,      * @param directory,      */,     public void setDirectory( String directory ),     {,         this.directory = directory;,     } //-- void setDirectory( String ), ,     /**,      * Set the list of filter properties files that are used when,      * filtering is enabled.,      * ,      * @param filters,      */,     public void setFilters( java.util.List<String> filters ),     {,         this.filters = filters;,     } //-- void setFilters( java.util.List ), ,     /**,      * Set the filename (excluding the extension, and with no path,      * information) that,      *             the produced artifact will be called.,      *             The default value is,      * <code>${artifactId}-${version}</code>.,      * ,      * @param finalName,      */,     public void setFinalName( String finalName ),     {,         this.finalName = finalName;,     } //-- void setFinalName( String ), ,     /**,      * Set this element describes all of the classpath resources,      * such as properties,      *             files associated with a project. These resources,      * are often included in the final,      *             package.,      * ,      * @param resources,      */,     public void setResources( java.util.List<Resource> resources ),     {,         this.resources = resources;,     } //-- void setResources( java.util.List ), ,     /**,      * Set this element describes all of the classpath resources,      * such as properties,      *             files associated with a project's unit tests.,      * ,      * @param testResources,      */,     public void setTestResources( java.util.List<Resource> testResources ),     {,         this.testResources = testResources;,     } //-- void setTestResources( java.util.List )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/BuildTest.java,testEqualsNullSafe,42-42,[        new Build().equals( new Build() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/CiManagement.java,,19-215,[@SuppressWarnings( "all" ), public class CiManagement,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The name of the continuous integration system,,      * e.g. <code>continuum</code>.,      *             ,      *           ,      */,     private String system;, ,     /**,      * URL for the continuous integration system used by the,      * project if it has a web,      *             interface.,      */,     private String url;, ,     /**,      * Field notifiers.,      */,     private java.util.List<Notifier> notifiers;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addNotifier.,      * ,      * @param notifier,      */,     public void addNotifier( Notifier notifier ),     {,         getNotifiers().add( notifier );,     } //-- void addNotifier( Notifier ), ,     /**,      * Method clone.,      * ,      * @return CiManagement,      */,     public CiManagement clone(),     {,         try,         {,             CiManagement copy = (CiManagement) super.clone();, ,             if ( this.notifiers != null ),             {,                 copy.notifiers = new java.util.ArrayList<Notifier>();,                 for ( Notifier item : this.notifiers ),                 {,                     copy.notifiers.add( ( (Notifier) item).clone() );,                 },             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- CiManagement clone(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Method getNotifiers.,      * ,      * @return List,      */,     public java.util.List<Notifier> getNotifiers(),     {,         if ( this.notifiers == null ),         {,             this.notifiers = new java.util.ArrayList<Notifier>();,         }, ,         return this.notifiers;,     } //-- java.util.List<Notifier> getNotifiers(), ,     /**,      * Get the name of the continuous integration system, e.g.,      * <code>continuum</code>.,      * ,      * @return String,      */,     public String getSystem(),     {,         return this.system;,     } //-- String getSystem(), ,     /**,      * Get uRL for the continuous integration system used by the,      * project if it has a web,      *             interface.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Method removeNotifier.,      * ,      * @param notifier,      */,     public void removeNotifier( Notifier notifier ),     {,         getNotifiers().remove( notifier );,     } //-- void removeNotifier( Notifier ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set configuration for notifying developers/users when a,      * build is unsuccessful,,      *             including user information and notification,      * mode.,      * ,      * @param notifiers,      */,     public void setNotifiers( java.util.List<Notifier> notifiers ),     {,         this.notifiers = notifiers;,     } //-- void setNotifiers( java.util.List ), ,     /**,      * Set the name of the continuous integration system, e.g.,      * <code>continuum</code>.,      * ,      * @param system,      */,     public void setSystem( String system ),     {,         this.system = system;,     } //-- void setSystem( String ), ,     /**,      * Set uRL for the continuous integration system used by the,      * project if it has a web,      *             interface.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/CiManagementTest.java,testEqualsNullSafe,42-42,[        new CiManagement().equals( new CiManagement() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/ConfigurationContainer.java,,14-255,[@SuppressWarnings( "all" ), public class ConfigurationContainer,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             Whether any configuration should be propagated,      * to child POMs. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>true</code>.,      *             ,      *           ,      */,     private String inherited;, ,     /**,      * ,      *             ,      *             <p>The configuration as DOM object.</p>,      *             <p>By default, every element content is trimmed,,      * but starting with Maven 3.1.0, you can add,      *             <code>xml:space="preserve"</code> to elements,      * you want to preserve whitespace.</p>,      *             <p>You can control how child POMs inherit,      * configuration from parent POMs by adding,      * <code>combine.children</code>,      *             or <code>combine.self</code> attributes to the,      * children of the configuration element:</p>,      *             <ul>,      *             <li><code>combine.children</code>: available,      * values are <code>merge</code> (default) and,      * <code>append</code>,</li>,      *             <li><code>combine.self</code>: available values,      * are <code>merge</code> (default) and,      * <code>override</code>.</li>,      *             </ul>,      *             <p>See <a,      * href="http://maven.apache.org/pom.html#Plugins">POM,      * Reference documentation</a> and,      *             <a,      * href="http://plexus.codehaus.org/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>,      *             for more information.</p>,      *             ,      *           ,      */,     private Object configuration;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return ConfigurationContainer,      */,     public ConfigurationContainer clone(),     {,         try,         {,             ConfigurationContainer copy = (ConfigurationContainer) super.clone();, ,             if ( this.configuration != null ),             {,                 copy.configuration = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.configuration );,             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ConfigurationContainer clone(), ,     /**,      * Get <p>The configuration as DOM object.</p>,      *             <p>By default, every element content is trimmed,,      * but starting with Maven 3.1.0, you can add,      *             <code>xml:space="preserve"</code> to elements,      * you want to preserve whitespace.</p>,      *             <p>You can control how child POMs inherit,      * configuration from parent POMs by adding,      * <code>combine.children</code>,      *             or <code>combine.self</code> attributes to the,      * children of the configuration element:</p>,      *             <ul>,      *             <li><code>combine.children</code>: available,      * values are <code>merge</code> (default) and,      * <code>append</code>,</li>,      *             <li><code>combine.self</code>: available values,      * are <code>merge</code> (default) and,      * <code>override</code>.</li>,      *             </ul>,      *             <p>See <a,      * href="http://maven.apache.org/pom.html#Plugins">POM,      * Reference documentation</a> and,      *             <a,      * href="http://plexus.codehaus.org/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>,      *             for more information.</p>,      * ,      * @return Object,      */,     public Object getConfiguration(),     {,         return this.configuration;,     } //-- Object getConfiguration(), ,     /**,      * Get whether any configuration should be propagated to child,      * POMs. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>true</code>.,      * ,      * @return String,      */,     public String getInherited(),     {,         return this.inherited;,     } //-- String getInherited(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Set <p>The configuration as DOM object.</p>,      *             <p>By default, every element content is trimmed,,      * but starting with Maven 3.1.0, you can add,      *             <code>xml:space="preserve"</code> to elements,      * you want to preserve whitespace.</p>,      *             <p>You can control how child POMs inherit,      * configuration from parent POMs by adding,      * <code>combine.children</code>,      *             or <code>combine.self</code> attributes to the,      * children of the configuration element:</p>,      *             <ul>,      *             <li><code>combine.children</code>: available,      * values are <code>merge</code> (default) and,      * <code>append</code>,</li>,      *             <li><code>combine.self</code>: available values,      * are <code>merge</code> (default) and,      * <code>override</code>.</li>,      *             </ul>,      *             <p>See <a,      * href="http://maven.apache.org/pom.html#Plugins">POM,      * Reference documentation</a> and,      *             <a,      * href="http://plexus.codehaus.org/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>,      *             for more information.</p>,      * ,      * @param configuration,      */,     public void setConfiguration( Object configuration ),     {,         this.configuration = configuration;,     } //-- void setConfiguration( Object ), ,     /**,      * Set whether any configuration should be propagated to child,      * POMs. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>true</code>.,      * ,      * @param inherited,      */,     public void setInherited( String inherited ),     {,         this.inherited = inherited;,     } //-- void setInherited( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     ,             ,     public boolean isInherited(),     {,         return ( inherited != null ) ? Boolean.parseBoolean( inherited ) : true;,     }, ,     public void setInherited( boolean inherited ),     {,         this.inherited = String.valueOf( inherited );,     }, ,     private boolean inheritanceApplied = true;, ,     public void unsetInheritanceApplied(),     {,         this.inheritanceApplied = false;,     }, ,     public boolean isInheritanceApplied(),     {,         return inheritanceApplied;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Contributor.java,,16-372,[@SuppressWarnings( "all" ), public class Contributor,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The full name of the contributor.,      */,     private String name;, ,     /**,      * The email address of the contributor.,      */,     private String email;, ,     /**,      * The URL for the homepage of the contributor.,      */,     private String url;, ,     /**,      * The organization to which the contributor belongs.,      */,     private String organization;, ,     /**,      * The URL of the organization.,      */,     private String organizationUrl;, ,     /**,      * Field roles.,      */,     private java.util.List<String> roles;, ,     /**,      * ,      *             ,      *               The timezone the contributor is in. Typically,,      * this is a number in the range,      *               <a,      * href="http://en.wikipedia.org/wiki/UTC%E2%88%9212:00">-12</a>,      * to <a,      * href="http://en.wikipedia.org/wiki/UTC%2B14:00">+14</a>,      *               or a valid time zone id like,      * "America/Montreal" (UTC-05:00) or "Europe/Paris",      * (UTC+01:00).,      *             ,      *           ,      */,     private String timezone;, ,     /**,      * Field properties.,      */,     private java.util.Properties properties;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addProperty.,      * ,      * @param key,      * @param value,      */,     public void addProperty( String key, String value ),     {,         getProperties().put( key, value );,     } //-- void addProperty( String, String ), ,     /**,      * Method addRole.,      * ,      * @param string,      */,     public void addRole( String string ),     {,         getRoles().add( string );,     } //-- void addRole( String ), ,     /**,      * Method clone.,      * ,      * @return Contributor,      */,     public Contributor clone(),     {,         try,         {,             Contributor copy = (Contributor) super.clone();, ,             if ( this.roles != null ),             {,                 copy.roles = new java.util.ArrayList<String>();,                 copy.roles.addAll( this.roles );,             }, ,             if ( this.properties != null ),             {,                 copy.properties = (java.util.Properties) this.properties.clone();,             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Contributor clone(), ,     /**,      * Get the email address of the contributor.,      * ,      * @return String,      */,     public String getEmail(),     {,         return this.email;,     } //-- String getEmail(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the full name of the contributor.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the organization to which the contributor belongs.,      * ,      * @return String,      */,     public String getOrganization(),     {,         return this.organization;,     } //-- String getOrganization(), ,     /**,      * Get the URL of the organization.,      * ,      * @return String,      */,     public String getOrganizationUrl(),     {,         return this.organizationUrl;,     } //-- String getOrganizationUrl(), ,     /**,      * Method getProperties.,      * ,      * @return Properties,      */,     public java.util.Properties getProperties(),     {,         if ( this.properties == null ),         {,             this.properties = new java.util.Properties();,         }, ,         return this.properties;,     } //-- java.util.Properties getProperties(), ,     /**,      * Method getRoles.,      * ,      * @return List,      */,     public java.util.List<String> getRoles(),     {,         if ( this.roles == null ),         {,             this.roles = new java.util.ArrayList<String>();,         }, ,         return this.roles;,     } //-- java.util.List<String> getRoles(), ,     /**,      * Get the timezone the contributor is in. Typically, this is a,      * number in the range,      *               <a,      * href="http://en.wikipedia.org/wiki/UTC%E2%88%9212:00">-12</a>,      * to <a,      * href="http://en.wikipedia.org/wiki/UTC%2B14:00">+14</a>,      *               or a valid time zone id like,      * "America/Montreal" (UTC-05:00) or "Europe/Paris",      * (UTC+01:00).,      * ,      * @return String,      */,     public String getTimezone(),     {,         return this.timezone;,     } //-- String getTimezone(), ,     /**,      * Get the URL for the homepage of the contributor.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Method removeRole.,      * ,      * @param string,      */,     public void removeRole( String string ),     {,         getRoles().remove( string );,     } //-- void removeRole( String ), ,     /**,      * Set the email address of the contributor.,      * ,      * @param email,      */,     public void setEmail( String email ),     {,         this.email = email;,     } //-- void setEmail( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the full name of the contributor.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the organization to which the contributor belongs.,      * ,      * @param organization,      */,     public void setOrganization( String organization ),     {,         this.organization = organization;,     } //-- void setOrganization( String ), ,     /**,      * Set the URL of the organization.,      * ,      * @param organizationUrl,      */,     public void setOrganizationUrl( String organizationUrl ),     {,         this.organizationUrl = organizationUrl;,     } //-- void setOrganizationUrl( String ), ,     /**,      * Set properties about the contributor, such as an instant,      * messenger handle.,      * ,      * @param properties,      */,     public void setProperties( java.util.Properties properties ),     {,         this.properties = properties;,     } //-- void setProperties( java.util.Properties ), ,     /**,      * Set the roles the contributor plays in the project. Each,      * role is described by a,      *             <code>role</code> element, the body of which is,      * a role name. This can also be used to,      *             describe the contribution.,      * ,      * @param roles,      */,     public void setRoles( java.util.List<String> roles ),     {,         this.roles = roles;,     } //-- void setRoles( java.util.List ), ,     /**,      * Set the timezone the contributor is in. Typically, this is a,      * number in the range,      *               <a,      * href="http://en.wikipedia.org/wiki/UTC%E2%88%9212:00">-12</a>,      * to <a,      * href="http://en.wikipedia.org/wiki/UTC%2B14:00">+14</a>,      *               or a valid time zone id like,      * "America/Montreal" (UTC-05:00) or "Europe/Paris",      * (UTC+01:00).,      * ,      * @param timezone,      */,     public void setTimezone( String timezone ),     {,         this.timezone = timezone;,     } //-- void setTimezone( String ), ,     /**,      * Set the URL for the homepage of the contributor.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ContributorTest.java,testEqualsNullSafe,42-42,[        new Contributor().equals( new Contributor() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Dependency.java,,19-605,[@SuppressWarnings( "all" ), public class Dependency,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The project group that produced the dependency,,      * e.g.,      *             <code>org.apache.maven</code>.,      *             ,      *           ,      */,     private String groupId;, ,     /**,      * ,      *             ,      *             The unique id for an artifact produced by the,      * project group, e.g.,      *             <code>maven-artifact</code>.,      *             ,      *           ,      */,     private String artifactId;, ,     /**,      * ,      *             ,      *             The version of the dependency, e.g.,      * <code>3.2.1</code>. In Maven 2, this can also be,      *             specified as a range of versions.,      *             ,      *           ,      */,     private String version;, ,     /**,      * ,      *             ,      *             The type of dependency. While it,      *             usually represents the extension on the filename,      * of the dependency,,      *             that is not always the case. A type can be,      * mapped to a different,      *             extension and a classifier.,      *             The type often corresponds to the packaging,      * used, though this is also,      *             not always the case.,      *             Some examples are <code>jar</code>,,      * <code>war</code>, <code>ejb-client</code>,      *             and <code>test-jar</code>: see <a,      * href="../maven-core/artifact-handlers.html">default,      *             artifact handlers</a> for a list.,      *             New types can be defined by plugins that set,      *             <code>extensions</code> to <code>true</code>, so,      * this is not a complete list.,      *             ,      *           ,      */,     private String type = "jar";, ,     /**,      * ,      *             ,      *             The classifier of the dependency. It is appended,      * to,      *             the filename after the version. This allows:,      *             <ul>,      *             <li>refering to attached artifact, for example,      * <code>sources</code> and <code>javadoc</code>:,      *             see <a,      * href="../maven-core/artifact-handlers.html">default artifact,      * handlers</a> for a list,</li>,      *             <li>distinguishing two artifacts,      *             that belong to the same POM but were built,      * differently.,      *             For example, <code>jdk14</code> and,      * <code>jdk15</code>.</li>,      *             </ul>,      *             ,      *           ,      */,     private String classifier;, ,     /**,      * ,      *             ,      *             The scope of the dependency -,      * <code>compile</code>, <code>runtime</code>,,      *             <code>test</code>, <code>system</code>, and,      * <code>provided</code>. Used to,      *             calculate the various classpaths used for,      * compilation, testing, and so on.,      *             It also assists in determining which artifacts,      * to include in a distribution of,      *             this project. For more information, see,      *             <a,      * href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the,      *             dependency mechanism</a>.,      *             ,      *           ,      */,     private String scope;, ,     /**,      * ,      *             ,      *             FOR SYSTEM SCOPE ONLY. Note that use of this,      * property is <b>discouraged</b>,      *             and may be replaced in later versions. This,      * specifies the path on the filesystem,      *             for this dependency.,      *             Requires an absolute path for the value, not,      * relative.,      *             Use a property that gives the machine specific,      * absolute path,,      *             e.g. <code>${java.home}</code>.,      *             ,      *           ,      */,     private String systemPath;, ,     /**,      * Field exclusions.,      */,     private java.util.List<Exclusion> exclusions;, ,     /**,      * ,      *             ,      *             Indicates the dependency is optional for use of,      * this library. While the,      *             version of the dependency will be taken into,      * account for dependency calculation if the,      *             library is used elsewhere, it will not be passed,      * on transitively. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      *             ,      *           ,      */,     private String optional;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addExclusion.,      * ,      * @param exclusion,      */,     public void addExclusion( Exclusion exclusion ),     {,         getExclusions().add( exclusion );,     } //-- void addExclusion( Exclusion ), ,     /**,      * Method clone.,      * ,      * @return Dependency,      */,     public Dependency clone(),     {,         try,         {,             Dependency copy = (Dependency) super.clone();, ,             if ( this.exclusions != null ),             {,                 copy.exclusions = new java.util.ArrayList<Exclusion>();,                 for ( Exclusion item : this.exclusions ),                 {,                     copy.exclusions.add( ( (Exclusion) item).clone() );,                 },             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Dependency clone(), ,     /**,      * Get the unique id for an artifact produced by the project,      * group, e.g.,      *             <code>maven-artifact</code>.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get the classifier of the dependency. It is appended to,      *             the filename after the version. This allows:,      *             <ul>,      *             <li>refering to attached artifact, for example,      * <code>sources</code> and <code>javadoc</code>:,      *             see <a,      * href="../maven-core/artifact-handlers.html">default artifact,      * handlers</a> for a list,</li>,      *             <li>distinguishing two artifacts,      *             that belong to the same POM but were built,      * differently.,      *             For example, <code>jdk14</code> and,      * <code>jdk15</code>.</li>,      *             </ul>,      * ,      * @return String,      */,     public String getClassifier(),     {,         return this.classifier;,     } //-- String getClassifier(), ,     /**,      * Method getExclusions.,      * ,      * @return List,      */,     public java.util.List<Exclusion> getExclusions(),     {,         if ( this.exclusions == null ),         {,             this.exclusions = new java.util.ArrayList<Exclusion>();,         }, ,         return this.exclusions;,     } //-- java.util.List<Exclusion> getExclusions(), ,     /**,      * Get the project group that produced the dependency, e.g.,      *             <code>org.apache.maven</code>.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get indicates the dependency is optional for use of this,      * library. While the,      *             version of the dependency will be taken into,      * account for dependency calculation if the,      *             library is used elsewhere, it will not be passed,      * on transitively. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @return String,      */,     public String getOptional(),     {,         return this.optional;,     } //-- String getOptional(), ,     /**,      * Get the scope of the dependency - <code>compile</code>,,      * <code>runtime</code>,,      *             <code>test</code>, <code>system</code>, and,      * <code>provided</code>. Used to,      *             calculate the various classpaths used for,      * compilation, testing, and so on.,      *             It also assists in determining which artifacts,      * to include in a distribution of,      *             this project. For more information, see,      *             <a,      * href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the,      *             dependency mechanism</a>.,      * ,      * @return String,      */,     public String getScope(),     {,         return this.scope;,     } //-- String getScope(), ,     /**,      * Get fOR SYSTEM SCOPE ONLY. Note that use of this property is,      * <b>discouraged</b>,      *             and may be replaced in later versions. This,      * specifies the path on the filesystem,      *             for this dependency.,      *             Requires an absolute path for the value, not,      * relative.,      *             Use a property that gives the machine specific,      * absolute path,,      *             e.g. <code>${java.home}</code>.,      * ,      * @return String,      */,     public String getSystemPath(),     {,         return this.systemPath;,     } //-- String getSystemPath(), ,     /**,      * Get the type of dependency. While it,      *             usually represents the extension on the filename,      * of the dependency,,      *             that is not always the case. A type can be,      * mapped to a different,      *             extension and a classifier.,      *             The type often corresponds to the packaging,      * used, though this is also,      *             not always the case.,      *             Some examples are <code>jar</code>,,      * <code>war</code>, <code>ejb-client</code>,      *             and <code>test-jar</code>: see <a,      * href="../maven-core/artifact-handlers.html">default,      *             artifact handlers</a> for a list.,      *             New types can be defined by plugins that set,      *             <code>extensions</code> to <code>true</code>, so,      * this is not a complete list.,      * ,      * @return String,      */,     public String getType(),     {,         return this.type;,     } //-- String getType(), ,     /**,      * Get the version of the dependency, e.g. <code>3.2.1</code>.,      * In Maven 2, this can also be,      *             specified as a range of versions.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Method removeExclusion.,      * ,      * @param exclusion,      */,     public void removeExclusion( Exclusion exclusion ),     {,         getExclusions().remove( exclusion );,     } //-- void removeExclusion( Exclusion ), ,     /**,      * Set the unique id for an artifact produced by the project,      * group, e.g.,      *             <code>maven-artifact</code>.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set the classifier of the dependency. It is appended to,      *             the filename after the version. This allows:,      *             <ul>,      *             <li>refering to attached artifact, for example,      * <code>sources</code> and <code>javadoc</code>:,      *             see <a,      * href="../maven-core/artifact-handlers.html">default artifact,      * handlers</a> for a list,</li>,      *             <li>distinguishing two artifacts,      *             that belong to the same POM but were built,      * differently.,      *             For example, <code>jdk14</code> and,      * <code>jdk15</code>.</li>,      *             </ul>,      * ,      * @param classifier,      */,     public void setClassifier( String classifier ),     {,         this.classifier = classifier;,     } //-- void setClassifier( String ), ,     /**,      * Set lists a set of artifacts that should be excluded from,      * this dependency's,      *             artifact list when it comes to calculating,      * transitive dependencies.,      * ,      * @param exclusions,      */,     public void setExclusions( java.util.List<Exclusion> exclusions ),     {,         this.exclusions = exclusions;,     } //-- void setExclusions( java.util.List ), ,     /**,      * Set the project group that produced the dependency, e.g.,      *             <code>org.apache.maven</code>.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set indicates the dependency is optional for use of this,      * library. While the,      *             version of the dependency will be taken into,      * account for dependency calculation if the,      *             library is used elsewhere, it will not be passed,      * on transitively. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @param optional,      */,     public void setOptional( String optional ),     {,         this.optional = optional;,     } //-- void setOptional( String ), ,     /**,      * Set the scope of the dependency - <code>compile</code>,,      * <code>runtime</code>,,      *             <code>test</code>, <code>system</code>, and,      * <code>provided</code>. Used to,      *             calculate the various classpaths used for,      * compilation, testing, and so on.,      *             It also assists in determining which artifacts,      * to include in a distribution of,      *             this project. For more information, see,      *             <a,      * href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the,      *             dependency mechanism</a>.,      * ,      * @param scope,      */,     public void setScope( String scope ),     {,         this.scope = scope;,     } //-- void setScope( String ), ,     /**,      * Set fOR SYSTEM SCOPE ONLY. Note that use of this property is,      * <b>discouraged</b>,      *             and may be replaced in later versions. This,      * specifies the path on the filesystem,      *             for this dependency.,      *             Requires an absolute path for the value, not,      * relative.,      *             Use a property that gives the machine specific,      * absolute path,,      *             e.g. <code>${java.home}</code>.,      * ,      * @param systemPath,      */,     public void setSystemPath( String systemPath ),     {,         this.systemPath = systemPath;,     } //-- void setSystemPath( String ), ,     /**,      * Set the type of dependency. While it,      *             usually represents the extension on the filename,      * of the dependency,,      *             that is not always the case. A type can be,      * mapped to a different,      *             extension and a classifier.,      *             The type often corresponds to the packaging,      * used, though this is also,      *             not always the case.,      *             Some examples are <code>jar</code>,,      * <code>war</code>, <code>ejb-client</code>,      *             and <code>test-jar</code>: see <a,      * href="../maven-core/artifact-handlers.html">default,      *             artifact handlers</a> for a list.,      *             New types can be defined by plugins that set,      *             <code>extensions</code> to <code>true</code>, so,      * this is not a complete list.,      * ,      * @param type,      */,     public void setType( String type ),     {,         this.type = type;,     } //-- void setType( String ), ,     /**,      * Set the version of the dependency, e.g. <code>3.2.1</code>.,      * In Maven 2, this can also be,      *             specified as a range of versions.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     ,             ,     public boolean isOptional(),     {,         return ( optional != null ) ? Boolean.parseBoolean( optional ) : false;,     }, ,     public void setOptional( boolean optional ),     {,         this.optional = String.valueOf( optional );,     }, ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         return "Dependency {groupId=" + groupId + ", artifactId=" + artifactId + ", version=" + version + ", type=" + type + "}";,     },             ,           ,     ,             ,     /**,      * @return the management key as <code>groupId:artifactId:type</code>,      */,     public String getManagementKey(),     {,         return groupId + ":" + artifactId + ":" + type + ( classifier != null ? ":" + classifier : "" );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/DependencyManagement.java,,15-149,[@SuppressWarnings( "all" ), public class DependencyManagement,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field dependencies.,      */,     private java.util.List<Dependency> dependencies;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addDependency.,      * ,      * @param dependency,      */,     public void addDependency( Dependency dependency ),     {,         getDependencies().add( dependency );,     } //-- void addDependency( Dependency ), ,     /**,      * Method clone.,      * ,      * @return DependencyManagement,      */,     public DependencyManagement clone(),     {,         try,         {,             DependencyManagement copy = (DependencyManagement) super.clone();, ,             if ( this.dependencies != null ),             {,                 copy.dependencies = new java.util.ArrayList<Dependency>();,                 for ( Dependency item : this.dependencies ),                 {,                     copy.dependencies.add( ( (Dependency) item).clone() );,                 },             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- DependencyManagement clone(), ,     /**,      * Method getDependencies.,      * ,      * @return List,      */,     public java.util.List<Dependency> getDependencies(),     {,         if ( this.dependencies == null ),         {,             this.dependencies = new java.util.ArrayList<Dependency>();,         }, ,         return this.dependencies;,     } //-- java.util.List<Dependency> getDependencies(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Method removeDependency.,      * ,      * @param dependency,      */,     public void removeDependency( Dependency dependency ),     {,         getDependencies().remove( dependency );,     } //-- void removeDependency( Dependency ), ,     /**,      * Set the dependencies specified here are not used until they,      * are referenced in a,      *             POM within the group. This allows the,      * specification of a "standard" version for a,      *             particular dependency.,      * ,      * @param dependencies,      */,     public void setDependencies( java.util.List<Dependency> dependencies ),     {,         this.dependencies = dependencies;,     } //-- void setDependencies( java.util.List ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/DependencyManagementTest.java,testEqualsNullSafe,42-42,[        new DependencyManagement().equals( new DependencyManagement() );],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/DependencyTest.java,testEqualsNullSafe,42-42,[        new Dependency().equals( new Dependency() );],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/maven/model/RepositoryBase.java,equals,109-124,[        if ( this == other ),         {,             return true;,         }, ,         if ( !( other instanceof RepositoryBase ) ),         {,             return false;,         }, ,         RepositoryBase that = (RepositoryBase) other;,         boolean result = true;, ,         result = result && ( getId() == null ? that.getId() == null : getId().equals( that.getId() ) );, ,         return result;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/DeploymentRepository.java,,15-82,[@SuppressWarnings( "all" ), public class DeploymentRepository,     extends Repository,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Whether to assign snapshots a unique version comprised of,      * the timestamp and,      *             build number, or to use the same version each,      * time.,      */,     private boolean uniqueVersion = true;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return DeploymentRepository,      */,     public DeploymentRepository clone(),     {,         try,         {,             DeploymentRepository copy = (DeploymentRepository) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- DeploymentRepository clone(), ,     /**,      * Get whether to assign snapshots a unique version comprised,      * of the timestamp and,      *             build number, or to use the same version each,      * time.,      * ,      * @return boolean,      */,     public boolean isUniqueVersion(),     {,         return this.uniqueVersion;,     } //-- boolean isUniqueVersion(), ,     /**,      * Set whether to assign snapshots a unique version comprised,      * of the timestamp and,      *             build number, or to use the same version each,      * time.,      * ,      * @param uniqueVersion,      */,     public void setUniqueVersion( boolean uniqueVersion ),     {,         this.uniqueVersion = uniqueVersion;,     } //-- void setUniqueVersion( boolean )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/DeploymentRepository.java,,15-82,[@SuppressWarnings( "all" ), public class DeploymentRepository,     extends Repository,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Whether to assign snapshots a unique version comprised of,      * the timestamp and,      *             build number, or to use the same version each,      * time.,      */,     private boolean uniqueVersion = true;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return DeploymentRepository,      */,     public DeploymentRepository clone(),     {,         try,         {,             DeploymentRepository copy = (DeploymentRepository) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- DeploymentRepository clone(), ,     /**,      * Get whether to assign snapshots a unique version comprised,      * of the timestamp and,      *             build number, or to use the same version each,      * time.,      * ,      * @return boolean,      */,     public boolean isUniqueVersion(),     {,         return this.uniqueVersion;,     } //-- boolean isUniqueVersion(), ,     /**,      * Set whether to assign snapshots a unique version comprised,      * of the timestamp and,      *             build number, or to use the same version each,      * time.,      * ,      * @param uniqueVersion,      */,     public void setUniqueVersion( boolean uniqueVersion ),     {,         this.uniqueVersion = uniqueVersion;,     } //-- void setUniqueVersion( boolean )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/DeploymentRepositoryTest.java,testEqualsNullSafe,42-42,[        new DeploymentRepository().equals( new DeploymentRepository() );],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/maven/model/DeploymentRepositoryTest.java,testHashCodeNullSafe,35-35,[        new DeploymentRepository().hashCode();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/Developer.java,,13-71,[@SuppressWarnings( "all" ), public class Developer,     extends Contributor,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The unique ID of the developer in the SCM.,      */,     private String id;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Developer,      */,     public Developer clone(),     {,         try,         {,             Developer copy = (Developer) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Developer clone(), ,     /**,      * Get the unique ID of the developer in the SCM.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Set the unique ID of the developer in the SCM.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Developer.java,,13-71,[@SuppressWarnings( "all" ), public class Developer,     extends Contributor,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The unique ID of the developer in the SCM.,      */,     private String id;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Developer,      */,     public Developer clone(),     {,         try,         {,             Developer copy = (Developer) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Developer clone(), ,     /**,      * Get the unique ID of the developer in the SCM.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Set the unique ID of the developer in the SCM.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/DeveloperTest.java,testEqualsNullSafe,42-42,[        new Developer().equals( new Developer() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/DistributionManagement.java,,16-346,[@SuppressWarnings( "all" ), public class DistributionManagement,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Information needed to deploy the artifacts generated by the,      * project to a,      *             remote repository.,      */,     private DeploymentRepository repository;, ,     /**,      * ,      *             ,      *             Where to deploy snapshots of artifacts to. If,      * not given, it defaults to the,      *             <code>repository</code> element.,      *             ,      *           ,      */,     private DeploymentRepository snapshotRepository;, ,     /**,      * Information needed for deploying the web site of the project.,      */,     private Site site;, ,     /**,      * ,      *             ,      *             The URL of the project's download page. If not,      * given users will be,      *             referred to the homepage given by,      * <code>url</code>.,      *             This is given to assist in locating artifacts,      * that are not in the repository due to,      *             licensing restrictions.,      *             ,      *           ,      */,     private String downloadUrl;, ,     /**,      * Relocation information of the artifact if it has been moved,      * to a new group ID,      *             and/or artifact ID.,      */,     private Relocation relocation;, ,     /**,      * ,      *             ,      *             Gives the status of this artifact in the remote,      * repository.,      *             This must not be set in your local project, as,      * it is updated by,      *             tools placing it in the reposiory. Valid values,      * are: <code>none</code> (default),,      *             <code>converted</code> (repository manager,      * converted this from an Maven 1 POM),,      *             <code>partner</code>,      *             (directly synced from a partner Maven 2,      * repository), <code>deployed</code> (was deployed from a,      * Maven 2,      *             instance), <code>verified</code> (has been hand,      * verified as correct and final).,      *             ,      *           ,      */,     private String status;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return DistributionManagement,      */,     public DistributionManagement clone(),     {,         try,         {,             DistributionManagement copy = (DistributionManagement) super.clone();, ,             if ( this.repository != null ),             {,                 copy.repository = (DeploymentRepository) this.repository.clone();,             }, ,             if ( this.snapshotRepository != null ),             {,                 copy.snapshotRepository = (DeploymentRepository) this.snapshotRepository.clone();,             }, ,             if ( this.site != null ),             {,                 copy.site = (Site) this.site.clone();,             }, ,             if ( this.relocation != null ),             {,                 copy.relocation = (Relocation) this.relocation.clone();,             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- DistributionManagement clone(), ,     /**,      * Get the URL of the project's download page. If not given,      * users will be,      *             referred to the homepage given by,      * <code>url</code>.,      *             This is given to assist in locating artifacts,      * that are not in the repository due to,      *             licensing restrictions.,      * ,      * @return String,      */,     public String getDownloadUrl(),     {,         return this.downloadUrl;,     } //-- String getDownloadUrl(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get relocation information of the artifact if it has been,      * moved to a new group ID,      *             and/or artifact ID.,      * ,      * @return Relocation,      */,     public Relocation getRelocation(),     {,         return this.relocation;,     } //-- Relocation getRelocation(), ,     /**,      * Get information needed to deploy the artifacts generated by,      * the project to a,      *             remote repository.,      * ,      * @return DeploymentRepository,      */,     public DeploymentRepository getRepository(),     {,         return this.repository;,     } //-- DeploymentRepository getRepository(), ,     /**,      * Get information needed for deploying the web site of the,      * project.,      * ,      * @return Site,      */,     public Site getSite(),     {,         return this.site;,     } //-- Site getSite(), ,     /**,      * Get where to deploy snapshots of artifacts to. If not given,,      * it defaults to the,      *             <code>repository</code> element.,      * ,      * @return DeploymentRepository,      */,     public DeploymentRepository getSnapshotRepository(),     {,         return this.snapshotRepository;,     } //-- DeploymentRepository getSnapshotRepository(), ,     /**,      * Get gives the status of this artifact in the remote,      * repository.,      *             This must not be set in your local project, as,      * it is updated by,      *             tools placing it in the reposiory. Valid values,      * are: <code>none</code> (default),,      *             <code>converted</code> (repository manager,      * converted this from an Maven 1 POM),,      *             <code>partner</code>,      *             (directly synced from a partner Maven 2,      * repository), <code>deployed</code> (was deployed from a,      * Maven 2,      *             instance), <code>verified</code> (has been hand,      * verified as correct and final).,      * ,      * @return String,      */,     public String getStatus(),     {,         return this.status;,     } //-- String getStatus(), ,     /**,      * Set the URL of the project's download page. If not given,      * users will be,      *             referred to the homepage given by,      * <code>url</code>.,      *             This is given to assist in locating artifacts,      * that are not in the repository due to,      *             licensing restrictions.,      * ,      * @param downloadUrl,      */,     public void setDownloadUrl( String downloadUrl ),     {,         this.downloadUrl = downloadUrl;,     } //-- void setDownloadUrl( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set relocation information of the artifact if it has been,      * moved to a new group ID,      *             and/or artifact ID.,      * ,      * @param relocation,      */,     public void setRelocation( Relocation relocation ),     {,         this.relocation = relocation;,     } //-- void setRelocation( Relocation ), ,     /**,      * Set information needed to deploy the artifacts generated by,      * the project to a,      *             remote repository.,      * ,      * @param repository,      */,     public void setRepository( DeploymentRepository repository ),     {,         this.repository = repository;,     } //-- void setRepository( DeploymentRepository ), ,     /**,      * Set information needed for deploying the web site of the,      * project.,      * ,      * @param site,      */,     public void setSite( Site site ),     {,         this.site = site;,     } //-- void setSite( Site ), ,     /**,      * Set where to deploy snapshots of artifacts to. If not given,,      * it defaults to the,      *             <code>repository</code> element.,      * ,      * @param snapshotRepository,      */,     public void setSnapshotRepository( DeploymentRepository snapshotRepository ),     {,         this.snapshotRepository = snapshotRepository;,     } //-- void setSnapshotRepository( DeploymentRepository ), ,     /**,      * Set gives the status of this artifact in the remote,      * repository.,      *             This must not be set in your local project, as,      * it is updated by,      *             tools placing it in the reposiory. Valid values,      * are: <code>none</code> (default),,      *             <code>converted</code> (repository manager,      * converted this from an Maven 1 POM),,      *             <code>partner</code>,      *             (directly synced from a partner Maven 2,      * repository), <code>deployed</code> (was deployed from a,      * Maven 2,      *             instance), <code>verified</code> (has been hand,      * verified as correct and final).,      * ,      * @param status,      */,     public void setStatus( String status ),     {,         this.status = status;,     } //-- void setStatus( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/DistributionManagementTest.java,testEqualsNullSafe,42-42,[        new DistributionManagement().equals( new DistributionManagement() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Exclusion.java,,19-140,[@SuppressWarnings( "all" ), public class Exclusion,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The artifact ID of the project to exclude.,      */,     private String artifactId;, ,     /**,      * The group ID of the project to exclude.,      */,     private String groupId;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Exclusion,      */,     public Exclusion clone(),     {,         try,         {,             Exclusion copy = (Exclusion) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Exclusion clone(), ,     /**,      * Get the artifact ID of the project to exclude.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get the group ID of the project to exclude.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Set the artifact ID of the project to exclude.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set the group ID of the project to exclude.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ExclusionTest.java,testEqualsNullSafe,42-42,[        new Exclusion().equals( new Exclusion() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Extension.java,,13-209,[@SuppressWarnings( "all" ), public class Extension,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The group ID of the extension's artifact.,      */,     private String groupId;, ,     /**,      * The artifact ID of the extension.,      */,     private String artifactId;, ,     /**,      * The version of the extension.,      */,     private String version;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Extension,      */,     public Extension clone(),     {,         try,         {,             Extension copy = (Extension) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Extension clone(), ,     /**,      * Get the artifact ID of the extension.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get the group ID of the extension's artifact.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the version of the extension.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Set the artifact ID of the extension.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set the group ID of the extension's artifact.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the version of the extension.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     ,             ,     /**,      * @see java.lang.Object#equals(java.lang.Object),      */,     public boolean equals( Object o ),     {,         if ( this == o ),         {,             return true;,         }, ,         if ( !( o instanceof Extension ) ),         {,             return false;,         }, ,         Extension e = (Extension) o;, ,         if ( !equal( e.getArtifactId(), getArtifactId() ) ),         {,             return false;,         },         else if ( !equal( e.getGroupId(), getGroupId() ) ),         {,             return false;,         },         else if ( !equal( e.getVersion(), getVersion() ) ),         {,             return false;,         },         return true;,     }, ,     private static <T> boolean equal( T obj1, T obj2 ),     {,         return ( obj1 != null ) ? obj1.equals( obj2 ) : obj2 == null;,     }, ,     /**,      * @see java.lang.Object#hashCode(),      */,     public int hashCode(),     {,         int result = 17;,         result = 37 * result + ( getArtifactId() != null ? getArtifactId().hashCode() : 0 );,         result = 37 * result + ( getGroupId() != null ? getGroupId().hashCode() : 0 );,         result = 37 * result + ( getVersion() != null ? getVersion().hashCode() : 0 );,         return result;],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ExtensionTest.java,testEqualsNullSafe,42-42,[        new Extension().equals( new Extension() );],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/maven/model/ExtensionTest.java,testHashCodeNullSafe,35-35,[        new Extension().hashCode();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/FileSet.java,,13-86,[@SuppressWarnings( "all" ), public class FileSet,     extends PatternSet,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Describe the directory where the resources are stored. The,      * path is relative,      *             to the POM.,      */,     private String directory;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return FileSet,      */,     public FileSet clone(),     {,         try,         {,             FileSet copy = (FileSet) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- FileSet clone(), ,     /**,      * Get describe the directory where the resources are stored.,      * The path is relative,      *             to the POM.,      * ,      * @return String,      */,     public String getDirectory(),     {,         return this.directory;,     } //-- String getDirectory(), ,     /**,      * Set describe the directory where the resources are stored.,      * The path is relative,      *             to the POM.,      * ,      * @param directory,      */,     public void setDirectory( String directory ),     {,         this.directory = directory;,     } //-- void setDirectory( String ), ,     ,             ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         return "FileSet {directory: " + getDirectory() + ", " + super.toString() + "}";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/FileSet.java,,13-86,[@SuppressWarnings( "all" ), public class FileSet,     extends PatternSet,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Describe the directory where the resources are stored. The,      * path is relative,      *             to the POM.,      */,     private String directory;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return FileSet,      */,     public FileSet clone(),     {,         try,         {,             FileSet copy = (FileSet) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- FileSet clone(), ,     /**,      * Get describe the directory where the resources are stored.,      * The path is relative,      *             to the POM.,      * ,      * @return String,      */,     public String getDirectory(),     {,         return this.directory;,     } //-- String getDirectory(), ,     /**,      * Set describe the directory where the resources are stored.,      * The path is relative,      *             to the POM.,      * ,      * @param directory,      */,     public void setDirectory( String directory ),     {,         this.directory = directory;,     } //-- void setDirectory( String ), ,     ,             ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         return "FileSet {directory: " + getDirectory() + ", " + super.toString() + "}";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/InputLocation.java,,13-279,[@SuppressWarnings( "all" ), public final class InputLocation,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The one-based line number. The value will be non-positive if,      * unknown.,      */,     private int lineNumber = -1;, ,     /**,      * The one-based column number. The value will be non-positive,      * if unknown.,      */,     private int columnNumber = -1;, ,     /**,      * Field source.,      */,     private InputSource source;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //----------------/,      //- Constructors -/,     //----------------/, ,     public InputLocation(int lineNumber, int columnNumber),     {,         this.lineNumber = lineNumber;,         this.columnNumber = columnNumber;,     } //-- org.apache.maven.model.InputLocation(int, int), ,     public InputLocation(int lineNumber, int columnNumber, InputSource source),     {,         this.lineNumber = lineNumber;,         this.columnNumber = columnNumber;,         this.source = source;,     } //-- org.apache.maven.model.InputLocation(int, int, InputSource), , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return InputLocation,      */,     public InputLocation clone(),     {,         try,         {,             InputLocation copy = (InputLocation) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- InputLocation clone(), ,     /**,      * Get the one-based column number. The value will be,      * non-positive if unknown.,      * ,      * @return int,      */,     public int getColumnNumber(),     {,         return this.columnNumber;,     } //-- int getColumnNumber(), ,     /**,      * Get the one-based line number. The value will be,      * non-positive if unknown.,      * ,      * @return int,      */,     public int getLineNumber(),     {,         return this.lineNumber;,     } //-- int getLineNumber(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * ,      * ,      * @return Map<Object, InputLocation>,      */,     public java.util.Map<Object, InputLocation> getLocations(),     {,         return locations;,     } //-- java.util.Map<Object, InputLocation> getLocations(), ,     /**,      * Get the source field.,      * ,      * @return InputSource,      */,     public InputSource getSource(),     {,         return this.source;,     } //-- InputSource getSource(), ,     /**,      * Method merge.,      * ,      * @param target,      * @param sourceDominant,      * @param source,      * @return InputLocation,      */,     public static InputLocation merge( InputLocation target, InputLocation source, boolean sourceDominant ),     {,         if ( source == null ),         {,             return target;,         },         else if ( target == null ),         {,             return source;,         }, ,         InputLocation result =,             new InputLocation( target.getLineNumber(), target.getColumnNumber(), target.getSource() );, ,         java.util.Map<Object, InputLocation> locations;,         java.util.Map<Object, InputLocation> sourceLocations = source.getLocations();,         java.util.Map<Object, InputLocation> targetLocations = target.getLocations();,         if ( sourceLocations == null ),         {,             locations = targetLocations;,         },         else if ( targetLocations == null ),         {,             locations = sourceLocations;,         },         else,         {,             locations = new java.util.LinkedHashMap<Object, InputLocation>();,             locations.putAll( sourceDominant ? targetLocations : sourceLocations );,             locations.putAll( sourceDominant ? sourceLocations : targetLocations );,         },         result.setLocations( locations );, ,         return result;,     } //-- InputLocation merge( InputLocation, InputLocation, boolean ), ,     /**,      * Method merge.,      * ,      * @param target,      * @param indices,      * @param source,      * @return InputLocation,      */,     public static InputLocation merge( InputLocation target, InputLocation source, java.util.Collection<Integer> indices ),     {,         if ( source == null ),         {,             return target;,         },         else if ( target == null ),         {,             return source;,         }, ,         InputLocation result =,             new InputLocation( target.getLineNumber(), target.getColumnNumber(), target.getSource() );, ,         java.util.Map<Object, InputLocation> locations;,         java.util.Map<Object, InputLocation> sourceLocations = source.getLocations();,         java.util.Map<Object, InputLocation> targetLocations = target.getLocations();,         if ( sourceLocations == null ),         {,             locations = targetLocations;,         },         else if ( targetLocations == null ),         {,             locations = sourceLocations;,         },         else,         {,             locations = new java.util.LinkedHashMap<Object, InputLocation>();,             for ( java.util.Iterator<Integer> it = indices.iterator(); it.hasNext(); ),             {,                 InputLocation location;,                 Integer index = it.next();,                 if ( index.intValue() < 0 ),                 {,                     location = sourceLocations.get( Integer.valueOf( ~index.intValue() ) );,                 },                 else,                 {,                     location = targetLocations.get( index );,                 },                 locations.put( Integer.valueOf( locations.size() ), location );,             },         },         result.setLocations( locations );, ,         return result;,     } //-- InputLocation merge( InputLocation, InputLocation, java.util.Collection ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * ,      * ,      * @param locations,      */,     public void setLocations( java.util.Map<Object, InputLocation> locations ),     {,         this.locations = locations;,     } //-- void setLocations( java.util.Map<Object, InputLocation> ), ,     ,             , ,     @Override,     public String toString(),     {,         return getLineNumber() + " : " + getColumnNumber() + ", " + getSource();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/InputSource.java,,13-114,[@SuppressWarnings( "all" ), public class InputSource,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The identifier of the POM in the format {@code,      * <groupId>:<artifactId>:<version>}.,      *             ,      *           ,      */,     private String modelId;, ,     /**,      * ,      *             ,      *             The path/URL of the POM or {@code null} if,      * unknown.,      *             ,      *           ,      */,     private String location;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return InputSource,      */,     public InputSource clone(),     {,         try,         {,             InputSource copy = (InputSource) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- InputSource clone(), ,     /**,      * Get the path/URL of the POM or {@code null} if unknown.,      * ,      * @return String,      */,     public String getLocation(),     {,         return this.location;,     } //-- String getLocation(), ,     /**,      * Get the identifier of the POM in the format {@code,      * <groupId>:<artifactId>:<version>}.,      * ,      * @return String,      */,     public String getModelId(),     {,         return this.modelId;,     } //-- String getModelId(), ,     /**,      * Set the path/URL of the POM or {@code null} if unknown.,      * ,      * @param location,      */,     public void setLocation( String location ),     {,         this.location = location;,     } //-- void setLocation( String ), ,     /**,      * Set the identifier of the POM in the format {@code,      * <groupId>:<artifactId>:<version>}.,      * ,      * @param modelId,      */,     public void setModelId( String modelId ),     {,         this.modelId = modelId;,     } //-- void setModelId( String ), ,     ,             ,     @Override,     public String toString(),     {,         return getModelId() + " " + getLocation();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/IssueManagement.java,,15-136,[@SuppressWarnings( "all" ), public class IssueManagement,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The name of the issue management system, e.g. Bugzilla.,      */,     private String system;, ,     /**,      * URL for the issue management system used by the project.,      */,     private String url;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return IssueManagement,      */,     public IssueManagement clone(),     {,         try,         {,             IssueManagement copy = (IssueManagement) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- IssueManagement clone(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the name of the issue management system, e.g. Bugzilla.,      * ,      * @return String,      */,     public String getSystem(),     {,         return this.system;,     } //-- String getSystem(), ,     /**,      * Get uRL for the issue management system used by the project.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the name of the issue management system, e.g. Bugzilla.,      * ,      * @param system,      */,     public void setSystem( String system ),     {,         this.system = system;,     } //-- void setSystem( String ), ,     /**,      * Set uRL for the issue management system used by the project.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/IssueManagementTest.java,testEqualsNullSafe,42-42,[        new IssueManagement().equals( new IssueManagement() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/License.java,,19-221,[@SuppressWarnings( "all" ), public class License,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The full legal name of the license.,      */,     private String name;, ,     /**,      * The official url for the license text.,      */,     private String url;, ,     /**,      * ,      *             ,      *             The primary method by which this project may be,      * distributed.,      *             <dl>,      *               <dt>repo</dt>,      *               <dd>may be downloaded from the Maven,      * repository</dd>,      *               <dt>manual</dt>,      *               <dd>user must manually download and install,      * the dependency.</dd>,      *             </dl>,      *             ,      *           ,      */,     private String distribution;, ,     /**,      * Addendum information pertaining to this license.,      */,     private String comments;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return License,      */,     public License clone(),     {,         try,         {,             License copy = (License) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- License clone(), ,     /**,      * Get addendum information pertaining to this license.,      * ,      * @return String,      */,     public String getComments(),     {,         return this.comments;,     } //-- String getComments(), ,     /**,      * Get the primary method by which this project may be,      * distributed.,      *             <dl>,      *               <dt>repo</dt>,      *               <dd>may be downloaded from the Maven,      * repository</dd>,      *               <dt>manual</dt>,      *               <dd>user must manually download and install,      * the dependency.</dd>,      *             </dl>,      * ,      * @return String,      */,     public String getDistribution(),     {,         return this.distribution;,     } //-- String getDistribution(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the full legal name of the license.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the official url for the license text.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Set addendum information pertaining to this license.,      * ,      * @param comments,      */,     public void setComments( String comments ),     {,         this.comments = comments;,     } //-- void setComments( String ), ,     /**,      * Set the primary method by which this project may be,      * distributed.,      *             <dl>,      *               <dt>repo</dt>,      *               <dd>may be downloaded from the Maven,      * repository</dd>,      *               <dt>manual</dt>,      *               <dd>user must manually download and install,      * the dependency.</dd>,      *             </dl>,      * ,      * @param distribution,      */,     public void setDistribution( String distribution ),     {,         this.distribution = distribution;,     } //-- void setDistribution( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the full legal name of the license.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the official url for the license text.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/LicenseTest.java,testEqualsNullSafe,42-42,[        new License().equals( new License() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/MailingList.java,,15-339,[@SuppressWarnings( "all" ), public class MailingList,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The name of the mailing list.,      *             ,      *           ,      */,     private String name;, ,     /**,      * ,      *             ,      *             The email address or link that can be used to,      * subscribe to,      *             the mailing list.  If this is an email address,,      * a,      *             <code>mailto:</code> link will automatically be,      * created,      *             when the documentation is created.,      *             ,      *           ,      */,     private String subscribe;, ,     /**,      * ,      *             ,      *             The email address or link that can be used to,      * unsubscribe to,      *             the mailing list.  If this is an email address,,      * a,      *             <code>mailto:</code> link will automatically be,      * created,      *             when the documentation is created.,      *             ,      *           ,      */,     private String unsubscribe;, ,     /**,      * ,      *             ,      *             The email address or link that can be used to,      * post to,      *             the mailing list.  If this is an email address,,      * a,      *             <code>mailto:</code> link will automatically be,      * created,      *             when the documentation is created.,      *             ,      *           ,      */,     private String post;, ,     /**,      * The link to a URL where you can browse the mailing list,      * archive.,      */,     private String archive;, ,     /**,      * Field otherArchives.,      */,     private java.util.List<String> otherArchives;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addOtherArchive.,      * ,      * @param string,      */,     public void addOtherArchive( String string ),     {,         getOtherArchives().add( string );,     } //-- void addOtherArchive( String ), ,     /**,      * Method clone.,      * ,      * @return MailingList,      */,     public MailingList clone(),     {,         try,         {,             MailingList copy = (MailingList) super.clone();, ,             if ( this.otherArchives != null ),             {,                 copy.otherArchives = new java.util.ArrayList<String>();,                 copy.otherArchives.addAll( this.otherArchives );,             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- MailingList clone(), ,     /**,      * Get the link to a URL where you can browse the mailing list,      * archive.,      * ,      * @return String,      */,     public String getArchive(),     {,         return this.archive;,     } //-- String getArchive(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the name of the mailing list.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Method getOtherArchives.,      * ,      * @return List,      */,     public java.util.List<String> getOtherArchives(),     {,         if ( this.otherArchives == null ),         {,             this.otherArchives = new java.util.ArrayList<String>();,         }, ,         return this.otherArchives;,     } //-- java.util.List<String> getOtherArchives(), ,     /**,      * Get the email address or link that can be used to post to,      *             the mailing list.  If this is an email address,,      * a,      *             <code>mailto:</code> link will automatically be,      * created,      *             when the documentation is created.,      * ,      * @return String,      */,     public String getPost(),     {,         return this.post;,     } //-- String getPost(), ,     /**,      * Get the email address or link that can be used to subscribe,      * to,      *             the mailing list.  If this is an email address,,      * a,      *             <code>mailto:</code> link will automatically be,      * created,      *             when the documentation is created.,      * ,      * @return String,      */,     public String getSubscribe(),     {,         return this.subscribe;,     } //-- String getSubscribe(), ,     /**,      * Get the email address or link that can be used to,      * unsubscribe to,      *             the mailing list.  If this is an email address,,      * a,      *             <code>mailto:</code> link will automatically be,      * created,      *             when the documentation is created.,      * ,      * @return String,      */,     public String getUnsubscribe(),     {,         return this.unsubscribe;,     } //-- String getUnsubscribe(), ,     /**,      * Method removeOtherArchive.,      * ,      * @param string,      */,     public void removeOtherArchive( String string ),     {,         getOtherArchives().remove( string );,     } //-- void removeOtherArchive( String ), ,     /**,      * Set the link to a URL where you can browse the mailing list,      * archive.,      * ,      * @param archive,      */,     public void setArchive( String archive ),     {,         this.archive = archive;,     } //-- void setArchive( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the name of the mailing list.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the link to alternate URLs where you can browse the list,      * archive.,      * ,      * @param otherArchives,      */,     public void setOtherArchives( java.util.List<String> otherArchives ),     {,         this.otherArchives = otherArchives;,     } //-- void setOtherArchives( java.util.List ), ,     /**,      * Set the email address or link that can be used to post to,      *             the mailing list.  If this is an email address,,      * a,      *             <code>mailto:</code> link will automatically be,      * created,      *             when the documentation is created.,      * ,      * @param post,      */,     public void setPost( String post ),     {,         this.post = post;,     } //-- void setPost( String ), ,     /**,      * Set the email address or link that can be used to subscribe,      * to,      *             the mailing list.  If this is an email address,,      * a,      *             <code>mailto:</code> link will automatically be,      * created,      *             when the documentation is created.,      * ,      * @param subscribe,      */,     public void setSubscribe( String subscribe ),     {,         this.subscribe = subscribe;,     } //-- void setSubscribe( String ), ,     /**,      * Set the email address or link that can be used to,      * unsubscribe to,      *             the mailing list.  If this is an email address,,      * a,      *             <code>mailto:</code> link will automatically be,      * created,      *             when the documentation is created.,      * ,      * @param unsubscribe,      */,     public void setUnsubscribe( String unsubscribe ),     {,         this.unsubscribe = unsubscribe;,     } //-- void setUnsubscribe( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/MailingListTest.java,testEqualsNullSafe,42-42,[        new MailingList().equals( new MailingList() );],,
STYLE,REC_CATCH_EXCEPTION,org/apache/maven/model/Model.java,clone,346-346,[        catch ( java.lang.Exception ex )],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/Model.java,,20-1031,[@SuppressWarnings( "all" ), public class Model,     extends ModelBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Declares to which version of project descriptor this POM,      * conforms.,      */,     private String modelVersion;, ,     /**,      * The location of the parent project, if one exists. Values,      * from the parent,      *             project will be the default for this project if,      * they are left unspecified. The location,      *             is given as a group ID, artifact ID and version.,      */,     private Parent parent;, ,     /**,      * ,      *             ,      *             A universally unique identifier for a project.,      * It is normal to,      *             use a fully-qualified package name to,      * distinguish it from other,      *             projects with a similar name (eg.,      * <code>org.apache.maven</code>).,      *             ,      *           ,      */,     private String groupId;, ,     /**,      * The identifier for this artifact that is unique within the,      * group given by the,      *             group ID. An artifact is something that is,      * either produced or used by a project.,      *             Examples of artifacts produced by Maven for a,      * project include: JARs, source and binary,      *             distributions, and WARs.,      */,     private String artifactId;, ,     /**,      * The current version of the artifact produced by this project.,      */,     private String version;, ,     /**,      * ,      *             ,      *             The type of artifact this project produces, for,      * example <code>jar</code>,      *               <code>war</code>,      *               <code>ear</code>,      *               <code>pom</code>.,      *             Plugins can create their own packaging, and,      *             therefore their own packaging types,,      *             so this list does not contain all possible,      * types.,      *             ,      *           ,      */,     private String packaging = "jar";, ,     /**,      * The full name of the project.,      */,     private String name;, ,     /**,      * A detailed description of the project, used by Maven,      * whenever it needs to,      *             describe the project, such as on the web site.,      * While this element can be specified as,      *             CDATA to enable the use of HTML tags within the,      * description, it is discouraged to allow,      *             plain text representation. If you need to modify,      * the index page of the generated web,      *             site, you are able to specify your own instead,      * of adjusting this text.,      */,     private String description;, ,     /**,      * ,      *             ,      *             The URL to the project's homepage.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId,      *             ,      *           .,      */,     private String url;, ,     /**,      * The year of the project's inception, specified with 4,      * digits. This value is,      *             used when generating copyright notices as well,      * as being informational.,      */,     private String inceptionYear;, ,     /**,      * This element describes various attributes of the,      * organization to which the,      *             project belongs. These attributes are utilized,      * when documentation is created (for,      *             copyright notices and links).,      */,     private Organization organization;, ,     /**,      * Field licenses.,      */,     private java.util.List<License> licenses;, ,     /**,      * Field developers.,      */,     private java.util.List<Developer> developers;, ,     /**,      * Field contributors.,      */,     private java.util.List<Contributor> contributors;, ,     /**,      * Field mailingLists.,      */,     private java.util.List<MailingList> mailingLists;, ,     /**,      * Describes the prerequisites in the build environment for,      * this project.,      */,     private Prerequisites prerequisites;, ,     /**,      * Specification for the SCM used by the project, such as CVS,,      * Subversion, etc.,      */,     private Scm scm;, ,     /**,      * The project's issue management system information.,      */,     private IssueManagement issueManagement;, ,     /**,      * The project's continuous integration information.,      */,     private CiManagement ciManagement;, ,     /**,      * Information required to build the project.,      */,     private Build build;, ,     /**,      * Field profiles.,      */,     private java.util.List<Profile> profiles;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addContributor.,      * ,      * @param contributor,      */,     public void addContributor( Contributor contributor ),     {,         getContributors().add( contributor );,     } //-- void addContributor( Contributor ), ,     /**,      * Method addDeveloper.,      * ,      * @param developer,      */,     public void addDeveloper( Developer developer ),     {,         getDevelopers().add( developer );,     } //-- void addDeveloper( Developer ), ,     /**,      * Method addLicense.,      * ,      * @param license,      */,     public void addLicense( License license ),     {,         getLicenses().add( license );,     } //-- void addLicense( License ), ,     /**,      * Method addMailingList.,      * ,      * @param mailingList,      */,     public void addMailingList( MailingList mailingList ),     {,         getMailingLists().add( mailingList );,     } //-- void addMailingList( MailingList ), ,     /**,      * Method addProfile.,      * ,      * @param profile,      */,     public void addProfile( Profile profile ),     {,         getProfiles().add( profile );,     } //-- void addProfile( Profile ), ,     /**,      * Method clone.,      * ,      * @return Model,      */,     public Model clone(),     {,         try,         {,             Model copy = (Model) super.clone();, ,             if ( this.parent != null ),             {,                 copy.parent = (Parent) this.parent.clone();,             }, ,             if ( this.organization != null ),             {,                 copy.organization = (Organization) this.organization.clone();,             }, ,             if ( this.licenses != null ),             {,                 copy.licenses = new java.util.ArrayList<License>();,                 for ( License item : this.licenses ),                 {,                     copy.licenses.add( ( (License) item).clone() );,                 },             }, ,             if ( this.developers != null ),             {,                 copy.developers = new java.util.ArrayList<Developer>();,                 for ( Developer item : this.developers ),                 {,                     copy.developers.add( ( (Developer) item).clone() );,                 },             }, ,             if ( this.contributors != null ),             {,                 copy.contributors = new java.util.ArrayList<Contributor>();,                 for ( Contributor item : this.contributors ),                 {,                     copy.contributors.add( ( (Contributor) item).clone() );,                 },             }, ,             if ( this.mailingLists != null ),             {,                 copy.mailingLists = new java.util.ArrayList<MailingList>();,                 for ( MailingList item : this.mailingLists ),                 {,                     copy.mailingLists.add( ( (MailingList) item).clone() );,                 },             }, ,             if ( this.prerequisites != null ),             {,                 copy.prerequisites = (Prerequisites) this.prerequisites.clone();,             }, ,             if ( this.scm != null ),             {,                 copy.scm = (Scm) this.scm.clone();,             }, ,             if ( this.issueManagement != null ),             {,                 copy.issueManagement = (IssueManagement) this.issueManagement.clone();,             }, ,             if ( this.ciManagement != null ),             {,                 copy.ciManagement = (CiManagement) this.ciManagement.clone();,             }, ,             if ( this.build != null ),             {,                 copy.build = (Build) this.build.clone();,             }, ,             if ( this.profiles != null ),             {,                 copy.profiles = new java.util.ArrayList<Profile>();,                 for ( Profile item : this.profiles ),                 {,                     copy.profiles.add( ( (Profile) item).clone() );,                 },             }, ,             cloneHook( copy );, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Model clone(), ,     /**,      * Get the identifier for this artifact that is unique within,      * the group given by the,      *             group ID. An artifact is something that is,      * either produced or used by a project.,      *             Examples of artifacts produced by Maven for a,      * project include: JARs, source and binary,      *             distributions, and WARs.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get information required to build the project.,      * ,      * @return Build,      */,     public Build getBuild(),     {,         return this.build;,     } //-- Build getBuild(), ,     /**,      * Get the project's continuous integration information.,      * ,      * @return CiManagement,      */,     public CiManagement getCiManagement(),     {,         return this.ciManagement;,     } //-- CiManagement getCiManagement(), ,     /**,      * Method getContributors.,      * ,      * @return List,      */,     public java.util.List<Contributor> getContributors(),     {,         if ( this.contributors == null ),         {,             this.contributors = new java.util.ArrayList<Contributor>();,         }, ,         return this.contributors;,     } //-- java.util.List<Contributor> getContributors(), ,     /**,      * Get a detailed description of the project, used by Maven,      * whenever it needs to,      *             describe the project, such as on the web site.,      * While this element can be specified as,      *             CDATA to enable the use of HTML tags within the,      * description, it is discouraged to allow,      *             plain text representation. If you need to modify,      * the index page of the generated web,      *             site, you are able to specify your own instead,      * of adjusting this text.,      * ,      * @return String,      */,     public String getDescription(),     {,         return this.description;,     } //-- String getDescription(), ,     /**,      * Method getDevelopers.,      * ,      * @return List,      */,     public java.util.List<Developer> getDevelopers(),     {,         if ( this.developers == null ),         {,             this.developers = new java.util.ArrayList<Developer>();,         }, ,         return this.developers;,     } //-- java.util.List<Developer> getDevelopers(), ,     /**,      * Get a universally unique identifier for a project. It is,      * normal to,      *             use a fully-qualified package name to,      * distinguish it from other,      *             projects with a similar name (eg.,      * <code>org.apache.maven</code>).,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * Get the year of the project's inception, specified with 4,      * digits. This value is,      *             used when generating copyright notices as well,      * as being informational.,      * ,      * @return String,      */,     public String getInceptionYear(),     {,         return this.inceptionYear;,     } //-- String getInceptionYear(), ,     /**,      * Get the project's issue management system information.,      * ,      * @return IssueManagement,      */,     public IssueManagement getIssueManagement(),     {,         return this.issueManagement;,     } //-- IssueManagement getIssueManagement(), ,     /**,      * Method getLicenses.,      * ,      * @return List,      */,     public java.util.List<License> getLicenses(),     {,         if ( this.licenses == null ),         {,             this.licenses = new java.util.ArrayList<License>();,         }, ,         return this.licenses;,     } //-- java.util.List<License> getLicenses(), ,     /**,      * Method getMailingLists.,      * ,      * @return List,      */,     public java.util.List<MailingList> getMailingLists(),     {,         if ( this.mailingLists == null ),         {,             this.mailingLists = new java.util.ArrayList<MailingList>();,         }, ,         return this.mailingLists;,     } //-- java.util.List<MailingList> getMailingLists(), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Get declares to which version of project descriptor this POM,      * conforms.,      * ,      * @return String,      */,     public String getModelVersion(),     {,         return this.modelVersion;,     } //-- String getModelVersion(), ,     /**,      * Get the full name of the project.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get this element describes various attributes of the,      * organization to which the,      *             project belongs. These attributes are utilized,      * when documentation is created (for,      *             copyright notices and links).,      * ,      * @return Organization,      */,     public Organization getOrganization(),     {,         return this.organization;,     } //-- Organization getOrganization(), ,     /**,      * Get the type of artifact this project produces, for example,      * <code>jar</code>,      *               <code>war</code>,      *               <code>ear</code>,      *               <code>pom</code>.,      *             Plugins can create their own packaging, and,      *             therefore their own packaging types,,      *             so this list does not contain all possible,      * types.,      * ,      * @return String,      */,     public String getPackaging(),     {,         return this.packaging;,     } //-- String getPackaging(), ,     /**,      * Get the location of the parent project, if one exists.,      * Values from the parent,      *             project will be the default for this project if,      * they are left unspecified. The location,      *             is given as a group ID, artifact ID and version.,      * ,      * @return Parent,      */,     public Parent getParent(),     {,         return this.parent;,     } //-- Parent getParent(), ,     /**,      * Get describes the prerequisites in the build environment for,      * this project.,      * ,      * @return Prerequisites,      */,     public Prerequisites getPrerequisites(),     {,         return this.prerequisites;,     } //-- Prerequisites getPrerequisites(), ,     /**,      * Method getProfiles.,      * ,      * @return List,      */,     public java.util.List<Profile> getProfiles(),     {,         if ( this.profiles == null ),         {,             this.profiles = new java.util.ArrayList<Profile>();,         }, ,         return this.profiles;,     } //-- java.util.List<Profile> getProfiles(), ,     /**,      * Get specification for the SCM used by the project, such as,      * CVS, Subversion, etc.,      * ,      * @return Scm,      */,     public Scm getScm(),     {,         return this.scm;,     } //-- Scm getScm(), ,     /**,      * Get the URL to the project's homepage.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Get the current version of the artifact produced by this,      * project.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Method removeContributor.,      * ,      * @param contributor,      */,     public void removeContributor( Contributor contributor ),     {,         getContributors().remove( contributor );,     } //-- void removeContributor( Contributor ), ,     /**,      * Method removeDeveloper.,      * ,      * @param developer,      */,     public void removeDeveloper( Developer developer ),     {,         getDevelopers().remove( developer );,     } //-- void removeDeveloper( Developer ), ,     /**,      * Method removeLicense.,      * ,      * @param license,      */,     public void removeLicense( License license ),     {,         getLicenses().remove( license );,     } //-- void removeLicense( License ), ,     /**,      * Method removeMailingList.,      * ,      * @param mailingList,      */,     public void removeMailingList( MailingList mailingList ),     {,         getMailingLists().remove( mailingList );,     } //-- void removeMailingList( MailingList ), ,     /**,      * Method removeProfile.,      * ,      * @param profile,      */,     public void removeProfile( Profile profile ),     {,         getProfiles().remove( profile );,     } //-- void removeProfile( Profile ), ,     /**,      * Set the identifier for this artifact that is unique within,      * the group given by the,      *             group ID. An artifact is something that is,      * either produced or used by a project.,      *             Examples of artifacts produced by Maven for a,      * project include: JARs, source and binary,      *             distributions, and WARs.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set information required to build the project.,      * ,      * @param build,      */,     public void setBuild( Build build ),     {,         this.build = build;,     } //-- void setBuild( Build ), ,     /**,      * Set the project's continuous integration information.,      * ,      * @param ciManagement,      */,     public void setCiManagement( CiManagement ciManagement ),     {,         this.ciManagement = ciManagement;,     } //-- void setCiManagement( CiManagement ), ,     /**,      * Set describes the contributors to a project that are not yet,      * committers.,      * ,      * @param contributors,      */,     public void setContributors( java.util.List<Contributor> contributors ),     {,         this.contributors = contributors;,     } //-- void setContributors( java.util.List ), ,     /**,      * Set a detailed description of the project, used by Maven,      * whenever it needs to,      *             describe the project, such as on the web site.,      * While this element can be specified as,      *             CDATA to enable the use of HTML tags within the,      * description, it is discouraged to allow,      *             plain text representation. If you need to modify,      * the index page of the generated web,      *             site, you are able to specify your own instead,      * of adjusting this text.,      * ,      * @param description,      */,     public void setDescription( String description ),     {,         this.description = description;,     } //-- void setDescription( String ), ,     /**,      * Set describes the committers of a project.,      * ,      * @param developers,      */,     public void setDevelopers( java.util.List<Developer> developers ),     {,         this.developers = developers;,     } //-- void setDevelopers( java.util.List ), ,     /**,      * Set a universally unique identifier for a project. It is,      * normal to,      *             use a fully-qualified package name to,      * distinguish it from other,      *             projects with a similar name (eg.,      * <code>org.apache.maven</code>).,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * Set the year of the project's inception, specified with 4,      * digits. This value is,      *             used when generating copyright notices as well,      * as being informational.,      * ,      * @param inceptionYear,      */,     public void setInceptionYear( String inceptionYear ),     {,         this.inceptionYear = inceptionYear;,     } //-- void setInceptionYear( String ), ,     /**,      * Set the project's issue management system information.,      * ,      * @param issueManagement,      */,     public void setIssueManagement( IssueManagement issueManagement ),     {,         this.issueManagement = issueManagement;,     } //-- void setIssueManagement( IssueManagement ), ,     /**,      * Set this element describes all of the licenses for this,      * project.,      *             Each license is described by a,      * <code>license</code> element, which,      *             is then described by additional elements.,      *             Projects should only list the license(s) that,      * applies to the project,      *             and not the licenses that apply to dependencies.,      *             If multiple licenses are listed, it is assumed,      * that the user can select,      *             any of them, not that they must accept all.,      * ,      * @param licenses,      */,     public void setLicenses( java.util.List<License> licenses ),     {,         this.licenses = licenses;,     } //-- void setLicenses( java.util.List ), ,     /**,      * Set contains information about a project's mailing lists.,      * ,      * @param mailingLists,      */,     public void setMailingLists( java.util.List<MailingList> mailingLists ),     {,         this.mailingLists = mailingLists;,     } //-- void setMailingLists( java.util.List ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String ), ,     /**,      * Set declares to which version of project descriptor this POM,      * conforms.,      * ,      * @param modelVersion,      */,     public void setModelVersion( String modelVersion ),     {,         this.modelVersion = modelVersion;,     } //-- void setModelVersion( String ), ,     /**,      * Set the full name of the project.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set this element describes various attributes of the,      * organization to which the,      *             project belongs. These attributes are utilized,      * when documentation is created (for,      *             copyright notices and links).,      * ,      * @param organization,      */,     public void setOrganization( Organization organization ),     {,         this.organization = organization;,     } //-- void setOrganization( Organization ), ,     /**,      * Set the type of artifact this project produces, for example,      * <code>jar</code>,      *               <code>war</code>,      *               <code>ear</code>,      *               <code>pom</code>.,      *             Plugins can create their own packaging, and,      *             therefore their own packaging types,,      *             so this list does not contain all possible,      * types.,      * ,      * @param packaging,      */,     public void setPackaging( String packaging ),     {,         this.packaging = packaging;,     } //-- void setPackaging( String ), ,     /**,      * Set the location of the parent project, if one exists.,      * Values from the parent,      *             project will be the default for this project if,      * they are left unspecified. The location,      *             is given as a group ID, artifact ID and version.,      * ,      * @param parent,      */,     public void setParent( Parent parent ),     {,         this.parent = parent;,     } //-- void setParent( Parent ), ,     /**,      * Set describes the prerequisites in the build environment for,      * this project.,      * ,      * @param prerequisites,      */,     public void setPrerequisites( Prerequisites prerequisites ),     {,         this.prerequisites = prerequisites;,     } //-- void setPrerequisites( Prerequisites ), ,     /**,      * Set a listing of project-local build profiles which will,      * modify the build process,      *             when activated.,      * ,      * @param profiles,      */,     public void setProfiles( java.util.List<Profile> profiles ),     {,         this.profiles = profiles;,     } //-- void setProfiles( java.util.List ), ,     /**,      * Set specification for the SCM used by the project, such as,      * CVS, Subversion, etc.,      * ,      * @param scm,      */,     public void setScm( Scm scm ),     {,         this.scm = scm;,     } //-- void setScm( Scm ), ,     /**,      * Set the URL to the project's homepage.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String ), ,     /**,      * Set the current version of the artifact produced by this,      * project.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     ,             ,     private void cloneHook( Model copy ),     {,         copy.pomFile = pomFile;,     }, ,     /**,      * The POM from which this model originated. This is transient runtime state and therefore not managed by Modello.,      */,     private java.io.File pomFile;, ,     /**,      * Gets the POM file for the corresponding project (if any).,      *,      * @return The POM file from which this model originated or {@code null} if this model does not belong to a local,      *         project (e.g. describes the metadata of some artifact from the repository).,      */,     public java.io.File getPomFile(),     {,         return pomFile;,     }, ,     public void setPomFile( java.io.File pomFile ),     {,         this.pomFile = ( pomFile != null ) ? pomFile.getAbsoluteFile() : null;,     }, ,     /**,      * Gets the base directory for the corresponding project (if any).,      *,      * @return The base directory for the corresponding project or {@code null} if this model does not belong to a local,      *         project (e.g. describes the metadata of some artifact from the repository).,      */,     public java.io.File getProjectDirectory(),     {,         return ( pomFile != null ) ? pomFile.getParentFile() : null;,     }, ,     /**,      * @return the model id as <code>groupId:artifactId:packaging:version</code>,      */,     public String getId(),     {,         StringBuilder id = new StringBuilder( 64 );, ,         id.append( ( getGroupId() == null ) ? "[inherited]" : getGroupId() );,         id.append( ":" );,         id.append( getArtifactId() );,         id.append( ":" );,         id.append( getPackaging() );,         id.append( ":" );,         id.append( ( getVersion() == null ) ? "[inherited]" : getVersion() );, ,         return id.toString();,     }, ,     @Override,     public String toString(),     {,         return getId();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Model.java,,20-1031,[@SuppressWarnings( "all" ), public class Model,     extends ModelBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Declares to which version of project descriptor this POM,      * conforms.,      */,     private String modelVersion;, ,     /**,      * The location of the parent project, if one exists. Values,      * from the parent,      *             project will be the default for this project if,      * they are left unspecified. The location,      *             is given as a group ID, artifact ID and version.,      */,     private Parent parent;, ,     /**,      * ,      *             ,      *             A universally unique identifier for a project.,      * It is normal to,      *             use a fully-qualified package name to,      * distinguish it from other,      *             projects with a similar name (eg.,      * <code>org.apache.maven</code>).,      *             ,      *           ,      */,     private String groupId;, ,     /**,      * The identifier for this artifact that is unique within the,      * group given by the,      *             group ID. An artifact is something that is,      * either produced or used by a project.,      *             Examples of artifacts produced by Maven for a,      * project include: JARs, source and binary,      *             distributions, and WARs.,      */,     private String artifactId;, ,     /**,      * The current version of the artifact produced by this project.,      */,     private String version;, ,     /**,      * ,      *             ,      *             The type of artifact this project produces, for,      * example <code>jar</code>,      *               <code>war</code>,      *               <code>ear</code>,      *               <code>pom</code>.,      *             Plugins can create their own packaging, and,      *             therefore their own packaging types,,      *             so this list does not contain all possible,      * types.,      *             ,      *           ,      */,     private String packaging = "jar";, ,     /**,      * The full name of the project.,      */,     private String name;, ,     /**,      * A detailed description of the project, used by Maven,      * whenever it needs to,      *             describe the project, such as on the web site.,      * While this element can be specified as,      *             CDATA to enable the use of HTML tags within the,      * description, it is discouraged to allow,      *             plain text representation. If you need to modify,      * the index page of the generated web,      *             site, you are able to specify your own instead,      * of adjusting this text.,      */,     private String description;, ,     /**,      * ,      *             ,      *             The URL to the project's homepage.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId,      *             ,      *           .,      */,     private String url;, ,     /**,      * The year of the project's inception, specified with 4,      * digits. This value is,      *             used when generating copyright notices as well,      * as being informational.,      */,     private String inceptionYear;, ,     /**,      * This element describes various attributes of the,      * organization to which the,      *             project belongs. These attributes are utilized,      * when documentation is created (for,      *             copyright notices and links).,      */,     private Organization organization;, ,     /**,      * Field licenses.,      */,     private java.util.List<License> licenses;, ,     /**,      * Field developers.,      */,     private java.util.List<Developer> developers;, ,     /**,      * Field contributors.,      */,     private java.util.List<Contributor> contributors;, ,     /**,      * Field mailingLists.,      */,     private java.util.List<MailingList> mailingLists;, ,     /**,      * Describes the prerequisites in the build environment for,      * this project.,      */,     private Prerequisites prerequisites;, ,     /**,      * Specification for the SCM used by the project, such as CVS,,      * Subversion, etc.,      */,     private Scm scm;, ,     /**,      * The project's issue management system information.,      */,     private IssueManagement issueManagement;, ,     /**,      * The project's continuous integration information.,      */,     private CiManagement ciManagement;, ,     /**,      * Information required to build the project.,      */,     private Build build;, ,     /**,      * Field profiles.,      */,     private java.util.List<Profile> profiles;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addContributor.,      * ,      * @param contributor,      */,     public void addContributor( Contributor contributor ),     {,         getContributors().add( contributor );,     } //-- void addContributor( Contributor ), ,     /**,      * Method addDeveloper.,      * ,      * @param developer,      */,     public void addDeveloper( Developer developer ),     {,         getDevelopers().add( developer );,     } //-- void addDeveloper( Developer ), ,     /**,      * Method addLicense.,      * ,      * @param license,      */,     public void addLicense( License license ),     {,         getLicenses().add( license );,     } //-- void addLicense( License ), ,     /**,      * Method addMailingList.,      * ,      * @param mailingList,      */,     public void addMailingList( MailingList mailingList ),     {,         getMailingLists().add( mailingList );,     } //-- void addMailingList( MailingList ), ,     /**,      * Method addProfile.,      * ,      * @param profile,      */,     public void addProfile( Profile profile ),     {,         getProfiles().add( profile );,     } //-- void addProfile( Profile ), ,     /**,      * Method clone.,      * ,      * @return Model,      */,     public Model clone(),     {,         try,         {,             Model copy = (Model) super.clone();, ,             if ( this.parent != null ),             {,                 copy.parent = (Parent) this.parent.clone();,             }, ,             if ( this.organization != null ),             {,                 copy.organization = (Organization) this.organization.clone();,             }, ,             if ( this.licenses != null ),             {,                 copy.licenses = new java.util.ArrayList<License>();,                 for ( License item : this.licenses ),                 {,                     copy.licenses.add( ( (License) item).clone() );,                 },             }, ,             if ( this.developers != null ),             {,                 copy.developers = new java.util.ArrayList<Developer>();,                 for ( Developer item : this.developers ),                 {,                     copy.developers.add( ( (Developer) item).clone() );,                 },             }, ,             if ( this.contributors != null ),             {,                 copy.contributors = new java.util.ArrayList<Contributor>();,                 for ( Contributor item : this.contributors ),                 {,                     copy.contributors.add( ( (Contributor) item).clone() );,                 },             }, ,             if ( this.mailingLists != null ),             {,                 copy.mailingLists = new java.util.ArrayList<MailingList>();,                 for ( MailingList item : this.mailingLists ),                 {,                     copy.mailingLists.add( ( (MailingList) item).clone() );,                 },             }, ,             if ( this.prerequisites != null ),             {,                 copy.prerequisites = (Prerequisites) this.prerequisites.clone();,             }, ,             if ( this.scm != null ),             {,                 copy.scm = (Scm) this.scm.clone();,             }, ,             if ( this.issueManagement != null ),             {,                 copy.issueManagement = (IssueManagement) this.issueManagement.clone();,             }, ,             if ( this.ciManagement != null ),             {,                 copy.ciManagement = (CiManagement) this.ciManagement.clone();,             }, ,             if ( this.build != null ),             {,                 copy.build = (Build) this.build.clone();,             }, ,             if ( this.profiles != null ),             {,                 copy.profiles = new java.util.ArrayList<Profile>();,                 for ( Profile item : this.profiles ),                 {,                     copy.profiles.add( ( (Profile) item).clone() );,                 },             }, ,             cloneHook( copy );, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Model clone(), ,     /**,      * Get the identifier for this artifact that is unique within,      * the group given by the,      *             group ID. An artifact is something that is,      * either produced or used by a project.,      *             Examples of artifacts produced by Maven for a,      * project include: JARs, source and binary,      *             distributions, and WARs.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get information required to build the project.,      * ,      * @return Build,      */,     public Build getBuild(),     {,         return this.build;,     } //-- Build getBuild(), ,     /**,      * Get the project's continuous integration information.,      * ,      * @return CiManagement,      */,     public CiManagement getCiManagement(),     {,         return this.ciManagement;,     } //-- CiManagement getCiManagement(), ,     /**,      * Method getContributors.,      * ,      * @return List,      */,     public java.util.List<Contributor> getContributors(),     {,         if ( this.contributors == null ),         {,             this.contributors = new java.util.ArrayList<Contributor>();,         }, ,         return this.contributors;,     } //-- java.util.List<Contributor> getContributors(), ,     /**,      * Get a detailed description of the project, used by Maven,      * whenever it needs to,      *             describe the project, such as on the web site.,      * While this element can be specified as,      *             CDATA to enable the use of HTML tags within the,      * description, it is discouraged to allow,      *             plain text representation. If you need to modify,      * the index page of the generated web,      *             site, you are able to specify your own instead,      * of adjusting this text.,      * ,      * @return String,      */,     public String getDescription(),     {,         return this.description;,     } //-- String getDescription(), ,     /**,      * Method getDevelopers.,      * ,      * @return List,      */,     public java.util.List<Developer> getDevelopers(),     {,         if ( this.developers == null ),         {,             this.developers = new java.util.ArrayList<Developer>();,         }, ,         return this.developers;,     } //-- java.util.List<Developer> getDevelopers(), ,     /**,      * Get a universally unique identifier for a project. It is,      * normal to,      *             use a fully-qualified package name to,      * distinguish it from other,      *             projects with a similar name (eg.,      * <code>org.apache.maven</code>).,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * Get the year of the project's inception, specified with 4,      * digits. This value is,      *             used when generating copyright notices as well,      * as being informational.,      * ,      * @return String,      */,     public String getInceptionYear(),     {,         return this.inceptionYear;,     } //-- String getInceptionYear(), ,     /**,      * Get the project's issue management system information.,      * ,      * @return IssueManagement,      */,     public IssueManagement getIssueManagement(),     {,         return this.issueManagement;,     } //-- IssueManagement getIssueManagement(), ,     /**,      * Method getLicenses.,      * ,      * @return List,      */,     public java.util.List<License> getLicenses(),     {,         if ( this.licenses == null ),         {,             this.licenses = new java.util.ArrayList<License>();,         }, ,         return this.licenses;,     } //-- java.util.List<License> getLicenses(), ,     /**,      * Method getMailingLists.,      * ,      * @return List,      */,     public java.util.List<MailingList> getMailingLists(),     {,         if ( this.mailingLists == null ),         {,             this.mailingLists = new java.util.ArrayList<MailingList>();,         }, ,         return this.mailingLists;,     } //-- java.util.List<MailingList> getMailingLists(), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Get declares to which version of project descriptor this POM,      * conforms.,      * ,      * @return String,      */,     public String getModelVersion(),     {,         return this.modelVersion;,     } //-- String getModelVersion(), ,     /**,      * Get the full name of the project.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get this element describes various attributes of the,      * organization to which the,      *             project belongs. These attributes are utilized,      * when documentation is created (for,      *             copyright notices and links).,      * ,      * @return Organization,      */,     public Organization getOrganization(),     {,         return this.organization;,     } //-- Organization getOrganization(), ,     /**,      * Get the type of artifact this project produces, for example,      * <code>jar</code>,      *               <code>war</code>,      *               <code>ear</code>,      *               <code>pom</code>.,      *             Plugins can create their own packaging, and,      *             therefore their own packaging types,,      *             so this list does not contain all possible,      * types.,      * ,      * @return String,      */,     public String getPackaging(),     {,         return this.packaging;,     } //-- String getPackaging(), ,     /**,      * Get the location of the parent project, if one exists.,      * Values from the parent,      *             project will be the default for this project if,      * they are left unspecified. The location,      *             is given as a group ID, artifact ID and version.,      * ,      * @return Parent,      */,     public Parent getParent(),     {,         return this.parent;,     } //-- Parent getParent(), ,     /**,      * Get describes the prerequisites in the build environment for,      * this project.,      * ,      * @return Prerequisites,      */,     public Prerequisites getPrerequisites(),     {,         return this.prerequisites;,     } //-- Prerequisites getPrerequisites(), ,     /**,      * Method getProfiles.,      * ,      * @return List,      */,     public java.util.List<Profile> getProfiles(),     {,         if ( this.profiles == null ),         {,             this.profiles = new java.util.ArrayList<Profile>();,         }, ,         return this.profiles;,     } //-- java.util.List<Profile> getProfiles(), ,     /**,      * Get specification for the SCM used by the project, such as,      * CVS, Subversion, etc.,      * ,      * @return Scm,      */,     public Scm getScm(),     {,         return this.scm;,     } //-- Scm getScm(), ,     /**,      * Get the URL to the project's homepage.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Get the current version of the artifact produced by this,      * project.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Method removeContributor.,      * ,      * @param contributor,      */,     public void removeContributor( Contributor contributor ),     {,         getContributors().remove( contributor );,     } //-- void removeContributor( Contributor ), ,     /**,      * Method removeDeveloper.,      * ,      * @param developer,      */,     public void removeDeveloper( Developer developer ),     {,         getDevelopers().remove( developer );,     } //-- void removeDeveloper( Developer ), ,     /**,      * Method removeLicense.,      * ,      * @param license,      */,     public void removeLicense( License license ),     {,         getLicenses().remove( license );,     } //-- void removeLicense( License ), ,     /**,      * Method removeMailingList.,      * ,      * @param mailingList,      */,     public void removeMailingList( MailingList mailingList ),     {,         getMailingLists().remove( mailingList );,     } //-- void removeMailingList( MailingList ), ,     /**,      * Method removeProfile.,      * ,      * @param profile,      */,     public void removeProfile( Profile profile ),     {,         getProfiles().remove( profile );,     } //-- void removeProfile( Profile ), ,     /**,      * Set the identifier for this artifact that is unique within,      * the group given by the,      *             group ID. An artifact is something that is,      * either produced or used by a project.,      *             Examples of artifacts produced by Maven for a,      * project include: JARs, source and binary,      *             distributions, and WARs.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set information required to build the project.,      * ,      * @param build,      */,     public void setBuild( Build build ),     {,         this.build = build;,     } //-- void setBuild( Build ), ,     /**,      * Set the project's continuous integration information.,      * ,      * @param ciManagement,      */,     public void setCiManagement( CiManagement ciManagement ),     {,         this.ciManagement = ciManagement;,     } //-- void setCiManagement( CiManagement ), ,     /**,      * Set describes the contributors to a project that are not yet,      * committers.,      * ,      * @param contributors,      */,     public void setContributors( java.util.List<Contributor> contributors ),     {,         this.contributors = contributors;,     } //-- void setContributors( java.util.List ), ,     /**,      * Set a detailed description of the project, used by Maven,      * whenever it needs to,      *             describe the project, such as on the web site.,      * While this element can be specified as,      *             CDATA to enable the use of HTML tags within the,      * description, it is discouraged to allow,      *             plain text representation. If you need to modify,      * the index page of the generated web,      *             site, you are able to specify your own instead,      * of adjusting this text.,      * ,      * @param description,      */,     public void setDescription( String description ),     {,         this.description = description;,     } //-- void setDescription( String ), ,     /**,      * Set describes the committers of a project.,      * ,      * @param developers,      */,     public void setDevelopers( java.util.List<Developer> developers ),     {,         this.developers = developers;,     } //-- void setDevelopers( java.util.List ), ,     /**,      * Set a universally unique identifier for a project. It is,      * normal to,      *             use a fully-qualified package name to,      * distinguish it from other,      *             projects with a similar name (eg.,      * <code>org.apache.maven</code>).,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * Set the year of the project's inception, specified with 4,      * digits. This value is,      *             used when generating copyright notices as well,      * as being informational.,      * ,      * @param inceptionYear,      */,     public void setInceptionYear( String inceptionYear ),     {,         this.inceptionYear = inceptionYear;,     } //-- void setInceptionYear( String ), ,     /**,      * Set the project's issue management system information.,      * ,      * @param issueManagement,      */,     public void setIssueManagement( IssueManagement issueManagement ),     {,         this.issueManagement = issueManagement;,     } //-- void setIssueManagement( IssueManagement ), ,     /**,      * Set this element describes all of the licenses for this,      * project.,      *             Each license is described by a,      * <code>license</code> element, which,      *             is then described by additional elements.,      *             Projects should only list the license(s) that,      * applies to the project,      *             and not the licenses that apply to dependencies.,      *             If multiple licenses are listed, it is assumed,      * that the user can select,      *             any of them, not that they must accept all.,      * ,      * @param licenses,      */,     public void setLicenses( java.util.List<License> licenses ),     {,         this.licenses = licenses;,     } //-- void setLicenses( java.util.List ), ,     /**,      * Set contains information about a project's mailing lists.,      * ,      * @param mailingLists,      */,     public void setMailingLists( java.util.List<MailingList> mailingLists ),     {,         this.mailingLists = mailingLists;,     } //-- void setMailingLists( java.util.List ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String ), ,     /**,      * Set declares to which version of project descriptor this POM,      * conforms.,      * ,      * @param modelVersion,      */,     public void setModelVersion( String modelVersion ),     {,         this.modelVersion = modelVersion;,     } //-- void setModelVersion( String ), ,     /**,      * Set the full name of the project.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set this element describes various attributes of the,      * organization to which the,      *             project belongs. These attributes are utilized,      * when documentation is created (for,      *             copyright notices and links).,      * ,      * @param organization,      */,     public void setOrganization( Organization organization ),     {,         this.organization = organization;,     } //-- void setOrganization( Organization ), ,     /**,      * Set the type of artifact this project produces, for example,      * <code>jar</code>,      *               <code>war</code>,      *               <code>ear</code>,      *               <code>pom</code>.,      *             Plugins can create their own packaging, and,      *             therefore their own packaging types,,      *             so this list does not contain all possible,      * types.,      * ,      * @param packaging,      */,     public void setPackaging( String packaging ),     {,         this.packaging = packaging;,     } //-- void setPackaging( String ), ,     /**,      * Set the location of the parent project, if one exists.,      * Values from the parent,      *             project will be the default for this project if,      * they are left unspecified. The location,      *             is given as a group ID, artifact ID and version.,      * ,      * @param parent,      */,     public void setParent( Parent parent ),     {,         this.parent = parent;,     } //-- void setParent( Parent ), ,     /**,      * Set describes the prerequisites in the build environment for,      * this project.,      * ,      * @param prerequisites,      */,     public void setPrerequisites( Prerequisites prerequisites ),     {,         this.prerequisites = prerequisites;,     } //-- void setPrerequisites( Prerequisites ), ,     /**,      * Set a listing of project-local build profiles which will,      * modify the build process,      *             when activated.,      * ,      * @param profiles,      */,     public void setProfiles( java.util.List<Profile> profiles ),     {,         this.profiles = profiles;,     } //-- void setProfiles( java.util.List ), ,     /**,      * Set specification for the SCM used by the project, such as,      * CVS, Subversion, etc.,      * ,      * @param scm,      */,     public void setScm( Scm scm ),     {,         this.scm = scm;,     } //-- void setScm( Scm ), ,     /**,      * Set the URL to the project's homepage.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String ), ,     /**,      * Set the current version of the artifact produced by this,      * project.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     ,             ,     private void cloneHook( Model copy ),     {,         copy.pomFile = pomFile;,     }, ,     /**,      * The POM from which this model originated. This is transient runtime state and therefore not managed by Modello.,      */,     private java.io.File pomFile;, ,     /**,      * Gets the POM file for the corresponding project (if any).,      *,      * @return The POM file from which this model originated or {@code null} if this model does not belong to a local,      *         project (e.g. describes the metadata of some artifact from the repository).,      */,     public java.io.File getPomFile(),     {,         return pomFile;,     }, ,     public void setPomFile( java.io.File pomFile ),     {,         this.pomFile = ( pomFile != null ) ? pomFile.getAbsoluteFile() : null;,     }, ,     /**,      * Gets the base directory for the corresponding project (if any).,      *,      * @return The base directory for the corresponding project or {@code null} if this model does not belong to a local,      *         project (e.g. describes the metadata of some artifact from the repository).,      */,     public java.io.File getProjectDirectory(),     {,         return ( pomFile != null ) ? pomFile.getParentFile() : null;,     }, ,     /**,      * @return the model id as <code>groupId:artifactId:packaging:version</code>,      */,     public String getId(),     {,         StringBuilder id = new StringBuilder( 64 );, ,         id.append( ( getGroupId() == null ) ? "[inherited]" : getGroupId() );,         id.append( ":" );,         id.append( getArtifactId() );,         id.append( ":" );,         id.append( getPackaging() );,         id.append( ":" );,         id.append( ( getVersion() == null ) ? "[inherited]" : getVersion() );, ,         return id.toString();,     }, ,     @Override,     public String toString(),     {,         return getId();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/maven/model/ModelBase.java,clone,235-235,[        catch ( java.lang.Exception ex )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/ModelBase.java,,18-574,[@SuppressWarnings( "all" ), public class ModelBase,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field modules.,      */,     private java.util.List<String> modules;, ,     /**,      * Distribution information for a project that enables,      * deployment of the site,      *             and artifacts to remote web servers and,      * repositories respectively.,      */,     private DistributionManagement distributionManagement;, ,     /**,      * Field properties.,      */,     private java.util.Properties properties;, ,     /**,      * Default dependency information for projects that inherit,      * from this one. The,      *             dependencies in this section are not immediately,      * resolved. Instead, when a POM derived,      *             from this one declares a dependency described by,      * a matching groupId and artifactId, the,      *             version and other values from this section are,      * used for that dependency if they were not,      *             already specified.,      */,     private DependencyManagement dependencyManagement;, ,     /**,      * Field dependencies.,      */,     private java.util.List<Dependency> dependencies;, ,     /**,      * Field repositories.,      */,     private java.util.List<Repository> repositories;, ,     /**,      * Field pluginRepositories.,      */,     private java.util.List<Repository> pluginRepositories;, ,     /**,      * ,      *             ,      *             <b>Deprecated</b>. Now ignored by Maven.,      *             ,      *           ,      */,     private Object reports;, ,     /**,      * ,      *             ,      *             This element includes the specification of,      * report plugins to use,      *             to generate the reports on the Maven-generated,      * site.,      *             These reports will be run when a user executes,      * <code>mvn site</code>.,      *             All of the reports will be included in the,      * navigation bar for browsing.,      *             ,      *           ,      */,     private Reporting reporting;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addDependency.,      * ,      * @param dependency,      */,     public void addDependency( Dependency dependency ),     {,         getDependencies().add( dependency );,     } //-- void addDependency( Dependency ), ,     /**,      * Method addModule.,      * ,      * @param string,      */,     public void addModule( String string ),     {,         getModules().add( string );,     } //-- void addModule( String ), ,     /**,      * Method addPluginRepository.,      * ,      * @param repository,      */,     public void addPluginRepository( Repository repository ),     {,         getPluginRepositories().add( repository );,     } //-- void addPluginRepository( Repository ), ,     /**,      * Method addProperty.,      * ,      * @param key,      * @param value,      */,     public void addProperty( String key, String value ),     {,         getProperties().put( key, value );,     } //-- void addProperty( String, String ), ,     /**,      * Method addRepository.,      * ,      * @param repository,      */,     public void addRepository( Repository repository ),     {,         getRepositories().add( repository );,     } //-- void addRepository( Repository ), ,     /**,      * Method clone.,      * ,      * @return ModelBase,      */,     public ModelBase clone(),     {,         try,         {,             ModelBase copy = (ModelBase) super.clone();, ,             if ( this.modules != null ),             {,                 copy.modules = new java.util.ArrayList<String>();,                 copy.modules.addAll( this.modules );,             }, ,             if ( this.distributionManagement != null ),             {,                 copy.distributionManagement = (DistributionManagement) this.distributionManagement.clone();,             }, ,             if ( this.properties != null ),             {,                 copy.properties = (java.util.Properties) this.properties.clone();,             }, ,             if ( this.dependencyManagement != null ),             {,                 copy.dependencyManagement = (DependencyManagement) this.dependencyManagement.clone();,             }, ,             if ( this.dependencies != null ),             {,                 copy.dependencies = new java.util.ArrayList<Dependency>();,                 for ( Dependency item : this.dependencies ),                 {,                     copy.dependencies.add( ( (Dependency) item).clone() );,                 },             }, ,             if ( this.repositories != null ),             {,                 copy.repositories = new java.util.ArrayList<Repository>();,                 for ( Repository item : this.repositories ),                 {,                     copy.repositories.add( ( (Repository) item).clone() );,                 },             }, ,             if ( this.pluginRepositories != null ),             {,                 copy.pluginRepositories = new java.util.ArrayList<Repository>();,                 for ( Repository item : this.pluginRepositories ),                 {,                     copy.pluginRepositories.add( ( (Repository) item).clone() );,                 },             }, ,             if ( this.reports != null ),             {,                 copy.reports = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.reports );,             }, ,             if ( this.reporting != null ),             {,                 copy.reporting = (Reporting) this.reporting.clone();,             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ModelBase clone(), ,     /**,      * Method getDependencies.,      * ,      * @return List,      */,     public java.util.List<Dependency> getDependencies(),     {,         if ( this.dependencies == null ),         {,             this.dependencies = new java.util.ArrayList<Dependency>();,         }, ,         return this.dependencies;,     } //-- java.util.List<Dependency> getDependencies(), ,     /**,      * Get default dependency information for projects that inherit,      * from this one. The,      *             dependencies in this section are not immediately,      * resolved. Instead, when a POM derived,      *             from this one declares a dependency described by,      * a matching groupId and artifactId, the,      *             version and other values from this section are,      * used for that dependency if they were not,      *             already specified.,      * ,      * @return DependencyManagement,      */,     public DependencyManagement getDependencyManagement(),     {,         return this.dependencyManagement;,     } //-- DependencyManagement getDependencyManagement(), ,     /**,      * Get distribution information for a project that enables,      * deployment of the site,      *             and artifacts to remote web servers and,      * repositories respectively.,      * ,      * @return DistributionManagement,      */,     public DistributionManagement getDistributionManagement(),     {,         return this.distributionManagement;,     } //-- DistributionManagement getDistributionManagement(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Method getModules.,      * ,      * @return List,      */,     public java.util.List<String> getModules(),     {,         if ( this.modules == null ),         {,             this.modules = new java.util.ArrayList<String>();,         }, ,         return this.modules;,     } //-- java.util.List<String> getModules(), ,     /**,      * Method getPluginRepositories.,      * ,      * @return List,      */,     public java.util.List<Repository> getPluginRepositories(),     {,         if ( this.pluginRepositories == null ),         {,             this.pluginRepositories = new java.util.ArrayList<Repository>();,         }, ,         return this.pluginRepositories;,     } //-- java.util.List<Repository> getPluginRepositories(), ,     /**,      * Method getProperties.,      * ,      * @return Properties,      */,     public java.util.Properties getProperties(),     {,         if ( this.properties == null ),         {,             this.properties = new java.util.Properties();,         }, ,         return this.properties;,     } //-- java.util.Properties getProperties(), ,     /**,      * Get this element includes the specification of report,      * plugins to use,      *             to generate the reports on the Maven-generated,      * site.,      *             These reports will be run when a user executes,      * <code>mvn site</code>.,      *             All of the reports will be included in the,      * navigation bar for browsing.,      * ,      * @return Reporting,      */,     public Reporting getReporting(),     {,         return this.reporting;,     } //-- Reporting getReporting(), ,     /**,      * Get <b>Deprecated</b>. Now ignored by Maven.,      * ,      * @return Object,      */,     public Object getReports(),     {,         return this.reports;,     } //-- Object getReports(), ,     /**,      * Method getRepositories.,      * ,      * @return List,      */,     public java.util.List<Repository> getRepositories(),     {,         if ( this.repositories == null ),         {,             this.repositories = new java.util.ArrayList<Repository>();,         }, ,         return this.repositories;,     } //-- java.util.List<Repository> getRepositories(), ,     /**,      * Method removeDependency.,      * ,      * @param dependency,      */,     public void removeDependency( Dependency dependency ),     {,         getDependencies().remove( dependency );,     } //-- void removeDependency( Dependency ), ,     /**,      * Method removeModule.,      * ,      * @param string,      */,     public void removeModule( String string ),     {,         getModules().remove( string );,     } //-- void removeModule( String ), ,     /**,      * Method removePluginRepository.,      * ,      * @param repository,      */,     public void removePluginRepository( Repository repository ),     {,         getPluginRepositories().remove( repository );,     } //-- void removePluginRepository( Repository ), ,     /**,      * Method removeRepository.,      * ,      * @param repository,      */,     public void removeRepository( Repository repository ),     {,         getRepositories().remove( repository );,     } //-- void removeRepository( Repository ), ,     /**,      * Set this element describes all of the dependencies,      * associated with a,      *             project.,      *             These dependencies are used to construct a,      * classpath for your,      *             project during the build process. They are,      * automatically downloaded from the,      *             repositories defined in this project.,      *             See <a,      * href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the,      *             dependency mechanism</a> for more information.,      * ,      * @param dependencies,      */,     public void setDependencies( java.util.List<Dependency> dependencies ),     {,         this.dependencies = dependencies;,     } //-- void setDependencies( java.util.List ), ,     /**,      * Set default dependency information for projects that inherit,      * from this one. The,      *             dependencies in this section are not immediately,      * resolved. Instead, when a POM derived,      *             from this one declares a dependency described by,      * a matching groupId and artifactId, the,      *             version and other values from this section are,      * used for that dependency if they were not,      *             already specified.,      * ,      * @param dependencyManagement,      */,     public void setDependencyManagement( DependencyManagement dependencyManagement ),     {,         this.dependencyManagement = dependencyManagement;,     } //-- void setDependencyManagement( DependencyManagement ), ,     /**,      * Set distribution information for a project that enables,      * deployment of the site,      *             and artifacts to remote web servers and,      * repositories respectively.,      * ,      * @param distributionManagement,      */,     public void setDistributionManagement( DistributionManagement distributionManagement ),     {,         this.distributionManagement = distributionManagement;,     } //-- void setDistributionManagement( DistributionManagement ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the modules (sometimes called subprojects) to build as a,      * part of this,      *             project. Each module listed is a relative path,      * to the directory containing the module.,      *             To be consistent with the way default urls are,      * calculated from parent, it is recommended,      *             to have module names match artifact ids.,      * ,      * @param modules,      */,     public void setModules( java.util.List<String> modules ),     {,         this.modules = modules;,     } //-- void setModules( java.util.List ), ,     /**,      * Set the lists of the remote repositories for discovering,      * plugins for builds and,      *             reports.,      * ,      * @param pluginRepositories,      */,     public void setPluginRepositories( java.util.List<Repository> pluginRepositories ),     {,         this.pluginRepositories = pluginRepositories;,     } //-- void setPluginRepositories( java.util.List ), ,     /**,      * Set properties that can be used throughout the POM as a,      * substitution, and,      *             are used as filters in resources if enabled.,      *             The format is,      * <code>&lt;name&gt;value&lt;/name&gt;</code>.,      * ,      * @param properties,      */,     public void setProperties( java.util.Properties properties ),     {,         this.properties = properties;,     } //-- void setProperties( java.util.Properties ), ,     /**,      * Set this element includes the specification of report,      * plugins to use,      *             to generate the reports on the Maven-generated,      * site.,      *             These reports will be run when a user executes,      * <code>mvn site</code>.,      *             All of the reports will be included in the,      * navigation bar for browsing.,      * ,      * @param reporting,      */,     public void setReporting( Reporting reporting ),     {,         this.reporting = reporting;,     } //-- void setReporting( Reporting ), ,     /**,      * Set <b>Deprecated</b>. Now ignored by Maven.,      * ,      * @param reports,      */,     public void setReports( Object reports ),     {,         this.reports = reports;,     } //-- void setReports( Object ), ,     /**,      * Set the lists of the remote repositories for discovering,      * dependencies and,      *             extensions.,      * ,      * @param repositories,      */,     public void setRepositories( java.util.List<Repository> repositories ),     {,         this.repositories = repositories;,     } //-- void setRepositories( java.util.List )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ModelTest.java,testEqualsNullSafe,42-42,[        new Model().equals( new Model() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Notifier.java,,14-289,[@SuppressWarnings( "all" ), public class Notifier,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The mechanism used to deliver notifications.,      */,     private String type = "mail";, ,     /**,      * Whether to send notifications on error.,      */,     private boolean sendOnError = true;, ,     /**,      * Whether to send notifications on failure.,      */,     private boolean sendOnFailure = true;, ,     /**,      * Whether to send notifications on success.,      */,     private boolean sendOnSuccess = true;, ,     /**,      * Whether to send notifications on warning.,      */,     private boolean sendOnWarning = true;, ,     /**,      * ,      *             ,      *             <b>Deprecated</b>. Where to send the,      * notification to - eg email address.,      *             ,      *           ,      */,     private String address;, ,     /**,      * Field configuration.,      */,     private java.util.Properties configuration;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addConfiguration.,      * ,      * @param key,      * @param value,      */,     public void addConfiguration( String key, String value ),     {,         getConfiguration().put( key, value );,     } //-- void addConfiguration( String, String ), ,     /**,      * Method clone.,      * ,      * @return Notifier,      */,     public Notifier clone(),     {,         try,         {,             Notifier copy = (Notifier) super.clone();, ,             if ( this.configuration != null ),             {,                 copy.configuration = (java.util.Properties) this.configuration.clone();,             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Notifier clone(), ,     /**,      * Get <b>Deprecated</b>. Where to send the notification to -,      * eg email address.,      * ,      * @return String,      */,     public String getAddress(),     {,         return this.address;,     } //-- String getAddress(), ,     /**,      * Method getConfiguration.,      * ,      * @return Properties,      */,     public java.util.Properties getConfiguration(),     {,         if ( this.configuration == null ),         {,             this.configuration = new java.util.Properties();,         }, ,         return this.configuration;,     } //-- java.util.Properties getConfiguration(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the mechanism used to deliver notifications.,      * ,      * @return String,      */,     public String getType(),     {,         return this.type;,     } //-- String getType(), ,     /**,      * Get whether to send notifications on error.,      * ,      * @return boolean,      */,     public boolean isSendOnError(),     {,         return this.sendOnError;,     } //-- boolean isSendOnError(), ,     /**,      * Get whether to send notifications on failure.,      * ,      * @return boolean,      */,     public boolean isSendOnFailure(),     {,         return this.sendOnFailure;,     } //-- boolean isSendOnFailure(), ,     /**,      * Get whether to send notifications on success.,      * ,      * @return boolean,      */,     public boolean isSendOnSuccess(),     {,         return this.sendOnSuccess;,     } //-- boolean isSendOnSuccess(), ,     /**,      * Get whether to send notifications on warning.,      * ,      * @return boolean,      */,     public boolean isSendOnWarning(),     {,         return this.sendOnWarning;,     } //-- boolean isSendOnWarning(), ,     /**,      * Set <b>Deprecated</b>. Where to send the notification to -,      * eg email address.,      * ,      * @param address,      */,     public void setAddress( String address ),     {,         this.address = address;,     } //-- void setAddress( String ), ,     /**,      * Set extended configuration specific to this notifier goes,      * here.,      * ,      * @param configuration,      */,     public void setConfiguration( java.util.Properties configuration ),     {,         this.configuration = configuration;,     } //-- void setConfiguration( java.util.Properties ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set whether to send notifications on error.,      * ,      * @param sendOnError,      */,     public void setSendOnError( boolean sendOnError ),     {,         this.sendOnError = sendOnError;,     } //-- void setSendOnError( boolean ), ,     /**,      * Set whether to send notifications on failure.,      * ,      * @param sendOnFailure,      */,     public void setSendOnFailure( boolean sendOnFailure ),     {,         this.sendOnFailure = sendOnFailure;,     } //-- void setSendOnFailure( boolean ), ,     /**,      * Set whether to send notifications on success.,      * ,      * @param sendOnSuccess,      */,     public void setSendOnSuccess( boolean sendOnSuccess ),     {,         this.sendOnSuccess = sendOnSuccess;,     } //-- void setSendOnSuccess( boolean ), ,     /**,      * Set whether to send notifications on warning.,      * ,      * @param sendOnWarning,      */,     public void setSendOnWarning( boolean sendOnWarning ),     {,         this.sendOnWarning = sendOnWarning;,     } //-- void setSendOnWarning( boolean ), ,     /**,      * Set the mechanism used to deliver notifications.,      * ,      * @param type,      */,     public void setType( String type ),     {,         this.type = type;,     } //-- void setType( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/NotifierTest.java,testEqualsNullSafe,42-42,[        new Notifier().equals( new Notifier() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Organization.java,,13-134,[@SuppressWarnings( "all" ), public class Organization,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The full name of the organization.,      */,     private String name;, ,     /**,      * The URL to the organization's home page.,      */,     private String url;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Organization,      */,     public Organization clone(),     {,         try,         {,             Organization copy = (Organization) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Organization clone(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the full name of the organization.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the URL to the organization's home page.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the full name of the organization.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the URL to the organization's home page.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/OrganizationTest.java,testEqualsNullSafe,42-42,[        new Organization().equals( new Organization() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Parent.java,,21-281,[@SuppressWarnings( "all" ), public class Parent,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The group id of the parent project to inherit from.,      */,     private String groupId;, ,     /**,      * The artifact id of the parent project to inherit from.,      */,     private String artifactId;, ,     /**,      * The version of the parent project to inherit.,      */,     private String version;, ,     /**,      * ,      *             ,      *             The relative path of the parent,      * <code>pom.xml</code> file within the check out.,      *             If not specified, it defaults to,      * <code>../pom.xml</code>.,      *             Maven looks for the parent POM first in this,      * location on,      *             the filesystem, then the local repository, and,      * lastly in the remote repo.,      *             <code>relativePath</code> allows you to select a,      * different location,,      *             for example when your structure is flat, or,      * deeper without an intermediate parent POM.,      *             However, the group ID, artifact ID and version,      * are still required,,      *             and must match the file in the location given or,      * it will revert to the repository for the POM.,      *             This feature is only for enhancing the,      * development in a local checkout of that project.,      *             Set the value to an empty string in case you,      * want to disable the feature and always resolve,      *             the parent POM from the repositories.,      *             ,      *           ,      */,     private String relativePath = "../pom.xml";, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Parent,      */,     public Parent clone(),     {,         try,         {,             Parent copy = (Parent) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Parent clone(), ,     /**,      * Get the artifact id of the parent project to inherit from.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get the group id of the parent project to inherit from.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the relative path of the parent <code>pom.xml</code>,      * file within the check out.,      *             If not specified, it defaults to,      * <code>../pom.xml</code>.,      *             Maven looks for the parent POM first in this,      * location on,      *             the filesystem, then the local repository, and,      * lastly in the remote repo.,      *             <code>relativePath</code> allows you to select a,      * different location,,      *             for example when your structure is flat, or,      * deeper without an intermediate parent POM.,      *             However, the group ID, artifact ID and version,      * are still required,,      *             and must match the file in the location given or,      * it will revert to the repository for the POM.,      *             This feature is only for enhancing the,      * development in a local checkout of that project.,      *             Set the value to an empty string in case you,      * want to disable the feature and always resolve,      *             the parent POM from the repositories.,      * ,      * @return String,      */,     public String getRelativePath(),     {,         return this.relativePath;,     } //-- String getRelativePath(), ,     /**,      * Get the version of the parent project to inherit.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Set the artifact id of the parent project to inherit from.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set the group id of the parent project to inherit from.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the relative path of the parent <code>pom.xml</code>,      * file within the check out.,      *             If not specified, it defaults to,      * <code>../pom.xml</code>.,      *             Maven looks for the parent POM first in this,      * location on,      *             the filesystem, then the local repository, and,      * lastly in the remote repo.,      *             <code>relativePath</code> allows you to select a,      * different location,,      *             for example when your structure is flat, or,      * deeper without an intermediate parent POM.,      *             However, the group ID, artifact ID and version,      * are still required,,      *             and must match the file in the location given or,      * it will revert to the repository for the POM.,      *             This feature is only for enhancing the,      * development in a local checkout of that project.,      *             Set the value to an empty string in case you,      * want to disable the feature and always resolve,      *             the parent POM from the repositories.,      * ,      * @param relativePath,      */,     public void setRelativePath( String relativePath ),     {,         this.relativePath = relativePath;,     } //-- void setRelativePath( String ), ,     /**,      * Set the version of the parent project to inherit.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     ,             ,     /**,      * @return the id as <code>groupId:artifactId:version</code>,      */,     public String getId(),     {,         StringBuilder id = new StringBuilder( 64 );, ,         id.append( getGroupId() );,         id.append( ":" );,         id.append( getArtifactId() );,         id.append( ":" );,         id.append( "pom" );,         id.append( ":" );,         id.append( getVersion() );, ,         return id.toString();,     }, ,     @Override,     public String toString(),     {,         return getId();],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ParentTest.java,testEqualsNullSafe,42-42,[        new Parent().equals( new Parent() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/PatternSet.java,,13-226,[@SuppressWarnings( "all" ), public class PatternSet,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field includes.,      */,     private java.util.List<String> includes;, ,     /**,      * Field excludes.,      */,     private java.util.List<String> excludes;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addExclude.,      * ,      * @param string,      */,     public void addExclude( String string ),     {,         getExcludes().add( string );,     } //-- void addExclude( String ), ,     /**,      * Method addInclude.,      * ,      * @param string,      */,     public void addInclude( String string ),     {,         getIncludes().add( string );,     } //-- void addInclude( String ), ,     /**,      * Method clone.,      * ,      * @return PatternSet,      */,     public PatternSet clone(),     {,         try,         {,             PatternSet copy = (PatternSet) super.clone();, ,             if ( this.includes != null ),             {,                 copy.includes = new java.util.ArrayList<String>();,                 copy.includes.addAll( this.includes );,             }, ,             if ( this.excludes != null ),             {,                 copy.excludes = new java.util.ArrayList<String>();,                 copy.excludes.addAll( this.excludes );,             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- PatternSet clone(), ,     /**,      * Method getExcludes.,      * ,      * @return List,      */,     public java.util.List<String> getExcludes(),     {,         if ( this.excludes == null ),         {,             this.excludes = new java.util.ArrayList<String>();,         }, ,         return this.excludes;,     } //-- java.util.List<String> getExcludes(), ,     /**,      * Method getIncludes.,      * ,      * @return List,      */,     public java.util.List<String> getIncludes(),     {,         if ( this.includes == null ),         {,             this.includes = new java.util.ArrayList<String>();,         }, ,         return this.includes;,     } //-- java.util.List<String> getIncludes(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Method removeExclude.,      * ,      * @param string,      */,     public void removeExclude( String string ),     {,         getExcludes().remove( string );,     } //-- void removeExclude( String ), ,     /**,      * Method removeInclude.,      * ,      * @param string,      */,     public void removeInclude( String string ),     {,         getIncludes().remove( string );,     } //-- void removeInclude( String ), ,     /**,      * Set a list of patterns to exclude, e.g.,      * <code>**&#47;*.xml</code>,      * ,      * @param excludes,      */,     public void setExcludes( java.util.List<String> excludes ),     {,         this.excludes = excludes;,     } //-- void setExcludes( java.util.List ), ,     /**,      * Set a list of patterns to include, e.g.,      * <code>**&#47;*.xml</code>.,      * ,      * @param includes,      */,     public void setIncludes( java.util.List<String> includes ),     {,         this.includes = includes;,     } //-- void setIncludes( java.util.List ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     ,             ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         StringBuilder sb = new StringBuilder( 128 );, ,         sb.append("PatternSet [includes: {");,         for (java.util.Iterator i = getIncludes().iterator(); i.hasNext(); ),         {,             String str = (String) i.next();,             sb.append(str).append(", ");,         },         if (sb.substring(sb.length() - 2).equals(", ")) sb.delete(sb.length() - 2, sb.length());, ,         sb.append("}, excludes: {");,         for (java.util.Iterator i = getExcludes().iterator(); i.hasNext(); ),         {,             String str = (String) i.next();,             sb.append(str).append(", ");,         },         if (sb.substring(sb.length() - 2).equals(", ")) sb.delete(sb.length() - 2, sb.length());, ,         sb.append("}]");,         return sb.toString();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/Plugin.java,getExecutions,369-369,[            if ( getExecutions() != null )],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/Plugin.java,,18-458,[@SuppressWarnings( "all" ), public class Plugin,     extends ConfigurationContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The group ID of the plugin in the repository.,      */,     private String groupId = "org.apache.maven.plugins";, ,     /**,      * The artifact ID of the plugin in the repository.,      */,     private String artifactId;, ,     /**,      * The version (or valid range of versions) of the plugin to be,      * used.,      */,     private String version;, ,     /**,      * ,      *             ,      *             Whether to load Maven extensions (such as,      * packaging and type handlers) from,      *             this plugin. For performance reasons, this,      * should only be enabled when necessary. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      *             ,      *           ,      */,     private String extensions;, ,     /**,      * Field executions.,      */,     private java.util.List<PluginExecution> executions;, ,     /**,      * Field dependencies.,      */,     private java.util.List<Dependency> dependencies;, ,     /**,      * ,      *             ,      *             <b>Deprecated</b>. Unused by Maven.,      *             ,      *           ,      */,     private Object goals;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addDependency.,      * ,      * @param dependency,      */,     public void addDependency( Dependency dependency ),     {,         getDependencies().add( dependency );,     } //-- void addDependency( Dependency ), ,     /**,      * Method addExecution.,      * ,      * @param pluginExecution,      */,     public void addExecution( PluginExecution pluginExecution ),     {,         getExecutions().add( pluginExecution );,     } //-- void addExecution( PluginExecution ), ,     /**,      * Method clone.,      * ,      * @return Plugin,      */,     public Plugin clone(),     {,         try,         {,             Plugin copy = (Plugin) super.clone();, ,             if ( this.executions != null ),             {,                 copy.executions = new java.util.ArrayList<PluginExecution>();,                 for ( PluginExecution item : this.executions ),                 {,                     copy.executions.add( ( (PluginExecution) item).clone() );,                 },             }, ,             if ( this.dependencies != null ),             {,                 copy.dependencies = new java.util.ArrayList<Dependency>();,                 for ( Dependency item : this.dependencies ),                 {,                     copy.dependencies.add( ( (Dependency) item).clone() );,                 },             }, ,             if ( this.goals != null ),             {,                 copy.goals = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.goals );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Plugin clone(), ,     /**,      * Get the artifact ID of the plugin in the repository.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Method getDependencies.,      * ,      * @return List,      */,     public java.util.List<Dependency> getDependencies(),     {,         if ( this.dependencies == null ),         {,             this.dependencies = new java.util.ArrayList<Dependency>();,         }, ,         return this.dependencies;,     } //-- java.util.List<Dependency> getDependencies(), ,     /**,      * Method getExecutions.,      * ,      * @return List,      */,     public java.util.List<PluginExecution> getExecutions(),     {,         if ( this.executions == null ),         {,             this.executions = new java.util.ArrayList<PluginExecution>();,         }, ,         return this.executions;,     } //-- java.util.List<PluginExecution> getExecutions(), ,     /**,      * Get whether to load Maven extensions (such as packaging and,      * type handlers) from,      *             this plugin. For performance reasons, this,      * should only be enabled when necessary. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @return String,      */,     public String getExtensions(),     {,         return this.extensions;,     } //-- String getExtensions(), ,     /**,      * Get <b>Deprecated</b>. Unused by Maven.,      * ,      * @return Object,      */,     public Object getGoals(),     {,         return this.goals;,     } //-- Object getGoals(), ,     /**,      * Get the group ID of the plugin in the repository.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * Get the version (or valid range of versions) of the plugin,      * to be used.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Method removeDependency.,      * ,      * @param dependency,      */,     public void removeDependency( Dependency dependency ),     {,         getDependencies().remove( dependency );,     } //-- void removeDependency( Dependency ), ,     /**,      * Method removeExecution.,      * ,      * @param pluginExecution,      */,     public void removeExecution( PluginExecution pluginExecution ),     {,         getExecutions().remove( pluginExecution );,     } //-- void removeExecution( PluginExecution ), ,     /**,      * Set the artifact ID of the plugin in the repository.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set additional dependencies that this project needs to,      * introduce to the plugin's,      *             classloader.,      * ,      * @param dependencies,      */,     public void setDependencies( java.util.List<Dependency> dependencies ),     {,         this.dependencies = dependencies;,     } //-- void setDependencies( java.util.List ), ,     /**,      * Set multiple specifications of a set of goals to execute,      * during the build,      *             lifecycle, each having (possibly) a different,      * configuration.,      * ,      * @param executions,      */,     public void setExecutions( java.util.List<PluginExecution> executions ),     {,         this.executions = executions;,     } //-- void setExecutions( java.util.List ), ,     /**,      * Set whether to load Maven extensions (such as packaging and,      * type handlers) from,      *             this plugin. For performance reasons, this,      * should only be enabled when necessary. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @param extensions,      */,     public void setExtensions( String extensions ),     {,         this.extensions = extensions;,     } //-- void setExtensions( String ), ,     /**,      * Set <b>Deprecated</b>. Unused by Maven.,      * ,      * @param goals,      */,     public void setGoals( Object goals ),     {,         this.goals = goals;,     } //-- void setGoals( Object ), ,     /**,      * Set the group ID of the plugin in the repository.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * Set the version (or valid range of versions) of the plugin,      * to be used.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     ,             ,     public boolean isExtensions(),     {,         return ( extensions != null ) ? Boolean.parseBoolean( extensions ) : false;,     }, ,     public void setExtensions( boolean extensions ),     {,         this.extensions = String.valueOf( extensions );,     }, ,     private java.util.Map<String, PluginExecution> executionMap = null;, ,     /**,      * Reset the <code>executionMap</code> field to <code>null</code>,      */,     public void flushExecutionMap(),     {,         this.executionMap = null;,     }, ,     /**,      * @return a Map of executions field with <code>PluginExecution#getId()</code> as key,      * @see org.apache.maven.model.PluginExecution#getId(),      */,     public java.util.Map<String, PluginExecution> getExecutionsAsMap(),     {,         if ( executionMap == null ),         {,             executionMap = new java.util.LinkedHashMap<String, PluginExecution>();,             if ( getExecutions() != null ),             {,                 for ( java.util.Iterator<PluginExecution> i = getExecutions().iterator(); i.hasNext(); ),                 {,                     PluginExecution exec = (PluginExecution) i.next();, ,                     if ( executionMap.containsKey( exec.getId() ) ),                     {,                         throw new IllegalStateException( "You cannot have two plugin executions with the same (or missing) <id/> elements.\nOffending execution\n\nId: \'" + exec.getId() + "\'\nPlugin:\'" + getKey() + "\'\n\n" );,                     }, ,                     executionMap.put( exec.getId(), exec );,                 },             },         }, ,         return executionMap;,     }, ,     /**,      * Gets the identifier of the plugin.,      *,      * @return The plugin id in the form {@code <groupId>:<artifactId>:<version>}, never {@code null}.,      */,     public String getId(),     {,         StringBuilder id = new StringBuilder( 128 );, ,         id.append( ( getGroupId() == null ) ? "[unknown-group-id]" : getGroupId() );,         id.append( ":" );,         id.append( ( getArtifactId() == null ) ? "[unknown-artifact-id]" : getArtifactId() );,         id.append( ":" );,         id.append( ( getVersion() == null ) ? "[unknown-version]" : getVersion() );, ,         return id.toString();,     }, ,     //TODO we shall reset key variable when groupId/artifactId change,     private String key = null;,     /**,      * @return the key of the plugin, ie <code>groupId:artifactId</code>,      */,     public String getKey(),     {,         if ( key == null ),         {,             key = constructKey( groupId, artifactId );,         },         return key;,     }, ,     /**,      * @param groupId,      * @param artifactId,      * @return the key of the plugin, ie <code>groupId:artifactId</code>,      */,     public static String constructKey( String groupId, String artifactId ),     {,         return groupId + ":" + artifactId;,     }, ,     /**,      * @see java.lang.Object#equals(java.lang.Object),      */,     public boolean equals( Object other ),     {,         if ( other instanceof Plugin ),         {,             Plugin otherPlugin = (Plugin) other;, ,             return getKey().equals( otherPlugin.getKey() );,         }, ,         return false;,     }, ,     /**,      * @see java.lang.Object#hashCode(),      */,     public int hashCode(),     {,         return getKey().hashCode();,     }, ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         return "Plugin [" + getKey() + "]";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Plugin.java,,18-458,[@SuppressWarnings( "all" ), public class Plugin,     extends ConfigurationContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The group ID of the plugin in the repository.,      */,     private String groupId = "org.apache.maven.plugins";, ,     /**,      * The artifact ID of the plugin in the repository.,      */,     private String artifactId;, ,     /**,      * The version (or valid range of versions) of the plugin to be,      * used.,      */,     private String version;, ,     /**,      * ,      *             ,      *             Whether to load Maven extensions (such as,      * packaging and type handlers) from,      *             this plugin. For performance reasons, this,      * should only be enabled when necessary. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      *             ,      *           ,      */,     private String extensions;, ,     /**,      * Field executions.,      */,     private java.util.List<PluginExecution> executions;, ,     /**,      * Field dependencies.,      */,     private java.util.List<Dependency> dependencies;, ,     /**,      * ,      *             ,      *             <b>Deprecated</b>. Unused by Maven.,      *             ,      *           ,      */,     private Object goals;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addDependency.,      * ,      * @param dependency,      */,     public void addDependency( Dependency dependency ),     {,         getDependencies().add( dependency );,     } //-- void addDependency( Dependency ), ,     /**,      * Method addExecution.,      * ,      * @param pluginExecution,      */,     public void addExecution( PluginExecution pluginExecution ),     {,         getExecutions().add( pluginExecution );,     } //-- void addExecution( PluginExecution ), ,     /**,      * Method clone.,      * ,      * @return Plugin,      */,     public Plugin clone(),     {,         try,         {,             Plugin copy = (Plugin) super.clone();, ,             if ( this.executions != null ),             {,                 copy.executions = new java.util.ArrayList<PluginExecution>();,                 for ( PluginExecution item : this.executions ),                 {,                     copy.executions.add( ( (PluginExecution) item).clone() );,                 },             }, ,             if ( this.dependencies != null ),             {,                 copy.dependencies = new java.util.ArrayList<Dependency>();,                 for ( Dependency item : this.dependencies ),                 {,                     copy.dependencies.add( ( (Dependency) item).clone() );,                 },             }, ,             if ( this.goals != null ),             {,                 copy.goals = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.goals );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Plugin clone(), ,     /**,      * Get the artifact ID of the plugin in the repository.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Method getDependencies.,      * ,      * @return List,      */,     public java.util.List<Dependency> getDependencies(),     {,         if ( this.dependencies == null ),         {,             this.dependencies = new java.util.ArrayList<Dependency>();,         }, ,         return this.dependencies;,     } //-- java.util.List<Dependency> getDependencies(), ,     /**,      * Method getExecutions.,      * ,      * @return List,      */,     public java.util.List<PluginExecution> getExecutions(),     {,         if ( this.executions == null ),         {,             this.executions = new java.util.ArrayList<PluginExecution>();,         }, ,         return this.executions;,     } //-- java.util.List<PluginExecution> getExecutions(), ,     /**,      * Get whether to load Maven extensions (such as packaging and,      * type handlers) from,      *             this plugin. For performance reasons, this,      * should only be enabled when necessary. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @return String,      */,     public String getExtensions(),     {,         return this.extensions;,     } //-- String getExtensions(), ,     /**,      * Get <b>Deprecated</b>. Unused by Maven.,      * ,      * @return Object,      */,     public Object getGoals(),     {,         return this.goals;,     } //-- Object getGoals(), ,     /**,      * Get the group ID of the plugin in the repository.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * Get the version (or valid range of versions) of the plugin,      * to be used.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Method removeDependency.,      * ,      * @param dependency,      */,     public void removeDependency( Dependency dependency ),     {,         getDependencies().remove( dependency );,     } //-- void removeDependency( Dependency ), ,     /**,      * Method removeExecution.,      * ,      * @param pluginExecution,      */,     public void removeExecution( PluginExecution pluginExecution ),     {,         getExecutions().remove( pluginExecution );,     } //-- void removeExecution( PluginExecution ), ,     /**,      * Set the artifact ID of the plugin in the repository.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set additional dependencies that this project needs to,      * introduce to the plugin's,      *             classloader.,      * ,      * @param dependencies,      */,     public void setDependencies( java.util.List<Dependency> dependencies ),     {,         this.dependencies = dependencies;,     } //-- void setDependencies( java.util.List ), ,     /**,      * Set multiple specifications of a set of goals to execute,      * during the build,      *             lifecycle, each having (possibly) a different,      * configuration.,      * ,      * @param executions,      */,     public void setExecutions( java.util.List<PluginExecution> executions ),     {,         this.executions = executions;,     } //-- void setExecutions( java.util.List ), ,     /**,      * Set whether to load Maven extensions (such as packaging and,      * type handlers) from,      *             this plugin. For performance reasons, this,      * should only be enabled when necessary. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @param extensions,      */,     public void setExtensions( String extensions ),     {,         this.extensions = extensions;,     } //-- void setExtensions( String ), ,     /**,      * Set <b>Deprecated</b>. Unused by Maven.,      * ,      * @param goals,      */,     public void setGoals( Object goals ),     {,         this.goals = goals;,     } //-- void setGoals( Object ), ,     /**,      * Set the group ID of the plugin in the repository.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * Set the version (or valid range of versions) of the plugin,      * to be used.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     ,             ,     public boolean isExtensions(),     {,         return ( extensions != null ) ? Boolean.parseBoolean( extensions ) : false;,     }, ,     public void setExtensions( boolean extensions ),     {,         this.extensions = String.valueOf( extensions );,     }, ,     private java.util.Map<String, PluginExecution> executionMap = null;, ,     /**,      * Reset the <code>executionMap</code> field to <code>null</code>,      */,     public void flushExecutionMap(),     {,         this.executionMap = null;,     }, ,     /**,      * @return a Map of executions field with <code>PluginExecution#getId()</code> as key,      * @see org.apache.maven.model.PluginExecution#getId(),      */,     public java.util.Map<String, PluginExecution> getExecutionsAsMap(),     {,         if ( executionMap == null ),         {,             executionMap = new java.util.LinkedHashMap<String, PluginExecution>();,             if ( getExecutions() != null ),             {,                 for ( java.util.Iterator<PluginExecution> i = getExecutions().iterator(); i.hasNext(); ),                 {,                     PluginExecution exec = (PluginExecution) i.next();, ,                     if ( executionMap.containsKey( exec.getId() ) ),                     {,                         throw new IllegalStateException( "You cannot have two plugin executions with the same (or missing) <id/> elements.\nOffending execution\n\nId: \'" + exec.getId() + "\'\nPlugin:\'" + getKey() + "\'\n\n" );,                     }, ,                     executionMap.put( exec.getId(), exec );,                 },             },         }, ,         return executionMap;,     }, ,     /**,      * Gets the identifier of the plugin.,      *,      * @return The plugin id in the form {@code <groupId>:<artifactId>:<version>}, never {@code null}.,      */,     public String getId(),     {,         StringBuilder id = new StringBuilder( 128 );, ,         id.append( ( getGroupId() == null ) ? "[unknown-group-id]" : getGroupId() );,         id.append( ":" );,         id.append( ( getArtifactId() == null ) ? "[unknown-artifact-id]" : getArtifactId() );,         id.append( ":" );,         id.append( ( getVersion() == null ) ? "[unknown-version]" : getVersion() );, ,         return id.toString();,     }, ,     //TODO we shall reset key variable when groupId/artifactId change,     private String key = null;,     /**,      * @return the key of the plugin, ie <code>groupId:artifactId</code>,      */,     public String getKey(),     {,         if ( key == null ),         {,             key = constructKey( groupId, artifactId );,         },         return key;,     }, ,     /**,      * @param groupId,      * @param artifactId,      * @return the key of the plugin, ie <code>groupId:artifactId</code>,      */,     public static String constructKey( String groupId, String artifactId ),     {,         return groupId + ":" + artifactId;,     }, ,     /**,      * @see java.lang.Object#equals(java.lang.Object),      */,     public boolean equals( Object other ),     {,         if ( other instanceof Plugin ),         {,             Plugin otherPlugin = (Plugin) other;, ,             return getKey().equals( otherPlugin.getKey() );,         }, ,         return false;,     }, ,     /**,      * @see java.lang.Object#hashCode(),      */,     public int hashCode(),     {,         return getKey().hashCode();,     }, ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         return "Plugin [" + getKey() + "]";],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/PluginConfiguration.java,,13-94,[@SuppressWarnings( "all" ), public class PluginConfiguration,     extends PluginContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Default plugin information to be made available for,      * reference by projects,      *             derived from this one. This plugin configuration,      * will not be resolved or bound to the,      *             lifecycle unless referenced. Any local,      * configuration for a given plugin will override,      *             the plugin's entire definition here.,      */,     private PluginManagement pluginManagement;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return PluginConfiguration,      */,     public PluginConfiguration clone(),     {,         try,         {,             PluginConfiguration copy = (PluginConfiguration) super.clone();, ,             if ( this.pluginManagement != null ),             {,                 copy.pluginManagement = (PluginManagement) this.pluginManagement.clone();,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- PluginConfiguration clone(), ,     /**,      * Get default plugin information to be made available for,      * reference by projects,      *             derived from this one. This plugin configuration,      * will not be resolved or bound to the,      *             lifecycle unless referenced. Any local,      * configuration for a given plugin will override,      *             the plugin's entire definition here.,      * ,      * @return PluginManagement,      */,     public PluginManagement getPluginManagement(),     {,         return this.pluginManagement;,     } //-- PluginManagement getPluginManagement(), ,     /**,      * Set default plugin information to be made available for,      * reference by projects,      *             derived from this one. This plugin configuration,      * will not be resolved or bound to the,      *             lifecycle unless referenced. Any local,      * configuration for a given plugin will override,      *             the plugin's entire definition here.,      * ,      * @param pluginManagement,      */,     public void setPluginManagement( PluginManagement pluginManagement ),     {,         this.pluginManagement = pluginManagement;,     } //-- void setPluginManagement( PluginManagement )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/PluginConfiguration.java,,13-94,[@SuppressWarnings( "all" ), public class PluginConfiguration,     extends PluginContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Default plugin information to be made available for,      * reference by projects,      *             derived from this one. This plugin configuration,      * will not be resolved or bound to the,      *             lifecycle unless referenced. Any local,      * configuration for a given plugin will override,      *             the plugin's entire definition here.,      */,     private PluginManagement pluginManagement;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return PluginConfiguration,      */,     public PluginConfiguration clone(),     {,         try,         {,             PluginConfiguration copy = (PluginConfiguration) super.clone();, ,             if ( this.pluginManagement != null ),             {,                 copy.pluginManagement = (PluginManagement) this.pluginManagement.clone();,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- PluginConfiguration clone(), ,     /**,      * Get default plugin information to be made available for,      * reference by projects,      *             derived from this one. This plugin configuration,      * will not be resolved or bound to the,      *             lifecycle unless referenced. Any local,      * configuration for a given plugin will override,      *             the plugin's entire definition here.,      * ,      * @return PluginManagement,      */,     public PluginManagement getPluginManagement(),     {,         return this.pluginManagement;,     } //-- PluginManagement getPluginManagement(), ,     /**,      * Set default plugin information to be made available for,      * reference by projects,      *             derived from this one. This plugin configuration,      * will not be resolved or bound to the,      *             lifecycle unless referenced. Any local,      * configuration for a given plugin will override,      *             the plugin's entire definition here.,      * ,      * @param pluginManagement,      */,     public void setPluginManagement( PluginManagement pluginManagement ),     {,         this.pluginManagement = pluginManagement;,     } //-- void setPluginManagement( PluginManagement )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/PluginConfigurationTest.java,testEqualsNullSafe,42-42,[        new PluginConfiguration().equals( new PluginConfiguration() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/PluginContainer.java,,13-176,[@SuppressWarnings( "all" ), public class PluginContainer,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field plugins.,      */,     private java.util.List<Plugin> plugins;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addPlugin.,      * ,      * @param plugin,      */,     public void addPlugin( Plugin plugin ),     {,         getPlugins().add( plugin );,     } //-- void addPlugin( Plugin ), ,     /**,      * Method clone.,      * ,      * @return PluginContainer,      */,     public PluginContainer clone(),     {,         try,         {,             PluginContainer copy = (PluginContainer) super.clone();, ,             if ( this.plugins != null ),             {,                 copy.plugins = new java.util.ArrayList<Plugin>();,                 for ( Plugin item : this.plugins ),                 {,                     copy.plugins.add( ( (Plugin) item).clone() );,                 },             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- PluginContainer clone(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Method getPlugins.,      * ,      * @return List,      */,     public java.util.List<Plugin> getPlugins(),     {,         if ( this.plugins == null ),         {,             this.plugins = new java.util.ArrayList<Plugin>();,         }, ,         return this.plugins;,     } //-- java.util.List<Plugin> getPlugins(), ,     /**,      * Method removePlugin.,      * ,      * @param plugin,      */,     public void removePlugin( Plugin plugin ),     {,         getPlugins().remove( plugin );,     } //-- void removePlugin( Plugin ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the list of plugins to use.,      * ,      * @param plugins,      */,     public void setPlugins( java.util.List<Plugin> plugins ),     {,         this.plugins = plugins;,     } //-- void setPlugins( java.util.List ), ,     ,             ,     java.util.Map<String, Plugin> pluginMap;, ,     /**,      * Reset the <code>pluginsMap</code> field to <code>null</code>,      */,     public synchronized void flushPluginMap(),     {,         this.pluginMap = null;,     }, ,     /**,      * @return a Map of plugins field with <code>Plugins#getKey()</code> as key,      * @see org.apache.maven.model.Plugin#getKey(),      */,     public synchronized java.util.Map<String, Plugin> getPluginsAsMap(),     {,         if ( pluginMap == null ),         {,             pluginMap = new java.util.LinkedHashMap<String, Plugin>();,             if ( plugins != null ),             {,                 for ( java.util.Iterator<Plugin> it = plugins.iterator(); it.hasNext(); ),                 {,                     Plugin plugin = (Plugin) it.next();,                     pluginMap.put( plugin.getKey(), plugin );,                 },             },         }, ,         return pluginMap;],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/PluginContainerTest.java,testEqualsNullSafe,42-42,[        new PluginContainer().equals( new PluginContainer() );],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/PluginExecution.java,,19-232,[@SuppressWarnings( "all" ), public class PluginExecution,     extends ConfigurationContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The identifier of this execution for labelling the goals,      * during the build,,      *             and for matching executions to merge during,      * inheritance and profile injection.,      */,     private String id = "default";, ,     /**,      * The build lifecycle phase to bind the goals in this,      * execution to. If omitted,,      *             the goals will be bound to the default phase,      * specified in their metadata. ,      */,     private String phase;, ,     /**,      * ,      *             ,      *             The priority of this execution compared to other,      * executions which are bound to the same phase.,      *             <strong>Warning:</strong> This is an internal,      * utility property that is only public for technical reasons,,      *             it is not part of the public API. In particular,,      * this property can be changed or deleted without prior,      *             notice.,      *             ,      *           ,      */,     private int priority = 0;, ,     /**,      * Field goals.,      */,     private java.util.List<String> goals;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addGoal.,      * ,      * @param string,      */,     public void addGoal( String string ),     {,         getGoals().add( string );,     } //-- void addGoal( String ), ,     /**,      * Method clone.,      * ,      * @return PluginExecution,      */,     public PluginExecution clone(),     {,         try,         {,             PluginExecution copy = (PluginExecution) super.clone();, ,             if ( this.goals != null ),             {,                 copy.goals = new java.util.ArrayList<String>();,                 copy.goals.addAll( this.goals );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- PluginExecution clone(), ,     /**,      * Method getGoals.,      * ,      * @return List,      */,     public java.util.List<String> getGoals(),     {,         if ( this.goals == null ),         {,             this.goals = new java.util.ArrayList<String>();,         }, ,         return this.goals;,     } //-- java.util.List<String> getGoals(), ,     /**,      * Get the identifier of this execution for labelling the goals,      * during the build,,      *             and for matching executions to merge during,      * inheritance and profile injection.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Get the build lifecycle phase to bind the goals in this,      * execution to. If omitted,,      *             the goals will be bound to the default phase,      * specified in their metadata.,      * ,      * @return String,      */,     public String getPhase(),     {,         return this.phase;,     } //-- String getPhase(), ,     /**,      * Get the priority of this execution compared to other,      * executions which are bound to the same phase.,      *             <strong>Warning:</strong> This is an internal,      * utility property that is only public for technical reasons,,      *             it is not part of the public API. In particular,,      * this property can be changed or deleted without prior,      *             notice.,      * ,      * @return int,      */,     public int getPriority(),     {,         return this.priority;,     } //-- int getPriority(), ,     /**,      * Method removeGoal.,      * ,      * @param string,      */,     public void removeGoal( String string ),     {,         getGoals().remove( string );,     } //-- void removeGoal( String ), ,     /**,      * Set the goals to execute with the given configuration.,      * ,      * @param goals,      */,     public void setGoals( java.util.List<String> goals ),     {,         this.goals = goals;,     } //-- void setGoals( java.util.List ), ,     /**,      * Set the identifier of this execution for labelling the goals,      * during the build,,      *             and for matching executions to merge during,      * inheritance and profile injection.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * Set the build lifecycle phase to bind the goals in this,      * execution to. If omitted,,      *             the goals will be bound to the default phase,      * specified in their metadata.,      * ,      * @param phase,      */,     public void setPhase( String phase ),     {,         this.phase = phase;,     } //-- void setPhase( String ), ,     /**,      * Set the priority of this execution compared to other,      * executions which are bound to the same phase.,      *             <strong>Warning:</strong> This is an internal,      * utility property that is only public for technical reasons,,      *             it is not part of the public API. In particular,,      * this property can be changed or deleted without prior,      *             notice.,      * ,      * @param priority,      */,     public void setPriority( int priority ),     {,         this.priority = priority;,     } //-- void setPriority( int ), ,     ,             ,     public static final String DEFAULT_EXECUTION_ID = "default";, ,     @Override,     public String toString(),     {,         return getId();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/PluginExecution.java,,19-232,[@SuppressWarnings( "all" ), public class PluginExecution,     extends ConfigurationContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The identifier of this execution for labelling the goals,      * during the build,,      *             and for matching executions to merge during,      * inheritance and profile injection.,      */,     private String id = "default";, ,     /**,      * The build lifecycle phase to bind the goals in this,      * execution to. If omitted,,      *             the goals will be bound to the default phase,      * specified in their metadata. ,      */,     private String phase;, ,     /**,      * ,      *             ,      *             The priority of this execution compared to other,      * executions which are bound to the same phase.,      *             <strong>Warning:</strong> This is an internal,      * utility property that is only public for technical reasons,,      *             it is not part of the public API. In particular,,      * this property can be changed or deleted without prior,      *             notice.,      *             ,      *           ,      */,     private int priority = 0;, ,     /**,      * Field goals.,      */,     private java.util.List<String> goals;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addGoal.,      * ,      * @param string,      */,     public void addGoal( String string ),     {,         getGoals().add( string );,     } //-- void addGoal( String ), ,     /**,      * Method clone.,      * ,      * @return PluginExecution,      */,     public PluginExecution clone(),     {,         try,         {,             PluginExecution copy = (PluginExecution) super.clone();, ,             if ( this.goals != null ),             {,                 copy.goals = new java.util.ArrayList<String>();,                 copy.goals.addAll( this.goals );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- PluginExecution clone(), ,     /**,      * Method getGoals.,      * ,      * @return List,      */,     public java.util.List<String> getGoals(),     {,         if ( this.goals == null ),         {,             this.goals = new java.util.ArrayList<String>();,         }, ,         return this.goals;,     } //-- java.util.List<String> getGoals(), ,     /**,      * Get the identifier of this execution for labelling the goals,      * during the build,,      *             and for matching executions to merge during,      * inheritance and profile injection.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Get the build lifecycle phase to bind the goals in this,      * execution to. If omitted,,      *             the goals will be bound to the default phase,      * specified in their metadata.,      * ,      * @return String,      */,     public String getPhase(),     {,         return this.phase;,     } //-- String getPhase(), ,     /**,      * Get the priority of this execution compared to other,      * executions which are bound to the same phase.,      *             <strong>Warning:</strong> This is an internal,      * utility property that is only public for technical reasons,,      *             it is not part of the public API. In particular,,      * this property can be changed or deleted without prior,      *             notice.,      * ,      * @return int,      */,     public int getPriority(),     {,         return this.priority;,     } //-- int getPriority(), ,     /**,      * Method removeGoal.,      * ,      * @param string,      */,     public void removeGoal( String string ),     {,         getGoals().remove( string );,     } //-- void removeGoal( String ), ,     /**,      * Set the goals to execute with the given configuration.,      * ,      * @param goals,      */,     public void setGoals( java.util.List<String> goals ),     {,         this.goals = goals;,     } //-- void setGoals( java.util.List ), ,     /**,      * Set the identifier of this execution for labelling the goals,      * during the build,,      *             and for matching executions to merge during,      * inheritance and profile injection.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * Set the build lifecycle phase to bind the goals in this,      * execution to. If omitted,,      *             the goals will be bound to the default phase,      * specified in their metadata.,      * ,      * @param phase,      */,     public void setPhase( String phase ),     {,         this.phase = phase;,     } //-- void setPhase( String ), ,     /**,      * Set the priority of this execution compared to other,      * executions which are bound to the same phase.,      *             <strong>Warning:</strong> This is an internal,      * utility property that is only public for technical reasons,,      *             it is not part of the public API. In particular,,      * this property can be changed or deleted without prior,      *             notice.,      * ,      * @param priority,      */,     public void setPriority( int priority ),     {,         this.priority = priority;,     } //-- void setPriority( int ), ,     ,             ,     public static final String DEFAULT_EXECUTION_ID = "default";, ,     @Override,     public String toString(),     {,         return getId();],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/PluginExecutionTest.java,testEqualsNullSafe,42-42,[        new PluginExecution().equals( new PluginExecution() );],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/PluginManagement.java,,15-41,[@SuppressWarnings( "all" ), public class PluginManagement,     extends PluginContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return PluginManagement,      */,     public PluginManagement clone(),     {,         try,         {,             PluginManagement copy = (PluginManagement) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/PluginManagement.java,,15-41,[@SuppressWarnings( "all" ), public class PluginManagement,     extends PluginContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return PluginManagement,      */,     public PluginManagement clone(),     {,         try,         {,             PluginManagement copy = (PluginManagement) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/PluginManagementTest.java,testEqualsNullSafe,42-42,[        new PluginManagement().equals( new PluginManagement() );],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/PluginTest.java,testEqualsNullSafe,42-42,[        new Plugin().equals( new Plugin() );],,
STYLE,UC_USELESS_OBJECT_STACK,org/apache/maven/model/PluginTest.java,testHashCodeNullSafe,35-35,[        new Plugin().hashCode();],,
STYLE,UC_USELESS_VOID_METHOD,org/apache/maven/model/PluginTest.java,testHashCodeNullSafe,36-36,[    }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Prerequisites.java,,13-115,[@SuppressWarnings( "all" ), public class Prerequisites,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The minimum version of Maven required to build the project,,      * or to use this,      *             plugin.,      */,     private String maven = "2.0";, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Prerequisites,      */,     public Prerequisites clone(),     {,         try,         {,             Prerequisites copy = (Prerequisites) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Prerequisites clone(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the minimum version of Maven required to build the,      * project, or to use this,      *             plugin.,      * ,      * @return String,      */,     public String getMaven(),     {,         return this.maven;,     } //-- String getMaven(), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the minimum version of Maven required to build the,      * project, or to use this,      *             plugin.,      * ,      * @param maven,      */,     public void setMaven( String maven ),     {,         this.maven = maven;,     } //-- void setMaven( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/PrerequisitesTest.java,testEqualsNullSafe,42-42,[        new Prerequisites().equals( new Prerequisites() );],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/Profile.java,,15-176,[@SuppressWarnings( "all" ), public class Profile,     extends ModelBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The identifier of this build profile. This is used for,      * command line,      *             activation, and identifies profiles to be,      * merged.,      *           ,      */,     private String id = "default";, ,     /**,      * The conditional logic which will automatically trigger the,      * inclusion of this,      *             profile.,      */,     private Activation activation;, ,     /**,      * Information required to build the project.,      */,     private BuildBase build;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Profile,      */,     public Profile clone(),     {,         try,         {,             Profile copy = (Profile) super.clone();, ,             if ( this.activation != null ),             {,                 copy.activation = (Activation) this.activation.clone();,             }, ,             if ( this.build != null ),             {,                 copy.build = (BuildBase) this.build.clone();,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Profile clone(), ,     /**,      * Get the conditional logic which will automatically trigger,      * the inclusion of this,      *             profile.,      * ,      * @return Activation,      */,     public Activation getActivation(),     {,         return this.activation;,     } //-- Activation getActivation(), ,     /**,      * Get information required to build the project.,      * ,      * @return BuildBase,      */,     public BuildBase getBuild(),     {,         return this.build;,     } //-- BuildBase getBuild(), ,     /**,      * Get the identifier of this build profile. This is used for,      * command line,      *             activation, and identifies profiles to be,      * merged.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Set the conditional logic which will automatically trigger,      * the inclusion of this,      *             profile.,      * ,      * @param activation,      */,     public void setActivation( Activation activation ),     {,         this.activation = activation;,     } //-- void setActivation( Activation ), ,     /**,      * Set information required to build the project.,      * ,      * @param build,      */,     public void setBuild( BuildBase build ),     {,         this.build = build;,     } //-- void setBuild( BuildBase ), ,     /**,      * Set the identifier of this build profile. This is used for,      * command line,      *             activation, and identifies profiles to be,      * merged.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     ,             ,     public static final String SOURCE_POM = "pom";, ,     public static final String SOURCE_SETTINGS = "settings.xml";, ,     // We don't want this to be parseable...it's sort of 'hidden',     // default source for this profile is in the pom itself.,     private String source = SOURCE_POM;, ,     public void setSource( String source ),     {,         this.source = source;,     }, ,     public String getSource(),     {,         return source;,     }, ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         return "Profile {id: " + getId() + ", source: " + getSource() + "}";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Profile.java,,15-176,[@SuppressWarnings( "all" ), public class Profile,     extends ModelBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The identifier of this build profile. This is used for,      * command line,      *             activation, and identifies profiles to be,      * merged.,      *           ,      */,     private String id = "default";, ,     /**,      * The conditional logic which will automatically trigger the,      * inclusion of this,      *             profile.,      */,     private Activation activation;, ,     /**,      * Information required to build the project.,      */,     private BuildBase build;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Profile,      */,     public Profile clone(),     {,         try,         {,             Profile copy = (Profile) super.clone();, ,             if ( this.activation != null ),             {,                 copy.activation = (Activation) this.activation.clone();,             }, ,             if ( this.build != null ),             {,                 copy.build = (BuildBase) this.build.clone();,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Profile clone(), ,     /**,      * Get the conditional logic which will automatically trigger,      * the inclusion of this,      *             profile.,      * ,      * @return Activation,      */,     public Activation getActivation(),     {,         return this.activation;,     } //-- Activation getActivation(), ,     /**,      * Get information required to build the project.,      * ,      * @return BuildBase,      */,     public BuildBase getBuild(),     {,         return this.build;,     } //-- BuildBase getBuild(), ,     /**,      * Get the identifier of this build profile. This is used for,      * command line,      *             activation, and identifies profiles to be,      * merged.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Set the conditional logic which will automatically trigger,      * the inclusion of this,      *             profile.,      * ,      * @param activation,      */,     public void setActivation( Activation activation ),     {,         this.activation = activation;,     } //-- void setActivation( Activation ), ,     /**,      * Set information required to build the project.,      * ,      * @param build,      */,     public void setBuild( BuildBase build ),     {,         this.build = build;,     } //-- void setBuild( BuildBase ), ,     /**,      * Set the identifier of this build profile. This is used for,      * command line,      *             activation, and identifies profiles to be,      * merged.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     ,             ,     public static final String SOURCE_POM = "pom";, ,     public static final String SOURCE_SETTINGS = "settings.xml";, ,     // We don't want this to be parseable...it's sort of 'hidden',     // default source for this profile is in the pom itself.,     private String source = SOURCE_POM;, ,     public void setSource( String source ),     {,         this.source = source;,     }, ,     public String getSource(),     {,         return source;,     }, ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         return "Profile {id: " + getId() + ", source: " + getSource() + "}";],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ProfileTest.java,testEqualsNullSafe,42-42,[        new Profile().equals( new Profile() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Relocation.java,,15-189,[@SuppressWarnings( "all" ), public class Relocation,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The group ID the artifact has moved to.,      */,     private String groupId;, ,     /**,      * The new artifact ID of the artifact.,      */,     private String artifactId;, ,     /**,      * The new version of the artifact.,      */,     private String version;, ,     /**,      * An additional message to show the user about the move, such,      * as the reason.,      */,     private String message;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Relocation,      */,     public Relocation clone(),     {,         try,         {,             Relocation copy = (Relocation) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Relocation clone(), ,     /**,      * Get the new artifact ID of the artifact.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get the group ID the artifact has moved to.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get an additional message to show the user about the move,,      * such as the reason.,      * ,      * @return String,      */,     public String getMessage(),     {,         return this.message;,     } //-- String getMessage(), ,     /**,      * Get the new version of the artifact.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Set the new artifact ID of the artifact.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set the group ID the artifact has moved to.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set an additional message to show the user about the move,,      * such as the reason.,      * ,      * @param message,      */,     public void setMessage( String message ),     {,         this.message = message;,     } //-- void setMessage( String ), ,     /**,      * Set the new version of the artifact.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/RelocationTest.java,testEqualsNullSafe,42-42,[        new Relocation().equals( new Relocation() );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/ReportPlugin.java,getReportSets,213-213,[            if ( getReportSets() != null )],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/ReportPlugin.java,,18-241,[@SuppressWarnings( "all" ), public class ReportPlugin,     extends ConfigurationContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The group ID of the reporting plugin in the repository.,      */,     private String groupId = "org.apache.maven.plugins";, ,     /**,      * The artifact ID of the reporting plugin in the repository.,      */,     private String artifactId;, ,     /**,      * The version of the reporting plugin to be used.,      */,     private String version;, ,     /**,      * Field reportSets.,      */,     private java.util.List<ReportSet> reportSets;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addReportSet.,      * ,      * @param reportSet,      */,     public void addReportSet( ReportSet reportSet ),     {,         getReportSets().add( reportSet );,     } //-- void addReportSet( ReportSet ), ,     /**,      * Method clone.,      * ,      * @return ReportPlugin,      */,     public ReportPlugin clone(),     {,         try,         {,             ReportPlugin copy = (ReportPlugin) super.clone();, ,             if ( this.reportSets != null ),             {,                 copy.reportSets = new java.util.ArrayList<ReportSet>();,                 for ( ReportSet item : this.reportSets ),                 {,                     copy.reportSets.add( ( (ReportSet) item).clone() );,                 },             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ReportPlugin clone(), ,     /**,      * Get the artifact ID of the reporting plugin in the,      * repository.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get the group ID of the reporting plugin in the repository.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * Method getReportSets.,      * ,      * @return List,      */,     public java.util.List<ReportSet> getReportSets(),     {,         if ( this.reportSets == null ),         {,             this.reportSets = new java.util.ArrayList<ReportSet>();,         }, ,         return this.reportSets;,     } //-- java.util.List<ReportSet> getReportSets(), ,     /**,      * Get the version of the reporting plugin to be used.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Method removeReportSet.,      * ,      * @param reportSet,      */,     public void removeReportSet( ReportSet reportSet ),     {,         getReportSets().remove( reportSet );,     } //-- void removeReportSet( ReportSet ), ,     /**,      * Set the artifact ID of the reporting plugin in the,      * repository.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set the group ID of the reporting plugin in the repository.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * Set multiple specifications of a set of reports, each having,      * (possibly) different,      *             configuration. This is the reporting parallel to,      * an <code>execution</code> in the build.,      * ,      * @param reportSets,      */,     public void setReportSets( java.util.List<ReportSet> reportSets ),     {,         this.reportSets = reportSets;,     } //-- void setReportSets( java.util.List ), ,     /**,      * Set the version of the reporting plugin to be used.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     ,             ,     private java.util.Map<String, ReportSet> reportSetMap = null;, ,     /**,      * Reset the <code>reportSetMap</code> field to <code>null</code>,      */,     public void flushReportSetMap(),     {,         this.reportSetMap = null;,     }, ,     /**,      * @return a Map of reportSets field with <code>ReportSet#getId()</code> as key,      * @see org.apache.maven.model.ReportSet#getId(),      */,     public java.util.Map<String, ReportSet> getReportSetsAsMap(),     {,         if ( reportSetMap == null ),         {,             reportSetMap = new java.util.LinkedHashMap<String, ReportSet>();,             if ( getReportSets() != null ),             {,                 for ( java.util.Iterator<ReportSet> i = getReportSets().iterator(); i.hasNext(); ),                 {,                     ReportSet reportSet = (ReportSet) i.next();,                     reportSetMap.put( reportSet.getId(), reportSet );,                 },             },         }, ,         return reportSetMap;,     }, ,     /**,      * @return the key of the report plugin, ie <code>groupId:artifactId</code>,      */,     public String getKey(),     {,         return constructKey( groupId, artifactId );,     }, ,     /**,      * @param groupId,      * @param artifactId,      * @return the key of the report plugin, ie <code>groupId:artifactId</code>,      */,     public static String constructKey( String groupId, String artifactId ),     {,         return groupId + ":" + artifactId;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/ReportPlugin.java,,18-241,[@SuppressWarnings( "all" ), public class ReportPlugin,     extends ConfigurationContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The group ID of the reporting plugin in the repository.,      */,     private String groupId = "org.apache.maven.plugins";, ,     /**,      * The artifact ID of the reporting plugin in the repository.,      */,     private String artifactId;, ,     /**,      * The version of the reporting plugin to be used.,      */,     private String version;, ,     /**,      * Field reportSets.,      */,     private java.util.List<ReportSet> reportSets;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addReportSet.,      * ,      * @param reportSet,      */,     public void addReportSet( ReportSet reportSet ),     {,         getReportSets().add( reportSet );,     } //-- void addReportSet( ReportSet ), ,     /**,      * Method clone.,      * ,      * @return ReportPlugin,      */,     public ReportPlugin clone(),     {,         try,         {,             ReportPlugin copy = (ReportPlugin) super.clone();, ,             if ( this.reportSets != null ),             {,                 copy.reportSets = new java.util.ArrayList<ReportSet>();,                 for ( ReportSet item : this.reportSets ),                 {,                     copy.reportSets.add( ( (ReportSet) item).clone() );,                 },             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ReportPlugin clone(), ,     /**,      * Get the artifact ID of the reporting plugin in the,      * repository.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get the group ID of the reporting plugin in the repository.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * Method getReportSets.,      * ,      * @return List,      */,     public java.util.List<ReportSet> getReportSets(),     {,         if ( this.reportSets == null ),         {,             this.reportSets = new java.util.ArrayList<ReportSet>();,         }, ,         return this.reportSets;,     } //-- java.util.List<ReportSet> getReportSets(), ,     /**,      * Get the version of the reporting plugin to be used.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Method removeReportSet.,      * ,      * @param reportSet,      */,     public void removeReportSet( ReportSet reportSet ),     {,         getReportSets().remove( reportSet );,     } //-- void removeReportSet( ReportSet ), ,     /**,      * Set the artifact ID of the reporting plugin in the,      * repository.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set the group ID of the reporting plugin in the repository.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * Set multiple specifications of a set of reports, each having,      * (possibly) different,      *             configuration. This is the reporting parallel to,      * an <code>execution</code> in the build.,      * ,      * @param reportSets,      */,     public void setReportSets( java.util.List<ReportSet> reportSets ),     {,         this.reportSets = reportSets;,     } //-- void setReportSets( java.util.List ), ,     /**,      * Set the version of the reporting plugin to be used.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String ), ,     ,             ,     private java.util.Map<String, ReportSet> reportSetMap = null;, ,     /**,      * Reset the <code>reportSetMap</code> field to <code>null</code>,      */,     public void flushReportSetMap(),     {,         this.reportSetMap = null;,     }, ,     /**,      * @return a Map of reportSets field with <code>ReportSet#getId()</code> as key,      * @see org.apache.maven.model.ReportSet#getId(),      */,     public java.util.Map<String, ReportSet> getReportSetsAsMap(),     {,         if ( reportSetMap == null ),         {,             reportSetMap = new java.util.LinkedHashMap<String, ReportSet>();,             if ( getReportSets() != null ),             {,                 for ( java.util.Iterator<ReportSet> i = getReportSets().iterator(); i.hasNext(); ),                 {,                     ReportSet reportSet = (ReportSet) i.next();,                     reportSetMap.put( reportSet.getId(), reportSet );,                 },             },         }, ,         return reportSetMap;,     }, ,     /**,      * @return the key of the report plugin, ie <code>groupId:artifactId</code>,      */,     public String getKey(),     {,         return constructKey( groupId, artifactId );,     }, ,     /**,      * @param groupId,      * @param artifactId,      * @return the key of the report plugin, ie <code>groupId:artifactId</code>,      */,     public static String constructKey( String groupId, String artifactId ),     {,         return groupId + ":" + artifactId;],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ReportPluginTest.java,testEqualsNullSafe,42-42,[        new ReportPlugin().equals( new ReportPlugin() );],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/ReportSet.java,,14-143,[@SuppressWarnings( "all" ), public class ReportSet,     extends ConfigurationContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The unique id for this report set, to be used during POM,      * inheritance and profile injection,      *             for merging of report sets.,      *           ,      */,     private String id = "default";, ,     /**,      * Field reports.,      */,     private java.util.List<String> reports;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addReport.,      * ,      * @param string,      */,     public void addReport( String string ),     {,         getReports().add( string );,     } //-- void addReport( String ), ,     /**,      * Method clone.,      * ,      * @return ReportSet,      */,     public ReportSet clone(),     {,         try,         {,             ReportSet copy = (ReportSet) super.clone();, ,             if ( this.reports != null ),             {,                 copy.reports = new java.util.ArrayList<String>();,                 copy.reports.addAll( this.reports );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ReportSet clone(), ,     /**,      * Get the unique id for this report set, to be used during POM,      * inheritance and profile injection,      *             for merging of report sets.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Method getReports.,      * ,      * @return List,      */,     public java.util.List<String> getReports(),     {,         if ( this.reports == null ),         {,             this.reports = new java.util.ArrayList<String>();,         }, ,         return this.reports;,     } //-- java.util.List<String> getReports(), ,     /**,      * Method removeReport.,      * ,      * @param string,      */,     public void removeReport( String string ),     {,         getReports().remove( string );,     } //-- void removeReport( String ), ,     /**,      * Set the unique id for this report set, to be used during POM,      * inheritance and profile injection,      *             for merging of report sets.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * Set the list of reports from this plugin which should be,      * generated from this set.,      * ,      * @param reports,      */,     public void setReports( java.util.List<String> reports ),     {,         this.reports = reports;,     } //-- void setReports( java.util.List ), ,     ,             ,     @Override,     public String toString(),     {,         return getId();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/ReportSet.java,,14-143,[@SuppressWarnings( "all" ), public class ReportSet,     extends ConfigurationContainer,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The unique id for this report set, to be used during POM,      * inheritance and profile injection,      *             for merging of report sets.,      *           ,      */,     private String id = "default";, ,     /**,      * Field reports.,      */,     private java.util.List<String> reports;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addReport.,      * ,      * @param string,      */,     public void addReport( String string ),     {,         getReports().add( string );,     } //-- void addReport( String ), ,     /**,      * Method clone.,      * ,      * @return ReportSet,      */,     public ReportSet clone(),     {,         try,         {,             ReportSet copy = (ReportSet) super.clone();, ,             if ( this.reports != null ),             {,                 copy.reports = new java.util.ArrayList<String>();,                 copy.reports.addAll( this.reports );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ReportSet clone(), ,     /**,      * Get the unique id for this report set, to be used during POM,      * inheritance and profile injection,      *             for merging of report sets.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Method getReports.,      * ,      * @return List,      */,     public java.util.List<String> getReports(),     {,         if ( this.reports == null ),         {,             this.reports = new java.util.ArrayList<String>();,         }, ,         return this.reports;,     } //-- java.util.List<String> getReports(), ,     /**,      * Method removeReport.,      * ,      * @param string,      */,     public void removeReport( String string ),     {,         getReports().remove( string );,     } //-- void removeReport( String ), ,     /**,      * Set the unique id for this report set, to be used during POM,      * inheritance and profile injection,      *             for merging of report sets.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * Set the list of reports from this plugin which should be,      * generated from this set.,      * ,      * @param reports,      */,     public void setReports( java.util.List<String> reports ),     {,         this.reports = reports;,     } //-- void setReports( java.util.List ), ,     ,             ,     @Override,     public String toString(),     {,         return getId();],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ReportSetTest.java,testEqualsNullSafe,42-42,[        new ReportSet().equals( new ReportSet() );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/Reporting.java,getPlugins,264-264,[            if ( getPlugins() != null )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Reporting.java,,13-274,[@SuppressWarnings( "all" ), public class Reporting,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             If true, then the default reports are not,      * included in the site generation.,      *             This includes the reports in the "Project Info",      * menu. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      *             ,      *           ,      */,     private String excludeDefaults;, ,     /**,      * ,      *             ,      *             Where to store all of the generated reports. The,      * default is,      *             <code>${project.build.directory}/site</code>,      *             .,      *             ,      *           ,      */,     private String outputDirectory;, ,     /**,      * Field plugins.,      */,     private java.util.List<ReportPlugin> plugins;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addPlugin.,      * ,      * @param reportPlugin,      */,     public void addPlugin( ReportPlugin reportPlugin ),     {,         getPlugins().add( reportPlugin );,     } //-- void addPlugin( ReportPlugin ), ,     /**,      * Method clone.,      * ,      * @return Reporting,      */,     public Reporting clone(),     {,         try,         {,             Reporting copy = (Reporting) super.clone();, ,             if ( this.plugins != null ),             {,                 copy.plugins = new java.util.ArrayList<ReportPlugin>();,                 for ( ReportPlugin item : this.plugins ),                 {,                     copy.plugins.add( ( (ReportPlugin) item).clone() );,                 },             }, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Reporting clone(), ,     /**,      * Get if true, then the default reports are not included in,      * the site generation.,      *             This includes the reports in the "Project Info",      * menu. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @return String,      */,     public String getExcludeDefaults(),     {,         return this.excludeDefaults;,     } //-- String getExcludeDefaults(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get where to store all of the generated reports. The default,      * is,      *             <code>${project.build.directory}/site</code>,      *             .,      * ,      * @return String,      */,     public String getOutputDirectory(),     {,         return this.outputDirectory;,     } //-- String getOutputDirectory(), ,     /**,      * Method getPlugins.,      * ,      * @return List,      */,     public java.util.List<ReportPlugin> getPlugins(),     {,         if ( this.plugins == null ),         {,             this.plugins = new java.util.ArrayList<ReportPlugin>();,         }, ,         return this.plugins;,     } //-- java.util.List<ReportPlugin> getPlugins(), ,     /**,      * Method removePlugin.,      * ,      * @param reportPlugin,      */,     public void removePlugin( ReportPlugin reportPlugin ),     {,         getPlugins().remove( reportPlugin );,     } //-- void removePlugin( ReportPlugin ), ,     /**,      * Set if true, then the default reports are not included in,      * the site generation.,      *             This includes the reports in the "Project Info",      * menu. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @param excludeDefaults,      */,     public void setExcludeDefaults( String excludeDefaults ),     {,         this.excludeDefaults = excludeDefaults;,     } //-- void setExcludeDefaults( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set where to store all of the generated reports. The default,      * is,      *             <code>${project.build.directory}/site</code>,      *             .,      * ,      * @param outputDirectory,      */,     public void setOutputDirectory( String outputDirectory ),     {,         this.outputDirectory = outputDirectory;,     } //-- void setOutputDirectory( String ), ,     /**,      * Set the reporting plugins to use and their configuration.,      * ,      * @param plugins,      */,     public void setPlugins( java.util.List<ReportPlugin> plugins ),     {,         this.plugins = plugins;,     } //-- void setPlugins( java.util.List ), ,     ,             ,     public boolean isExcludeDefaults(),     {,         return ( excludeDefaults != null ) ? Boolean.parseBoolean( excludeDefaults ) : false;,     }, ,     public void setExcludeDefaults( boolean excludeDefaults ),     {,         this.excludeDefaults = String.valueOf( excludeDefaults );,     }, ,     java.util.Map<String, ReportPlugin> reportPluginMap;, ,     /**,      * Reset the <code>reportPluginMap</code> field to <code>null</code>,      */,     public synchronized void flushReportPluginMap(),     {,         this.reportPluginMap = null;,     }, ,     /**,      * @return a Map of plugins field with <code>ReportPlugin#getKey()</code> as key,      * @see org.apache.maven.model.ReportPlugin#getKey(),      */,     public synchronized java.util.Map<String, ReportPlugin> getReportPluginsAsMap(),     {,         if ( reportPluginMap == null ),         {,             reportPluginMap = new java.util.LinkedHashMap<String, ReportPlugin>();,             if ( getPlugins() != null ),             {,                 for ( java.util.Iterator<ReportPlugin> it = getPlugins().iterator(); it.hasNext(); ),                 {,                     ReportPlugin reportPlugin = (ReportPlugin) it.next();,                     reportPluginMap.put( reportPlugin.getKey(), reportPlugin );,                 },             },         }, ,         return reportPluginMap;],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ReportingTest.java,testEqualsNullSafe,42-42,[        new Reporting().equals( new Reporting() );],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/maven/model/RepositoryBase.java,equals,109-124,[        if ( this == other ),         {,             return true;,         }, ,         if ( !( other instanceof RepositoryBase ) ),         {,             return false;,         }, ,         RepositoryBase that = (RepositoryBase) other;,         boolean result = true;, ,         result = result && ( getId() == null ? that.getId() == null : getId().equals( that.getId() ) );, ,         return result;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/Repository.java,,15-112,[@SuppressWarnings( "all" ), public class Repository,     extends RepositoryBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * How to handle downloading of releases from this repository.,      */,     private RepositoryPolicy releases;, ,     /**,      * How to handle downloading of snapshots from this repository.,      */,     private RepositoryPolicy snapshots;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Repository,      */,     public Repository clone(),     {,         try,         {,             Repository copy = (Repository) super.clone();, ,             if ( this.releases != null ),             {,                 copy.releases = (RepositoryPolicy) this.releases.clone();,             }, ,             if ( this.snapshots != null ),             {,                 copy.snapshots = (RepositoryPolicy) this.snapshots.clone();,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Repository clone(), ,     /**,      * Get how to handle downloading of releases from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getReleases(),     {,         return this.releases;,     } //-- RepositoryPolicy getReleases(), ,     /**,      * Get how to handle downloading of snapshots from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getSnapshots(),     {,         return this.snapshots;,     } //-- RepositoryPolicy getSnapshots(), ,     /**,      * Set how to handle downloading of releases from this,      * repository.,      * ,      * @param releases,      */,     public void setReleases( RepositoryPolicy releases ),     {,         this.releases = releases;,     } //-- void setReleases( RepositoryPolicy ), ,     /**,      * Set how to handle downloading of snapshots from this,      * repository.,      * ,      * @param snapshots,      */,     public void setSnapshots( RepositoryPolicy snapshots ),     {,         this.snapshots = snapshots;,     } //-- void setSnapshots( RepositoryPolicy )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Repository.java,,15-112,[@SuppressWarnings( "all" ), public class Repository,     extends RepositoryBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * How to handle downloading of releases from this repository.,      */,     private RepositoryPolicy releases;, ,     /**,      * How to handle downloading of snapshots from this repository.,      */,     private RepositoryPolicy snapshots;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Repository,      */,     public Repository clone(),     {,         try,         {,             Repository copy = (Repository) super.clone();, ,             if ( this.releases != null ),             {,                 copy.releases = (RepositoryPolicy) this.releases.clone();,             }, ,             if ( this.snapshots != null ),             {,                 copy.snapshots = (RepositoryPolicy) this.snapshots.clone();,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Repository clone(), ,     /**,      * Get how to handle downloading of releases from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getReleases(),     {,         return this.releases;,     } //-- RepositoryPolicy getReleases(), ,     /**,      * Get how to handle downloading of snapshots from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getSnapshots(),     {,         return this.snapshots;,     } //-- RepositoryPolicy getSnapshots(), ,     /**,      * Set how to handle downloading of releases from this,      * repository.,      * ,      * @param releases,      */,     public void setReleases( RepositoryPolicy releases ),     {,         this.releases = releases;,     } //-- void setReleases( RepositoryPolicy ), ,     /**,      * Set how to handle downloading of snapshots from this,      * repository.,      * ,      * @param snapshots,      */,     public void setSnapshots( RepositoryPolicy snapshots ),     {,         this.snapshots = snapshots;,     } //-- void setSnapshots( RepositoryPolicy )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/RepositoryBase.java,,15-283,[@SuppressWarnings( "all" ), public class RepositoryBase,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             A unique identifier for a repository. This is,      * used to match the repository,      *             to configuration in the,      * <code>settings.xml</code> file, for example. Furthermore,,      * the identifier is,      *             used during POM inheritance and profile,      * injection to detect repositories that should be merged.,      *             ,      *           ,      */,     private String id;, ,     /**,      * Human readable name of the repository.,      */,     private String name;, ,     /**,      * ,      *             ,      *             The url of the repository, in the form,      * <code>protocol://hostname/path</code>.,      *             ,      *           ,      */,     private String url;, ,     /**,      * ,      *             ,      *             The type of layout this repository uses for,      * locating and storing artifacts -,      *             can be <code>legacy</code> or,      * <code>default</code>.,      *             ,      *           ,      */,     private String layout = "default";, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return RepositoryBase,      */,     public RepositoryBase clone(),     {,         try,         {,             RepositoryBase copy = (RepositoryBase) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- RepositoryBase clone(), ,     /**,      * Method equals.,      * ,      * @param other,      * @return boolean,      */,     public boolean equals( Object other ),     {,         if ( this == other ),         {,             return true;,         }, ,         if ( !( other instanceof RepositoryBase ) ),         {,             return false;,         }, ,         RepositoryBase that = (RepositoryBase) other;,         boolean result = true;, ,         result = result && ( getId() == null ? that.getId() == null : getId().equals( that.getId() ) );, ,         return result;,     } //-- boolean equals( Object ), ,     /**,      * Get a unique identifier for a repository. This is used to,      * match the repository,      *             to configuration in the,      * <code>settings.xml</code> file, for example. Furthermore,,      * the identifier is,      *             used during POM inheritance and profile,      * injection to detect repositories that should be merged.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Get the type of layout this repository uses for locating and,      * storing artifacts -,      *             can be <code>legacy</code> or,      * <code>default</code>.,      * ,      * @return String,      */,     public String getLayout(),     {,         return this.layout;,     } //-- String getLayout(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get human readable name of the repository.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the url of the repository, in the form,      * <code>protocol://hostname/path</code>.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Method hashCode.,      * ,      * @return int,      */,     public int hashCode(),     {,         int result = 17;, ,         result = 37 * result + ( id != null ? id.hashCode() : 0 );, ,         return result;,     } //-- int hashCode(), ,     /**,      * Set a unique identifier for a repository. This is used to,      * match the repository,      *             to configuration in the,      * <code>settings.xml</code> file, for example. Furthermore,,      * the identifier is,      *             used during POM inheritance and profile,      * injection to detect repositories that should be merged.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * Set the type of layout this repository uses for locating and,      * storing artifacts -,      *             can be <code>legacy</code> or,      * <code>default</code>.,      * ,      * @param layout,      */,     public void setLayout( String layout ),     {,         this.layout = layout;,     } //-- void setLayout( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set human readable name of the repository.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the url of the repository, in the form,      * <code>protocol://hostname/path</code>.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String ), ,     /**,      * Method toString.,      * ,      * @return String,      */,     public java.lang.String toString(),     {,         StringBuilder buf = new StringBuilder( 128 );, ,         buf.append( "id = '" );,         buf.append( getId() );,         buf.append( "'" );, ,         return buf.toString();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/RepositoryPolicy.java,,13-241,[@SuppressWarnings( "all" ), public class RepositoryPolicy,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             Whether to use this repository for downloading,      * this type of artifact. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>true</code>.,      *             ,      *           ,      */,     private String enabled;, ,     /**,      * ,      *             ,      *             The frequency for downloading updates - can be,      *             <code>always,</code>,      *             <code>daily</code>,      *             (default),,      *             <code>interval:XXX</code>,      *             (in minutes) or,      *             <code>never</code>,      *             (only if it doesn't exist locally).,      *             ,      *           ,      */,     private String updatePolicy;, ,     /**,      * ,      *             ,      *             What to do when verification of an artifact,      * checksum fails. Valid values are,      *             <code>ignore</code>,      *             ,,      *             <code>fail</code>,      *             or,      *             <code>warn</code>,      *             (the default).,      *             ,      *           ,      */,     private String checksumPolicy;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy clone(),     {,         try,         {,             RepositoryPolicy copy = (RepositoryPolicy) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- RepositoryPolicy clone(), ,     /**,      * Get what to do when verification of an artifact checksum,      * fails. Valid values are,      *             <code>ignore</code>,      *             ,,      *             <code>fail</code>,      *             or,      *             <code>warn</code>,      *             (the default).,      * ,      * @return String,      */,     public String getChecksumPolicy(),     {,         return this.checksumPolicy;,     } //-- String getChecksumPolicy(), ,     /**,      * Get whether to use this repository for downloading this type,      * of artifact. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>true</code>.,      * ,      * @return String,      */,     public String getEnabled(),     {,         return this.enabled;,     } //-- String getEnabled(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the frequency for downloading updates - can be,      *             <code>always,</code>,      *             <code>daily</code>,      *             (default),,      *             <code>interval:XXX</code>,      *             (in minutes) or,      *             <code>never</code>,      *             (only if it doesn't exist locally).,      * ,      * @return String,      */,     public String getUpdatePolicy(),     {,         return this.updatePolicy;,     } //-- String getUpdatePolicy(), ,     /**,      * Set what to do when verification of an artifact checksum,      * fails. Valid values are,      *             <code>ignore</code>,      *             ,,      *             <code>fail</code>,      *             or,      *             <code>warn</code>,      *             (the default).,      * ,      * @param checksumPolicy,      */,     public void setChecksumPolicy( String checksumPolicy ),     {,         this.checksumPolicy = checksumPolicy;,     } //-- void setChecksumPolicy( String ), ,     /**,      * Set whether to use this repository for downloading this type,      * of artifact. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>true</code>.,      * ,      * @param enabled,      */,     public void setEnabled( String enabled ),     {,         this.enabled = enabled;,     } //-- void setEnabled( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the frequency for downloading updates - can be,      *             <code>always,</code>,      *             <code>daily</code>,      *             (default),,      *             <code>interval:XXX</code>,      *             (in minutes) or,      *             <code>never</code>,      *             (only if it doesn't exist locally).,      * ,      * @param updatePolicy,      */,     public void setUpdatePolicy( String updatePolicy ),     {,         this.updatePolicy = updatePolicy;,     } //-- void setUpdatePolicy( String ), ,     ,             , ,     public boolean isEnabled(),     {,         return ( enabled != null ) ? Boolean.parseBoolean( enabled ) : true;,     }, ,     public void setEnabled( boolean enabled ),     {,         this.enabled = String.valueOf( enabled );,     }],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/RepositoryPolicyTest.java,testEqualsNullSafe,42-42,[        new RepositoryPolicy().equals( new RepositoryPolicy() );],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/RepositoryTest.java,testEqualsNullSafe,42-42,[        new Repository().equals( new Repository() );],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/maven/model/RepositoryTest.java,testHashCodeNullSafe,35-35,[        new Repository().hashCode();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/model/Resource.java,,15-251,[@SuppressWarnings( "all" ), public class Resource,     extends FileSet,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             Describe the resource target path. The path is,      * relative to the target/classes,      *             directory (i.e.,      * <code>${project.build.outputDirectory}</code>).,      *             For example, if you want that resource to appear,      * in a specific package,      *             (<code>org.apache.maven.messages</code>), you,      * must specify this,      *             element with this value:,      * <code>org/apache/maven/messages</code>.,      *             This is not required if you simply put the,      * resources in that directory,      *             structure at the source, however.,      *             ,      *           ,      */,     private String targetPath;, ,     /**,      * ,      *             ,      *             Whether resources are filtered to replace tokens,      * with parameterised values or not.,      *             The values are taken from the,      * <code>properties</code> element and from the,      *             properties in the files listed in the,      * <code>filters</code> element. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      *             ,      *           ,      */,     private String filtering;, ,     /**,      * ,      *             ,      *             FOR INTERNAL USE ONLY. This is a unique,      * identifier assigned to each,      *             resource to allow Maven to merge changes to this,      * resource that take,      *             place during the execution of a plugin. This,      * field must be managed,      *             by the generated parser and formatter classes in,      * order to allow it,      *             to survive model interpolation.,      *             ,      *           ,      */,     private String mergeId;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Resource,      */,     public Resource clone(),     {,         try,         {,             Resource copy = (Resource) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Resource clone(), ,     /**,      * Get whether resources are filtered to replace tokens with,      * parameterised values or not.,      *             The values are taken from the,      * <code>properties</code> element and from the,      *             properties in the files listed in the,      * <code>filters</code> element. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @return String,      */,     public String getFiltering(),     {,         return this.filtering;,     } //-- String getFiltering(), ,     /**,      * Get fOR INTERNAL USE ONLY. This is a unique identifier,      * assigned to each,      *             resource to allow Maven to merge changes to this,      * resource that take,      *             place during the execution of a plugin. This,      * field must be managed,      *             by the generated parser and formatter classes in,      * order to allow it,      *             to survive model interpolation.,      * ,      * @return String,      */,     public String getMergeId(),     {,         return this.mergeId;,     } //-- String getMergeId(), ,     /**,      * Get describe the resource target path. The path is relative,      * to the target/classes,      *             directory (i.e.,      * <code>${project.build.outputDirectory}</code>).,      *             For example, if you want that resource to appear,      * in a specific package,      *             (<code>org.apache.maven.messages</code>), you,      * must specify this,      *             element with this value:,      * <code>org/apache/maven/messages</code>.,      *             This is not required if you simply put the,      * resources in that directory,      *             structure at the source, however.,      * ,      * @return String,      */,     public String getTargetPath(),     {,         return this.targetPath;,     } //-- String getTargetPath(), ,     /**,      * Set whether resources are filtered to replace tokens with,      * parameterised values or not.,      *             The values are taken from the,      * <code>properties</code> element and from the,      *             properties in the files listed in the,      * <code>filters</code> element. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @param filtering,      */,     public void setFiltering( String filtering ),     {,         this.filtering = filtering;,     } //-- void setFiltering( String ), ,     /**,      * Set fOR INTERNAL USE ONLY. This is a unique identifier,      * assigned to each,      *             resource to allow Maven to merge changes to this,      * resource that take,      *             place during the execution of a plugin. This,      * field must be managed,      *             by the generated parser and formatter classes in,      * order to allow it,      *             to survive model interpolation.,      * ,      * @param mergeId,      */,     public void setMergeId( String mergeId ),     {,         this.mergeId = mergeId;,     } //-- void setMergeId( String ), ,     /**,      * Set describe the resource target path. The path is relative,      * to the target/classes,      *             directory (i.e.,      * <code>${project.build.outputDirectory}</code>).,      *             For example, if you want that resource to appear,      * in a specific package,      *             (<code>org.apache.maven.messages</code>), you,      * must specify this,      *             element with this value:,      * <code>org/apache/maven/messages</code>.,      *             This is not required if you simply put the,      * resources in that directory,      *             structure at the source, however.,      * ,      * @param targetPath,      */,     public void setTargetPath( String targetPath ),     {,         this.targetPath = targetPath;,     } //-- void setTargetPath( String ), ,     ,             ,     private static int mergeIdCounter = 0;, ,     public void initMergeId(),     {,         if ( getMergeId() == null ),         {,             setMergeId( "resource-" + (mergeIdCounter++) );,         },     }, ,     public boolean isFiltering(),     {,         return ( filtering != null ) ? Boolean.parseBoolean( filtering ) : false;,     }, ,     public void setFiltering( boolean filtering ),     {,         this.filtering = String.valueOf( filtering );,     }, ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         return "Resource {targetPath: " + getTargetPath() + ", filtering: " + isFiltering() + ", " + super.toString() + "}";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Resource.java,,15-251,[@SuppressWarnings( "all" ), public class Resource,     extends FileSet,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             Describe the resource target path. The path is,      * relative to the target/classes,      *             directory (i.e.,      * <code>${project.build.outputDirectory}</code>).,      *             For example, if you want that resource to appear,      * in a specific package,      *             (<code>org.apache.maven.messages</code>), you,      * must specify this,      *             element with this value:,      * <code>org/apache/maven/messages</code>.,      *             This is not required if you simply put the,      * resources in that directory,      *             structure at the source, however.,      *             ,      *           ,      */,     private String targetPath;, ,     /**,      * ,      *             ,      *             Whether resources are filtered to replace tokens,      * with parameterised values or not.,      *             The values are taken from the,      * <code>properties</code> element and from the,      *             properties in the files listed in the,      * <code>filters</code> element. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      *             ,      *           ,      */,     private String filtering;, ,     /**,      * ,      *             ,      *             FOR INTERNAL USE ONLY. This is a unique,      * identifier assigned to each,      *             resource to allow Maven to merge changes to this,      * resource that take,      *             place during the execution of a plugin. This,      * field must be managed,      *             by the generated parser and formatter classes in,      * order to allow it,      *             to survive model interpolation.,      *             ,      *           ,      */,     private String mergeId;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Resource,      */,     public Resource clone(),     {,         try,         {,             Resource copy = (Resource) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Resource clone(), ,     /**,      * Get whether resources are filtered to replace tokens with,      * parameterised values or not.,      *             The values are taken from the,      * <code>properties</code> element and from the,      *             properties in the files listed in the,      * <code>filters</code> element. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @return String,      */,     public String getFiltering(),     {,         return this.filtering;,     } //-- String getFiltering(), ,     /**,      * Get fOR INTERNAL USE ONLY. This is a unique identifier,      * assigned to each,      *             resource to allow Maven to merge changes to this,      * resource that take,      *             place during the execution of a plugin. This,      * field must be managed,      *             by the generated parser and formatter classes in,      * order to allow it,      *             to survive model interpolation.,      * ,      * @return String,      */,     public String getMergeId(),     {,         return this.mergeId;,     } //-- String getMergeId(), ,     /**,      * Get describe the resource target path. The path is relative,      * to the target/classes,      *             directory (i.e.,      * <code>${project.build.outputDirectory}</code>).,      *             For example, if you want that resource to appear,      * in a specific package,      *             (<code>org.apache.maven.messages</code>), you,      * must specify this,      *             element with this value:,      * <code>org/apache/maven/messages</code>.,      *             This is not required if you simply put the,      * resources in that directory,      *             structure at the source, however.,      * ,      * @return String,      */,     public String getTargetPath(),     {,         return this.targetPath;,     } //-- String getTargetPath(), ,     /**,      * Set whether resources are filtered to replace tokens with,      * parameterised values or not.,      *             The values are taken from the,      * <code>properties</code> element and from the,      *             properties in the files listed in the,      * <code>filters</code> element. Note: While the type,      *             of this field is <code>String</code> for,      * technical reasons, the semantic type is actually,      *             <code>Boolean</code>. Default value is,      * <code>false</code>.,      * ,      * @param filtering,      */,     public void setFiltering( String filtering ),     {,         this.filtering = filtering;,     } //-- void setFiltering( String ), ,     /**,      * Set fOR INTERNAL USE ONLY. This is a unique identifier,      * assigned to each,      *             resource to allow Maven to merge changes to this,      * resource that take,      *             place during the execution of a plugin. This,      * field must be managed,      *             by the generated parser and formatter classes in,      * order to allow it,      *             to survive model interpolation.,      * ,      * @param mergeId,      */,     public void setMergeId( String mergeId ),     {,         this.mergeId = mergeId;,     } //-- void setMergeId( String ), ,     /**,      * Set describe the resource target path. The path is relative,      * to the target/classes,      *             directory (i.e.,      * <code>${project.build.outputDirectory}</code>).,      *             For example, if you want that resource to appear,      * in a specific package,      *             (<code>org.apache.maven.messages</code>), you,      * must specify this,      *             element with this value:,      * <code>org/apache/maven/messages</code>.,      *             This is not required if you simply put the,      * resources in that directory,      *             structure at the source, however.,      * ,      * @param targetPath,      */,     public void setTargetPath( String targetPath ),     {,         this.targetPath = targetPath;,     } //-- void setTargetPath( String ), ,     ,             ,     private static int mergeIdCounter = 0;, ,     public void initMergeId(),     {,         if ( getMergeId() == null ),         {,             setMergeId( "resource-" + (mergeIdCounter++) );,         },     }, ,     public boolean isFiltering(),     {,         return ( filtering != null ) ? Boolean.parseBoolean( filtering ) : false;,     }, ,     public void setFiltering( boolean filtering ),     {,         this.filtering = String.valueOf( filtering );,     }, ,     /**,      * @see java.lang.Object#toString(),      */,     public String toString(),     {,         return "Resource {targetPath: " + getTargetPath() + ", filtering: " + isFiltering() + ", " + super.toString() + "}";],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/maven/model/Resource.java,initMergeId,232-232,[            setMergeId( "resource-" + (mergeIdCounter++) );],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ResourceTest.java,testEqualsNullSafe,42-42,[        new Resource().equals( new Resource() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Scm.java,,19-262,[@SuppressWarnings( "all" ), public class Scm,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The source control management system URL,      *             that describes the repository and how to connect,      * to the,      *             repository. For more information, see the,      *             <a,      * href="http://maven.apache.org/scm/scm-url-format.html">URL,      * format</a>,      *             and <a,      * href="http://maven.apache.org/scm/scms-overview.html">list,      * of supported SCMs</a>.,      *             This connection is read-only.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId,      *             ,      *           .,      */,     private String connection;, ,     /**,      * ,      *             ,      *             Just like <code>connection</code>, but for,      * developers, i.e. this scm connection,      *             will not be read only.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId,      *             ,      *           .,      */,     private String developerConnection;, ,     /**,      * The tag of current code. By default, it's set to HEAD during,      * development.,      */,     private String tag = "HEAD";, ,     /**,      * ,      *             ,      *             The URL to the project's browsable SCM,      * repository, such as ViewVC or Fisheye.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId,      *             ,      *           .,      */,     private String url;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Scm,      */,     public Scm clone(),     {,         try,         {,             Scm copy = (Scm) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Scm clone(), ,     /**,      * Get the source control management system URL,      *             that describes the repository and how to connect,      * to the,      *             repository. For more information, see the,      *             <a,      * href="http://maven.apache.org/scm/scm-url-format.html">URL,      * format</a>,      *             and <a,      * href="http://maven.apache.org/scm/scms-overview.html">list,      * of supported SCMs</a>.,      *             This connection is read-only.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @return String,      */,     public String getConnection(),     {,         return this.connection;,     } //-- String getConnection(), ,     /**,      * Get just like <code>connection</code>, but for developers,,      * i.e. this scm connection,      *             will not be read only.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @return String,      */,     public String getDeveloperConnection(),     {,         return this.developerConnection;,     } //-- String getDeveloperConnection(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get the tag of current code. By default, it's set to HEAD,      * during development.,      * ,      * @return String,      */,     public String getTag(),     {,         return this.tag;,     } //-- String getTag(), ,     /**,      * Get the URL to the project's browsable SCM repository, such,      * as ViewVC or Fisheye.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Set the source control management system URL,      *             that describes the repository and how to connect,      * to the,      *             repository. For more information, see the,      *             <a,      * href="http://maven.apache.org/scm/scm-url-format.html">URL,      * format</a>,      *             and <a,      * href="http://maven.apache.org/scm/scms-overview.html">list,      * of supported SCMs</a>.,      *             This connection is read-only.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @param connection,      */,     public void setConnection( String connection ),     {,         this.connection = connection;,     } //-- void setConnection( String ), ,     /**,      * Set just like <code>connection</code>, but for developers,,      * i.e. this scm connection,      *             will not be read only.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @param developerConnection,      */,     public void setDeveloperConnection( String developerConnection ),     {,         this.developerConnection = developerConnection;,     } //-- void setDeveloperConnection( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set the tag of current code. By default, it's set to HEAD,      * during development.,      * ,      * @param tag,      */,     public void setTag( String tag ),     {,         this.tag = tag;,     } //-- void setTag( String ), ,     /**,      * Set the URL to the project's browsable SCM repository, such,      * as ViewVC or Fisheye.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/ScmTest.java,testEqualsNullSafe,42-42,[        new Scm().equals( new Scm() );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/model/Site.java,,13-185,[@SuppressWarnings( "all" ), public class Site,     implements java.io.Serializable, java.lang.Cloneable, org.apache.maven.model.InputLocationTracker, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             A unique identifier for a deployment location.,      * This is used to match the,      *             site to configuration in the,      * <code>settings.xml</code> file, for example.,      *             ,      *           ,      */,     private String id;, ,     /**,      * Human readable name of the deployment location.,      */,     private String name;, ,     /**,      * ,      *             ,      *             The url of the location where website is,      * deployed, in the form <code>protocol://hostname/path</code>.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId,      *             ,      *           .,      */,     private String url;, ,     /**,      * Field locations.,      */,     private java.util.Map<Object, InputLocation> locations;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Site,      */,     public Site clone(),     {,         try,         {,             Site copy = (Site) super.clone();, ,             if ( copy.locations != null ),             {,                 copy.locations = new java.util.LinkedHashMap( copy.locations );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Site clone(), ,     /**,      * Get a unique identifier for a deployment location. This is,      * used to match the,      *             site to configuration in the,      * <code>settings.xml</code> file, for example.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * ,      * ,      * @param key,      * @return InputLocation,      */,     public InputLocation getLocation( Object key ),     {,         return ( locations != null ) ? locations.get( key ) : null;,     } //-- InputLocation getLocation( Object ), ,     /**,      * Get human readable name of the deployment location.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the url of the location where website is deployed, in,      * the form <code>protocol://hostname/path</code>.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Set a unique identifier for a deployment location. This is,      * used to match the,      *             site to configuration in the,      * <code>settings.xml</code> file, for example.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * ,      * ,      * @param key,      * @param location,      */,     public void setLocation( Object key, InputLocation location ),     {,         if ( location != null ),         {,             if ( this.locations == null ),             {,                 this.locations = new java.util.LinkedHashMap<Object, InputLocation>();,             },             this.locations.put( key, location );,         },     } //-- void setLocation( Object, InputLocation ), ,     /**,      * Set human readable name of the deployment location.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the url of the location where website is deployed, in,      * the form <code>protocol://hostname/path</code>.,      *             <br /><b>Default value is</b>: parent value [+,      * path adjustment] + artifactId.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String )],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/maven/model/SiteTest.java,testEqualsNullSafe,42-42,[        new Site().equals( new Site() );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/building/DefaultModelBuilder.java,build,268-268,[        for ( ModelData currentData = resultData; currentData != null; )],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/maven/model/building/DefaultModelBuilder.java,build,318-318,[                    message += modelId + " -> ";],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/maven/model/building/DefaultModelBuilder.java,importDependencyManagement,943-943,[                    message += modelId + " -> ";],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/maven/model/building/DefaultModelBuilder.java,checkPluginVersions,619-619,[            if ( versions.get( key ) == null && managedVersions.get( key ) == null )],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/model/building/DefaultModelBuilder.java,,855-859,[            {,                 @Override,                 public int getValidationLevel(),                 {,                     return ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/maven/model/building/DefaultModelBuildingRequest.java,getBuildStartTime,300-300,[        return buildStartTime;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/maven/model/building/DefaultModelBuildingRequest.java,setBuildStartTime,305-305,[        this.buildStartTime = buildStartTime;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/maven/model/building/DefaultModelBuildingRequest.java,,123-123,[        this.modelSource = modelSource;],,,114-114,[        if ( modelSource == null && pomFile != null )],,,118-118,[        return modelSource;],,,116-116,[            modelSource = new FileModelSource( pomFile );],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/maven/model/building/DefaultModelBuildingRequest.java,,102-102,[        return pomFile;],,,107-107,[        this.pomFile = ( pomFile != null ) ? pomFile.getAbsoluteFile() : null;],,,114-114,[        if ( modelSource == null && pomFile != null )],,,116-116,[            modelSource = new FileModelSource( pomFile );],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/maven/model/building/DefaultModelProblemCollector.java,add,169-169,[            ModelParseException e = (ModelParseException) req.getException();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/building/DefaultModelProcessor.java,locatePom,59-59,[        return locator.locatePom( projectDirectory );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/building/DefaultModelProcessor.java,read,65-65,[        return reader.read( input, options );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/building/DefaultModelProcessor.java,read,77-77,[        return reader.read( input, options );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/building/DefaultModelProcessor.java,read,71-71,[        return reader.read( input, options );],,
BAD_PRACTICE,SE_BAD_FIELD_STORE,org/apache/maven/model/building/ModelBuildingException.java,,65-65,[            result = tmp;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/inheritance/DefaultInheritanceAssemblerTest.java,testPluginConfiguration,81-81,[        assembler.assembleModelInheritance( child, parent, null, problems );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/inheritance/DefaultInheritanceAssemblerTest.java,getModel,69-69,[        return reader.read( getPom( name ), null );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/inheritance/DefaultInheritanceAssemblerTest.java,testPluginConfiguration,85-85,[        writer.write( actual, null, child );],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java,testShouldThrowExceptionOnRecursiveScmConnectionReference,154-154,[        catch ( Exception e )],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/maven/model/interpolation/AbstractModelInterpolatorTest.java,testShouldInterpolateUnprefixedBasedirExpression,438-438,[        File basedir = new File( "/test/path" );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/interpolation/AbstractStringBasedModelInterpolator.java,createValueSources,173-173,[            if ( modelProperties != null )],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/model/interpolation/AbstractStringBasedModelInterpolator.java,,147-154,[            {,                 public Object getValue( String expression ),                 {,                     if ( "basedir".equals( expression ) ),                     {,                         return projectDir.getAbsolutePath();,                     },                     return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/model/interpolation/AbstractStringBasedModelInterpolator.java,,160-167,[            {,                 public Object getValue( String expression ),                 {,                     if ( "baseUri".equals( expression ) ),                     {,                         return projectDir.getAbsoluteFile().toURI().toString();,                     },                     return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/model/interpolation/AbstractStringBasedModelInterpolator.java,,189-192,[        {,             public Object getValue( String expression ),             {,                 return config.getSystemProperties().getProperty( "env." + expression );],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/maven/model/interpolation/StringSearchModelInterpolator.java,interpolate,295-295,[                    field.setAccessible( true );],,interpolate,317-317,[                        field.setAccessible( isAccessible );],,
BAD_PRACTICE,ISC_INSTANTIATE_STATIC_CLASS,org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java,testFinalFieldsExcludedFromInterpolation,473-473,[        interpolator.interpolateObject( new ClassWithFinalField(), new Model(), null, request, problems );],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java,,445-445,[            this.values1 = values1;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java,,447-447,[            this.values3 = values3;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/maven/model/interpolation/StringSearchModelInterpolatorTest.java,,446-446,[            this.values2 = values2;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/maven/model/io/DefaultModelReader.java,read,56-56,[        Model model = read( new FileInputStream( input ), options );],,read,58-58,[        model.setPomFile( input );],,read,60-60,[        return model;],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/model/io/DefaultModelWriter.java,write,58-58,[        output.getParentFile().mkdirs();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseActivation,620-620,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseActivationFile,679-679,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseActivationOS,726-726,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseActivationProperty,781-781,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseBuild,828-828,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseBuildBase,983-983,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseCiManagement,1102-1102,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseConfigurationContainer,1165-1165,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseContributor,1212-1212,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseDependency,1300-1300,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseDependencyManagement,1387-1387,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseDeploymentRepository,1442-1442,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseDeveloper,1509-1509,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseDistributionManagement,1601-1601,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseExclusion,1664-1664,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseExtension,1711-1711,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseFileSet,1762-1762,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseIssueManagement,1837-1837,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseLicense,1884-1884,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseMailingList,1939-1939,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseModel,2014-2014,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseModelBase,2290-2290,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseNotifier,2418-2418,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseOrganization,2490-2490,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseParent,2537-2537,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePatternSet,2592-2592,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePlugin,2663-2663,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePluginConfiguration,2762-2762,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePluginContainer,2821-2821,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePluginExecution,2876-2876,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePluginManagement,2947-2947,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePrerequisites,3002-3002,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseProfile,3045-3045,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseRelocation,3185-3185,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseReportPlugin,3240-3240,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseReportSet,3315-3315,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseReporting,3382-3382,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseRepository,3445-3445,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseRepositoryBase,3508-3508,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseRepositoryPolicy,3563-3563,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseResource,3614-3614,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseScm,3697-3697,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseSite,3752-3752,[            String value = parser.getAttributeValue( i );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getIntegerValue,406-406,[                return Integer.valueOf( s ).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getLongValue,436-436,[                return Long.valueOf( s ).longValue();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getBooleanValue,191-191,[        return getBooleanValue( s, attribute, parser, null );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getDateValue,279-279,[        return getDateValue( s, attribute, null, parser );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getByteValue,231-245,[        if ( s != null ),         {,             try,             {,                 return Byte.valueOf( s ).byteValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getCharacterValue,260-264,[        if ( s != null ),         {,             return s.charAt( 0 );,         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getDoubleValue,342-356,[        if ( s != null ),         {,             try,             {,                 return Double.valueOf( s ).doubleValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getFloatValue,372-386,[        if ( s != null ),         {,             try,             {,                 return Float.valueOf( s ).floatValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getIntegerValue,402-416,[        if ( s != null ),         {,             try,             {,                 return Integer.valueOf( s ).intValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getLongValue,432-446,[        if ( s != null ),         {,             try,             {,                 return Long.valueOf( s ).longValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getRequiredAttributeValue,462-469,[        if ( s == null ),         {,             if ( strict ),             {,                 throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );,             },         },         return s;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,getShortValue,485-499,[        if ( s != null ),         {,             try,             {,                 return Short.valueOf( s ).shortValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseConfigurationContainer,1160-1192,[        String tagName = parser.getName();,         ConfigurationContainer configurationContainer = new ConfigurationContainer();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) ),             {,                 configurationContainer.setInherited( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) ),             {,                 configurationContainer.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );,             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return configurationContainer;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseFileSet,1757-1817,[        String tagName = parser.getName();,         FileSet fileSet = new FileSet();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) ),             {,                 fileSet.setDirectory( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) ),             {,                 java.util.List includes = new java.util.ArrayList/*<String>*/();,                 fileSet.setIncludes( includes );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "include".equals( parser.getName() ) ),                     {,                         includes.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) ),             {,                 java.util.List excludes = new java.util.ArrayList/*<String>*/();,                 fileSet.setExcludes( excludes );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "exclude".equals( parser.getName() ) ),                     {,                         excludes.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return fileSet;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseModelBase,2285-2398,[        String tagName = parser.getName();,         ModelBase modelBase = new ModelBase();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) ),             {,                 java.util.List modules = new java.util.ArrayList/*<String>*/();,                 modelBase.setModules( modules );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "module".equals( parser.getName() ) ),                     {,                         modules.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) ),             {,                 modelBase.setDistributionManagement( parseDistributionManagement( parser, strict ) );,             },             else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) ),             {,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     String key = parser.getName();,                     String value = parser.nextText().trim();,                     modelBase.addProperty( key, value );,                 },             },             else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) ),             {,                 modelBase.setDependencyManagement( parseDependencyManagement( parser, strict ) );,             },             else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) ),             {,                 java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();,                 modelBase.setDependencies( dependencies );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "dependency".equals( parser.getName() ) ),                     {,                         dependencies.add( parseDependency( parser, strict ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) ),             {,                 java.util.List repositories = new java.util.ArrayList/*<Repository>*/();,                 modelBase.setRepositories( repositories );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "repository".equals( parser.getName() ) ),                     {,                         repositories.add( parseRepository( parser, strict ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) ),             {,                 java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();,                 modelBase.setPluginRepositories( pluginRepositories );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "pluginRepository".equals( parser.getName() ) ),                     {,                         pluginRepositories.add( parseRepository( parser, strict ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) ),             {,                 modelBase.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );,             },             else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) ),             {,                 modelBase.setReporting( parseReporting( parser, strict ) );,             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return modelBase;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePatternSet,2587-2643,[        String tagName = parser.getName();,         PatternSet patternSet = new PatternSet();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) ),             {,                 java.util.List includes = new java.util.ArrayList/*<String>*/();,                 patternSet.setIncludes( includes );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "include".equals( parser.getName() ) ),                     {,                         includes.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) ),             {,                 java.util.List excludes = new java.util.ArrayList/*<String>*/();,                 patternSet.setExcludes( excludes );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "exclude".equals( parser.getName() ) ),                     {,                         excludes.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return patternSet;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePluginConfiguration,2757-2801,[        String tagName = parser.getName();,         PluginConfiguration pluginConfiguration = new PluginConfiguration();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) ),             {,                 pluginConfiguration.setPluginManagement( parsePluginManagement( parser, strict ) );,             },             else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) ),             {,                 java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();,                 pluginConfiguration.setPlugins( plugins );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "plugin".equals( parser.getName() ) ),                     {,                         plugins.add( parsePlugin( parser, strict ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return pluginConfiguration;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parsePluginContainer,2816-2856,[        String tagName = parser.getName();,         PluginContainer pluginContainer = new PluginContainer();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) ),             {,                 java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();,                 pluginContainer.setPlugins( plugins );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "plugin".equals( parser.getName() ) ),                     {,                         plugins.add( parsePlugin( parser, strict ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return pluginContainer;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Reader.java,parseRepositoryBase,3503-3543,[        String tagName = parser.getName();,         RepositoryBase repositoryBase = new RepositoryBase();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "id", null, parsed ) ),             {,                 repositoryBase.setId( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) ),             {,                 repositoryBase.setName( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) ),             {,                 repositoryBase.setUrl( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) ),             {,                 repositoryBase.setLayout( getTrimmedValue( parser.nextText() ) );,             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return repositoryBase;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseActivation,600-600,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseActivationFile,667-667,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseActivationOS,722-722,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseActivationProperty,789-789,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseBuild,844-844,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseBuildBase,1024-1024,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseCiManagement,1158-1158,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseConfigurationContainer,1229-1229,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseContributor,1284-1284,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseDependency,1398-1398,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseDependencyManagement,1505-1505,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseDeploymentRepository,1564-1564,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseDeveloper,1645-1645,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseDistributionManagement,1765-1765,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseExclusion,1836-1836,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseExtension,1891-1891,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseFileSet,1952-1952,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseIssueManagement,2043-2043,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseLicense,2098-2098,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseMailingList,2165-2165,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseModel,2259-2259,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseModelBase,2569-2569,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseNotifier,2713-2713,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseOrganization,2806-2806,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseParent,2861-2861,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePatternSet,2928-2928,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePlugin,3013-3013,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePluginConfiguration,3130-3130,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePluginContainer,3193-3193,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePluginExecution,3252-3252,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePluginManagement,3340-3340,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePrerequisites,3399-3399,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseProfile,3448-3448,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseRelocation,3606-3606,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseReportPlugin,3673-3673,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseReportSet,3762-3762,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseReporting,3844-3844,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseRepository,3915-3915,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseRepositoryBase,3990-3990,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseRepositoryPolicy,4057-4057,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseResource,4118-4118,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseScm,4221-4221,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseSite,4288-4288,[            String value = parser.getAttributeValue( i );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getIntegerValue,408-408,[                return Integer.valueOf( s ).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getLongValue,438-438,[                return Long.valueOf( s ).longValue();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getBooleanValue,193-193,[        return getBooleanValue( s, attribute, parser, null );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getDateValue,281-281,[        return getDateValue( s, attribute, null, parser );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getByteValue,233-247,[        if ( s != null ),         {,             try,             {,                 return Byte.valueOf( s ).byteValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getCharacterValue,262-266,[        if ( s != null ),         {,             return s.charAt( 0 );,         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getDoubleValue,344-358,[        if ( s != null ),         {,             try,             {,                 return Double.valueOf( s ).doubleValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getFloatValue,374-388,[        if ( s != null ),         {,             try,             {,                 return Float.valueOf( s ).floatValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getIntegerValue,404-418,[        if ( s != null ),         {,             try,             {,                 return Integer.valueOf( s ).intValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getLongValue,434-448,[        if ( s != null ),         {,             try,             {,                 return Long.valueOf( s ).longValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getRequiredAttributeValue,464-471,[        if ( s == null ),         {,             if ( strict ),             {,                 throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );,             },         },         return s;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,getShortValue,487-501,[        if ( s != null ),         {,             try,             {,                 return Short.valueOf( s ).shortValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseConfigurationContainer,1221-1260,[        String tagName = parser.getName();,         ConfigurationContainer configurationContainer = new ConfigurationContainer();,         InputLocation _location;,         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,         configurationContainer.setLocation( "", _location );,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) ),             {,                 _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 configurationContainer.setLocation( "inherited", _location );,                 configurationContainer.setInherited( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) ),             {,                 _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 configurationContainer.setLocation( "configuration", _location );,                 configurationContainer.setConfiguration( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );,             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return configurationContainer;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseFileSet,1944-2019,[        String tagName = parser.getName();,         FileSet fileSet = new FileSet();,         InputLocation _location;,         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,         fileSet.setLocation( "", _location );,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) ),             {,                 _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 fileSet.setLocation( "directory", _location );,                 fileSet.setDirectory( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) ),             {,                 java.util.List includes = new java.util.ArrayList/*<String>*/();,                 fileSet.setIncludes( includes );,                 InputLocation _locations;,                 _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 fileSet.setLocation( "includes", _locations );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "include".equals( parser.getName() ) ),                     {,                         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                         _locations.setLocation( Integer.valueOf( includes.size() ), _location );,                         includes.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) ),             {,                 java.util.List excludes = new java.util.ArrayList/*<String>*/();,                 fileSet.setExcludes( excludes );,                 InputLocation _locations;,                 _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 fileSet.setLocation( "excludes", _locations );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "exclude".equals( parser.getName() ) ),                     {,                         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                         _locations.setLocation( Integer.valueOf( excludes.size() ), _location );,                         excludes.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return fileSet;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseModelBase,2561-2689,[        String tagName = parser.getName();,         ModelBase modelBase = new ModelBase();,         InputLocation _location;,         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,         modelBase.setLocation( "", _location );,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) ),             {,                 java.util.List modules = new java.util.ArrayList/*<String>*/();,                 modelBase.setModules( modules );,                 InputLocation _locations;,                 _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 modelBase.setLocation( "modules", _locations );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "module".equals( parser.getName() ) ),                     {,                         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                         _locations.setLocation( Integer.valueOf( modules.size() ), _location );,                         modules.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) ),             {,                 modelBase.setDistributionManagement( parseDistributionManagement( parser, strict, source ) );,             },             else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) ),             {,                 InputLocation _locations;,                 _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 modelBase.setLocation( "properties", _locations );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     String key = parser.getName();,                     _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                     _locations.setLocation( key, _location );,                     String value = parser.nextText().trim();,                     modelBase.addProperty( key, value );,                 },             },             else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) ),             {,                 modelBase.setDependencyManagement( parseDependencyManagement( parser, strict, source ) );,             },             else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) ),             {,                 java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();,                 modelBase.setDependencies( dependencies );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "dependency".equals( parser.getName() ) ),                     {,                         dependencies.add( parseDependency( parser, strict, source ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) ),             {,                 java.util.List repositories = new java.util.ArrayList/*<Repository>*/();,                 modelBase.setRepositories( repositories );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "repository".equals( parser.getName() ) ),                     {,                         repositories.add( parseRepository( parser, strict, source ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) ),             {,                 java.util.List pluginRepositories = new java.util.ArrayList/*<Repository>*/();,                 modelBase.setPluginRepositories( pluginRepositories );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "pluginRepository".equals( parser.getName() ) ),                     {,                         pluginRepositories.add( parseRepository( parser, strict, source ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) ),             {,                 _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 modelBase.setLocation( "reports", _location );,                 modelBase.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true ) );,             },             else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) ),             {,                 modelBase.setReporting( parseReporting( parser, strict, source ) );,             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return modelBase;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePatternSet,2920-2989,[        String tagName = parser.getName();,         PatternSet patternSet = new PatternSet();,         InputLocation _location;,         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,         patternSet.setLocation( "", _location );,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) ),             {,                 java.util.List includes = new java.util.ArrayList/*<String>*/();,                 patternSet.setIncludes( includes );,                 InputLocation _locations;,                 _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 patternSet.setLocation( "includes", _locations );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "include".equals( parser.getName() ) ),                     {,                         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                         _locations.setLocation( Integer.valueOf( includes.size() ), _location );,                         includes.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) ),             {,                 java.util.List excludes = new java.util.ArrayList/*<String>*/();,                 patternSet.setExcludes( excludes );,                 InputLocation _locations;,                 _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 patternSet.setLocation( "excludes", _locations );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "exclude".equals( parser.getName() ) ),                     {,                         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                         _locations.setLocation( Integer.valueOf( excludes.size() ), _location );,                         excludes.add( getTrimmedValue( parser.nextText() ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return patternSet;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePluginConfiguration,3122-3169,[        String tagName = parser.getName();,         PluginConfiguration pluginConfiguration = new PluginConfiguration();,         InputLocation _location;,         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,         pluginConfiguration.setLocation( "", _location );,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) ),             {,                 pluginConfiguration.setPluginManagement( parsePluginManagement( parser, strict, source ) );,             },             else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) ),             {,                 java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();,                 pluginConfiguration.setPlugins( plugins );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "plugin".equals( parser.getName() ) ),                     {,                         plugins.add( parsePlugin( parser, strict, source ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return pluginConfiguration;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parsePluginContainer,3185-3228,[        String tagName = parser.getName();,         PluginContainer pluginContainer = new PluginContainer();,         InputLocation _location;,         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,         pluginContainer.setLocation( "", _location );,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) ),             {,                 java.util.List plugins = new java.util.ArrayList/*<Plugin>*/();,                 pluginContainer.setPlugins( plugins );,                 while ( parser.nextTag() == XmlPullParser.START_TAG ),                 {,                     if ( "plugin".equals( parser.getName() ) ),                     {,                         plugins.add( parsePlugin( parser, strict, source ) );,                     },                     else,                     {,                         checkUnknownElement( parser, strict );,                     },                 },             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return pluginContainer;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3ReaderEx.java,parseRepositoryBase,3982-4033,[        String tagName = parser.getName();,         RepositoryBase repositoryBase = new RepositoryBase();,         InputLocation _location;,         _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,         repositoryBase.setLocation( "", _location );,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "id", null, parsed ) ),             {,                 _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 repositoryBase.setLocation( "id", _location );,                 repositoryBase.setId( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) ),             {,                 _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 repositoryBase.setLocation( "name", _location );,                 repositoryBase.setName( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) ),             {,                 _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 repositoryBase.setLocation( "url", _location );,                 repositoryBase.setUrl( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) ),             {,                 _location = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );,                 repositoryBase.setLocation( "layout", _location );,                 repositoryBase.setLayout( getTrimmedValue( parser.nextText() ) );,             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return repositoryBase;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeBuild,267-267,[        if ( ( build.getExtensions() != null ) && ( build.getExtensions().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeBuild,309-309,[        if ( ( build.getFilters() != null ) && ( build.getFilters().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeBuild,281-281,[        if ( ( build.getResources() != null ) && ( build.getResources().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeBuild,291-291,[        if ( ( build.getTestResources() != null ) && ( build.getTestResources().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeBuild,323-323,[        if ( ( build.getPlugins() != null ) && ( build.getPlugins().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeBuildBase,380-380,[        if ( ( buildBase.getFilters() != null ) && ( buildBase.getFilters().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeBuildBase,352-352,[        if ( ( buildBase.getResources() != null ) && ( buildBase.getResources().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeBuildBase,362-362,[        if ( ( buildBase.getTestResources() != null ) && ( buildBase.getTestResources().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeBuildBase,394-394,[        if ( ( buildBase.getPlugins() != null ) && ( buildBase.getPlugins().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeCiManagement,427-427,[        if ( ( ciManagement.getNotifiers() != null ) && ( ciManagement.getNotifiers().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeContributor,509-509,[        if ( ( contributor.getProperties() != null ) && ( contributor.getProperties().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeContributor,495-495,[        if ( ( contributor.getRoles() != null ) && ( contributor.getRoles().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeDependency,563-563,[        if ( ( dependency.getExclusions() != null ) && ( dependency.getExclusions().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeDependencyManagement,592-592,[        if ( ( dependencyManagement.getDependencies() != null ) && ( dependencyManagement.getDependencies().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeDeveloper,698-698,[        if ( ( developer.getProperties() != null ) && ( developer.getProperties().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeDeveloper,684-684,[        if ( ( developer.getRoles() != null ) && ( developer.getRoles().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeFileSet,827-827,[        if ( ( fileSet.getExcludes() != null ) && ( fileSet.getExcludes().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeFileSet,817-817,[        if ( ( fileSet.getIncludes() != null ) && ( fileSet.getIncludes().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeMailingList,926-926,[        if ( ( mailingList.getOtherArchives() != null ) && ( mailingList.getOtherArchives().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,1018-1018,[        if ( ( model.getContributors() != null ) && ( model.getContributors().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,1008-1008,[        if ( ( model.getDevelopers() != null ) && ( model.getDevelopers().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,998-998,[        if ( ( model.getLicenses() != null ) && ( model.getLicenses().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,1028-1028,[        if ( ( model.getMailingLists() != null ) && ( model.getMailingLists().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,1125-1125,[        if ( ( model.getProfiles() != null ) && ( model.getProfiles().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,1083-1083,[        if ( ( model.getDependencies() != null ) && ( model.getDependencies().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,1042-1042,[        if ( ( model.getModules() != null ) && ( model.getModules().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,1103-1103,[        if ( ( model.getPluginRepositories() != null ) && ( model.getPluginRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,1068-1068,[        if ( ( model.getProperties() != null ) && ( model.getProperties().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModel,1093-1093,[        if ( ( model.getRepositories() != null ) && ( model.getRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModelBase,1179-1179,[        if ( ( modelBase.getDependencies() != null ) && ( modelBase.getDependencies().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModelBase,1150-1150,[        if ( ( modelBase.getModules() != null ) && ( modelBase.getModules().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModelBase,1199-1199,[        if ( ( modelBase.getPluginRepositories() != null ) && ( modelBase.getPluginRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModelBase,1164-1164,[        if ( ( modelBase.getProperties() != null ) && ( modelBase.getProperties().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModelBase,1189-1189,[        if ( ( modelBase.getRepositories() != null ) && ( modelBase.getRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeNotifier,1256-1256,[        if ( ( notifier.getConfiguration() != null ) && ( notifier.getConfiguration().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePatternSet,1346-1346,[        if ( ( patternSet.getExcludes() != null ) && ( patternSet.getExcludes().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePatternSet,1336-1336,[        if ( ( patternSet.getIncludes() != null ) && ( patternSet.getIncludes().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePlugin,1397-1397,[        if ( ( plugin.getDependencies() != null ) && ( plugin.getDependencies().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePlugin,1387-1387,[        if ( ( plugin.getExecutions() != null ) && ( plugin.getExecutions().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePluginConfiguration,1438-1438,[        if ( ( pluginConfiguration.getPlugins() != null ) && ( pluginConfiguration.getPlugins().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePluginContainer,1463-1463,[        if ( ( pluginContainer.getPlugins() != null ) && ( pluginContainer.getPlugins().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePluginExecution,1496-1496,[        if ( ( pluginExecution.getGoals() != null ) && ( pluginExecution.getGoals().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePluginManagement,1529-1529,[        if ( ( pluginManagement.getPlugins() != null ) && ( pluginManagement.getPlugins().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeProfile,1614-1614,[        if ( ( profile.getDependencies() != null ) && ( profile.getDependencies().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeProfile,1585-1585,[        if ( ( profile.getModules() != null ) && ( profile.getModules().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeProfile,1634-1634,[        if ( ( profile.getPluginRepositories() != null ) && ( profile.getPluginRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeProfile,1599-1599,[        if ( ( profile.getProperties() != null ) && ( profile.getProperties().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeProfile,1624-1624,[        if ( ( profile.getRepositories() != null ) && ( profile.getRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeReportPlugin,1710-1710,[        if ( ( reportPlugin.getReportSets() != null ) && ( reportPlugin.getReportSets().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeReportSet,1747-1747,[        if ( ( reportSet.getReports() != null ) && ( reportSet.getReports().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeReporting,1788-1788,[        if ( ( reporting.getPlugins() != null ) && ( reporting.getPlugins().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeResource,1932-1932,[        if ( ( resource.getExcludes() != null ) && ( resource.getExcludes().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeResource,1922-1922,[        if ( ( resource.getIncludes() != null ) && ( resource.getIncludes().size() > 0 ) )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeConfigurationContainer,451-461,[        serializer.startTag( NAMESPACE, tagName );,         if ( configurationContainer.getInherited() != null ),         {,             serializer.startTag( NAMESPACE, "inherited" ).text( configurationContainer.getInherited() ).endTag( NAMESPACE, "inherited" );,         },         if ( configurationContainer.getConfiguration() != null ),         {,             ((Xpp3Dom) configurationContainer.getConfiguration()).writeToSerializer( NAMESPACE, serializer );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writeConfigurationContainer( ConfigurationContainer, String, XmlSerializer )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeFileSet,812-838,[        serializer.startTag( NAMESPACE, tagName );,         if ( fileSet.getDirectory() != null ),         {,             serializer.startTag( NAMESPACE, "directory" ).text( fileSet.getDirectory() ).endTag( NAMESPACE, "directory" );,         },         if ( ( fileSet.getIncludes() != null ) && ( fileSet.getIncludes().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "includes" );,             for ( Iterator iter = fileSet.getIncludes().iterator(); iter.hasNext(); ),             {,                 String include = (String) iter.next();,                 serializer.startTag( NAMESPACE, "include" ).text( include ).endTag( NAMESPACE, "include" );,             },             serializer.endTag( NAMESPACE, "includes" );,         },         if ( ( fileSet.getExcludes() != null ) && ( fileSet.getExcludes().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "excludes" );,             for ( Iterator iter = fileSet.getExcludes().iterator(); iter.hasNext(); ),             {,                 String exclude = (String) iter.next();,                 serializer.startTag( NAMESPACE, "exclude" ).text( exclude ).endTag( NAMESPACE, "exclude" );,             },             serializer.endTag( NAMESPACE, "excludes" );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writeFileSet( FileSet, String, XmlSerializer )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeModelBase,1149-1218,[        serializer.startTag( NAMESPACE, tagName );,         if ( ( modelBase.getModules() != null ) && ( modelBase.getModules().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "modules" );,             for ( Iterator iter = modelBase.getModules().iterator(); iter.hasNext(); ),             {,                 String module = (String) iter.next();,                 serializer.startTag( NAMESPACE, "module" ).text( module ).endTag( NAMESPACE, "module" );,             },             serializer.endTag( NAMESPACE, "modules" );,         },         if ( modelBase.getDistributionManagement() != null ),         {,             writeDistributionManagement( (DistributionManagement) modelBase.getDistributionManagement(), "distributionManagement", serializer );,         },         if ( ( modelBase.getProperties() != null ) && ( modelBase.getProperties().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "properties" );,             for ( Iterator iter = modelBase.getProperties().keySet().iterator(); iter.hasNext(); ),             {,                 String key = (String) iter.next();,                 String value = (String) modelBase.getProperties().get( key );,                 serializer.startTag( NAMESPACE, "" + key + "" ).text( value ).endTag( NAMESPACE, "" + key + "" );,             },             serializer.endTag( NAMESPACE, "properties" );,         },         if ( modelBase.getDependencyManagement() != null ),         {,             writeDependencyManagement( (DependencyManagement) modelBase.getDependencyManagement(), "dependencyManagement", serializer );,         },         if ( ( modelBase.getDependencies() != null ) && ( modelBase.getDependencies().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "dependencies" );,             for ( Iterator iter = modelBase.getDependencies().iterator(); iter.hasNext(); ),             {,                 Dependency o = (Dependency) iter.next();,                 writeDependency( o, "dependency", serializer );,             },             serializer.endTag( NAMESPACE, "dependencies" );,         },         if ( ( modelBase.getRepositories() != null ) && ( modelBase.getRepositories().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "repositories" );,             for ( Iterator iter = modelBase.getRepositories().iterator(); iter.hasNext(); ),             {,                 Repository o = (Repository) iter.next();,                 writeRepository( o, "repository", serializer );,             },             serializer.endTag( NAMESPACE, "repositories" );,         },         if ( ( modelBase.getPluginRepositories() != null ) && ( modelBase.getPluginRepositories().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "pluginRepositories" );,             for ( Iterator iter = modelBase.getPluginRepositories().iterator(); iter.hasNext(); ),             {,                 Repository o = (Repository) iter.next();,                 writeRepository( o, "pluginRepository", serializer );,             },             serializer.endTag( NAMESPACE, "pluginRepositories" );,         },         if ( modelBase.getReports() != null ),         {,             ((Xpp3Dom) modelBase.getReports()).writeToSerializer( NAMESPACE, serializer );,         },         if ( modelBase.getReporting() != null ),         {,             writeReporting( (Reporting) modelBase.getReporting(), "reporting", serializer );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writeModelBase( ModelBase, String, XmlSerializer )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePatternSet,1335-1357,[        serializer.startTag( NAMESPACE, tagName );,         if ( ( patternSet.getIncludes() != null ) && ( patternSet.getIncludes().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "includes" );,             for ( Iterator iter = patternSet.getIncludes().iterator(); iter.hasNext(); ),             {,                 String include = (String) iter.next();,                 serializer.startTag( NAMESPACE, "include" ).text( include ).endTag( NAMESPACE, "include" );,             },             serializer.endTag( NAMESPACE, "includes" );,         },         if ( ( patternSet.getExcludes() != null ) && ( patternSet.getExcludes().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "excludes" );,             for ( Iterator iter = patternSet.getExcludes().iterator(); iter.hasNext(); ),             {,                 String exclude = (String) iter.next();,                 serializer.startTag( NAMESPACE, "exclude" ).text( exclude ).endTag( NAMESPACE, "exclude" );,             },             serializer.endTag( NAMESPACE, "excludes" );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writePatternSet( PatternSet, String, XmlSerializer )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePluginConfiguration,1433-1449,[        serializer.startTag( NAMESPACE, tagName );,         if ( pluginConfiguration.getPluginManagement() != null ),         {,             writePluginManagement( (PluginManagement) pluginConfiguration.getPluginManagement(), "pluginManagement", serializer );,         },         if ( ( pluginConfiguration.getPlugins() != null ) && ( pluginConfiguration.getPlugins().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "plugins" );,             for ( Iterator iter = pluginConfiguration.getPlugins().iterator(); iter.hasNext(); ),             {,                 Plugin o = (Plugin) iter.next();,                 writePlugin( o, "plugin", serializer );,             },             serializer.endTag( NAMESPACE, "plugins" );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writePluginConfiguration( PluginConfiguration, String, XmlSerializer )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writePluginContainer,1462-1474,[        serializer.startTag( NAMESPACE, tagName );,         if ( ( pluginContainer.getPlugins() != null ) && ( pluginContainer.getPlugins().size() > 0 ) ),         {,             serializer.startTag( NAMESPACE, "plugins" );,             for ( Iterator iter = pluginContainer.getPlugins().iterator(); iter.hasNext(); ),             {,                 Plugin o = (Plugin) iter.next();,                 writePlugin( o, "plugin", serializer );,             },             serializer.endTag( NAMESPACE, "plugins" );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writePluginContainer( PluginContainer, String, XmlSerializer )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/model/io/xpp3/MavenXpp3Writer.java,writeRepositoryBase,1851-1869,[        serializer.startTag( NAMESPACE, tagName );,         if ( repositoryBase.getId() != null ),         {,             serializer.startTag( NAMESPACE, "id" ).text( repositoryBase.getId() ).endTag( NAMESPACE, "id" );,         },         if ( repositoryBase.getName() != null ),         {,             serializer.startTag( NAMESPACE, "name" ).text( repositoryBase.getName() ).endTag( NAMESPACE, "name" );,         },         if ( repositoryBase.getUrl() != null ),         {,             serializer.startTag( NAMESPACE, "url" ).text( repositoryBase.getUrl() ).endTag( NAMESPACE, "url" );,         },         if ( ( repositoryBase.getLayout() != null ) && !repositoryBase.getLayout().equals( "default" ) ),         {,             serializer.startTag( NAMESPACE, "layout" ).text( repositoryBase.getLayout() ).endTag( NAMESPACE, "layout" );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writeRepositoryBase( RepositoryBase, String, XmlSerializer )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/model/path/DefaultModelPathTranslator.java,alignToBaseDirectory,82-82,[            if ( build.getFilters() != null )],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/path/DefaultModelPathTranslator.java,alignToBaseDirectory,107-107,[        return pathTranslator.alignToBaseDirectory( path, basedir );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/path/DefaultModelUrlNormalizer.java,normalize,80-80,[        return urlNormalizer.normalize( url );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/path/DefaultUrlNormalizerTest.java,normalize,53-53,[        return normalizer.normalize( url );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/profile/activation/AbstractProfileActivatorTest.java,assertActivation,86-86,[        assertEquals( active, activator.isActive( profile, context, problems ) );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/profile/activation/FileProfileActivator.java,isActive,140-140,[        path = pathTranslator.alignToBaseDirectory( path, basedir );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/model/profile/activation/FileProfileActivator.java,,101-112,[            {,                 public Object getValue( String expression ),                 {,                     /*,                      * NOTE: We intentionally only support ${basedir} and not ${project.basedir} as the latter form,                      * would suggest that other project.* expressions can be used which is however beyond the design.,                      */,                     if ( "basedir".equals( expression ) ),                     {,                         return basedir.getAbsolutePath();,                     },                     return null;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/maven/model/superpom/DefaultSuperPomProvider.java,getSuperModel,62-62,[            InputStream is = getClass().getResourceAsStream( resource );],,getSuperModel,64-64,[            if ( is == null )],,getSuperModel,72-72,[                Map<String, String> options = new HashMap<String, String>();],,getSuperModel,73-73,[                options.put( "xml:4.0.0", "xml:4.0.0" );],,getSuperModel,74-74,[                superModel = modelProcessor.read( is, options );],,getSuperModel,80-80,[            }],,getSuperModel,83-83,[        return superModel;],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/maven/model/superpom/DefaultSuperPomProvider.java,getSuperModel,62-62,[            InputStream is = getClass().getResourceAsStream( resource );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/superpom/DefaultSuperPomProvider.java,getSuperModel,74-74,[                superModel = modelProcessor.read( is, options );],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/maven/model/validation/DefaultModelValidatorTest.java,read,45-45,[        InputStream is = getClass().getResourceAsStream( resource );],,read,46-46,[        assertNotNull( "missing resource: " + resource, is );],,read,47-47,[        return new MavenXpp3Reader().read( is );],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/maven/model/validation/DefaultModelValidatorTest.java,read,45-45,[        InputStream is = getClass().getResourceAsStream( resource );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/validation/DefaultModelValidatorTest.java,validateEffective,69-69,[        validator.validateEffectiveModel( problems.getModel(), request, problems );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/model/validation/DefaultModelValidatorTest.java,validateRaw,81-81,[        validator.validateRawModel( problems.getModel(), request, problems );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/plugin/DefaultBuildPluginManager.java,executeMojo,165-165,[            Exception wrapper = new PluginContainerException( mojoDescriptor, pluginRealm, os.toString(), e );],,executeMojo,180-180,[            Exception wrapper = new PluginContainerException( mojoDescriptor, pluginRealm, os.toString(), e );],,executeMojo,195-195,[            throw new PluginExecutionException( mojoExecution, project, os.toString(), e );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/plugin/DefaultBuildPluginManager.java,executeMojo,160-160,[            PrintStream ps = new PrintStream( os );],,executeMojo,175-175,[            PrintStream ps = new PrintStream( os );],,executeMojo,190-190,[            PrintStream ps = new PrintStream( os );],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/maven/plugin/DefaultBuildPluginManager.java,,65-65,[        this.mojoExecutionListeners = listeners;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/maven/plugin/MojoExecution.java,,60-235,[    private Source source = Source.LIFECYCLE;, ,     /**,      * The phase may or may not have been bound to a phase but once the plan has been calculated we know what phase,      * this mojo execution is going to run in.,      */,     private String lifecyclePhase;, ,     /**,      * The executions to fork before this execution, indexed by the groupId:artifactId:version of the project on which,      * the forked execution are to be run and in reactor build order.,      */,     private Map<String, List<MojoExecution>> forkedExecutions = new LinkedHashMap<String, List<MojoExecution>>();, ,     public MojoExecution( Plugin plugin, String goal, String executionId ),     {,         this.plugin = plugin;,         this.goal = goal;,         this.executionId = executionId;,     },     ,     public MojoExecution( MojoDescriptor mojoDescriptor ),     {,         this.mojoDescriptor = mojoDescriptor;,         this.executionId = null;,         this.configuration = null;,     }, ,     public MojoExecution( MojoDescriptor mojoDescriptor, String executionId, Source source ),     {,         this.mojoDescriptor = mojoDescriptor;,         this.executionId = executionId;,         this.configuration = null;,         this.source = source;,     }, ,     public MojoExecution( MojoDescriptor mojoDescriptor, String executionId ),     {,         this.mojoDescriptor = mojoDescriptor;,         this.executionId = executionId;,         this.configuration = null;,     }, ,     public MojoExecution( MojoDescriptor mojoDescriptor, Xpp3Dom configuration ),     {,         this.mojoDescriptor = mojoDescriptor;,         this.configuration = configuration;,         this.executionId = null;,     }, ,     /**,      * Gets the source of this execution.,      * ,      * @return The source of this execution or {@code null} if unknown.,      */,     public Source getSource(),     {,         return source;,     }, ,     public String getExecutionId(),     {,         return executionId;,     }, ,     public Plugin getPlugin(),     {,         if ( mojoDescriptor != null ),         {,             return mojoDescriptor.getPluginDescriptor().getPlugin();,         }, ,         return plugin;,     }, ,     public MojoDescriptor getMojoDescriptor(),     {,         return mojoDescriptor;,     }, ,     public Xpp3Dom getConfiguration(),     {,         return configuration;,     }, ,     public void setConfiguration( Xpp3Dom configuration ),     {,         this.configuration = configuration;,     },     ,     public String identify(),     {,         StringBuilder sb = new StringBuilder( 256 );,         ,         sb.append( executionId );,         sb.append( configuration.toString() );,         ,         return sb.toString();,     }, ,     public String getLifecyclePhase(),     {,         return lifecyclePhase;,     }, ,     public void setLifecyclePhase( String lifecyclePhase ),     {,         this.lifecyclePhase = lifecyclePhase;,     }        , ,     @Override,     public String toString(),     {,         StringBuilder buffer = new StringBuilder( 128 );,         if ( mojoDescriptor != null ),         {,             buffer.append( mojoDescriptor.getId() );,         },         buffer.append( " {execution: " ).append( executionId ).append( "}" );,         return buffer.toString();,     }, ,     public String getGroupId(),     {,         if ( mojoDescriptor != null ),         {,             return mojoDescriptor.getPluginDescriptor().getGroupId();,         },         ,         return plugin.getGroupId();,     }, ,     public String getArtifactId(),     {,         if ( mojoDescriptor != null ),         {,             return mojoDescriptor.getPluginDescriptor().getArtifactId();,         },         ,         return plugin.getArtifactId();,     }, ,     public String getVersion(),     {,         if ( mojoDescriptor != null ),         {,             return mojoDescriptor.getPluginDescriptor().getVersion();,         }        ,         ,         return plugin.getVersion();,     }, ,     public String getGoal(),     {,         if ( mojoDescriptor != null ),         {,             return mojoDescriptor.getGoal();,         },         ,         return goal;,     }, ,     public void setMojoDescriptor( MojoDescriptor mojoDescriptor ),     {,         this.mojoDescriptor = mojoDescriptor;,     }, ,     public Map<String, List<MojoExecution>> getForkedExecutions(),     {,         return forkedExecutions;,     }, ,     public void setForkedExecutions( String projectKey, List<MojoExecution> forkedExecutions ),     {,         this.forkedExecutions.put( projectKey, forkedExecutions );,     }],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/maven/project/MavenProject.java,,96-2247,[public class MavenProject,     implements Cloneable, {,     public static final String EMPTY_PROJECT_GROUP_ID = "unknown";, ,     public static final String EMPTY_PROJECT_ARTIFACT_ID = "empty-project";, ,     public static final String EMPTY_PROJECT_VERSION = "0";, ,     private static final MavenProject ERROR_BUILDING_PARENT = new MavenProject();, ,     private Model model;, ,     private MavenProject parent;, ,     private File file;, ,     private Set<Artifact> resolvedArtifacts;, ,     private ArtifactFilter artifactFilter;, ,     private Set<Artifact> artifacts;, ,     private Artifact parentArtifact;, ,     private Set<Artifact> pluginArtifacts;, ,     private List<ArtifactRepository> remoteArtifactRepositories;, ,     private List<ArtifactRepository> pluginArtifactRepositories;, ,     private List<RemoteRepository> remoteProjectRepositories;, ,     private List<RemoteRepository> remotePluginRepositories;, ,     private List<Artifact> attachedArtifacts;, ,     private MavenProject executionProject;, ,     private List<MavenProject> collectedProjects;, ,     private List<String> compileSourceRoots = new ArrayList<String>();, ,     private List<String> testCompileSourceRoots = new ArrayList<String>();, ,     private List<String> scriptSourceRoots = new ArrayList<String>();, ,     private ArtifactRepository releaseArtifactRepository;, ,     private ArtifactRepository snapshotArtifactRepository;, ,     private List<Profile> activeProfiles = new ArrayList<Profile>();, ,     private Map<String, List<String>> injectedProfileIds = new LinkedHashMap<String, List<String>>();, ,     private Set<Artifact> dependencyArtifacts;, ,     private Artifact artifact;, ,     // calculated.,     private Map<String, Artifact> artifactMap;, ,     private Model originalModel;, ,     private Map<String, Artifact> pluginArtifactMap;, ,     private Set<Artifact> reportArtifacts;, ,     private Map<String, Artifact> reportArtifactMap;, ,     private Set<Artifact> extensionArtifacts;, ,     private Map<String, Artifact> extensionArtifactMap;, ,     private Map<String, Artifact> managedVersionMap;, ,     private Map<String, MavenProject> projectReferences = new HashMap<String, MavenProject>();, ,     private boolean executionRoot;, ,     private Map<String, String> moduleAdjustments;, ,     private ProjectBuilder mavenProjectBuilder;, ,     private ProjectBuildingRequest projectBuilderConfiguration;, ,     private RepositorySystem repositorySystem;,     ,     private File parentFile;, ,     private Map<String, Object> context;, ,     private ClassRealm classRealm;, ,     private DependencyFilter extensionDependencyFilter;, ,     private final Set<String> lifecyclePhases = Collections.synchronizedSet( new LinkedHashSet<String>() );, ,     private Logger logger;, ,     public MavenProject(),     {,         Model model = new Model();, ,         model.setGroupId( EMPTY_PROJECT_GROUP_ID );,         model.setArtifactId( EMPTY_PROJECT_ARTIFACT_ID );,         model.setVersion( EMPTY_PROJECT_VERSION );, ,         setModel( model );,     }, ,     public MavenProject( Model model ),     {,         setModel( model );,     }, ,     /**,      * @deprecated use {@link #clone()} so subclasses can provide a copy of the same class,      */,     @Deprecated,     public MavenProject( MavenProject project ),     {,         repositorySystem = project.repositorySystem;,         logger = project.logger;,         mavenProjectBuilder = project.mavenProjectBuilder;,         projectBuilderConfiguration = project.projectBuilderConfiguration;,         deepCopy( project );,     },     ,     @Deprecated,     public MavenProject( Model model, RepositorySystem repositorySystem ),     {        ,         this.repositorySystem = repositorySystem;,         setModel( model );,     }, ,     public File getParentFile(),     {,         return parentFile;,     }, ,     public void setParentFile( File parentFile ),     {,         this.parentFile = parentFile;,     }, ,     /**,      * Constructor,      * ,      * @param repositorySystem - may not be null,      * @param mavenProjectBuilder,      * @param projectBuilderConfiguration,      * @throws InvalidRepositoryException,      */,     MavenProject( RepositorySystem repositorySystem, ProjectBuilder mavenProjectBuilder,,                   ProjectBuildingRequest projectBuilderConfiguration, Logger logger ),     {,         if ( repositorySystem == null ),         {,             throw new IllegalArgumentException( "mavenTools: null" );,         }, ,         this.mavenProjectBuilder = mavenProjectBuilder;,         this.projectBuilderConfiguration = projectBuilderConfiguration;,         this.repositorySystem = repositorySystem;,         this.logger = logger;,     }, ,     @Deprecated,     public Set<Artifact> createArtifacts( ArtifactFactory artifactFactory, String inheritedScope, ArtifactFilter filter ),         throws InvalidDependencyVersionException,     {,         return MavenMetadataSource.createArtifacts( artifactFactory, getDependencies(), inheritedScope, filter, this );,     }, ,     // TODO: Find a way to use <relativePath/> here...it's tricky, because the moduleProject,     // usually doesn't have a file associated with it yet.,     public String getModulePathAdjustment( MavenProject moduleProject ),         throws IOException,     {,         // FIXME: This is hacky. What if module directory doesn't match artifactid, and parent,         // is coming from the repository??,         String module = moduleProject.getArtifactId();, ,         File moduleFile = moduleProject.getFile();, ,         if ( moduleFile != null ),         {,             File moduleDir = moduleFile.getCanonicalFile().getParentFile();, ,             module = moduleDir.getName();,         }, ,         if ( moduleAdjustments == null ),         {,             moduleAdjustments = new HashMap<String, String>();, ,             List<String> modules = getModules();,             if ( modules != null ),             {,                 for ( String modulePath : modules ),                 {,                     String moduleName = modulePath;, ,                     if ( moduleName.endsWith( "/" ) || moduleName.endsWith( "\\" ) ),                     {,                         moduleName = moduleName.substring( 0, moduleName.length() - 1 );,                     }, ,                     int lastSlash = moduleName.lastIndexOf( '/' );, ,                     if ( lastSlash < 0 ),                     {,                         lastSlash = moduleName.lastIndexOf( '\\' );,                     }, ,                     String adjustment = null;, ,                     if ( lastSlash > -1 ),                     {,                         moduleName = moduleName.substring( lastSlash + 1 );,                         adjustment = modulePath.substring( 0, lastSlash );,                     }, ,                     moduleAdjustments.put( moduleName, adjustment );,                 },             },         }, ,         return moduleAdjustments.get( module );,     }, ,     // ----------------------------------------------------------------------,     // Accessors,     // ----------------------------------------------------------------------, ,     public Artifact getArtifact(),     {,         return artifact;,     }, ,     public void setArtifact( Artifact artifact ),     {,         this.artifact = artifact;,     }, ,     //@todo I would like to get rid of this. jvz.,     public Model getModel(),     {,         return model;,     }, ,     /**,      * Returns the project corresponding to a declared parent.,      * @return the parent, or null if no parent is declared or there was an error building it,      */,     public MavenProject getParent(),     {,         if ( parent == null ),         {,             /*,              * TODO: This is suboptimal. Without a cache in the project builder, rebuilding the parent chain currently,              * causes O(n^2) parser invocations for an inheritance hierarchy of depth n.,              */,             if ( parentFile != null ),             {,                 checkProjectBuildingRequest();,                 ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );,                 request.setRemoteRepositories( getRemoteArtifactRepositories() );, ,                 try,                 {,                     parent = mavenProjectBuilder.build( parentFile, request ).getProject();,                 },                 catch ( ProjectBuildingException e ),                 {,                     if ( logger != null ),                     {,                         logger.error( "Failed to build parent project for " + getId(), e );,                     },                     parent = ERROR_BUILDING_PARENT;,                 },             },             else if ( model.getParent() != null ),             {,                 checkProjectBuildingRequest();,                 ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );,                 request.setRemoteRepositories( getRemoteArtifactRepositories() );, ,                 try,                 {,                     parent = mavenProjectBuilder.build( getParentArtifact(), request ).getProject();,                 },                 catch ( ProjectBuildingException e ),                 {,                     if ( logger != null ),                     {,                         logger.error( "Failed to build parent project for " + getId(), e );,                     },                     parent = ERROR_BUILDING_PARENT;,                 },             },         },         return parent == ERROR_BUILDING_PARENT ? null : parent;,     }, ,     public void setParent( MavenProject parent ),     {,         this.parent = parent;,     },     ,     public boolean hasParent(),     {,         return getParent() != null;,     }, ,     public File getFile(),     {,         return file;,     }, ,     public void setFile( File file ),     {,         this.file = file;,     }, ,     public File getBasedir(),     {,         if ( getFile() != null ),         {,             return getFile().getParentFile();,         },         else,         {,             // repository based POM,             return null;,         },     }, ,     public void setDependencies( List<Dependency> dependencies ),     {,         getModel().setDependencies( dependencies );,     }, ,     public List<Dependency> getDependencies(),     {,         return getModel().getDependencies();,     }, ,     public DependencyManagement getDependencyManagement(),     {,         return getModel().getDependencyManagement();,     }, ,     // ----------------------------------------------------------------------,     // Test and compile sourceroots.,     // ----------------------------------------------------------------------, ,     private void addPath( List<String> paths, String path ),     {,         if ( path != null ),         {,             path = path.trim();,             if ( path.length() > 0 ),             {,                 File file = new File( path );,                 if ( file.isAbsolute() ),                 {,                     path = file.getAbsolutePath();,                 },                 else,                 {,                     path = new File( getBasedir(), path ).getAbsolutePath();,                 }, ,                 if ( !paths.contains( path ) ),                 {,                     paths.add( path );,                 },             },         },     }, ,     public void addCompileSourceRoot( String path ),     {,         addPath( getCompileSourceRoots(), path );,     }, ,     public void addScriptSourceRoot( String path ),     {,         if ( path != null ),         {,             path = path.trim();,             if ( path.length() != 0 ),             {,                 if ( !getScriptSourceRoots().contains( path ) ),                 {,                     getScriptSourceRoots().add( path );,                 },             },         },     }, ,     public void addTestCompileSourceRoot( String path ),     {,         addPath( getTestCompileSourceRoots(), path );,     }, ,     public List<String> getCompileSourceRoots(),     {,         return compileSourceRoots;,     }, ,     public List<String> getScriptSourceRoots(),     {,         return scriptSourceRoots;,     }, ,     public List<String> getTestCompileSourceRoots(),     {,         return testCompileSourceRoots;,     }, ,     public List<String> getCompileClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );, ,         String d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         for ( Artifact a : getArtifacts() ),         {                        ,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     addArtifactPath( a, list );,                 },             },         }, ,         return list;,     }, ,     @Deprecated,     public List<Artifact> getCompileArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts() ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     list.add( a );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getCompileDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: let the scope handler deal with this,             if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),             {,                 Dependency dependency = new Dependency();, ,                 dependency.setArtifactId( a.getArtifactId() );,                 dependency.setGroupId( a.getGroupId() );,                 dependency.setVersion( a.getVersion() );,                 dependency.setScope( a.getScope() );,                 dependency.setType( a.getType() );,                 dependency.setClassifier( a.getClassifier() );, ,                 list.add( dependency );,             },         },         return list;,     }, ,     //TODO: this checking for file == null happens because the resolver has been confused about the root,     // artifact or not. things like the stupid dummy artifact coming from surefire.,     public List<String> getTestClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() + 2 );, ,         String d = getBuild().getTestOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         },         ,         for ( Artifact a : getArtifacts() ),         {            ,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {                ,                 addArtifactPath( a, list );,             },         }, ,         return list;,     }, ,     @Deprecated,     public List<Artifact> getTestArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts() ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 list.add( a );,             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getTestDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             Dependency dependency = new Dependency();, ,             dependency.setArtifactId( a.getArtifactId() );,             dependency.setGroupId( a.getGroupId() );,             dependency.setVersion( a.getVersion() );,             dependency.setScope( a.getScope() );,             dependency.setType( a.getType() );,             dependency.setClassifier( a.getClassifier() );, ,             list.add( dependency );,         },         return list;,     }, ,     public List<String> getRuntimeClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );, ,         String d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         for ( Artifact a : getArtifacts() ),         {,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ),                 {,                     addArtifactPath( a, list );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Artifact> getRuntimeArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ),                 {,                     list.add( a );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getRuntimeDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: let the scope handler deal with this,             if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ),             {,                 Dependency dependency = new Dependency();, ,                 dependency.setArtifactId( a.getArtifactId() );,                 dependency.setGroupId( a.getGroupId() );,                 dependency.setVersion( a.getVersion() );,                 dependency.setScope( a.getScope() );,                 dependency.setType( a.getType() );,                 dependency.setClassifier( a.getClassifier() );, ,                 list.add( dependency );,             },         },         return list;,     }, ,     public List<String> getSystemClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() );, ,         String d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         for ( Artifact a : getArtifacts() ),         {,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     addArtifactPath( a, list );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Artifact> getSystemArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     list.add( a );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getSystemDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: let the scope handler deal with this,             if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),             {,                 Dependency dependency = new Dependency();, ,                 dependency.setArtifactId( a.getArtifactId() );,                 dependency.setGroupId( a.getGroupId() );,                 dependency.setVersion( a.getVersion() );,                 dependency.setScope( a.getScope() );,                 dependency.setType( a.getType() );,                 dependency.setClassifier( a.getClassifier() );, ,                 list.add( dependency );,             },         },         return list;,     }, ,     // ----------------------------------------------------------------------,     // Delegate to the model,     // ----------------------------------------------------------------------, ,     public void setModelVersion( String pomVersion ),     {,         getModel().setModelVersion( pomVersion );,     }, ,     public String getModelVersion(),     {,         return getModel().getModelVersion();,     }, ,     public String getId(),     {,         return getModel().getId();,     }, ,     public void setGroupId( String groupId ),     {,         getModel().setGroupId( groupId );,     }, ,     public String getGroupId(),     {,         String groupId = getModel().getGroupId();, ,         if ( ( groupId == null ) && ( getModel().getParent() != null ) ),         {,             groupId = getModel().getParent().getGroupId();,         }, ,         return groupId;,     }, ,     public void setArtifactId( String artifactId ),     {,         getModel().setArtifactId( artifactId );,     }, ,     public String getArtifactId(),     {,         return getModel().getArtifactId();,     }, ,     public void setName( String name ),     {,         getModel().setName( name );,     }, ,     public String getName(),     {,         // TODO: this should not be allowed to be null.,         if ( getModel().getName() != null ),         {,             return getModel().getName();,         },         else,         {,             return getArtifactId();,         },     }, ,     public void setVersion( String version ),     {,         getModel().setVersion( version );,     }, ,     public String getVersion(),     {,         String version = getModel().getVersion();, ,         if ( ( version == null ) && ( getModel().getParent() != null ) ),         {,             version = getModel().getParent().getVersion();,         }, ,         return version;,     }, ,     public String getPackaging(),     {,         return getModel().getPackaging();,     }, ,     public void setPackaging( String packaging ),     {,         getModel().setPackaging( packaging );,     }, ,     public void setInceptionYear( String inceptionYear ),     {,         getModel().setInceptionYear( inceptionYear );,     }, ,     public String getInceptionYear(),     {,         return getModel().getInceptionYear();,     }, ,     public void setUrl( String url ),     {,         getModel().setUrl( url );,     }, ,     public String getUrl(),     {,         return getModel().getUrl();,     }, ,     public Prerequisites getPrerequisites(),     {,         return getModel().getPrerequisites();,     }, ,     public void setIssueManagement( IssueManagement issueManagement ),     {,         getModel().setIssueManagement( issueManagement );,     }, ,     public CiManagement getCiManagement(),     {,         return getModel().getCiManagement();,     }, ,     public void setCiManagement( CiManagement ciManagement ),     {,         getModel().setCiManagement( ciManagement );,     }, ,     public IssueManagement getIssueManagement(),     {,         return getModel().getIssueManagement();,     }, ,     public void setDistributionManagement( DistributionManagement distributionManagement ),     {,         getModel().setDistributionManagement( distributionManagement );,     }, ,     public DistributionManagement getDistributionManagement(),     {,         return getModel().getDistributionManagement();,     }, ,     public void setDescription( String description ),     {,         getModel().setDescription( description );,     }, ,     public String getDescription(),     {,         return getModel().getDescription();,     }, ,     public void setOrganization( Organization organization ),     {,         getModel().setOrganization( organization );,     }, ,     public Organization getOrganization(),     {,         return getModel().getOrganization();,     }, ,     public void setScm( Scm scm ),     {,         getModel().setScm( scm );,     }, ,     public Scm getScm(),     {,         return getModel().getScm();,     }, ,     public void setMailingLists( List<MailingList> mailingLists ),     {,         getModel().setMailingLists( mailingLists );,     }, ,     public List<MailingList> getMailingLists(),     {,         return getModel().getMailingLists();,     }, ,     public void addMailingList( MailingList mailingList ),     {,         getModel().addMailingList( mailingList );,     }, ,     public void setDevelopers( List<Developer> developers ),     {,         getModel().setDevelopers( developers );,     }, ,     public List<Developer> getDevelopers(),     {,         return getModel().getDevelopers();,     }, ,     public void addDeveloper( Developer developer ),     {,         getModel().addDeveloper( developer );,     }, ,     public void setContributors( List<Contributor> contributors ),     {,         getModel().setContributors( contributors );,     }, ,     public List<Contributor> getContributors(),     {,         return getModel().getContributors();,     }, ,     public void addContributor( Contributor contributor ),     {,         getModel().addContributor( contributor );,     }, ,     public void setBuild( Build build ),     {,         getModel().setBuild( build );,     }, ,     public Build getBuild(),     {,         return getModelBuild();,     }, ,     public List<Resource> getResources(),     {,         return getBuild().getResources();,     }, ,     public List<Resource> getTestResources(),     {,         return getBuild().getTestResources();,     }, ,     public void addResource( Resource resource ),     {,         getBuild().addResource( resource );,     }, ,     public void addTestResource( Resource testResource ),     {,         getBuild().addTestResource( testResource );,     }, ,     @Deprecated,     public void setReporting( Reporting reporting ),     {,         getModel().setReporting( reporting );,     }, ,     @Deprecated,     public Reporting getReporting(),     {,         return getModel().getReporting();,     }, ,     public void setLicenses( List<License> licenses ),     {,         getModel().setLicenses( licenses );,     }, ,     public List<License> getLicenses(),     {,         return getModel().getLicenses();,     }, ,     public void addLicense( License license ),     {,         getModel().addLicense( license );,     }, ,     public void setArtifacts( Set<Artifact> artifacts ),     {,         this.artifacts = artifacts;, ,         // flush the calculated artifactMap,         artifactMap = null;,     }, ,     /**,      * All dependencies that this project has, including transitive ones. Contents are lazily,      * populated, so depending on what phases have run dependencies in some scopes won't be,      * included. eg. if only compile phase has run, dependencies with scope test won't be included.,      * ,      * @return {@link Set} &lt; {@link Artifact} >,      * @see #getDependencyArtifacts() to get only direct dependencies,      */,     public Set<Artifact> getArtifacts(),     {,         if ( artifacts == null ),         {,             if ( artifactFilter == null || resolvedArtifacts == null ),             {,                 artifacts = new LinkedHashSet<Artifact>();,             },             else,             {,                 artifacts = new LinkedHashSet<Artifact>( resolvedArtifacts.size() * 2 );,                 for ( Artifact artifact : resolvedArtifacts ),                 {,                     if ( artifactFilter.include( artifact ) ),                     {,                         artifacts.add( artifact );,                     },                 },             },         },         return artifacts;,     }, ,     public Map<String, Artifact> getArtifactMap(),     {,         if ( artifactMap == null ),         {,             artifactMap = ArtifactUtils.artifactMapByVersionlessId( getArtifacts() );,         },         return artifactMap;,     }, ,     public void setPluginArtifacts( Set<Artifact> pluginArtifacts ),     {,         this.pluginArtifacts = pluginArtifacts;, ,         this.pluginArtifactMap = null;,     }, ,     public Set<Artifact> getPluginArtifacts(),     {,         if ( pluginArtifacts != null ),         {,             return pluginArtifacts;,         }, ,         pluginArtifacts = new HashSet<Artifact>();, ,         if ( repositorySystem != null ),         {,             for ( Plugin p : getBuildPlugins() ),             {,                 Artifact artifact = repositorySystem.createPluginArtifact( p );, ,                 if ( artifact != null ),                 {,                     pluginArtifacts.add( artifact );,                 },             },         }, ,         pluginArtifactMap = null;, ,         return pluginArtifacts;,     }, ,     public Map<String, Artifact> getPluginArtifactMap(),     {,         if ( pluginArtifactMap == null ),         {,             pluginArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getPluginArtifacts() );,         }, ,         return pluginArtifactMap;,     }, ,     @Deprecated,     public void setReportArtifacts( Set<Artifact> reportArtifacts ),     {,         this.reportArtifacts = reportArtifacts;, ,         reportArtifactMap = null;,     }, ,     @Deprecated,     public Set<Artifact> getReportArtifacts(),     {,         if ( reportArtifacts != null ),         {,             return reportArtifacts;,         }, ,         reportArtifacts = new HashSet<Artifact>();, ,         if ( repositorySystem != null ),         {,             for ( ReportPlugin p : getReportPlugins() ),             {,                 Plugin pp = new Plugin();,                 pp.setGroupId( p.getGroupId() );,                 pp.setArtifactId( p.getArtifactId() );,                 pp.setVersion( p.getVersion() );, ,                 Artifact artifact = repositorySystem.createPluginArtifact( pp );, ,                 if ( artifact != null ),                 {,                     reportArtifacts.add( artifact );,                 },             },         }, ,         reportArtifactMap = null;, ,         return reportArtifacts;,     }, ,     @Deprecated,     public Map<String, Artifact> getReportArtifactMap(),     {,         if ( reportArtifactMap == null ),         {,             reportArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getReportArtifacts() );,         }, ,         return reportArtifactMap;,     }, ,     public void setExtensionArtifacts( Set<Artifact> extensionArtifacts ),     {,         this.extensionArtifacts = extensionArtifacts;, ,         extensionArtifactMap = null;,     }, ,     public Set<Artifact> getExtensionArtifacts(),     {,         if ( extensionArtifacts != null ),         {,             return extensionArtifacts;,         },         extensionArtifacts = new HashSet<Artifact>();,         List<Extension> extensions = getBuildExtensions();,         if ( extensions != null ),         {,             for ( Extension ext : extensions ),             {,                 String version;,                 if ( StringUtils.isEmpty( ext.getVersion() ) ),                 {,                     version = "RELEASE";,                 },                 else,                 {,                     version = ext.getVersion();,                 }, ,                 Artifact artifact =,                     repositorySystem.createArtifact( ext.getGroupId(), ext.getArtifactId(), version, null, "jar" );, ,                 if ( artifact != null ),                 {,                     extensionArtifacts.add( artifact );,                 },             },         },         extensionArtifactMap = null;,         return extensionArtifacts;,     }, ,     public Map<String, Artifact> getExtensionArtifactMap(),     {,         if ( extensionArtifactMap == null ),         {,             extensionArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getExtensionArtifacts() );,         }, ,         return extensionArtifactMap;,     }, ,     public void setParentArtifact( Artifact parentArtifact ),     {,         this.parentArtifact = parentArtifact;,     }, ,     public Artifact getParentArtifact(),     {,         if ( parentArtifact == null && model.getParent() != null ),         {,             Parent p = model.getParent();,             parentArtifact = repositorySystem.createProjectArtifact( p.getGroupId(), p.getArtifactId(), p.getVersion() );,         },         return parentArtifact;,     }, ,     public List<Repository> getRepositories(),     {,         return getModel().getRepositories();,     }, ,     // ----------------------------------------------------------------------,     // Plugins,     // ----------------------------------------------------------------------, ,     @Deprecated,     public List<ReportPlugin> getReportPlugins(),     {,         if ( getModel().getReporting() == null ),         {,             return Collections.emptyList();,         },         return getModel().getReporting().getPlugins();, ,     }, ,     public List<Plugin> getBuildPlugins(),     {,         if ( getModel().getBuild() == null ),         {,             return Collections.emptyList();,         },         return getModel().getBuild().getPlugins();,     }, ,     public List<String> getModules(),     {,         return getModel().getModules();,     }, ,     public PluginManagement getPluginManagement(),     {,         PluginManagement pluginMgmt = null;, ,         Build build = getModel().getBuild();,         if ( build != null ),         {,             pluginMgmt = build.getPluginManagement();,         }, ,         return pluginMgmt;,     }, ,     private Build getModelBuild(),     {,         Build build = getModel().getBuild();, ,         if ( build == null ),         {,             build = new Build();, ,             getModel().setBuild( build );,         }, ,         return build;,     }, ,     public void setRemoteArtifactRepositories( List<ArtifactRepository> remoteArtifactRepositories ),     {,         this.remoteArtifactRepositories = remoteArtifactRepositories;,         this.remoteProjectRepositories = RepositoryUtils.toRepos( getRemoteArtifactRepositories() );,     }, ,     public List<ArtifactRepository> getRemoteArtifactRepositories(),     {,         if ( remoteArtifactRepositories == null ),         {,             remoteArtifactRepositories = new ArrayList<ArtifactRepository>();,         }, ,         return remoteArtifactRepositories;,     }, ,     public void setPluginArtifactRepositories( List<ArtifactRepository> pluginArtifactRepositories ),     {,         this.pluginArtifactRepositories = pluginArtifactRepositories;,         this.remotePluginRepositories = RepositoryUtils.toRepos( getPluginArtifactRepositories() );,     }, ,     /**,      * @return a list of ArtifactRepository objects constructed from the Repository objects returned,      *         by getPluginRepositories.,      */,     public List<ArtifactRepository> getPluginArtifactRepositories(),     {,         if ( pluginArtifactRepositories == null ),         {,             pluginArtifactRepositories = new ArrayList<ArtifactRepository>();,         }, ,         return pluginArtifactRepositories;,     }, ,     public ArtifactRepository getDistributionManagementArtifactRepository(),     {,         return getArtifact().isSnapshot() && ( getSnapshotArtifactRepository() != null ) ? getSnapshotArtifactRepository() : getReleaseArtifactRepository();,     }, ,     public List<Repository> getPluginRepositories(),     {,         return getModel().getPluginRepositories();,     }, ,     public List<RemoteRepository> getRemoteProjectRepositories(),     {,         return remoteProjectRepositories;,     }, ,     public List<RemoteRepository> getRemotePluginRepositories(),     {,         return remotePluginRepositories;,     }, ,     public void setActiveProfiles( List<Profile> activeProfiles ),     {,         this.activeProfiles = activeProfiles;,     }, ,     public List<Profile> getActiveProfiles(),     {,         return activeProfiles;,     }, ,     public void setInjectedProfileIds( String source, List<String> injectedProfileIds ),     {,         if ( injectedProfileIds != null ),         {,             this.injectedProfileIds.put( source, new ArrayList<String>( injectedProfileIds ) );,         },         else,         {,             this.injectedProfileIds.remove( source );,         },     }, ,     /**,      * Gets the identifiers of all profiles that contributed to this project's effective model. This includes active,      * profiles from the project's POM and all its parent POMs as well as from external sources like the {@code,      * settings.xml}. The profile identifiers are grouped by the identifier of their source, e.g. {@code,      * <groupId>:<artifactId>:<version>} for a POM profile or {@code external} for profiles from the {@code,      * settings.xml}.,      * ,      * @return The identifiers of all injected profiles, indexed by the source from which the profiles originated, never,      *         {@code null}.,      */,     public Map<String, List<String>> getInjectedProfileIds(),     {,         return this.injectedProfileIds;,     }, ,     private String logStringForArtifactFile( Artifact a ),     {,         if ( a.getFile() != null ),         {,             return a.getFile().getAbsolutePath();,         },         else,         {,             return "(no path)";,         },     }, ,     /**,      * Add or replace an artifact.,      * In spite of the 'throws' declaration on this API, this method has never thrown an exception since Maven 3.0.x.,      * Historically, it logged and ignored a second addition of the same g/a/v/c/t. Now it replaces the file for,      * the artifact, so that plugins (e.g. shade) can change the pathname of the file for a particular set of,      * coordinates.,      * @param artifact the artifact to add or replace.,      * @throws DuplicateArtifactAttachmentException,      */,     public void addAttachedArtifact( Artifact artifact ),         throws DuplicateArtifactAttachmentException,     {,         List<Artifact> attachedArtifacts = getAttachedArtifacts();,         for ( int ax = 0; ax < attachedArtifacts.size(); ax++ ),         {,             Artifact a = attachedArtifacts.get( ax );,             if ( a.equals( artifact ) ),             {,                 if ( logger != null ),                 {,                     logger.debug( String.format( "Replacing attached artifact %s. Old path %s, new path %s. ",,                                                  a,,                                                  logStringForArtifactFile( a ),,                                                  logStringForArtifactFile( artifact ) ) );,                 },                 attachedArtifacts.set( ax, artifact );,                 return;,             },         }, ,         getAttachedArtifacts().add( artifact );,     }, ,     public List<Artifact> getAttachedArtifacts(),     {,         if ( attachedArtifacts == null ),         {,             attachedArtifacts = new ArrayList<Artifact>();,         },         return attachedArtifacts;,     }, ,     public Xpp3Dom getGoalConfiguration( String pluginGroupId, String pluginArtifactId, String executionId,,                                          String goalId ),     {,         Xpp3Dom dom = null;, ,         if ( getBuildPlugins() != null ),         {,             for ( Plugin plugin : getBuildPlugins() ),             {,                 if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) ),                 {,                     dom = (Xpp3Dom) plugin.getConfiguration();, ,                     if ( executionId != null ),                     {,                         PluginExecution execution = plugin.getExecutionsAsMap().get( executionId );,                         if ( execution != null ),                         {,                             // NOTE: The PluginConfigurationExpander already merged the plugin-level config in,                             dom = (Xpp3Dom) execution.getConfiguration();,                         },                     },                     break;,                 },             },         }, ,         if ( dom != null ),         {,             // make a copy so the original in the POM doesn't get messed with,             dom = new Xpp3Dom( dom );,         }, ,         return dom;,     }, ,     @Deprecated,     public Xpp3Dom getReportConfiguration( String pluginGroupId, String pluginArtifactId, String reportSetId ),     {,         Xpp3Dom dom = null;, ,         // ----------------------------------------------------------------------,         // I would like to be able to lookup the Mojo object using a key but,         // we have a limitation in modello that will be remedied shortly. So,         // for now I have to iterate through and see what we have.,         // ----------------------------------------------------------------------, ,         if ( getReportPlugins() != null ),         {,             for ( ReportPlugin plugin : getReportPlugins() ),             {,                 if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) ),                 {,                     dom = (Xpp3Dom) plugin.getConfiguration();, ,                     if ( reportSetId != null ),                     {,                         ReportSet reportSet = plugin.getReportSetsAsMap().get( reportSetId );,                         if ( reportSet != null ),                         {,                             Xpp3Dom executionConfiguration = (Xpp3Dom) reportSet.getConfiguration();,                             if ( executionConfiguration != null ),                             {,                                 Xpp3Dom newDom = new Xpp3Dom( executionConfiguration );,                                 dom = Xpp3Dom.mergeXpp3Dom( newDom, dom );,                             },                         },                     },                     break;,                 },             },         }, ,         if ( dom != null ),         {,             // make a copy so the original in the POM doesn't get messed with,             dom = new Xpp3Dom( dom );,         }, ,         return dom;,     }, ,     public MavenProject getExecutionProject(),     {,         return ( executionProject == null ? this : executionProject );,     }, ,     public void setExecutionProject( MavenProject executionProject ),     {,         this.executionProject = executionProject;,     }, ,     public List<MavenProject> getCollectedProjects(),     {,         return collectedProjects;,     }, ,     public void setCollectedProjects( List<MavenProject> collectedProjects ),     {,         this.collectedProjects = collectedProjects;,     }, ,     /**,      * Direct dependencies that this project has.,      * ,      * @return {@link Set} &lt; {@link Artifact} >,      * @see #getArtifacts() to get all transitive dependencies,      */,     public Set<Artifact> getDependencyArtifacts(),     {,         return dependencyArtifacts;,     }, ,     public void setDependencyArtifacts( Set<Artifact> dependencyArtifacts ),     {,         this.dependencyArtifacts = dependencyArtifacts;,     }, ,     public void setReleaseArtifactRepository( ArtifactRepository releaseArtifactRepository ),     {,         this.releaseArtifactRepository = releaseArtifactRepository;,     }, ,     public void setSnapshotArtifactRepository( ArtifactRepository snapshotArtifactRepository ),     {,         this.snapshotArtifactRepository = snapshotArtifactRepository;,     }, ,     public void setOriginalModel( Model originalModel ),     {,         this.originalModel = originalModel;,     }, ,     public Model getOriginalModel(),     {,         return originalModel;,     }, ,     public void setManagedVersionMap( Map<String, Artifact> map ),     {,         managedVersionMap = map;,     }, ,     public Map<String, Artifact> getManagedVersionMap(),     {,         if ( managedVersionMap != null ),         {,             return managedVersionMap;,         }, ,         Map<String, Artifact> map = null;,         if ( repositorySystem != null ),         {, ,             List<Dependency> deps;,             DependencyManagement dependencyManagement = getDependencyManagement();,             if ( ( dependencyManagement != null ) && ( ( deps = dependencyManagement.getDependencies() ) != null ) && ( deps.size() > 0 ) ),             {,                 map = new HashMap<String, Artifact>();,                 for ( Dependency d : dependencyManagement.getDependencies() ),                 {,                     Artifact artifact = repositorySystem.createDependencyArtifact( d );, ,                     if ( artifact == null ),                     {,                         map = Collections.emptyMap();,                     }, ,                     map.put( d.getManagementKey(), artifact );,                 },             },             else,             {,                 map = Collections.emptyMap();,             },         },         managedVersionMap = map;,         return managedVersionMap;,     }, ,     @Override,     public boolean equals( Object other ),     {,         if ( other == this ),         {,             return true;,         },         else if ( !( other instanceof MavenProject ) ),         {,             return false;,         }, ,         MavenProject that = (MavenProject) other;, ,         return eq( getArtifactId(), that.getArtifactId() ),             && eq( getGroupId(), that.getGroupId() ),             && eq( getVersion(), that.getVersion() );,     }, ,     private static <T> boolean eq( T s1, T s2 ),     {,         return ( s1 != null ) ? s1.equals( s2 ) : s2 == null;,     }, ,     @Override,     public int hashCode(),     {,         int hash = 17;,         hash = 31 * hash + getGroupId().hashCode();,         hash = 31 * hash + getArtifactId().hashCode();,         hash = 31 * hash + getVersion().hashCode();,         return hash;,     }, ,     public List<Extension> getBuildExtensions(),     {,         Build build = getBuild();,         if ( ( build == null ) || ( build.getExtensions() == null ) ),         {,             return Collections.emptyList();,         },         else,         {,             return build.getExtensions();,         },     }, ,     public void addProjectReference( MavenProject project ),     {,         projectReferences.put( getProjectReferenceId( project.getGroupId(), project.getArtifactId(), project.getVersion() ), project );,     }, ,     /**,      * @deprecated Use MavenProjectHelper.attachArtifact(..) instead.,      */,     @Deprecated,     public void attachArtifact( String type, String classifier, File file ),     {,     }, ,     public Properties getProperties(),     {,         return getModel().getProperties();,     }, ,     public List<String> getFilters(),     {,         return getBuild().getFilters();,     }, ,     public Map<String, MavenProject> getProjectReferences(),     {,         return projectReferences;,     }, ,     public boolean isExecutionRoot(),     {,         return executionRoot;,     }, ,     public void setExecutionRoot( boolean executionRoot ),     {,         this.executionRoot = executionRoot;,     }, ,     public String getDefaultGoal(),     {,         return getBuild() != null ? getBuild().getDefaultGoal() : null;,     }, ,     public Plugin getPlugin( String pluginKey ),     {,         return getBuild().getPluginsAsMap().get( pluginKey );,     }, ,     /**,      * Default toString,      */,     @Override,     public String toString(),     {,         StringBuilder sb = new StringBuilder( 128 );,         sb.append( "MavenProject: " );,         sb.append( getGroupId() );,         sb.append( ":" );,         sb.append( getArtifactId() );,         sb.append( ":" );,         sb.append( getVersion() );,         sb.append( " @ " );, ,         try,         {,             sb.append( getFile().getPath() );,         },         catch ( NullPointerException e ),         {,             //don't log it.,         }, ,         return sb.toString();,     }, ,     /**,      * @deprecated Use {@link org.apache.maven.model.io.ModelWriter}.,      */,     @Deprecated,     public void writeModel( Writer writer ),         throws IOException,     {,         MavenXpp3Writer pomWriter = new MavenXpp3Writer();,         pomWriter.write( writer, getModel() );,     }, ,     /**,      * @deprecated Use {@link org.apache.maven.model.io.ModelWriter}.,      */,     @Deprecated,     public void writeOriginalModel( Writer writer ),         throws IOException,     {,         MavenXpp3Writer pomWriter = new MavenXpp3Writer();,         pomWriter.write( writer, getOriginalModel() );,     }, ,     /**,      * @throws CloneNotSupportedException,      * @since 2.0.9,      */,     @Override,     public MavenProject clone(),     {,         MavenProject clone;,         try,         {,             clone = (MavenProject) super.clone();,         },         catch ( CloneNotSupportedException e ),         {,             throw new UnsupportedOperationException( e );,         }, ,         clone.deepCopy( this );, ,         return clone;,     }, ,     protected void setModel( Model model ),     {,         this.model = model;,     }, ,     protected void setAttachedArtifacts( List<Artifact> attachedArtifacts ),     {,         this.attachedArtifacts = attachedArtifacts;,     }, ,     protected void setCompileSourceRoots( List<String> compileSourceRoots ),     {,         this.compileSourceRoots = compileSourceRoots;,     }, ,     protected void setTestCompileSourceRoots( List<String> testCompileSourceRoots ),     {,         this.testCompileSourceRoots = testCompileSourceRoots;,     }, ,     protected void setScriptSourceRoots( List<String> scriptSourceRoots ),     {,         this.scriptSourceRoots = scriptSourceRoots;,     }, ,     protected ArtifactRepository getReleaseArtifactRepository(),     {,         if ( releaseArtifactRepository == null ),         {,             if ( getDistributionManagement() != null && getDistributionManagement().getRepository() != null ),             {,                 checkProjectBuildingRequest();,                 try,                 {,                     ArtifactRepository repo =,                         repositorySystem.buildArtifactRepository( getDistributionManagement().getRepository() );,                     repositorySystem.injectProxy( projectBuilderConfiguration.getRepositorySession(),,                                                   Arrays.asList( repo ) );,                     repositorySystem.injectAuthentication( projectBuilderConfiguration.getRepositorySession(),,                                                            Arrays.asList( repo ) );,                     setReleaseArtifactRepository( repo );,                 },                 catch ( InvalidRepositoryException e ),                 {,                     throw new IllegalStateException( "Failed to create release distribution repository for " + getId(),,                                                      e );,                 },             },         }, ,         return releaseArtifactRepository;,     }, ,     protected ArtifactRepository getSnapshotArtifactRepository(),     {,         if ( snapshotArtifactRepository == null ),         {,             if ( getDistributionManagement() != null && getDistributionManagement().getSnapshotRepository() != null ),             {,                 checkProjectBuildingRequest();,                 try,                 {,                     ArtifactRepository repo =,                         repositorySystem.buildArtifactRepository( getDistributionManagement().getSnapshotRepository() );,                     repositorySystem.injectProxy( projectBuilderConfiguration.getRepositorySession(),,                                                   Arrays.asList( repo ) );,                     repositorySystem.injectAuthentication( projectBuilderConfiguration.getRepositorySession(),,                                                            Arrays.asList( repo ) );,                     setSnapshotArtifactRepository( repo );,                 },                 catch ( InvalidRepositoryException e ),                 {,                     throw new IllegalStateException(,                                                      "Failed to create snapshot distribution repository for " + getId(),,                                                      e );,                 },             },         }, ,         return snapshotArtifactRepository;,     }, ,     @Deprecated,     public Artifact replaceWithActiveArtifact( Artifact pluginArtifact ),     {,         return pluginArtifact;,     }, ,     private void deepCopy( MavenProject project ),     {,         // disown the parent, ,         // copy fields,         setFile( project.getFile() );, ,         // don't need a deep copy, they don't get modified or added/removed to/from - but make them unmodifiable to be,         // sure!,         if ( project.getDependencyArtifacts() != null ),         {,             setDependencyArtifacts( Collections.unmodifiableSet( project.getDependencyArtifacts() ) );,         }, ,         if ( project.getArtifacts() != null ),         {,             setArtifacts( Collections.unmodifiableSet( project.getArtifacts() ) );,         }, ,         if ( project.getParentFile() != null ),         {,             parentFile = new File( project.getParentFile().getAbsolutePath() );,         }, ,         if ( project.getPluginArtifacts() != null ),         {,             setPluginArtifacts( Collections.unmodifiableSet( project.getPluginArtifacts() ) );,         }, ,         if ( project.getReportArtifacts() != null ),         {,             setReportArtifacts( Collections.unmodifiableSet( project.getReportArtifacts() ) );,         }, ,         if ( project.getExtensionArtifacts() != null ),         {,             setExtensionArtifacts( Collections.unmodifiableSet( project.getExtensionArtifacts() ) );,         }, ,         setParentArtifact( ( project.getParentArtifact() ) );, ,         if ( project.getRemoteArtifactRepositories() != null ),         {,             setRemoteArtifactRepositories( Collections.unmodifiableList( project.getRemoteArtifactRepositories() ) );,         }, ,         if ( project.getPluginArtifactRepositories() != null ),         {,             setPluginArtifactRepositories( ( Collections.unmodifiableList( project.getPluginArtifactRepositories() ) ) );,         }, ,         if ( project.getActiveProfiles() != null ),         {,             setActiveProfiles( ( Collections.unmodifiableList( project.getActiveProfiles() ) ) );,         }, ,         if ( project.getAttachedArtifacts() != null ),         {,             // clone properties modifyable by plugins in a forked lifecycle,             setAttachedArtifacts( new ArrayList<Artifact>( project.getAttachedArtifacts() ) );,         }, ,         if ( project.getCompileSourceRoots() != null ),         {,             // clone source roots,             setCompileSourceRoots( ( new ArrayList<String>( project.getCompileSourceRoots() ) ) );,         }, ,         if ( project.getTestCompileSourceRoots() != null ),         {,             setTestCompileSourceRoots( ( new ArrayList<String>( project.getTestCompileSourceRoots() ) ) );,         }, ,         if ( project.getScriptSourceRoots() != null ),         {,             setScriptSourceRoots( ( new ArrayList<String>( project.getScriptSourceRoots() ) ) );,         }, ,         if ( project.getModel() != null ),         {,             setModel( project.getModel().clone() );,         }, ,         if ( project.getOriginalModel() != null ),         {,             setOriginalModel( project.getOriginalModel() );,         }, ,         setExecutionRoot( project.isExecutionRoot() );, ,         if ( project.getArtifact() != null ),         {,             setArtifact( ArtifactUtils.copyArtifact( project.getArtifact() ) );,         }, ,         if ( project.getManagedVersionMap() != null ),         {,             setManagedVersionMap( new HashMap<String, Artifact>( project.getManagedVersionMap() ) );,         }, ,         lifecyclePhases.addAll( project.lifecyclePhases );,     }, ,     private void addArtifactPath( Artifact artifact, List<String> classpath ),     {,         File file = artifact.getFile();,         if ( file != null ),         {,             classpath.add( file.getPath() );,         },     }, ,     private static String getProjectReferenceId( String groupId, String artifactId, String version ),     {,         StringBuilder buffer = new StringBuilder( 128 );,         buffer.append( groupId ).append( ':' ).append( artifactId ).append( ':' ).append( version );,         return buffer.toString();,     }, ,     /**,      * Sets the value of the context value of this project identified,      * by the given key. If the supplied value is <code>null</code>,,      * the context value is removed from this project.,      * ,      * Context values are intended to allow core extensions to associate,      * derived state with project instances. ,      */,     public void setContextValue( String key, Object value ),     {,         if ( context == null ),         {,             context = new HashMap<String, Object>();,         },         if ( value != null ),         {,             context.put( key, value );,         },         else,         {,             context.remove( key );,         },     }, ,     /**,      * Returns context value of this project associated with the given key ,      * or null if this project has no such value. ,      */,     public Object getContextValue( String key ),     {,         if ( context == null ),         {,             return null;,         },         return context.get( key );,     }, ,     /**,      * Sets the project's class realm. <strong>Warning:</strong> This is an internal utility method that is only public,      * for technical reasons, it is not part of the public API. In particular, this method can be changed or deleted,      * without prior notice and must not be used by plugins.,      * ,      * @param classRealm The class realm hosting the build extensions of this project, may be {@code null}.,      */,     public void setClassRealm( ClassRealm classRealm ),     {,         this.classRealm = classRealm;,     }, ,     /**,      * Gets the project's class realm. This class realm hosts the build extensions of the project.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @return The project's class realm or {@code null}.,      */,     public ClassRealm getClassRealm(),     {,         return classRealm;,     }, ,     /**,      * Sets the artifact filter used to exclude shared extension artifacts from plugin realms. <strong>Warning:</strong>,      * This is an internal utility method that is only public for technical reasons, it is not part of the public API.,      * In particular, this method can be changed or deleted without prior notice and must not be used by plugins.,      * ,      * @param extensionDependencyFilter The dependency filter to apply to plugins, may be {@code null}.,      */,     public void setExtensionDependencyFilter( DependencyFilter extensionDependencyFilter ),     {,         this.extensionDependencyFilter = extensionDependencyFilter;,     }, ,     /**,      * Gets the dependency filter used to exclude shared extension artifacts from plugin realms.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @return The dependency filter or {@code null}.,      */,     public DependencyFilter getExtensionDependencyFilter(),     {,         return extensionDependencyFilter;,     }, ,     /**,      * Sets the transitive dependency artifacts that have been resolved/collected for this project.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param artifacts The set of artifacts, may be {@code null}.,      */,     public void setResolvedArtifacts( Set<Artifact> artifacts ),     {,         this.resolvedArtifacts = ( artifacts != null ) ? artifacts : Collections.<Artifact> emptySet();,         this.artifacts = null;,         this.artifactMap = null;,     }, ,     /**,      * Sets the scope filter to select the artifacts being exposed to the currently executed mojo.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param artifactFilter The artifact filter, may be {@code null} to exclude all artifacts.,      */,     public void setArtifactFilter( ArtifactFilter artifactFilter ),     {,         this.artifactFilter = artifactFilter;,         this.artifacts = null;,         this.artifactMap = null;,     }, ,     /**,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param phase The phase to check for, must not be {@code null}.,      * @return {@code true} if the phase has been seen.,      */,     public boolean hasLifecyclePhase( String phase ),     {,         return lifecyclePhases.contains( phase );,     }, ,     /**,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param lifecyclePhase The lifecycle phase to add, must not be {@code null}.,      */,     public void addLifecyclePhase( String lifecyclePhase ),     {,         lifecyclePhases.add( lifecyclePhase );,     }, ,     /**,      * Gets the project building request from which this project instance was created. <strong>Warning:</strong> This is,      * an utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.,      * ,      * @return The project building request or {@code null}.,      * @since 2.1,      */,     public ProjectBuildingRequest getProjectBuildingRequest(),     {,         return projectBuilderConfiguration;,     }, ,     /**,      * Sets the project building request from which this project instance was created. <strong>Warning:</strong> This is,      * an utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.,      * ,      * @param projectBuildingRequest The project building request, may be {@code null}.,      * @since 2.1,      */,     public void setProjectBuildingRequest( ProjectBuildingRequest projectBuildingRequest ),     {,         projectBuilderConfiguration = projectBuildingRequest;,     }, ,     private void checkProjectBuildingRequest(),     {,         if ( projectBuilderConfiguration == null ),         {,             throw new IllegalStateException( "project building request missing" );,         },     }],,
STYLE,UC_USELESS_OBJECT,org/apache/maven/plugin/PluginManagerTest.java,testPluginRealmCache,281-281,[        RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();],,
STYLE,UC_USELESS_OBJECT,org/apache/maven/plugin/PluginManagerTest.java,testThatPluginDependencyThatHasSystemScopeIsResolved,242-242,[        RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/maven/plugin/descriptor/Parameter.java,,25-203,[public class Parameter,     implements Cloneable, {,     private String alias;, ,     private String name;, ,     private String type;, ,     private boolean required;, ,     private boolean editable = true;, ,     private String description;, ,     private String expression;, ,     private String deprecated;, ,     private String defaultValue;, ,     private String implementation;, ,     private Requirement requirement;, ,     private String since;, ,     // ----------------------------------------------------------------------,     //,     // ----------------------------------------------------------------------, ,     public String getName(),     {,         return name;,     }, ,     public void setName( String name ),     {,         this.name = name;,     }, ,     public String getType(),     {,         return type;,     }, ,     public void setType( String type ),     {,         this.type = type;,     }, ,     public boolean isRequired(),     {,         return required;,     }, ,     public void setRequired( boolean required ),     {,         this.required = required;,     }, ,     public String getDescription(),     {,         return description;,     }, ,     public void setDescription( String description ),     {,         this.description = description;,     }, ,     public String getExpression(),     {,         return expression;,     }, ,     public void setExpression( String expression ),     {,         this.expression = expression;,     }, ,     public String getDeprecated(),     {,         return deprecated;,     }, ,     public void setDeprecated( String deprecated ),     {,         this.deprecated = deprecated;,     }, ,     public int hashCode(),     {,         return name.hashCode();,     }, ,     public boolean equals( Object other ),     {,         return ( other instanceof Parameter ) && getName().equals( ( (Parameter) other ).getName() );,     }, ,     public String getAlias(),     {,         return alias;,     }, ,     public void setAlias( String alias ),     {,         this.alias = alias;,     }, ,     public boolean isEditable(),     {,         return editable;,     }, ,     public void setEditable( boolean editable ),     {,         this.editable = editable;,     }, ,     public void setDefaultValue( String defaultValue ),     {,         this.defaultValue = defaultValue;,     }, ,     public String getDefaultValue(),     {,         return defaultValue;,     }, ,     public String toString(),     {,         return "Mojo parameter [name: \'" + getName() + "\'; alias: \'" + getAlias() + "\']";,     }, ,     public Requirement getRequirement(),     {,         return requirement;,     }, ,     public void setRequirement( Requirement requirement ),     {,         this.requirement = requirement;,     }, ,     public String getImplementation(),     {,         return implementation;,     }, ,     public void setImplementation( String implementation ),     {,         this.implementation = implementation;,     }, ,     public String getSince(),     {,         return since;,     }, ,     public void setSince( String since ),     {,         this.since = since;,     }, ,     /**,      * Creates a shallow copy of this parameter.,      */,     @Override,     public Parameter clone(),     {,         try,         {,             return (Parameter) super.clone();,         },         catch ( CloneNotSupportedException e ),         {,             throw new UnsupportedOperationException( e );],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/maven/plugin/PluginParameterExpressionEvaluator.java,evaluate,379-379,[            if ( ( value == null ) && ( properties != null ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/PluginParameterExpressionEvaluator.java,evaluate,389-389,[            if ( ( value == null ) && ( ( project != null ) && ( project.getProperties() != null ) ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/maven/plugin/PluginParameterExpressionEvaluator.java,evaluate,379-379,[            if ( ( value == null ) && ( properties != null ) )],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/maven/plugin/PluginParameterExpressionEvaluator.java,<init>,95-95,[        this.properties = session.getExecutionProperties();],,<init>,111-111,[        if ( ( basedir == null ) && ( session != null ) )],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/plugin/PluginParameterExpressionEvaluatorTest.java,createArtifact,440-440,[        return factory.createDependencyArtifact( dependency );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/plugin/PluginParameterExpressionEvaluatorTest.java,createArtifact,454-454,[        return factory.createDependencyArtifact( dependency );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/plugin/PluginParameterExpressionEvaluatorTest.java,createExpressionEvaluator,415-415,[        ArtifactRepository repo = factory.createDefaultLocalRepository();],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/maven/plugin/descriptor/MojoDescriptor.java,compareObjects,562-562,[        return first.equals( second );],,compareObjects,557-557,[        if ( ( first == null && second != null ) || ( first != null && second == null ) )],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/plugin/descriptor/Parameter.java,hashCode,118-118,[        return name.hashCode();],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/maven/plugin/descriptor/PluginDescriptor.java,equals,275-275,[        return getId().equals( ( (PluginDescriptor) object ).getId() );],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/maven/plugin/descriptor/PluginDescriptor.java,equals,270-275,[        if ( this == object ),         {,             return true;,         }, ,         return getId().equals( ( (PluginDescriptor) object ).getId() );],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/maven/plugin/descriptor/PluginDescriptorBuilderTest.java,build,45-45,[        Reader reader = ReaderFactory.newXmlReader( getClass().getResourceAsStream( resource ) );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/descriptor/model/Configuration.java,,14-106,[public class Configuration,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Parameter expression, to let user override default value,      * with a system property, pom property or settings property.,      */,     private String expression;, ,     /**,      * Field implementation.,      */,     private String implementation;, ,     /**,      * The default value, as an expression that will be evaluated,      * at injection or run-time.,      */,     private String defaultValue;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get the default value, as an expression that will be,      * evaluated at injection or run-time.,      * ,      * @return String,      */,     public String getDefaultValue(),     {,         return this.defaultValue;,     } //-- String getDefaultValue(), ,     /**,      * Get parameter expression, to let user override default value,      * with a system property, pom property or settings property.,      * ,      * @return String,      */,     public String getExpression(),     {,         return this.expression;,     } //-- String getExpression(), ,     /**,      * Get the implementation field.,      * ,      * @return String,      */,     public String getImplementation(),     {,         return this.implementation;,     } //-- String getImplementation(), ,     /**,      * Set the default value, as an expression that will be,      * evaluated at injection or run-time.,      * ,      * @param defaultValue,      */,     public void setDefaultValue( String defaultValue ),     {,         this.defaultValue = defaultValue;,     } //-- void setDefaultValue( String ), ,     /**,      * Set parameter expression, to let user override default value,      * with a system property, pom property or settings property.,      * ,      * @param expression,      */,     public void setExpression( String expression ),     {,         this.expression = expression;,     } //-- void setExpression( String ), ,     /**,      * Set the implementation field.,      * ,      * @param implementation,      */,     public void setImplementation( String implementation ),     {,         this.implementation = implementation;,     } //-- void setImplementation( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/descriptor/model/Dependency.java,,14-125,[public class Dependency,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The group id of the dependency.,      */,     private String groupId;, ,     /**,      * The artifact id of the dependency.,      */,     private String artifactId;, ,     /**,      * The version of the dependency.,      */,     private String version;, ,     /**,      * The type of dependency.,      */,     private String type = "jar";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get the artifact id of the dependency.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Get the group id of the dependency.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * Get the type of dependency.,      * ,      * @return String,      */,     public String getType(),     {,         return this.type;,     } //-- String getType(), ,     /**,      * Get the version of the dependency.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Set the artifact id of the dependency.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set the group id of the dependency.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * Set the type of dependency.,      * ,      * @param type,      */,     public void setType( String type ),     {,         this.type = type;,     } //-- void setType( String ), ,     /**,      * Set the version of the dependency.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/descriptor/model/MojoDescriptor.java,,16-911,[public class MojoDescriptor,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             The goal name for the Mojo, that users will,      * reference from the command line to execute the Mojo,      * directly,,      *             or inside a POM in order to provide,      * Mojo-specific configuration.,      *           ,      */,     private String goal;, ,     /**,      * The description of this Mojo's functionality.,      */,     private String description;, ,     /**,      * ,      *             The Mojo's fully-qualified class name (or script,      * path in the case of non-Java Mojos).,      *           ,      */,     private String implementation;, ,     /**,      * The implementation language for this Mojo (java, beanshell,,      * etc.).,      */,     private String language = "java";, ,     /**,      * ,      *             Defines a default phase to bind a mojo execution,      * to if the user does not explicitly set a phase in the POM.,      *             <i>Note:</i> This will not automagically make a,      * mojo run when the plugin declaration is added,      *             to the POM. It merely enables the user to omit,      * the <code>&lt;phase&gt;</code> element from the,      *             surrounding <code>&lt;execution&gt;</code>,      * element.,      *           ,      */,     private String phase;, ,     /**,      * Reference the invocation phase of the Mojo.,      */,     private String executePhase;, ,     /**,      * Reference the invocation goal of the Mojo.,      */,     private String executeGoal;, ,     /**,      * Field executeLifecycle.,      */,     private String executeLifecycle;, ,     /**,      * ,      *             Flags this Mojo as requiring the dependencies in,      * the specified class path to be resolved before it can,      *             execute: <code>compile</code>,,      * <code>runtime</code>, <code>test</code>,,      *             <code>compile+runtime</code> (since Maven 3.0),      * or <code>runtime+system</code> (since Maven 3.0),      *           .,      */,     private String requiresDependencyResolution = "runtime";, ,     /**,      * ,      *             Flags this mojo as requiring information about,      * the dependencies that would make up the specified class,      *             path. As the name suggests, this is similar to,      * requiresDependencyResolution and supports the same values.,      *             The important difference is this will not,      * resolve the files for the dependencies, i.e. the artifacts,      *             associated with a Maven project can lack a file.,      * As such, this annotation is meant for mojos that only,      *             want to analyze the set of transitive,      * dependencies, in particular during early lifecycle phases,      * where,      *             full dependency resolution might fail due to,      * projects which haven't been built yet.,      *           ,      */,     private String requiresDependencyCollection;, ,     /**,      * Flags this Mojo to be invoked directly only.,      */,     private boolean requiresDirectInvocation = false;, ,     /**,      * Flags this Mojo to require running inside of a project.,      */,     private boolean requiresProject = true;, ,     /**,      * Flags this Mojo to require running inside of a reports,      * context. Unsupported since Maven 3.0.,      */,     private boolean requiresReports = false;, ,     /**,      * Flags this Mojo to require online mode for its operation.,      */,     private boolean requiresOnline = false;, ,     /**,      * ,      *             Flags this Mojo to run it in a multi module way,,      * i.e. aggregate the build with the set of projects,      *             listed as modules.,      *           ,      */,     private boolean aggregator = false;, ,     /**,      * Specify that the Mojo is inherited.,      */,     private boolean inheritedByDefault = true;, ,     /**,      * ,      *             Marks this mojo as being thread-safe, i.e. the,      * mojo safely supports concurrent execution during parallel,      *             builds. Mojos without this annotation will make,      * Maven output a warning when used during a parallel build,      *             session. Since Maven 3.0.,      *           ,      */,     private boolean threadSafe = false;, ,     /**,      * Specify the instantiation strategy.,      */,     private String instantiationStrategy = "per-lookup";, ,     /**,      * ,      *             Specify the execution strategy:,      * <code>once-per-session</code>, <code>always</code>.,      *           ,      */,     private String executionStrategy = "once-per-session";, ,     /**,      * Specify the version when the Mojo was added to the API.,      * Similar to Javadoc since.,      */,     private String since;, ,     /**,      * ,      *             Specify the version when the Mojo was deprecated,      * to the API. Similar to Javadoc deprecated. This will,      *             trigger a warning when a user tries to configure,      * a parameter marked as deprecated.,      *           ,      */,     private String deprecated;, ,     /**,      * ,      *             The configurator type to use when injecting,      * parameter values into this Mojo. The value is normally,      * deduced,      *             from the Mojo's implementation language, but can,      * be specified to allow a custom ComponentConfigurator,      *             implementation to be used.,      *           ,      */,     private String configurator;, ,     /**,      * Field composer.,      */,     private String composer;, ,     /**,      * Field parameters.,      */,     private java.util.List<Parameter> parameters;, ,     /**,      * Field configuration.,      */,     private java.util.List<Configuration> configuration;, ,     /**,      * Field requirements.,      */,     private java.util.List<Requirement> requirements;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addConfiguration.,      * ,      * @param configuration,      */,     public void addConfiguration( Configuration configuration ),     {,         getConfiguration().add( configuration );,     } //-- void addConfiguration( Configuration ), ,     /**,      * Method addParameter.,      * ,      * @param parameter,      */,     public void addParameter( Parameter parameter ),     {,         getParameters().add( parameter );,     } //-- void addParameter( Parameter ), ,     /**,      * Method addRequirement.,      * ,      * @param requirement,      */,     public void addRequirement( Requirement requirement ),     {,         getRequirements().add( requirement );,     } //-- void addRequirement( Requirement ), ,     /**,      * Get the composer field.,      * ,      * @return String,      */,     public String getComposer(),     {,         return this.composer;,     } //-- String getComposer(), ,     /**,      * Method getConfiguration.,      * ,      * @return List,      */,     public java.util.List<Configuration> getConfiguration(),     {,         if ( this.configuration == null ),         {,             this.configuration = new java.util.ArrayList<Configuration>();,         }, ,         return this.configuration;,     } //-- java.util.List<Configuration> getConfiguration(), ,     /**,      * Get the configurator type to use when injecting parameter,      * values into this Mojo. The value is normally deduced,      *             from the Mojo's implementation language, but can,      * be specified to allow a custom ComponentConfigurator,      *             implementation to be used.,      * ,      * @return String,      */,     public String getConfigurator(),     {,         return this.configurator;,     } //-- String getConfigurator(), ,     /**,      * Get specify the version when the Mojo was deprecated to the,      * API. Similar to Javadoc deprecated. This will,      *             trigger a warning when a user tries to configure,      * a parameter marked as deprecated.,      * ,      * @return String,      */,     public String getDeprecated(),     {,         return this.deprecated;,     } //-- String getDeprecated(), ,     /**,      * Get the description of this Mojo's functionality.,      * ,      * @return String,      */,     public String getDescription(),     {,         return this.description;,     } //-- String getDescription(), ,     /**,      * Get reference the invocation goal of the Mojo.,      * ,      * @return String,      */,     public String getExecuteGoal(),     {,         return this.executeGoal;,     } //-- String getExecuteGoal(), ,     /**,      * Get the executeLifecycle field.,      * ,      * @return String,      */,     public String getExecuteLifecycle(),     {,         return this.executeLifecycle;,     } //-- String getExecuteLifecycle(), ,     /**,      * Get reference the invocation phase of the Mojo.,      * ,      * @return String,      */,     public String getExecutePhase(),     {,         return this.executePhase;,     } //-- String getExecutePhase(), ,     /**,      * Get specify the execution strategy:,      * <code>once-per-session</code>, <code>always</code>.,      * ,      * @return String,      */,     public String getExecutionStrategy(),     {,         return this.executionStrategy;,     } //-- String getExecutionStrategy(), ,     /**,      * Get the goal name for the Mojo, that users will reference,      * from the command line to execute the Mojo directly,,      *             or inside a POM in order to provide,      * Mojo-specific configuration.,      * ,      * @return String,      */,     public String getGoal(),     {,         return this.goal;,     } //-- String getGoal(), ,     /**,      * Get the Mojo's fully-qualified class name (or script path in,      * the case of non-Java Mojos).,      * ,      * @return String,      */,     public String getImplementation(),     {,         return this.implementation;,     } //-- String getImplementation(), ,     /**,      * Get specify the instantiation strategy.,      * ,      * @return String,      */,     public String getInstantiationStrategy(),     {,         return this.instantiationStrategy;,     } //-- String getInstantiationStrategy(), ,     /**,      * Get the implementation language for this Mojo (java,,      * beanshell, etc.).,      * ,      * @return String,      */,     public String getLanguage(),     {,         return this.language;,     } //-- String getLanguage(), ,     /**,      * Method getParameters.,      * ,      * @return List,      */,     public java.util.List<Parameter> getParameters(),     {,         if ( this.parameters == null ),         {,             this.parameters = new java.util.ArrayList<Parameter>();,         }, ,         return this.parameters;,     } //-- java.util.List<Parameter> getParameters(), ,     /**,      * Get defines a default phase to bind a mojo execution to if,      * the user does not explicitly set a phase in the POM.,      *             <i>Note:</i> This will not automagically make a,      * mojo run when the plugin declaration is added,      *             to the POM. It merely enables the user to omit,      * the <code>&lt;phase&gt;</code> element from the,      *             surrounding <code>&lt;execution&gt;</code>,      * element.,      * ,      * @return String,      */,     public String getPhase(),     {,         return this.phase;,     } //-- String getPhase(), ,     /**,      * Method getRequirements.,      * ,      * @return List,      */,     public java.util.List<Requirement> getRequirements(),     {,         if ( this.requirements == null ),         {,             this.requirements = new java.util.ArrayList<Requirement>();,         }, ,         return this.requirements;,     } //-- java.util.List<Requirement> getRequirements(), ,     /**,      * Get flags this mojo as requiring information about the,      * dependencies that would make up the specified class,      *             path. As the name suggests, this is similar to,      * requiresDependencyResolution and supports the same values.,      *             The important difference is this will not,      * resolve the files for the dependencies, i.e. the artifacts,      *             associated with a Maven project can lack a file.,      * As such, this annotation is meant for mojos that only,      *             want to analyze the set of transitive,      * dependencies, in particular during early lifecycle phases,      * where,      *             full dependency resolution might fail due to,      * projects which haven't been built yet.,      * ,      * @return String,      */,     public String getRequiresDependencyCollection(),     {,         return this.requiresDependencyCollection;,     } //-- String getRequiresDependencyCollection(), ,     /**,      * Get flags this Mojo as requiring the dependencies in the,      * specified class path to be resolved before it can,      *             execute: <code>compile</code>,,      * <code>runtime</code>, <code>test</code>,,      *             <code>compile+runtime</code> (since Maven 3.0),      * or <code>runtime+system</code> (since Maven 3.0).,      * ,      * @return String,      */,     public String getRequiresDependencyResolution(),     {,         return this.requiresDependencyResolution;,     } //-- String getRequiresDependencyResolution(), ,     /**,      * Get specify the version when the Mojo was added to the API.,      * Similar to Javadoc since.,      * ,      * @return String,      */,     public String getSince(),     {,         return this.since;,     } //-- String getSince(), ,     /**,      * Get flags this Mojo to run it in a multi module way, i.e.,      * aggregate the build with the set of projects,      *             listed as modules.,      * ,      * @return boolean,      */,     public boolean isAggregator(),     {,         return this.aggregator;,     } //-- boolean isAggregator(), ,     /**,      * Get specify that the Mojo is inherited.,      * ,      * @return boolean,      */,     public boolean isInheritedByDefault(),     {,         return this.inheritedByDefault;,     } //-- boolean isInheritedByDefault(), ,     /**,      * Get flags this Mojo to be invoked directly only.,      * ,      * @return boolean,      */,     public boolean isRequiresDirectInvocation(),     {,         return this.requiresDirectInvocation;,     } //-- boolean isRequiresDirectInvocation(), ,     /**,      * Get flags this Mojo to require online mode for its,      * operation.,      * ,      * @return boolean,      */,     public boolean isRequiresOnline(),     {,         return this.requiresOnline;,     } //-- boolean isRequiresOnline(), ,     /**,      * Get flags this Mojo to require running inside of a project.,      * ,      * @return boolean,      */,     public boolean isRequiresProject(),     {,         return this.requiresProject;,     } //-- boolean isRequiresProject(), ,     /**,      * Get flags this Mojo to require running inside of a reports,      * context. Unsupported since Maven 3.0.,      * ,      * @return boolean,      */,     public boolean isRequiresReports(),     {,         return this.requiresReports;,     } //-- boolean isRequiresReports(), ,     /**,      * Get marks this mojo as being thread-safe, i.e. the mojo,      * safely supports concurrent execution during parallel,      *             builds. Mojos without this annotation will make,      * Maven output a warning when used during a parallel build,      *             session. Since Maven 3.0.,      * ,      * @return boolean,      */,     public boolean isThreadSafe(),     {,         return this.threadSafe;,     } //-- boolean isThreadSafe(), ,     /**,      * Method removeConfiguration.,      * ,      * @param configuration,      */,     public void removeConfiguration( Configuration configuration ),     {,         getConfiguration().remove( configuration );,     } //-- void removeConfiguration( Configuration ), ,     /**,      * Method removeParameter.,      * ,      * @param parameter,      */,     public void removeParameter( Parameter parameter ),     {,         getParameters().remove( parameter );,     } //-- void removeParameter( Parameter ), ,     /**,      * Method removeRequirement.,      * ,      * @param requirement,      */,     public void removeRequirement( Requirement requirement ),     {,         getRequirements().remove( requirement );,     } //-- void removeRequirement( Requirement ), ,     /**,      * Set flags this Mojo to run it in a multi module way, i.e.,      * aggregate the build with the set of projects,      *             listed as modules.,      * ,      * @param aggregator,      */,     public void setAggregator( boolean aggregator ),     {,         this.aggregator = aggregator;,     } //-- void setAggregator( boolean ), ,     /**,      * Set the composer field.,      * ,      * @param composer,      */,     public void setComposer( String composer ),     {,         this.composer = composer;,     } //-- void setComposer( String ), ,     /**,      * Set the configuration field.,      * ,      * @param configuration,      */,     public void setConfiguration( java.util.List<Configuration> configuration ),     {,         this.configuration = configuration;,     } //-- void setConfiguration( java.util.List ), ,     /**,      * Set the configurator type to use when injecting parameter,      * values into this Mojo. The value is normally deduced,      *             from the Mojo's implementation language, but can,      * be specified to allow a custom ComponentConfigurator,      *             implementation to be used.,      * ,      * @param configurator,      */,     public void setConfigurator( String configurator ),     {,         this.configurator = configurator;,     } //-- void setConfigurator( String ), ,     /**,      * Set specify the version when the Mojo was deprecated to the,      * API. Similar to Javadoc deprecated. This will,      *             trigger a warning when a user tries to configure,      * a parameter marked as deprecated.,      * ,      * @param deprecated,      */,     public void setDeprecated( String deprecated ),     {,         this.deprecated = deprecated;,     } //-- void setDeprecated( String ), ,     /**,      * Set the description of this Mojo's functionality.,      * ,      * @param description,      */,     public void setDescription( String description ),     {,         this.description = description;,     } //-- void setDescription( String ), ,     /**,      * Set reference the invocation goal of the Mojo.,      * ,      * @param executeGoal,      */,     public void setExecuteGoal( String executeGoal ),     {,         this.executeGoal = executeGoal;,     } //-- void setExecuteGoal( String ), ,     /**,      * Set the executeLifecycle field.,      * ,      * @param executeLifecycle,      */,     public void setExecuteLifecycle( String executeLifecycle ),     {,         this.executeLifecycle = executeLifecycle;,     } //-- void setExecuteLifecycle( String ), ,     /**,      * Set reference the invocation phase of the Mojo.,      * ,      * @param executePhase,      */,     public void setExecutePhase( String executePhase ),     {,         this.executePhase = executePhase;,     } //-- void setExecutePhase( String ), ,     /**,      * Set specify the execution strategy:,      * <code>once-per-session</code>, <code>always</code>.,      * ,      * @param executionStrategy,      */,     public void setExecutionStrategy( String executionStrategy ),     {,         this.executionStrategy = executionStrategy;,     } //-- void setExecutionStrategy( String ), ,     /**,      * Set the goal name for the Mojo, that users will reference,      * from the command line to execute the Mojo directly,,      *             or inside a POM in order to provide,      * Mojo-specific configuration.,      * ,      * @param goal,      */,     public void setGoal( String goal ),     {,         this.goal = goal;,     } //-- void setGoal( String ), ,     /**,      * Set the Mojo's fully-qualified class name (or script path in,      * the case of non-Java Mojos).,      * ,      * @param implementation,      */,     public void setImplementation( String implementation ),     {,         this.implementation = implementation;,     } //-- void setImplementation( String ), ,     /**,      * Set specify that the Mojo is inherited.,      * ,      * @param inheritedByDefault,      */,     public void setInheritedByDefault( boolean inheritedByDefault ),     {,         this.inheritedByDefault = inheritedByDefault;,     } //-- void setInheritedByDefault( boolean ), ,     /**,      * Set specify the instantiation strategy.,      * ,      * @param instantiationStrategy,      */,     public void setInstantiationStrategy( String instantiationStrategy ),     {,         this.instantiationStrategy = instantiationStrategy;,     } //-- void setInstantiationStrategy( String ), ,     /**,      * Set the implementation language for this Mojo (java,,      * beanshell, etc.).,      * ,      * @param language,      */,     public void setLanguage( String language ),     {,         this.language = language;,     } //-- void setLanguage( String ), ,     /**,      * Set the parameters field.,      * ,      * @param parameters,      */,     public void setParameters( java.util.List<Parameter> parameters ),     {,         this.parameters = parameters;,     } //-- void setParameters( java.util.List ), ,     /**,      * Set defines a default phase to bind a mojo execution to if,      * the user does not explicitly set a phase in the POM.,      *             <i>Note:</i> This will not automagically make a,      * mojo run when the plugin declaration is added,      *             to the POM. It merely enables the user to omit,      * the <code>&lt;phase&gt;</code> element from the,      *             surrounding <code>&lt;execution&gt;</code>,      * element.,      * ,      * @param phase,      */,     public void setPhase( String phase ),     {,         this.phase = phase;,     } //-- void setPhase( String ), ,     /**,      * Set the requirements field.,      * ,      * @param requirements,      */,     public void setRequirements( java.util.List<Requirement> requirements ),     {,         this.requirements = requirements;,     } //-- void setRequirements( java.util.List ), ,     /**,      * Set flags this mojo as requiring information about the,      * dependencies that would make up the specified class,      *             path. As the name suggests, this is similar to,      * requiresDependencyResolution and supports the same values.,      *             The important difference is this will not,      * resolve the files for the dependencies, i.e. the artifacts,      *             associated with a Maven project can lack a file.,      * As such, this annotation is meant for mojos that only,      *             want to analyze the set of transitive,      * dependencies, in particular during early lifecycle phases,      * where,      *             full dependency resolution might fail due to,      * projects which haven't been built yet.,      * ,      * @param requiresDependencyCollection,      */,     public void setRequiresDependencyCollection( String requiresDependencyCollection ),     {,         this.requiresDependencyCollection = requiresDependencyCollection;,     } //-- void setRequiresDependencyCollection( String ), ,     /**,      * Set flags this Mojo as requiring the dependencies in the,      * specified class path to be resolved before it can,      *             execute: <code>compile</code>,,      * <code>runtime</code>, <code>test</code>,,      *             <code>compile+runtime</code> (since Maven 3.0),      * or <code>runtime+system</code> (since Maven 3.0).,      * ,      * @param requiresDependencyResolution,      */,     public void setRequiresDependencyResolution( String requiresDependencyResolution ),     {,         this.requiresDependencyResolution = requiresDependencyResolution;,     } //-- void setRequiresDependencyResolution( String ), ,     /**,      * Set flags this Mojo to be invoked directly only.,      * ,      * @param requiresDirectInvocation,      */,     public void setRequiresDirectInvocation( boolean requiresDirectInvocation ),     {,         this.requiresDirectInvocation = requiresDirectInvocation;,     } //-- void setRequiresDirectInvocation( boolean ), ,     /**,      * Set flags this Mojo to require online mode for its,      * operation.,      * ,      * @param requiresOnline,      */,     public void setRequiresOnline( boolean requiresOnline ),     {,         this.requiresOnline = requiresOnline;,     } //-- void setRequiresOnline( boolean ), ,     /**,      * Set flags this Mojo to require running inside of a project.,      * ,      * @param requiresProject,      */,     public void setRequiresProject( boolean requiresProject ),     {,         this.requiresProject = requiresProject;,     } //-- void setRequiresProject( boolean ), ,     /**,      * Set flags this Mojo to require running inside of a reports,      * context. Unsupported since Maven 3.0.,      * ,      * @param requiresReports,      */,     public void setRequiresReports( boolean requiresReports ),     {,         this.requiresReports = requiresReports;,     } //-- void setRequiresReports( boolean ), ,     /**,      * Set specify the version when the Mojo was added to the API.,      * Similar to Javadoc since.,      * ,      * @param since,      */,     public void setSince( String since ),     {,         this.since = since;,     } //-- void setSince( String ), ,     /**,      * Set marks this mojo as being thread-safe, i.e. the mojo,      * safely supports concurrent execution during parallel,      *             builds. Mojos without this annotation will make,      * Maven output a warning when used during a parallel build,      *             session. Since Maven 3.0.,      * ,      * @param threadSafe,      */,     public void setThreadSafe( boolean threadSafe ),     {,         this.threadSafe = threadSafe;,     } //-- void setThreadSafe( boolean )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/descriptor/model/Parameter.java,,14-358,[public class Parameter,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             The name of the parameter, to be used while,      * configuring this parameter from the Mojo's declared defaults,      *             or from the POM.,      *           ,      */,     private String name;, ,     /**,      * ,      *             Specifies an alias which can be used to,      * configure this parameter from the POM.,      *             This is primarily useful to improve,      * user-friendliness, where Mojo field names are not intuitive,      * to the,      *             user or are otherwise not conducive to,      * configuration via the POM.,      *           ,      */,     private String alias;, ,     /**,      * ,      *             The Java type for this parameter. This is used,      * to validate the result of any expressions used to calculate,      *             the value which should be injected into the Mojo,      * for this parameter.,      *           ,      */,     private String type;, ,     /**,      * ,      *             Whether this parameter is required for the Mojo,      * to function. This is used to validate the configuration,      *             for a Mojo before it is injected, and before the,      * Mojo is executed from some half-state.,      *           ,      */,     private boolean required = false;, ,     /**,      * ,      *             Specifies that this parameter can be configured,      * directly by the user (as in the case of POM-specified,      *             configuration). This is useful when you want to,      * force the user to use common POM elements rather than,      *             plugin configurations, as in the case where you,      * want to use the artifact's final name as a parameter. In,      *             this case, you want the user to modify,      * <code>&lt;build&gt;&lt;finalName/&gt;&lt;/build&gt;</code>,      * rather,      *             than specifying a value for finalName directly,      * in the plugin configuration section. It is also useful to,      *             ensure that - for example - a List-typed,      * parameter which expects items of type Artifact doesn't get a,      * List,      *             full of Strings.,      *           ,      */,     private boolean editable = true;, ,     /**,      * Field implementation.,      */,     private String implementation;, ,     /**,      * The description of this parameter's use inside the Mojo.,      */,     private String description;, ,     /**,      * Specify the version when the parameter was added to the API.,      * Similar to Javadoc since.,      */,     private String since;, ,     /**,      * ,      *             Specify the version when the parameter was,      * deprecated to the API. Similar to Javadoc deprecated.,      *             This will trigger a warning when a user tries to,      * configure a parameter marked as deprecated.,      *           ,      */,     private String deprecated;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get specifies an alias which can be used to configure this,      * parameter from the POM.,      *             This is primarily useful to improve,      * user-friendliness, where Mojo field names are not intuitive,      * to the,      *             user or are otherwise not conducive to,      * configuration via the POM.,      * ,      * @return String,      */,     public String getAlias(),     {,         return this.alias;,     } //-- String getAlias(), ,     /**,      * Get specify the version when the parameter was deprecated to,      * the API. Similar to Javadoc deprecated.,      *             This will trigger a warning when a user tries to,      * configure a parameter marked as deprecated.,      * ,      * @return String,      */,     public String getDeprecated(),     {,         return this.deprecated;,     } //-- String getDeprecated(), ,     /**,      * Get the description of this parameter's use inside the Mojo.,      * ,      * @return String,      */,     public String getDescription(),     {,         return this.description;,     } //-- String getDescription(), ,     /**,      * Get the implementation field.,      * ,      * @return String,      */,     public String getImplementation(),     {,         return this.implementation;,     } //-- String getImplementation(), ,     /**,      * Get the name of the parameter, to be used while configuring,      * this parameter from the Mojo's declared defaults,      *             or from the POM.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get specify the version when the parameter was added to the,      * API. Similar to Javadoc since.,      * ,      * @return String,      */,     public String getSince(),     {,         return this.since;,     } //-- String getSince(), ,     /**,      * Get the Java type for this parameter. This is used to,      * validate the result of any expressions used to calculate,      *             the value which should be injected into the Mojo,      * for this parameter.,      * ,      * @return String,      */,     public String getType(),     {,         return this.type;,     } //-- String getType(), ,     /**,      * Get specifies that this parameter can be configured directly,      * by the user (as in the case of POM-specified,      *             configuration). This is useful when you want to,      * force the user to use common POM elements rather than,      *             plugin configurations, as in the case where you,      * want to use the artifact's final name as a parameter. In,      *             this case, you want the user to modify,      * <code>&lt;build&gt;&lt;finalName/&gt;&lt;/build&gt;</code>,      * rather,      *             than specifying a value for finalName directly,      * in the plugin configuration section. It is also useful to,      *             ensure that - for example - a List-typed,      * parameter which expects items of type Artifact doesn't get a,      * List,      *             full of Strings.,      * ,      * @return boolean,      */,     public boolean isEditable(),     {,         return this.editable;,     } //-- boolean isEditable(), ,     /**,      * Get whether this parameter is required for the Mojo to,      * function. This is used to validate the configuration,      *             for a Mojo before it is injected, and before the,      * Mojo is executed from some half-state.,      * ,      * @return boolean,      */,     public boolean isRequired(),     {,         return this.required;,     } //-- boolean isRequired(), ,     /**,      * Set specifies an alias which can be used to configure this,      * parameter from the POM.,      *             This is primarily useful to improve,      * user-friendliness, where Mojo field names are not intuitive,      * to the,      *             user or are otherwise not conducive to,      * configuration via the POM.,      * ,      * @param alias,      */,     public void setAlias( String alias ),     {,         this.alias = alias;,     } //-- void setAlias( String ), ,     /**,      * Set specify the version when the parameter was deprecated to,      * the API. Similar to Javadoc deprecated.,      *             This will trigger a warning when a user tries to,      * configure a parameter marked as deprecated.,      * ,      * @param deprecated,      */,     public void setDeprecated( String deprecated ),     {,         this.deprecated = deprecated;,     } //-- void setDeprecated( String ), ,     /**,      * Set the description of this parameter's use inside the Mojo.,      * ,      * @param description,      */,     public void setDescription( String description ),     {,         this.description = description;,     } //-- void setDescription( String ), ,     /**,      * Set specifies that this parameter can be configured directly,      * by the user (as in the case of POM-specified,      *             configuration). This is useful when you want to,      * force the user to use common POM elements rather than,      *             plugin configurations, as in the case where you,      * want to use the artifact's final name as a parameter. In,      *             this case, you want the user to modify,      * <code>&lt;build&gt;&lt;finalName/&gt;&lt;/build&gt;</code>,      * rather,      *             than specifying a value for finalName directly,      * in the plugin configuration section. It is also useful to,      *             ensure that - for example - a List-typed,      * parameter which expects items of type Artifact doesn't get a,      * List,      *             full of Strings.,      * ,      * @param editable,      */,     public void setEditable( boolean editable ),     {,         this.editable = editable;,     } //-- void setEditable( boolean ), ,     /**,      * Set the implementation field.,      * ,      * @param implementation,      */,     public void setImplementation( String implementation ),     {,         this.implementation = implementation;,     } //-- void setImplementation( String ), ,     /**,      * Set the name of the parameter, to be used while configuring,      * this parameter from the Mojo's declared defaults,      *             or from the POM.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set whether this parameter is required for the Mojo to,      * function. This is used to validate the configuration,      *             for a Mojo before it is injected, and before the,      * Mojo is executed from some half-state.,      * ,      * @param required,      */,     public void setRequired( boolean required ),     {,         this.required = required;,     } //-- void setRequired( boolean ), ,     /**,      * Set specify the version when the parameter was added to the,      * API. Similar to Javadoc since.,      * ,      * @param since,      */,     public void setSince( String since ),     {,         this.since = since;,     } //-- void setSince( String ), ,     /**,      * Set the Java type for this parameter. This is used to,      * validate the result of any expressions used to calculate,      *             the value which should be injected into the Mojo,      * for this parameter.,      * ,      * @param type,      */,     public void setType( String type ),     {,         this.type = type;,     } //-- void setType( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/descriptor/model/PluginDescriptor.java,,14-328,[public class PluginDescriptor,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Description of the plugin.,      */,     private String description;, ,     /**,      * The group id of the plugin.,      */,     private String groupId;, ,     /**,      * The artifact id of the plugin.,      */,     private String artifactId;, ,     /**,      * The version of the plugin.,      */,     private String version;, ,     /**,      * Field goalPrefix.,      */,     private String goalPrefix;, ,     /**,      * Field isolatedRealm.,      */,     private boolean isolatedRealm = false;, ,     /**,      * Field inheritedByDefault.,      */,     private boolean inheritedByDefault = true;, ,     /**,      * Field mojos.,      */,     private java.util.List<MojoDescriptor> mojos;, ,     /**,      * Field dependencies.,      */,     private java.util.List<Dependency> dependencies;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addDependency.,      * ,      * @param dependency,      */,     public void addDependency( Dependency dependency ),     {,         getDependencies().add( dependency );,     } //-- void addDependency( Dependency ), ,     /**,      * Method addMojo.,      * ,      * @param mojoDescriptor,      */,     public void addMojo( MojoDescriptor mojoDescriptor ),     {,         getMojos().add( mojoDescriptor );,     } //-- void addMojo( MojoDescriptor ), ,     /**,      * Get the artifact id of the plugin.,      * ,      * @return String,      */,     public String getArtifactId(),     {,         return this.artifactId;,     } //-- String getArtifactId(), ,     /**,      * Method getDependencies.,      * ,      * @return List,      */,     public java.util.List<Dependency> getDependencies(),     {,         if ( this.dependencies == null ),         {,             this.dependencies = new java.util.ArrayList<Dependency>();,         }, ,         return this.dependencies;,     } //-- java.util.List<Dependency> getDependencies(), ,     /**,      * Get description of the plugin.,      * ,      * @return String,      */,     public String getDescription(),     {,         return this.description;,     } //-- String getDescription(), ,     /**,      * Get the goalPrefix field.,      * ,      * @return String,      */,     public String getGoalPrefix(),     {,         return this.goalPrefix;,     } //-- String getGoalPrefix(), ,     /**,      * Get the group id of the plugin.,      * ,      * @return String,      */,     public String getGroupId(),     {,         return this.groupId;,     } //-- String getGroupId(), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Method getMojos.,      * ,      * @return List,      */,     public java.util.List<MojoDescriptor> getMojos(),     {,         if ( this.mojos == null ),         {,             this.mojos = new java.util.ArrayList<MojoDescriptor>();,         }, ,         return this.mojos;,     } //-- java.util.List<MojoDescriptor> getMojos(), ,     /**,      * Get the version of the plugin.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Get the inheritedByDefault field.,      * ,      * @return boolean,      */,     public boolean isInheritedByDefault(),     {,         return this.inheritedByDefault;,     } //-- boolean isInheritedByDefault(), ,     /**,      * Get the isolatedRealm field.,      * ,      * @return boolean,      */,     public boolean isIsolatedRealm(),     {,         return this.isolatedRealm;,     } //-- boolean isIsolatedRealm(), ,     /**,      * Method removeDependency.,      * ,      * @param dependency,      */,     public void removeDependency( Dependency dependency ),     {,         getDependencies().remove( dependency );,     } //-- void removeDependency( Dependency ), ,     /**,      * Method removeMojo.,      * ,      * @param mojoDescriptor,      */,     public void removeMojo( MojoDescriptor mojoDescriptor ),     {,         getMojos().remove( mojoDescriptor );,     } //-- void removeMojo( MojoDescriptor ), ,     /**,      * Set the artifact id of the plugin.,      * ,      * @param artifactId,      */,     public void setArtifactId( String artifactId ),     {,         this.artifactId = artifactId;,     } //-- void setArtifactId( String ), ,     /**,      * Set a set of dependencies which the plugin requires in order,      * to function. This enables the plugin to function,      *             independently of its POM (or at least to declare,      * the libraries it needs to run).,      * ,      * @param dependencies,      */,     public void setDependencies( java.util.List<Dependency> dependencies ),     {,         this.dependencies = dependencies;,     } //-- void setDependencies( java.util.List ), ,     /**,      * Set description of the plugin.,      * ,      * @param description,      */,     public void setDescription( String description ),     {,         this.description = description;,     } //-- void setDescription( String ), ,     /**,      * Set the goalPrefix field.,      * ,      * @param goalPrefix,      */,     public void setGoalPrefix( String goalPrefix ),     {,         this.goalPrefix = goalPrefix;,     } //-- void setGoalPrefix( String ), ,     /**,      * Set the group id of the plugin.,      * ,      * @param groupId,      */,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     } //-- void setGroupId( String ), ,     /**,      * Set the inheritedByDefault field.,      * ,      * @param inheritedByDefault,      */,     public void setInheritedByDefault( boolean inheritedByDefault ),     {,         this.inheritedByDefault = inheritedByDefault;,     } //-- void setInheritedByDefault( boolean ), ,     /**,      * Set the isolatedRealm field.,      * ,      * @param isolatedRealm,      */,     public void setIsolatedRealm( boolean isolatedRealm ),     {,         this.isolatedRealm = isolatedRealm;,     } //-- void setIsolatedRealm( boolean ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String ), ,     /**,      * Set description of each Mojo provided by the plugin.,      * ,      * @param mojos,      */,     public void setMojos( java.util.List<MojoDescriptor> mojos ),     {,         this.mojos = mojos;,     } //-- void setMojos( java.util.List ), ,     /**,      * Set the version of the plugin.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/descriptor/model/Requirement.java,,14-100,[public class Requirement,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field role.,      */,     private String role;, ,     /**,      * Field roleHint.,      */,     private String roleHint;, ,     /**,      * The field name which has this requirement.,      */,     private String fieldName;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get the field name which has this requirement.,      * ,      * @return String,      */,     public String getFieldName(),     {,         return this.fieldName;,     } //-- String getFieldName(), ,     /**,      * Get the role field.,      * ,      * @return String,      */,     public String getRole(),     {,         return this.role;,     } //-- String getRole(), ,     /**,      * Get the roleHint field.,      * ,      * @return String,      */,     public String getRoleHint(),     {,         return this.roleHint;,     } //-- String getRoleHint(), ,     /**,      * Set the field name which has this requirement.,      * ,      * @param fieldName,      */,     public void setFieldName( String fieldName ),     {,         this.fieldName = fieldName;,     } //-- void setFieldName( String ), ,     /**,      * Set the role field.,      * ,      * @param role,      */,     public void setRole( String role ),     {,         this.role = role;,     } //-- void setRole( String ), ,     /**,      * Set the roleHint field.,      * ,      * @param roleHint,      */,     public void setRoleHint( String roleHint ),     {,         this.roleHint = roleHint;,     } //-- void setRoleHint( String )],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,parseDependency,623-623,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,parseMojoDescriptor,678-678,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,parseParameter,857-857,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,parsePluginDescriptor,932-932,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,parseRequirement,1035-1035,[            String value = parser.getAttributeValue( i );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getIntegerValue,369-369,[                return Integer.valueOf( s ).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getLongValue,399-399,[                return Long.valueOf( s ).longValue();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getBooleanValue,154-154,[        return getBooleanValue( s, attribute, parser, null );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getDateValue,242-242,[        return getDateValue( s, attribute, null, parser );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getByteValue,194-208,[        if ( s != null ),         {,             try,             {,                 return Byte.valueOf( s ).byteValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getCharacterValue,223-227,[        if ( s != null ),         {,             return s.charAt( 0 );,         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getDoubleValue,305-319,[        if ( s != null ),         {,             try,             {,                 return Double.valueOf( s ).doubleValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getFloatValue,335-349,[        if ( s != null ),         {,             try,             {,                 return Float.valueOf( s ).floatValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getIntegerValue,365-379,[        if ( s != null ),         {,             try,             {,                 return Integer.valueOf( s ).intValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getLongValue,395-409,[        if ( s != null ),         {,             try,             {,                 return Long.valueOf( s ).longValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getRequiredAttributeValue,425-432,[        if ( s == null ),         {,             if ( strict ),             {,                 throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );,             },         },         return s;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Reader.java,getShortValue,448-462,[        if ( s != null ),         {,             try,             {,                 return Short.valueOf( s ).shortValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );,                 },             },         },         return 0;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Writer.java,writeMojoDescriptor,254-254,[        if ( ( mojoDescriptor.getConfiguration() != null ) && ( mojoDescriptor.getConfiguration().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Writer.java,writeMojoDescriptor,244-244,[        if ( ( mojoDescriptor.getParameters() != null ) && ( mojoDescriptor.getParameters().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Writer.java,writeMojoDescriptor,264-264,[        if ( ( mojoDescriptor.getRequirements() != null ) && ( mojoDescriptor.getRequirements().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Writer.java,writePluginDescriptor,381-381,[        if ( ( pluginDescriptor.getDependencies() != null ) && ( pluginDescriptor.getDependencies().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/descriptor/model/io/xpp3/PluginDescriptorXpp3Writer.java,writePluginDescriptor,371-371,[        if ( ( pluginDescriptor.getMojos() != null ) && ( pluginDescriptor.getMojos().size() > 0 ) )],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/plugin/internal/DefaultMavenPluginManager.java,getConfiguredMojo,481-481,[                    throw new PluginContainerException( mojoDescriptor, pluginRealm, os.toString(), cause );],,getConfiguredMojo,492-492,[                    throw new PluginContainerException( mojoDescriptor, pluginRealm, os.toString(), cause );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/plugin/internal/DefaultMavenPluginManager.java,getConfiguredMojo,476-476,[                    PrintStream ps = new PrintStream( os );],,getConfiguredMojo,486-486,[                    PrintStream ps = new PrintStream( os );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/plugin/internal/DefaultMavenPluginManager.java,populatePluginFields,621-621,[            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), os.toString(), e );],,populatePluginFields,631-631,[            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), os.toString(), e );],,
I18N,DM_DEFAULT_ENCODING,org/apache/maven/plugin/internal/DefaultMavenPluginManager.java,populatePluginFields,616-616,[            PrintStream ps = new PrintStream( os );],,populatePluginFields,626-626,[            PrintStream ps = new PrintStream( os );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/internal/DefaultMavenPluginManager.java,getConfiguredMojo,506-506,[                if ( pluginContext != null )],,
STYLE,REC_CATCH_EXCEPTION,org/apache/maven/plugin/internal/DefaultPluginManager.java,getPluginDescriptorForPrefix,193-193,[        catch ( Exception e )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/lifecycle/Execution.java,,14-100,[public class Execution,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Configuration to pass to the goals.,      */,     private Object configuration;, ,     /**,      * Field goals.,      */,     private java.util.List<String> goals;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addGoal.,      * ,      * @param string,      */,     public void addGoal( String string ),     {,         getGoals().add( string );,     } //-- void addGoal( String ), ,     /**,      * Get configuration to pass to the goals.,      * ,      * @return Object,      */,     public Object getConfiguration(),     {,         return this.configuration;,     } //-- Object getConfiguration(), ,     /**,      * Method getGoals.,      * ,      * @return List,      */,     public java.util.List<String> getGoals(),     {,         if ( this.goals == null ),         {,             this.goals = new java.util.ArrayList<String>();,         }, ,         return this.goals;,     } //-- java.util.List<String> getGoals(), ,     /**,      * Method removeGoal.,      * ,      * @param string,      */,     public void removeGoal( String string ),     {,         getGoals().remove( string );,     } //-- void removeGoal( String ), ,     /**,      * Set configuration to pass to the goals.,      * ,      * @param configuration,      */,     public void setConfiguration( Object configuration ),     {,         this.configuration = configuration;,     } //-- void setConfiguration( Object ), ,     /**,      * Set the goals to execute.,      * ,      * @param goals,      */,     public void setGoals( java.util.List<String> goals ),     {,         this.goals = goals;,     } //-- void setGoals( java.util.List )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/lifecycle/Lifecycle.java,,16-105,[public class Lifecycle,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The ID of this lifecycle, for identification in the mojo,      * descriptor.,      */,     private String id;, ,     /**,      * Field phases.,      */,     private java.util.List<Phase> phases;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addPhase.,      * ,      * @param phase,      */,     public void addPhase( Phase phase ),     {,         getPhases().add( phase );,     } //-- void addPhase( Phase ), ,     /**,      * Get the ID of this lifecycle, for identification in the mojo,      * descriptor.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Method getPhases.,      * ,      * @return List,      */,     public java.util.List<Phase> getPhases(),     {,         if ( this.phases == null ),         {,             this.phases = new java.util.ArrayList<Phase>();,         }, ,         return this.phases;,     } //-- java.util.List<Phase> getPhases(), ,     /**,      * Method removePhase.,      * ,      * @param phase,      */,     public void removePhase( Phase phase ),     {,         getPhases().remove( phase );,     } //-- void removePhase( Phase ), ,     /**,      * Set the ID of this lifecycle, for identification in the mojo,      * descriptor.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * Set the phase mappings for this lifecycle.,      * ,      * @param phases,      */,     public void setPhases( java.util.List<Phase> phases ),     {,         this.phases = phases;,     } //-- void setPhases( java.util.List )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/lifecycle/LifecycleConfiguration.java,,14-100,[public class LifecycleConfiguration,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field lifecycles.,      */,     private java.util.List<Lifecycle> lifecycles;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addLifecycle.,      * ,      * @param lifecycle,      */,     public void addLifecycle( Lifecycle lifecycle ),     {,         getLifecycles().add( lifecycle );,     } //-- void addLifecycle( Lifecycle ), ,     /**,      * Method getLifecycles.,      * ,      * @return List,      */,     public java.util.List<Lifecycle> getLifecycles(),     {,         if ( this.lifecycles == null ),         {,             this.lifecycles = new java.util.ArrayList<Lifecycle>();,         }, ,         return this.lifecycles;,     } //-- java.util.List<Lifecycle> getLifecycles(), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Method removeLifecycle.,      * ,      * @param lifecycle,      */,     public void removeLifecycle( Lifecycle lifecycle ),     {,         getLifecycles().remove( lifecycle );,     } //-- void removeLifecycle( Lifecycle ), ,     /**,      * Set the lifecycles field.,      * ,      * @param lifecycles,      */,     public void setLifecycles( java.util.List<Lifecycle> lifecycles ),     {,         this.lifecycles = lifecycles;,     } //-- void setLifecycles( java.util.List ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/plugin/lifecycle/Phase.java,,14-125,[public class Phase,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The ID of this phase, eg <code>generate-sources</code>.,      */,     private String id;, ,     /**,      * Field executions.,      */,     private java.util.List<Execution> executions;, ,     /**,      * Configuration to pass to all goals run in this phase.,      */,     private Object configuration;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addExecution.,      * ,      * @param execution,      */,     public void addExecution( Execution execution ),     {,         getExecutions().add( execution );,     } //-- void addExecution( Execution ), ,     /**,      * Get configuration to pass to all goals run in this phase.,      * ,      * @return Object,      */,     public Object getConfiguration(),     {,         return this.configuration;,     } //-- Object getConfiguration(), ,     /**,      * Method getExecutions.,      * ,      * @return List,      */,     public java.util.List<Execution> getExecutions(),     {,         if ( this.executions == null ),         {,             this.executions = new java.util.ArrayList<Execution>();,         }, ,         return this.executions;,     } //-- java.util.List<Execution> getExecutions(), ,     /**,      * Get the ID of this phase, eg <code>generate-sources</code>.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Method removeExecution.,      * ,      * @param execution,      */,     public void removeExecution( Execution execution ),     {,         getExecutions().remove( execution );,     } //-- void removeExecution( Execution ), ,     /**,      * Set configuration to pass to all goals run in this phase.,      * ,      * @param configuration,      */,     public void setConfiguration( Object configuration ),     {,         this.configuration = configuration;,     } //-- void setConfiguration( Object ), ,     /**,      * Set the goals to execute within the phase.,      * ,      * @param executions,      */,     public void setExecutions( java.util.List<Execution> executions ),     {,         this.executions = executions;,     } //-- void setExecutions( java.util.List ), ,     /**,      * Set the ID of this phase, eg <code>generate-sources</code>.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String )],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,parseLifecycleConfiguration,714-714,[        java.util.Set parsed = new java.util.HashSet();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,parseExecution,581-581,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,parseLifecycle,640-640,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,parseLifecycleConfiguration,699-699,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,parsePhase,752-752,[            String value = parser.getAttributeValue( i );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getIntegerValue,367-367,[                return Integer.valueOf( s ).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getLongValue,397-397,[                return Long.valueOf( s ).longValue();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,parseLifecycleConfiguration,720-720,[                if ( lifecycles == null )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getBooleanValue,152-152,[        return getBooleanValue( s, attribute, parser, null );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getDateValue,240-240,[        return getDateValue( s, attribute, null, parser );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getByteValue,192-206,[        if ( s != null ),         {,             try,             {,                 return Byte.valueOf( s ).byteValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getCharacterValue,221-225,[        if ( s != null ),         {,             return s.charAt( 0 );,         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getDoubleValue,303-317,[        if ( s != null ),         {,             try,             {,                 return Double.valueOf( s ).doubleValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getFloatValue,333-347,[        if ( s != null ),         {,             try,             {,                 return Float.valueOf( s ).floatValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getIntegerValue,363-377,[        if ( s != null ),         {,             try,             {,                 return Integer.valueOf( s ).intValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getLongValue,393-407,[        if ( s != null ),         {,             try,             {,                 return Long.valueOf( s ).longValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getRequiredAttributeValue,423-430,[        if ( s == null ),         {,             if ( strict ),             {,                 throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );,             },         },         return s;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Reader.java,getShortValue,446-460,[        if ( s != null ),         {,             try,             {,                 return Short.valueOf( s ).shortValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );,                 },             },         },         return 0;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Writer.java,writeExecution,100-100,[        if ( ( execution.getGoals() != null ) && ( execution.getGoals().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Writer.java,writeLifecycle,129-129,[        if ( ( lifecycle.getPhases() != null ) && ( lifecycle.getPhases().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Writer.java,writeLifecycleConfiguration,157-157,[        if ( ( lifecycleConfiguration.getLifecycles() != null ) && ( lifecycleConfiguration.getLifecycles().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/lifecycle/io/xpp3/LifecycleMappingsXpp3Writer.java,writePhase,184-184,[        if ( ( phase.getExecutions() != null ) && ( phase.getExecutions().size() > 0 ) )],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/maven/plugin/prefix/NoPluginFoundForPrefixException.java,format,55-55,[                    repos += repository.getId() + " (" + repository.getUrl() + ")";],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/plugin/prefix/internal/DefaultPluginPrefixResolver.java,resolveFromRepository,258-258,[                if ( plugins != null )],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/maven/plugin/version/PluginVersionResolutionException.java,format,97-97,[                    repos += repository.getId() + " (" + repository.getUrl() + ")";],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/profiles/Activation.java,,18-176,[public class Activation,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Flag specifying whether this profile is active as a default.,      */,     private boolean activeByDefault = false;, ,     /**,      * ,      *             Specifies that this profile will be activated,      * when a matching JDK is detected.,      *           ,      */,     private String jdk;, ,     /**,      * ,      *             Specifies that this profile will be activated,      * when matching OS attributes are detected.,      *           ,      */,     private ActivationOS os;, ,     /**,      * ,      *             Specifies that this profile will be activated,      * when this System property is specified.,      *           ,      */,     private ActivationProperty property;, ,     /**,      * ,      *              Specifies that this profile will be activated,      * based on existence of a file.,      *              ,      */,     private ActivationFile file;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get specifies that this profile will be activated based on,      * existence of a file.,      * ,      * @return ActivationFile,      */,     public ActivationFile getFile(),     {,         return this.file;,     } //-- ActivationFile getFile(), ,     /**,      * Get specifies that this profile will be activated when a,      * matching JDK is detected.,      * ,      * @return String,      */,     public String getJdk(),     {,         return this.jdk;,     } //-- String getJdk(), ,     /**,      * Get specifies that this profile will be activated when,      * matching OS attributes are detected.,      * ,      * @return ActivationOS,      */,     public ActivationOS getOs(),     {,         return this.os;,     } //-- ActivationOS getOs(), ,     /**,      * Get specifies that this profile will be activated when this,      * System property is specified.,      * ,      * @return ActivationProperty,      */,     public ActivationProperty getProperty(),     {,         return this.property;,     } //-- ActivationProperty getProperty(), ,     /**,      * Get flag specifying whether this profile is active as a,      * default.,      * ,      * @return boolean,      */,     public boolean isActiveByDefault(),     {,         return this.activeByDefault;,     } //-- boolean isActiveByDefault(), ,     /**,      * Set flag specifying whether this profile is active as a,      * default.,      * ,      * @param activeByDefault,      */,     public void setActiveByDefault( boolean activeByDefault ),     {,         this.activeByDefault = activeByDefault;,     } //-- void setActiveByDefault( boolean ), ,     /**,      * Set specifies that this profile will be activated based on,      * existence of a file.,      * ,      * @param file,      */,     public void setFile( ActivationFile file ),     {,         this.file = file;,     } //-- void setFile( ActivationFile ), ,     /**,      * Set specifies that this profile will be activated when a,      * matching JDK is detected.,      * ,      * @param jdk,      */,     public void setJdk( String jdk ),     {,         this.jdk = jdk;,     } //-- void setJdk( String ), ,     /**,      * Set specifies that this profile will be activated when,      * matching OS attributes are detected.,      * ,      * @param os,      */,     public void setOs( ActivationOS os ),     {,         this.os = os;,     } //-- void setOs( ActivationOS ), ,     /**,      * Set specifies that this profile will be activated when this,      * System property is specified.,      * ,      * @param property,      */,     public void setProperty( ActivationProperty property ),     {,         this.property = property;,     } //-- void setProperty( ActivationProperty )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/profiles/ActivationFile.java,,21-87,[public class ActivationFile,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The name of the file that should be missing to activate a,      * profile.,      */,     private String missing;, ,     /**,      * The name of the file that should exist to activate a profile.,      */,     private String exists;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get the name of the file that should exist to activate a,      * profile.,      * ,      * @return String,      */,     public String getExists(),     {,         return this.exists;,     } //-- String getExists(), ,     /**,      * Get the name of the file that should be missing to activate,      * a profile.,      * ,      * @return String,      */,     public String getMissing(),     {,         return this.missing;,     } //-- String getMissing(), ,     /**,      * Set the name of the file that should exist to activate a,      * profile.,      * ,      * @param exists,      */,     public void setExists( String exists ),     {,         this.exists = exists;,     } //-- void setExists( String ), ,     /**,      * Set the name of the file that should be missing to activate,      * a profile.,      * ,      * @param missing,      */,     public void setMissing( String missing ),     {,         this.missing = missing;,     } //-- void setMissing( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/profiles/ActivationOS.java,,18-134,[public class ActivationOS,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The name of the OS to be used to activate a profile.,      */,     private String name;, ,     /**,      * The general family of the OS to be used to activate a,      * profile (e.g. 'windows').,      */,     private String family;, ,     /**,      * The architecture of the OS to be used to activate a profile.,      */,     private String arch;, ,     /**,      * The version of the OS to be used to activate a profile.,      */,     private String version;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get the architecture of the OS to be used to activate a,      * profile.,      * ,      * @return String,      */,     public String getArch(),     {,         return this.arch;,     } //-- String getArch(), ,     /**,      * Get the general family of the OS to be used to activate a,      * profile (e.g. 'windows').,      * ,      * @return String,      */,     public String getFamily(),     {,         return this.family;,     } //-- String getFamily(), ,     /**,      * Get the name of the OS to be used to activate a profile.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the version of the OS to be used to activate a profile.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Set the architecture of the OS to be used to activate a,      * profile.,      * ,      * @param arch,      */,     public void setArch( String arch ),     {,         this.arch = arch;,     } //-- void setArch( String ), ,     /**,      * Set the general family of the OS to be used to activate a,      * profile (e.g. 'windows').,      * ,      * @param family,      */,     public void setFamily( String family ),     {,         this.family = family;,     } //-- void setFamily( String ), ,     /**,      * Set the name of the OS to be used to activate a profile.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the version of the OS to be used to activate a profile.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/profiles/ActivationProperty.java,,20-85,[public class ActivationProperty,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The name of the property to be used to activate a profile.,      */,     private String name;, ,     /**,      * The value of the property to be used to activate a profile.,      */,     private String value;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get the name of the property to be used to activate a,      * profile.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the value of the property to be used to activate a,      * profile.,      * ,      * @return String,      */,     public String getValue(),     {,         return this.value;,     } //-- String getValue(), ,     /**,      * Set the name of the property to be used to activate a,      * profile.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the value of the property to be used to activate a,      * profile.,      * ,      * @param value,      */,     public void setValue( String value ),     {,         this.value = value;,     } //-- void setValue( String )],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/profiles/DefaultProfileManager.java,,193-201,[            {, ,                 public void add( ModelProblemCollectorRequest req ),                 {,                     if ( !ModelProblem.Severity.WARNING.equals( req.getSeverity() ) ),                     {,                         errors.add( new ProfileActivationException( req.getMessage(), req.getException() ) );,                     },                 }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/profiles/Profile.java,,18-231,[public class Profile,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The ID of this build profile, for activation,      *             purposes.,      */,     private String id;, ,     /**,      * The conditional logic which will automatically,      *             trigger the inclusion of this profile.,      */,     private Activation activation;, ,     /**,      * Field properties.,      */,     private java.util.Properties properties;, ,     /**,      * Field repositories.,      */,     private java.util.List<Repository> repositories;, ,     /**,      *  This may be removed or relocated in the near,      *             future. It is undecided whether plugins really,      * need a remote,      *             repository set of their own. ,      */,     private java.util.List<Repository> pluginRepositories;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addPluginRepository.,      * ,      * @param repository,      */,     public void addPluginRepository( Repository repository ),     {,         getPluginRepositories().add( repository );,     } //-- void addPluginRepository( Repository ), ,     /**,      * Method addProperty.,      * ,      * @param key,      * @param value,      */,     public void addProperty( String key, String value ),     {,         getProperties().put( key, value );,     } //-- void addProperty( String, String ), ,     /**,      * Method addRepository.,      * ,      * @param repository,      */,     public void addRepository( Repository repository ),     {,         getRepositories().add( repository );,     } //-- void addRepository( Repository ), ,     /**,      * Get the conditional logic which will automatically,      *             trigger the inclusion of this profile.,      * ,      * @return Activation,      */,     public Activation getActivation(),     {,         return this.activation;,     } //-- Activation getActivation(), ,     /**,      * Get the ID of this build profile, for activation,      *             purposes.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Method getPluginRepositories.,      * ,      * @return List,      */,     public java.util.List<Repository> getPluginRepositories(),     {,         if ( this.pluginRepositories == null ),         {,             this.pluginRepositories = new java.util.ArrayList<Repository>();,         }, ,         return this.pluginRepositories;,     } //-- java.util.List<Repository> getPluginRepositories(), ,     /**,      * Method getProperties.,      * ,      * @return Properties,      */,     public java.util.Properties getProperties(),     {,         if ( this.properties == null ),         {,             this.properties = new java.util.Properties();,         }, ,         return this.properties;,     } //-- java.util.Properties getProperties(), ,     /**,      * Method getRepositories.,      * ,      * @return List,      */,     public java.util.List<Repository> getRepositories(),     {,         if ( this.repositories == null ),         {,             this.repositories = new java.util.ArrayList<Repository>();,         }, ,         return this.repositories;,     } //-- java.util.List<Repository> getRepositories(), ,     /**,      * Method removePluginRepository.,      * ,      * @param repository,      */,     public void removePluginRepository( Repository repository ),     {,         getPluginRepositories().remove( repository );,     } //-- void removePluginRepository( Repository ), ,     /**,      * Method removeRepository.,      * ,      * @param repository,      */,     public void removeRepository( Repository repository ),     {,         getRepositories().remove( repository );,     } //-- void removeRepository( Repository ), ,     /**,      * Set the conditional logic which will automatically,      *             trigger the inclusion of this profile.,      * ,      * @param activation,      */,     public void setActivation( Activation activation ),     {,         this.activation = activation;,     } //-- void setActivation( Activation ), ,     /**,      * Set the ID of this build profile, for activation,      *             purposes.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * Set the lists of the remote repositories for discovering,      * plugins.,      * ,      * @param pluginRepositories,      */,     public void setPluginRepositories( java.util.List<Repository> pluginRepositories ),     {,         this.pluginRepositories = pluginRepositories;,     } //-- void setPluginRepositories( java.util.List ), ,     /**,      * Set extended configuration specific to this profile goes,      *             here.,      * ,      * @param properties,      */,     public void setProperties( java.util.Properties properties ),     {,         this.properties = properties;,     } //-- void setProperties( java.util.Properties ), ,     /**,      * Set the lists of the remote repositories.,      * ,      * @param repositories,      */,     public void setRepositories( java.util.List<Repository> repositories ),     {,         this.repositories = repositories;,     } //-- void setRepositories( java.util.List )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/profiles/ProfilesConversionUtils.java,convertFromProfileXmlProfile,109-109,[        if ( pluginRepos != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/profiles/ProfilesConversionUtils.java,convertFromProfileXmlProfile,100-100,[        if ( repos != null )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/profiles/ProfilesRoot.java,,14-153,[public class ProfilesRoot,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field profiles.,      */,     private java.util.List<Profile> profiles;, ,     /**,      * Field activeProfiles.,      */,     private java.util.List<String> activeProfiles;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addActiveProfile.,      * ,      * @param string,      */,     public void addActiveProfile( String string ),     {,         getActiveProfiles().add( string );,     } //-- void addActiveProfile( String ), ,     /**,      * Method addProfile.,      * ,      * @param profile,      */,     public void addProfile( Profile profile ),     {,         getProfiles().add( profile );,     } //-- void addProfile( Profile ), ,     /**,      * Method getActiveProfiles.,      * ,      * @return List,      */,     public java.util.List<String> getActiveProfiles(),     {,         if ( this.activeProfiles == null ),         {,             this.activeProfiles = new java.util.ArrayList<String>();,         }, ,         return this.activeProfiles;,     } //-- java.util.List<String> getActiveProfiles(), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Method getProfiles.,      * ,      * @return List,      */,     public java.util.List<Profile> getProfiles(),     {,         if ( this.profiles == null ),         {,             this.profiles = new java.util.ArrayList<Profile>();,         }, ,         return this.profiles;,     } //-- java.util.List<Profile> getProfiles(), ,     /**,      * Method removeActiveProfile.,      * ,      * @param string,      */,     public void removeActiveProfile( String string ),     {,         getActiveProfiles().remove( string );,     } //-- void removeActiveProfile( String ), ,     /**,      * Method removeProfile.,      * ,      * @param profile,      */,     public void removeProfile( Profile profile ),     {,         getProfiles().remove( profile );,     } //-- void removeProfile( Profile ), ,     /**,      * Set list of manually-activated build profiles, specified in,      * the order in which,      *             they should be applied.,      * ,      * @param activeProfiles,      */,     public void setActiveProfiles( java.util.List<String> activeProfiles ),     {,         this.activeProfiles = activeProfiles;,     } //-- void setActiveProfiles( java.util.List ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String ), ,     /**,      * Set configuration of build profiles for adjusting the build,      *             according to environmental parameters.,      * ,      * @param profiles,      */,     public void setProfiles( java.util.List<Profile> profiles ),     {,         this.profiles = profiles;,     } //-- void setProfiles( java.util.List )],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/maven/profiles/Repository.java,equals,88-88,[                return super.equals( obj );],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/profiles/Repository.java,,17-88,[public class Repository,     extends RepositoryBase,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * How to handle downloading of releases from this repository.,      */,     private RepositoryPolicy releases;, ,     /**,      * How to handle downloading of snapshots from this repository.,      */,     private RepositoryPolicy snapshots;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get how to handle downloading of releases from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getReleases(),     {,         return this.releases;,     } //-- RepositoryPolicy getReleases(), ,     /**,      * Get how to handle downloading of snapshots from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getSnapshots(),     {,         return this.snapshots;,     } //-- RepositoryPolicy getSnapshots(), ,     /**,      * Set how to handle downloading of releases from this,      * repository.,      * ,      * @param releases,      */,     public void setReleases( RepositoryPolicy releases ),     {,         this.releases = releases;,     } //-- void setReleases( RepositoryPolicy ), ,     /**,      * Set how to handle downloading of snapshots from this,      * repository.,      * ,      * @param snapshots,      */,     public void setSnapshots( RepositoryPolicy snapshots ),     {,         this.snapshots = snapshots;,     } //-- void setSnapshots( RepositoryPolicy ), ,     ,             public boolean equals( Object obj ),             {,                 return super.equals( obj );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/profiles/Repository.java,,17-88,[public class Repository,     extends RepositoryBase,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * How to handle downloading of releases from this repository.,      */,     private RepositoryPolicy releases;, ,     /**,      * How to handle downloading of snapshots from this repository.,      */,     private RepositoryPolicy snapshots;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get how to handle downloading of releases from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getReleases(),     {,         return this.releases;,     } //-- RepositoryPolicy getReleases(), ,     /**,      * Get how to handle downloading of snapshots from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getSnapshots(),     {,         return this.snapshots;,     } //-- RepositoryPolicy getSnapshots(), ,     /**,      * Set how to handle downloading of releases from this,      * repository.,      * ,      * @param releases,      */,     public void setReleases( RepositoryPolicy releases ),     {,         this.releases = releases;,     } //-- void setReleases( RepositoryPolicy ), ,     /**,      * Set how to handle downloading of snapshots from this,      * repository.,      * ,      * @param snapshots,      */,     public void setSnapshots( RepositoryPolicy snapshots ),     {,         this.snapshots = snapshots;,     } //-- void setSnapshots( RepositoryPolicy ), ,     ,             public boolean equals( Object obj ),             {,                 return super.equals( obj );],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/maven/profiles/RepositoryBase.java,equals,145-145,[                RepositoryBase other =  (RepositoryBase) obj;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/maven/profiles/RepositoryBase.java,equals,145-154,[                RepositoryBase other =  (RepositoryBase) obj;, ,                 boolean retValue = false;, ,                 if ( id != null ),                 {,                     retValue = id.equals( other.id );,                 }, ,                 return retValue;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/profiles/RepositoryBase.java,,17-154,[public class RepositoryBase,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             A unique identifier for a repository.,      *           ,      */,     private String id;, ,     /**,      * ,      *             Human readable name of the repository,      *           .,      */,     private String name;, ,     /**,      * ,      *              The url of the repository,      *           .,      */,     private String url;, ,     /**,      * The type of layout this repository uses for locating and,      * storing artifacts - can be "legacy" or,      *             "default".,      */,     private String layout = "default";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get a unique identifier for a repository.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Get the type of layout this repository uses for locating and,      * storing artifacts - can be "legacy" or,      *             "default".,      * ,      * @return String,      */,     public String getLayout(),     {,         return this.layout;,     } //-- String getLayout(), ,     /**,      * Get human readable name of the repository.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the url of the repository.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Set a unique identifier for a repository.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * Set the type of layout this repository uses for locating and,      * storing artifacts - can be "legacy" or,      *             "default".,      * ,      * @param layout,      */,     public void setLayout( String layout ),     {,         this.layout = layout;,     } //-- void setLayout( String ), ,     /**,      * Set human readable name of the repository.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the url of the repository.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String ), ,     ,             public boolean equals( Object obj ),             {,                 RepositoryBase other =  (RepositoryBase) obj;, ,                 boolean retValue = false;, ,                 if ( id != null ),                 {,                     retValue = id.equals( other.id );,                 }, ,                 return retValue;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/profiles/RepositoryPolicy.java,,14-117,[public class RepositoryPolicy,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Whether to use this repository for downloading this type of,      * artifact.,      */,     private boolean enabled = true;, ,     /**,      * ,      *             The frequency for downloading updates - can be,      * "always", "daily" (default), "interval:XXX" (in minutes) or,      *             "never" (only if it doesn't exist locally).,      *           ,      */,     private String updatePolicy;, ,     /**,      * What to do when verification of an artifact checksum fails -,      * warn, fail, etc. Valid values are,      *             "fail" or "warn".,      */,     private String checksumPolicy;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get what to do when verification of an artifact checksum,      * fails - warn, fail, etc. Valid values are,      *             "fail" or "warn".,      * ,      * @return String,      */,     public String getChecksumPolicy(),     {,         return this.checksumPolicy;,     } //-- String getChecksumPolicy(), ,     /**,      * Get the frequency for downloading updates - can be "always",,      * "daily" (default), "interval:XXX" (in minutes) or,      *             "never" (only if it doesn't exist locally).,      * ,      * @return String,      */,     public String getUpdatePolicy(),     {,         return this.updatePolicy;,     } //-- String getUpdatePolicy(), ,     /**,      * Get whether to use this repository for downloading this type,      * of artifact.,      * ,      * @return boolean,      */,     public boolean isEnabled(),     {,         return this.enabled;,     } //-- boolean isEnabled(), ,     /**,      * Set what to do when verification of an artifact checksum,      * fails - warn, fail, etc. Valid values are,      *             "fail" or "warn".,      * ,      * @param checksumPolicy,      */,     public void setChecksumPolicy( String checksumPolicy ),     {,         this.checksumPolicy = checksumPolicy;,     } //-- void setChecksumPolicy( String ), ,     /**,      * Set whether to use this repository for downloading this type,      * of artifact.,      * ,      * @param enabled,      */,     public void setEnabled( boolean enabled ),     {,         this.enabled = enabled;,     } //-- void setEnabled( boolean ), ,     /**,      * Set the frequency for downloading updates - can be "always",,      * "daily" (default), "interval:XXX" (in minutes) or,      *             "never" (only if it doesn't exist locally).,      * ,      * @param updatePolicy,      */,     public void setUpdatePolicy( String updatePolicy ),     {,         this.updatePolicy = updatePolicy;,     } //-- void setUpdatePolicy( String )],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/profiles/activation/FileProfileActivator.java,isActive,89-89,[                if ( logger.isDebugEnabled() )],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/profiles/activation/SystemPropertyProfileActivator.java,isActive,72-72,[            String sysValue = properties.getProperty( name );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseActivation,586-586,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseActivationFile,645-645,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseActivationOS,692-692,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseActivationProperty,747-747,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseProfile,794-794,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseProfilesRoot,882-882,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseRepository,957-957,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseRepositoryBase,1020-1020,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseRepositoryPolicy,1075-1075,[            String value = parser.getAttributeValue( i );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getIntegerValue,372-372,[                return Integer.valueOf( s ).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getLongValue,402-402,[                return Long.valueOf( s ).longValue();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getBooleanValue,157-157,[        return getBooleanValue( s, attribute, parser, null );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getDateValue,245-245,[        return getDateValue( s, attribute, null, parser );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getByteValue,197-211,[        if ( s != null ),         {,             try,             {,                 return Byte.valueOf( s ).byteValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getCharacterValue,226-230,[        if ( s != null ),         {,             return s.charAt( 0 );,         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getDoubleValue,308-322,[        if ( s != null ),         {,             try,             {,                 return Double.valueOf( s ).doubleValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getFloatValue,338-352,[        if ( s != null ),         {,             try,             {,                 return Float.valueOf( s ).floatValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getIntegerValue,368-382,[        if ( s != null ),         {,             try,             {,                 return Integer.valueOf( s ).intValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getLongValue,398-412,[        if ( s != null ),         {,             try,             {,                 return Long.valueOf( s ).longValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getRequiredAttributeValue,428-435,[        if ( s == null ),         {,             if ( strict ),             {,                 throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );,             },         },         return s;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,getShortValue,451-465,[        if ( s != null ),         {,             try,             {,                 return Short.valueOf( s ).shortValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Reader.java,parseRepositoryBase,1015-1055,[        String tagName = parser.getName();,         RepositoryBase repositoryBase = new RepositoryBase();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "id", null, parsed ) ),             {,                 repositoryBase.setId( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) ),             {,                 repositoryBase.setName( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) ),             {,                 repositoryBase.setUrl( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) ),             {,                 repositoryBase.setLayout( getTrimmedValue( parser.nextText() ) );,             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return repositoryBase;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java,writeProfile,241-241,[        if ( ( profile.getPluginRepositories() != null ) && ( profile.getPluginRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java,writeProfile,220-220,[        if ( ( profile.getProperties() != null ) && ( profile.getProperties().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java,writeProfile,231-231,[        if ( ( profile.getRepositories() != null ) && ( profile.getRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java,writeProfilesRoot,279-279,[        if ( ( profilesRoot.getActiveProfiles() != null ) && ( profilesRoot.getActiveProfiles().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java,writeProfilesRoot,269-269,[        if ( ( profilesRoot.getProfiles() != null ) && ( profilesRoot.getProfiles().size() > 0 ) )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/profiles/io/xpp3/ProfilesXpp3Writer.java,writeRepositoryBase,342-360,[        serializer.startTag( NAMESPACE, tagName );,         if ( repositoryBase.getId() != null ),         {,             serializer.startTag( NAMESPACE, "id" ).text( repositoryBase.getId() ).endTag( NAMESPACE, "id" );,         },         if ( repositoryBase.getName() != null ),         {,             serializer.startTag( NAMESPACE, "name" ).text( repositoryBase.getName() ).endTag( NAMESPACE, "name" );,         },         if ( repositoryBase.getUrl() != null ),         {,             serializer.startTag( NAMESPACE, "url" ).text( repositoryBase.getUrl() ).endTag( NAMESPACE, "url" );,         },         if ( ( repositoryBase.getLayout() != null ) && !repositoryBase.getLayout().equals( "default" ) ),         {,             serializer.startTag( NAMESPACE, "layout" ).text( repositoryBase.getLayout() ).endTag( NAMESPACE, "layout" );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writeRepositoryBase( RepositoryBase, String, XmlSerializer )],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/maven/project/AbstractMavenProjectTestCase.java,getProjectWithDependencies,155-155,[                    message += problem + "\n";],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/maven/project/DefaultMavenProjectBuilder.java,buildStandaloneSuperProject,272-272,[        ModelSource modelSource = new UrlModelSource( getClass().getResource( "standalone.xml" ) );],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/project/DefaultMavenProjectBuilderTest.java,setUp,49-49,[        localRepoDir.mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/project/DefaultMavenProjectBuilderTest.java,tearDown,72-72,[                        file.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/project/DefaultMavenProjectBuilderTest.java,getLocalRepository,142-142,[            repositorySystem.createArtifactRepository( "local", "file://" + localRepoDir.getAbsolutePath(), repoLayout,],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/maven/project/DefaultProjectBuilder.java,,678-685,[        {,             this.request = request;,             this.modelPool = modelPool;,             session =,                 LegacyLocalRepositoryManager.overlay( request.getLocalRepository(), request.getRepositorySession(),,                                                       repoSystem );,             repositories = RepositoryUtils.toRepos( request.getRemoteRepositories() );,         }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/maven/project/DefaultProjectBuilderConfiguration.java,getBuildStartTime,98-98,[        return buildStartTime;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/maven/project/DefaultProjectBuilderConfiguration.java,setBuildStartTime,103-103,[        this.buildStartTime = buildStartTime;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/maven/project/DefaultProjectBuildingHelper.java,createProjectRealm,247-247,[                    pluginArtifactsCache.register( project, recordArtifacts );],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/maven/project/DefaultProjectBuildingRequest.java,getBuildStartTime,287-287,[        return buildStartTime;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/maven/project/DefaultProjectBuildingRequest.java,setBuildStartTime,292-292,[        this.buildStartTime = buildStartTime;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/maven/project/MavenProject.java,,96-2247,[public class MavenProject,     implements Cloneable, {,     public static final String EMPTY_PROJECT_GROUP_ID = "unknown";, ,     public static final String EMPTY_PROJECT_ARTIFACT_ID = "empty-project";, ,     public static final String EMPTY_PROJECT_VERSION = "0";, ,     private static final MavenProject ERROR_BUILDING_PARENT = new MavenProject();, ,     private Model model;, ,     private MavenProject parent;, ,     private File file;, ,     private Set<Artifact> resolvedArtifacts;, ,     private ArtifactFilter artifactFilter;, ,     private Set<Artifact> artifacts;, ,     private Artifact parentArtifact;, ,     private Set<Artifact> pluginArtifacts;, ,     private List<ArtifactRepository> remoteArtifactRepositories;, ,     private List<ArtifactRepository> pluginArtifactRepositories;, ,     private List<RemoteRepository> remoteProjectRepositories;, ,     private List<RemoteRepository> remotePluginRepositories;, ,     private List<Artifact> attachedArtifacts;, ,     private MavenProject executionProject;, ,     private List<MavenProject> collectedProjects;, ,     private List<String> compileSourceRoots = new ArrayList<String>();, ,     private List<String> testCompileSourceRoots = new ArrayList<String>();, ,     private List<String> scriptSourceRoots = new ArrayList<String>();, ,     private ArtifactRepository releaseArtifactRepository;, ,     private ArtifactRepository snapshotArtifactRepository;, ,     private List<Profile> activeProfiles = new ArrayList<Profile>();, ,     private Map<String, List<String>> injectedProfileIds = new LinkedHashMap<String, List<String>>();, ,     private Set<Artifact> dependencyArtifacts;, ,     private Artifact artifact;, ,     // calculated.,     private Map<String, Artifact> artifactMap;, ,     private Model originalModel;, ,     private Map<String, Artifact> pluginArtifactMap;, ,     private Set<Artifact> reportArtifacts;, ,     private Map<String, Artifact> reportArtifactMap;, ,     private Set<Artifact> extensionArtifacts;, ,     private Map<String, Artifact> extensionArtifactMap;, ,     private Map<String, Artifact> managedVersionMap;, ,     private Map<String, MavenProject> projectReferences = new HashMap<String, MavenProject>();, ,     private boolean executionRoot;, ,     private Map<String, String> moduleAdjustments;, ,     private ProjectBuilder mavenProjectBuilder;, ,     private ProjectBuildingRequest projectBuilderConfiguration;, ,     private RepositorySystem repositorySystem;,     ,     private File parentFile;, ,     private Map<String, Object> context;, ,     private ClassRealm classRealm;, ,     private DependencyFilter extensionDependencyFilter;, ,     private final Set<String> lifecyclePhases = Collections.synchronizedSet( new LinkedHashSet<String>() );, ,     private Logger logger;, ,     public MavenProject(),     {,         Model model = new Model();, ,         model.setGroupId( EMPTY_PROJECT_GROUP_ID );,         model.setArtifactId( EMPTY_PROJECT_ARTIFACT_ID );,         model.setVersion( EMPTY_PROJECT_VERSION );, ,         setModel( model );,     }, ,     public MavenProject( Model model ),     {,         setModel( model );,     }, ,     /**,      * @deprecated use {@link #clone()} so subclasses can provide a copy of the same class,      */,     @Deprecated,     public MavenProject( MavenProject project ),     {,         repositorySystem = project.repositorySystem;,         logger = project.logger;,         mavenProjectBuilder = project.mavenProjectBuilder;,         projectBuilderConfiguration = project.projectBuilderConfiguration;,         deepCopy( project );,     },     ,     @Deprecated,     public MavenProject( Model model, RepositorySystem repositorySystem ),     {        ,         this.repositorySystem = repositorySystem;,         setModel( model );,     }, ,     public File getParentFile(),     {,         return parentFile;,     }, ,     public void setParentFile( File parentFile ),     {,         this.parentFile = parentFile;,     }, ,     /**,      * Constructor,      * ,      * @param repositorySystem - may not be null,      * @param mavenProjectBuilder,      * @param projectBuilderConfiguration,      * @throws InvalidRepositoryException,      */,     MavenProject( RepositorySystem repositorySystem, ProjectBuilder mavenProjectBuilder,,                   ProjectBuildingRequest projectBuilderConfiguration, Logger logger ),     {,         if ( repositorySystem == null ),         {,             throw new IllegalArgumentException( "mavenTools: null" );,         }, ,         this.mavenProjectBuilder = mavenProjectBuilder;,         this.projectBuilderConfiguration = projectBuilderConfiguration;,         this.repositorySystem = repositorySystem;,         this.logger = logger;,     }, ,     @Deprecated,     public Set<Artifact> createArtifacts( ArtifactFactory artifactFactory, String inheritedScope, ArtifactFilter filter ),         throws InvalidDependencyVersionException,     {,         return MavenMetadataSource.createArtifacts( artifactFactory, getDependencies(), inheritedScope, filter, this );,     }, ,     // TODO: Find a way to use <relativePath/> here...it's tricky, because the moduleProject,     // usually doesn't have a file associated with it yet.,     public String getModulePathAdjustment( MavenProject moduleProject ),         throws IOException,     {,         // FIXME: This is hacky. What if module directory doesn't match artifactid, and parent,         // is coming from the repository??,         String module = moduleProject.getArtifactId();, ,         File moduleFile = moduleProject.getFile();, ,         if ( moduleFile != null ),         {,             File moduleDir = moduleFile.getCanonicalFile().getParentFile();, ,             module = moduleDir.getName();,         }, ,         if ( moduleAdjustments == null ),         {,             moduleAdjustments = new HashMap<String, String>();, ,             List<String> modules = getModules();,             if ( modules != null ),             {,                 for ( String modulePath : modules ),                 {,                     String moduleName = modulePath;, ,                     if ( moduleName.endsWith( "/" ) || moduleName.endsWith( "\\" ) ),                     {,                         moduleName = moduleName.substring( 0, moduleName.length() - 1 );,                     }, ,                     int lastSlash = moduleName.lastIndexOf( '/' );, ,                     if ( lastSlash < 0 ),                     {,                         lastSlash = moduleName.lastIndexOf( '\\' );,                     }, ,                     String adjustment = null;, ,                     if ( lastSlash > -1 ),                     {,                         moduleName = moduleName.substring( lastSlash + 1 );,                         adjustment = modulePath.substring( 0, lastSlash );,                     }, ,                     moduleAdjustments.put( moduleName, adjustment );,                 },             },         }, ,         return moduleAdjustments.get( module );,     }, ,     // ----------------------------------------------------------------------,     // Accessors,     // ----------------------------------------------------------------------, ,     public Artifact getArtifact(),     {,         return artifact;,     }, ,     public void setArtifact( Artifact artifact ),     {,         this.artifact = artifact;,     }, ,     //@todo I would like to get rid of this. jvz.,     public Model getModel(),     {,         return model;,     }, ,     /**,      * Returns the project corresponding to a declared parent.,      * @return the parent, or null if no parent is declared or there was an error building it,      */,     public MavenProject getParent(),     {,         if ( parent == null ),         {,             /*,              * TODO: This is suboptimal. Without a cache in the project builder, rebuilding the parent chain currently,              * causes O(n^2) parser invocations for an inheritance hierarchy of depth n.,              */,             if ( parentFile != null ),             {,                 checkProjectBuildingRequest();,                 ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );,                 request.setRemoteRepositories( getRemoteArtifactRepositories() );, ,                 try,                 {,                     parent = mavenProjectBuilder.build( parentFile, request ).getProject();,                 },                 catch ( ProjectBuildingException e ),                 {,                     if ( logger != null ),                     {,                         logger.error( "Failed to build parent project for " + getId(), e );,                     },                     parent = ERROR_BUILDING_PARENT;,                 },             },             else if ( model.getParent() != null ),             {,                 checkProjectBuildingRequest();,                 ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );,                 request.setRemoteRepositories( getRemoteArtifactRepositories() );, ,                 try,                 {,                     parent = mavenProjectBuilder.build( getParentArtifact(), request ).getProject();,                 },                 catch ( ProjectBuildingException e ),                 {,                     if ( logger != null ),                     {,                         logger.error( "Failed to build parent project for " + getId(), e );,                     },                     parent = ERROR_BUILDING_PARENT;,                 },             },         },         return parent == ERROR_BUILDING_PARENT ? null : parent;,     }, ,     public void setParent( MavenProject parent ),     {,         this.parent = parent;,     },     ,     public boolean hasParent(),     {,         return getParent() != null;,     }, ,     public File getFile(),     {,         return file;,     }, ,     public void setFile( File file ),     {,         this.file = file;,     }, ,     public File getBasedir(),     {,         if ( getFile() != null ),         {,             return getFile().getParentFile();,         },         else,         {,             // repository based POM,             return null;,         },     }, ,     public void setDependencies( List<Dependency> dependencies ),     {,         getModel().setDependencies( dependencies );,     }, ,     public List<Dependency> getDependencies(),     {,         return getModel().getDependencies();,     }, ,     public DependencyManagement getDependencyManagement(),     {,         return getModel().getDependencyManagement();,     }, ,     // ----------------------------------------------------------------------,     // Test and compile sourceroots.,     // ----------------------------------------------------------------------, ,     private void addPath( List<String> paths, String path ),     {,         if ( path != null ),         {,             path = path.trim();,             if ( path.length() > 0 ),             {,                 File file = new File( path );,                 if ( file.isAbsolute() ),                 {,                     path = file.getAbsolutePath();,                 },                 else,                 {,                     path = new File( getBasedir(), path ).getAbsolutePath();,                 }, ,                 if ( !paths.contains( path ) ),                 {,                     paths.add( path );,                 },             },         },     }, ,     public void addCompileSourceRoot( String path ),     {,         addPath( getCompileSourceRoots(), path );,     }, ,     public void addScriptSourceRoot( String path ),     {,         if ( path != null ),         {,             path = path.trim();,             if ( path.length() != 0 ),             {,                 if ( !getScriptSourceRoots().contains( path ) ),                 {,                     getScriptSourceRoots().add( path );,                 },             },         },     }, ,     public void addTestCompileSourceRoot( String path ),     {,         addPath( getTestCompileSourceRoots(), path );,     }, ,     public List<String> getCompileSourceRoots(),     {,         return compileSourceRoots;,     }, ,     public List<String> getScriptSourceRoots(),     {,         return scriptSourceRoots;,     }, ,     public List<String> getTestCompileSourceRoots(),     {,         return testCompileSourceRoots;,     }, ,     public List<String> getCompileClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );, ,         String d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         for ( Artifact a : getArtifacts() ),         {                        ,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     addArtifactPath( a, list );,                 },             },         }, ,         return list;,     }, ,     @Deprecated,     public List<Artifact> getCompileArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts() ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     list.add( a );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getCompileDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: let the scope handler deal with this,             if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),             {,                 Dependency dependency = new Dependency();, ,                 dependency.setArtifactId( a.getArtifactId() );,                 dependency.setGroupId( a.getGroupId() );,                 dependency.setVersion( a.getVersion() );,                 dependency.setScope( a.getScope() );,                 dependency.setType( a.getType() );,                 dependency.setClassifier( a.getClassifier() );, ,                 list.add( dependency );,             },         },         return list;,     }, ,     //TODO: this checking for file == null happens because the resolver has been confused about the root,     // artifact or not. things like the stupid dummy artifact coming from surefire.,     public List<String> getTestClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() + 2 );, ,         String d = getBuild().getTestOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         },         ,         for ( Artifact a : getArtifacts() ),         {            ,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {                ,                 addArtifactPath( a, list );,             },         }, ,         return list;,     }, ,     @Deprecated,     public List<Artifact> getTestArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts() ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 list.add( a );,             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getTestDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             Dependency dependency = new Dependency();, ,             dependency.setArtifactId( a.getArtifactId() );,             dependency.setGroupId( a.getGroupId() );,             dependency.setVersion( a.getVersion() );,             dependency.setScope( a.getScope() );,             dependency.setType( a.getType() );,             dependency.setClassifier( a.getClassifier() );, ,             list.add( dependency );,         },         return list;,     }, ,     public List<String> getRuntimeClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );, ,         String d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         for ( Artifact a : getArtifacts() ),         {,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ),                 {,                     addArtifactPath( a, list );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Artifact> getRuntimeArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ),                 {,                     list.add( a );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getRuntimeDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: let the scope handler deal with this,             if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ),             {,                 Dependency dependency = new Dependency();, ,                 dependency.setArtifactId( a.getArtifactId() );,                 dependency.setGroupId( a.getGroupId() );,                 dependency.setVersion( a.getVersion() );,                 dependency.setScope( a.getScope() );,                 dependency.setType( a.getType() );,                 dependency.setClassifier( a.getClassifier() );, ,                 list.add( dependency );,             },         },         return list;,     }, ,     public List<String> getSystemClasspathElements(),         throws DependencyResolutionRequiredException,     {,         List<String> list = new ArrayList<String>( getArtifacts().size() );, ,         String d = getBuild().getOutputDirectory();,         if ( d != null ),         {,             list.add( d );,         }, ,         for ( Artifact a : getArtifacts() ),         {,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     addArtifactPath( a, list );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Artifact> getSystemArtifacts(),     {,         List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: classpath check doesn't belong here - that's the other method,             if ( a.getArtifactHandler().isAddedToClasspath() ),             {,                 // TODO: let the scope handler deal with this,                 if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),                 {,                     list.add( a );,                 },             },         },         return list;,     }, ,     @Deprecated,     public List<Dependency> getSystemDependencies(),     {,         Set<Artifact> artifacts = getArtifacts();, ,         if ( ( artifacts == null ) || artifacts.isEmpty() ),         {,             return Collections.emptyList();,         }, ,         List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );, ,         for ( Artifact a : getArtifacts()  ),         {,             // TODO: let the scope handler deal with this,             if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ),             {,                 Dependency dependency = new Dependency();, ,                 dependency.setArtifactId( a.getArtifactId() );,                 dependency.setGroupId( a.getGroupId() );,                 dependency.setVersion( a.getVersion() );,                 dependency.setScope( a.getScope() );,                 dependency.setType( a.getType() );,                 dependency.setClassifier( a.getClassifier() );, ,                 list.add( dependency );,             },         },         return list;,     }, ,     // ----------------------------------------------------------------------,     // Delegate to the model,     // ----------------------------------------------------------------------, ,     public void setModelVersion( String pomVersion ),     {,         getModel().setModelVersion( pomVersion );,     }, ,     public String getModelVersion(),     {,         return getModel().getModelVersion();,     }, ,     public String getId(),     {,         return getModel().getId();,     }, ,     public void setGroupId( String groupId ),     {,         getModel().setGroupId( groupId );,     }, ,     public String getGroupId(),     {,         String groupId = getModel().getGroupId();, ,         if ( ( groupId == null ) && ( getModel().getParent() != null ) ),         {,             groupId = getModel().getParent().getGroupId();,         }, ,         return groupId;,     }, ,     public void setArtifactId( String artifactId ),     {,         getModel().setArtifactId( artifactId );,     }, ,     public String getArtifactId(),     {,         return getModel().getArtifactId();,     }, ,     public void setName( String name ),     {,         getModel().setName( name );,     }, ,     public String getName(),     {,         // TODO: this should not be allowed to be null.,         if ( getModel().getName() != null ),         {,             return getModel().getName();,         },         else,         {,             return getArtifactId();,         },     }, ,     public void setVersion( String version ),     {,         getModel().setVersion( version );,     }, ,     public String getVersion(),     {,         String version = getModel().getVersion();, ,         if ( ( version == null ) && ( getModel().getParent() != null ) ),         {,             version = getModel().getParent().getVersion();,         }, ,         return version;,     }, ,     public String getPackaging(),     {,         return getModel().getPackaging();,     }, ,     public void setPackaging( String packaging ),     {,         getModel().setPackaging( packaging );,     }, ,     public void setInceptionYear( String inceptionYear ),     {,         getModel().setInceptionYear( inceptionYear );,     }, ,     public String getInceptionYear(),     {,         return getModel().getInceptionYear();,     }, ,     public void setUrl( String url ),     {,         getModel().setUrl( url );,     }, ,     public String getUrl(),     {,         return getModel().getUrl();,     }, ,     public Prerequisites getPrerequisites(),     {,         return getModel().getPrerequisites();,     }, ,     public void setIssueManagement( IssueManagement issueManagement ),     {,         getModel().setIssueManagement( issueManagement );,     }, ,     public CiManagement getCiManagement(),     {,         return getModel().getCiManagement();,     }, ,     public void setCiManagement( CiManagement ciManagement ),     {,         getModel().setCiManagement( ciManagement );,     }, ,     public IssueManagement getIssueManagement(),     {,         return getModel().getIssueManagement();,     }, ,     public void setDistributionManagement( DistributionManagement distributionManagement ),     {,         getModel().setDistributionManagement( distributionManagement );,     }, ,     public DistributionManagement getDistributionManagement(),     {,         return getModel().getDistributionManagement();,     }, ,     public void setDescription( String description ),     {,         getModel().setDescription( description );,     }, ,     public String getDescription(),     {,         return getModel().getDescription();,     }, ,     public void setOrganization( Organization organization ),     {,         getModel().setOrganization( organization );,     }, ,     public Organization getOrganization(),     {,         return getModel().getOrganization();,     }, ,     public void setScm( Scm scm ),     {,         getModel().setScm( scm );,     }, ,     public Scm getScm(),     {,         return getModel().getScm();,     }, ,     public void setMailingLists( List<MailingList> mailingLists ),     {,         getModel().setMailingLists( mailingLists );,     }, ,     public List<MailingList> getMailingLists(),     {,         return getModel().getMailingLists();,     }, ,     public void addMailingList( MailingList mailingList ),     {,         getModel().addMailingList( mailingList );,     }, ,     public void setDevelopers( List<Developer> developers ),     {,         getModel().setDevelopers( developers );,     }, ,     public List<Developer> getDevelopers(),     {,         return getModel().getDevelopers();,     }, ,     public void addDeveloper( Developer developer ),     {,         getModel().addDeveloper( developer );,     }, ,     public void setContributors( List<Contributor> contributors ),     {,         getModel().setContributors( contributors );,     }, ,     public List<Contributor> getContributors(),     {,         return getModel().getContributors();,     }, ,     public void addContributor( Contributor contributor ),     {,         getModel().addContributor( contributor );,     }, ,     public void setBuild( Build build ),     {,         getModel().setBuild( build );,     }, ,     public Build getBuild(),     {,         return getModelBuild();,     }, ,     public List<Resource> getResources(),     {,         return getBuild().getResources();,     }, ,     public List<Resource> getTestResources(),     {,         return getBuild().getTestResources();,     }, ,     public void addResource( Resource resource ),     {,         getBuild().addResource( resource );,     }, ,     public void addTestResource( Resource testResource ),     {,         getBuild().addTestResource( testResource );,     }, ,     @Deprecated,     public void setReporting( Reporting reporting ),     {,         getModel().setReporting( reporting );,     }, ,     @Deprecated,     public Reporting getReporting(),     {,         return getModel().getReporting();,     }, ,     public void setLicenses( List<License> licenses ),     {,         getModel().setLicenses( licenses );,     }, ,     public List<License> getLicenses(),     {,         return getModel().getLicenses();,     }, ,     public void addLicense( License license ),     {,         getModel().addLicense( license );,     }, ,     public void setArtifacts( Set<Artifact> artifacts ),     {,         this.artifacts = artifacts;, ,         // flush the calculated artifactMap,         artifactMap = null;,     }, ,     /**,      * All dependencies that this project has, including transitive ones. Contents are lazily,      * populated, so depending on what phases have run dependencies in some scopes won't be,      * included. eg. if only compile phase has run, dependencies with scope test won't be included.,      * ,      * @return {@link Set} &lt; {@link Artifact} >,      * @see #getDependencyArtifacts() to get only direct dependencies,      */,     public Set<Artifact> getArtifacts(),     {,         if ( artifacts == null ),         {,             if ( artifactFilter == null || resolvedArtifacts == null ),             {,                 artifacts = new LinkedHashSet<Artifact>();,             },             else,             {,                 artifacts = new LinkedHashSet<Artifact>( resolvedArtifacts.size() * 2 );,                 for ( Artifact artifact : resolvedArtifacts ),                 {,                     if ( artifactFilter.include( artifact ) ),                     {,                         artifacts.add( artifact );,                     },                 },             },         },         return artifacts;,     }, ,     public Map<String, Artifact> getArtifactMap(),     {,         if ( artifactMap == null ),         {,             artifactMap = ArtifactUtils.artifactMapByVersionlessId( getArtifacts() );,         },         return artifactMap;,     }, ,     public void setPluginArtifacts( Set<Artifact> pluginArtifacts ),     {,         this.pluginArtifacts = pluginArtifacts;, ,         this.pluginArtifactMap = null;,     }, ,     public Set<Artifact> getPluginArtifacts(),     {,         if ( pluginArtifacts != null ),         {,             return pluginArtifacts;,         }, ,         pluginArtifacts = new HashSet<Artifact>();, ,         if ( repositorySystem != null ),         {,             for ( Plugin p : getBuildPlugins() ),             {,                 Artifact artifact = repositorySystem.createPluginArtifact( p );, ,                 if ( artifact != null ),                 {,                     pluginArtifacts.add( artifact );,                 },             },         }, ,         pluginArtifactMap = null;, ,         return pluginArtifacts;,     }, ,     public Map<String, Artifact> getPluginArtifactMap(),     {,         if ( pluginArtifactMap == null ),         {,             pluginArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getPluginArtifacts() );,         }, ,         return pluginArtifactMap;,     }, ,     @Deprecated,     public void setReportArtifacts( Set<Artifact> reportArtifacts ),     {,         this.reportArtifacts = reportArtifacts;, ,         reportArtifactMap = null;,     }, ,     @Deprecated,     public Set<Artifact> getReportArtifacts(),     {,         if ( reportArtifacts != null ),         {,             return reportArtifacts;,         }, ,         reportArtifacts = new HashSet<Artifact>();, ,         if ( repositorySystem != null ),         {,             for ( ReportPlugin p : getReportPlugins() ),             {,                 Plugin pp = new Plugin();,                 pp.setGroupId( p.getGroupId() );,                 pp.setArtifactId( p.getArtifactId() );,                 pp.setVersion( p.getVersion() );, ,                 Artifact artifact = repositorySystem.createPluginArtifact( pp );, ,                 if ( artifact != null ),                 {,                     reportArtifacts.add( artifact );,                 },             },         }, ,         reportArtifactMap = null;, ,         return reportArtifacts;,     }, ,     @Deprecated,     public Map<String, Artifact> getReportArtifactMap(),     {,         if ( reportArtifactMap == null ),         {,             reportArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getReportArtifacts() );,         }, ,         return reportArtifactMap;,     }, ,     public void setExtensionArtifacts( Set<Artifact> extensionArtifacts ),     {,         this.extensionArtifacts = extensionArtifacts;, ,         extensionArtifactMap = null;,     }, ,     public Set<Artifact> getExtensionArtifacts(),     {,         if ( extensionArtifacts != null ),         {,             return extensionArtifacts;,         },         extensionArtifacts = new HashSet<Artifact>();,         List<Extension> extensions = getBuildExtensions();,         if ( extensions != null ),         {,             for ( Extension ext : extensions ),             {,                 String version;,                 if ( StringUtils.isEmpty( ext.getVersion() ) ),                 {,                     version = "RELEASE";,                 },                 else,                 {,                     version = ext.getVersion();,                 }, ,                 Artifact artifact =,                     repositorySystem.createArtifact( ext.getGroupId(), ext.getArtifactId(), version, null, "jar" );, ,                 if ( artifact != null ),                 {,                     extensionArtifacts.add( artifact );,                 },             },         },         extensionArtifactMap = null;,         return extensionArtifacts;,     }, ,     public Map<String, Artifact> getExtensionArtifactMap(),     {,         if ( extensionArtifactMap == null ),         {,             extensionArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getExtensionArtifacts() );,         }, ,         return extensionArtifactMap;,     }, ,     public void setParentArtifact( Artifact parentArtifact ),     {,         this.parentArtifact = parentArtifact;,     }, ,     public Artifact getParentArtifact(),     {,         if ( parentArtifact == null && model.getParent() != null ),         {,             Parent p = model.getParent();,             parentArtifact = repositorySystem.createProjectArtifact( p.getGroupId(), p.getArtifactId(), p.getVersion() );,         },         return parentArtifact;,     }, ,     public List<Repository> getRepositories(),     {,         return getModel().getRepositories();,     }, ,     // ----------------------------------------------------------------------,     // Plugins,     // ----------------------------------------------------------------------, ,     @Deprecated,     public List<ReportPlugin> getReportPlugins(),     {,         if ( getModel().getReporting() == null ),         {,             return Collections.emptyList();,         },         return getModel().getReporting().getPlugins();, ,     }, ,     public List<Plugin> getBuildPlugins(),     {,         if ( getModel().getBuild() == null ),         {,             return Collections.emptyList();,         },         return getModel().getBuild().getPlugins();,     }, ,     public List<String> getModules(),     {,         return getModel().getModules();,     }, ,     public PluginManagement getPluginManagement(),     {,         PluginManagement pluginMgmt = null;, ,         Build build = getModel().getBuild();,         if ( build != null ),         {,             pluginMgmt = build.getPluginManagement();,         }, ,         return pluginMgmt;,     }, ,     private Build getModelBuild(),     {,         Build build = getModel().getBuild();, ,         if ( build == null ),         {,             build = new Build();, ,             getModel().setBuild( build );,         }, ,         return build;,     }, ,     public void setRemoteArtifactRepositories( List<ArtifactRepository> remoteArtifactRepositories ),     {,         this.remoteArtifactRepositories = remoteArtifactRepositories;,         this.remoteProjectRepositories = RepositoryUtils.toRepos( getRemoteArtifactRepositories() );,     }, ,     public List<ArtifactRepository> getRemoteArtifactRepositories(),     {,         if ( remoteArtifactRepositories == null ),         {,             remoteArtifactRepositories = new ArrayList<ArtifactRepository>();,         }, ,         return remoteArtifactRepositories;,     }, ,     public void setPluginArtifactRepositories( List<ArtifactRepository> pluginArtifactRepositories ),     {,         this.pluginArtifactRepositories = pluginArtifactRepositories;,         this.remotePluginRepositories = RepositoryUtils.toRepos( getPluginArtifactRepositories() );,     }, ,     /**,      * @return a list of ArtifactRepository objects constructed from the Repository objects returned,      *         by getPluginRepositories.,      */,     public List<ArtifactRepository> getPluginArtifactRepositories(),     {,         if ( pluginArtifactRepositories == null ),         {,             pluginArtifactRepositories = new ArrayList<ArtifactRepository>();,         }, ,         return pluginArtifactRepositories;,     }, ,     public ArtifactRepository getDistributionManagementArtifactRepository(),     {,         return getArtifact().isSnapshot() && ( getSnapshotArtifactRepository() != null ) ? getSnapshotArtifactRepository() : getReleaseArtifactRepository();,     }, ,     public List<Repository> getPluginRepositories(),     {,         return getModel().getPluginRepositories();,     }, ,     public List<RemoteRepository> getRemoteProjectRepositories(),     {,         return remoteProjectRepositories;,     }, ,     public List<RemoteRepository> getRemotePluginRepositories(),     {,         return remotePluginRepositories;,     }, ,     public void setActiveProfiles( List<Profile> activeProfiles ),     {,         this.activeProfiles = activeProfiles;,     }, ,     public List<Profile> getActiveProfiles(),     {,         return activeProfiles;,     }, ,     public void setInjectedProfileIds( String source, List<String> injectedProfileIds ),     {,         if ( injectedProfileIds != null ),         {,             this.injectedProfileIds.put( source, new ArrayList<String>( injectedProfileIds ) );,         },         else,         {,             this.injectedProfileIds.remove( source );,         },     }, ,     /**,      * Gets the identifiers of all profiles that contributed to this project's effective model. This includes active,      * profiles from the project's POM and all its parent POMs as well as from external sources like the {@code,      * settings.xml}. The profile identifiers are grouped by the identifier of their source, e.g. {@code,      * <groupId>:<artifactId>:<version>} for a POM profile or {@code external} for profiles from the {@code,      * settings.xml}.,      * ,      * @return The identifiers of all injected profiles, indexed by the source from which the profiles originated, never,      *         {@code null}.,      */,     public Map<String, List<String>> getInjectedProfileIds(),     {,         return this.injectedProfileIds;,     }, ,     private String logStringForArtifactFile( Artifact a ),     {,         if ( a.getFile() != null ),         {,             return a.getFile().getAbsolutePath();,         },         else,         {,             return "(no path)";,         },     }, ,     /**,      * Add or replace an artifact.,      * In spite of the 'throws' declaration on this API, this method has never thrown an exception since Maven 3.0.x.,      * Historically, it logged and ignored a second addition of the same g/a/v/c/t. Now it replaces the file for,      * the artifact, so that plugins (e.g. shade) can change the pathname of the file for a particular set of,      * coordinates.,      * @param artifact the artifact to add or replace.,      * @throws DuplicateArtifactAttachmentException,      */,     public void addAttachedArtifact( Artifact artifact ),         throws DuplicateArtifactAttachmentException,     {,         List<Artifact> attachedArtifacts = getAttachedArtifacts();,         for ( int ax = 0; ax < attachedArtifacts.size(); ax++ ),         {,             Artifact a = attachedArtifacts.get( ax );,             if ( a.equals( artifact ) ),             {,                 if ( logger != null ),                 {,                     logger.debug( String.format( "Replacing attached artifact %s. Old path %s, new path %s. ",,                                                  a,,                                                  logStringForArtifactFile( a ),,                                                  logStringForArtifactFile( artifact ) ) );,                 },                 attachedArtifacts.set( ax, artifact );,                 return;,             },         }, ,         getAttachedArtifacts().add( artifact );,     }, ,     public List<Artifact> getAttachedArtifacts(),     {,         if ( attachedArtifacts == null ),         {,             attachedArtifacts = new ArrayList<Artifact>();,         },         return attachedArtifacts;,     }, ,     public Xpp3Dom getGoalConfiguration( String pluginGroupId, String pluginArtifactId, String executionId,,                                          String goalId ),     {,         Xpp3Dom dom = null;, ,         if ( getBuildPlugins() != null ),         {,             for ( Plugin plugin : getBuildPlugins() ),             {,                 if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) ),                 {,                     dom = (Xpp3Dom) plugin.getConfiguration();, ,                     if ( executionId != null ),                     {,                         PluginExecution execution = plugin.getExecutionsAsMap().get( executionId );,                         if ( execution != null ),                         {,                             // NOTE: The PluginConfigurationExpander already merged the plugin-level config in,                             dom = (Xpp3Dom) execution.getConfiguration();,                         },                     },                     break;,                 },             },         }, ,         if ( dom != null ),         {,             // make a copy so the original in the POM doesn't get messed with,             dom = new Xpp3Dom( dom );,         }, ,         return dom;,     }, ,     @Deprecated,     public Xpp3Dom getReportConfiguration( String pluginGroupId, String pluginArtifactId, String reportSetId ),     {,         Xpp3Dom dom = null;, ,         // ----------------------------------------------------------------------,         // I would like to be able to lookup the Mojo object using a key but,         // we have a limitation in modello that will be remedied shortly. So,         // for now I have to iterate through and see what we have.,         // ----------------------------------------------------------------------, ,         if ( getReportPlugins() != null ),         {,             for ( ReportPlugin plugin : getReportPlugins() ),             {,                 if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) ),                 {,                     dom = (Xpp3Dom) plugin.getConfiguration();, ,                     if ( reportSetId != null ),                     {,                         ReportSet reportSet = plugin.getReportSetsAsMap().get( reportSetId );,                         if ( reportSet != null ),                         {,                             Xpp3Dom executionConfiguration = (Xpp3Dom) reportSet.getConfiguration();,                             if ( executionConfiguration != null ),                             {,                                 Xpp3Dom newDom = new Xpp3Dom( executionConfiguration );,                                 dom = Xpp3Dom.mergeXpp3Dom( newDom, dom );,                             },                         },                     },                     break;,                 },             },         }, ,         if ( dom != null ),         {,             // make a copy so the original in the POM doesn't get messed with,             dom = new Xpp3Dom( dom );,         }, ,         return dom;,     }, ,     public MavenProject getExecutionProject(),     {,         return ( executionProject == null ? this : executionProject );,     }, ,     public void setExecutionProject( MavenProject executionProject ),     {,         this.executionProject = executionProject;,     }, ,     public List<MavenProject> getCollectedProjects(),     {,         return collectedProjects;,     }, ,     public void setCollectedProjects( List<MavenProject> collectedProjects ),     {,         this.collectedProjects = collectedProjects;,     }, ,     /**,      * Direct dependencies that this project has.,      * ,      * @return {@link Set} &lt; {@link Artifact} >,      * @see #getArtifacts() to get all transitive dependencies,      */,     public Set<Artifact> getDependencyArtifacts(),     {,         return dependencyArtifacts;,     }, ,     public void setDependencyArtifacts( Set<Artifact> dependencyArtifacts ),     {,         this.dependencyArtifacts = dependencyArtifacts;,     }, ,     public void setReleaseArtifactRepository( ArtifactRepository releaseArtifactRepository ),     {,         this.releaseArtifactRepository = releaseArtifactRepository;,     }, ,     public void setSnapshotArtifactRepository( ArtifactRepository snapshotArtifactRepository ),     {,         this.snapshotArtifactRepository = snapshotArtifactRepository;,     }, ,     public void setOriginalModel( Model originalModel ),     {,         this.originalModel = originalModel;,     }, ,     public Model getOriginalModel(),     {,         return originalModel;,     }, ,     public void setManagedVersionMap( Map<String, Artifact> map ),     {,         managedVersionMap = map;,     }, ,     public Map<String, Artifact> getManagedVersionMap(),     {,         if ( managedVersionMap != null ),         {,             return managedVersionMap;,         }, ,         Map<String, Artifact> map = null;,         if ( repositorySystem != null ),         {, ,             List<Dependency> deps;,             DependencyManagement dependencyManagement = getDependencyManagement();,             if ( ( dependencyManagement != null ) && ( ( deps = dependencyManagement.getDependencies() ) != null ) && ( deps.size() > 0 ) ),             {,                 map = new HashMap<String, Artifact>();,                 for ( Dependency d : dependencyManagement.getDependencies() ),                 {,                     Artifact artifact = repositorySystem.createDependencyArtifact( d );, ,                     if ( artifact == null ),                     {,                         map = Collections.emptyMap();,                     }, ,                     map.put( d.getManagementKey(), artifact );,                 },             },             else,             {,                 map = Collections.emptyMap();,             },         },         managedVersionMap = map;,         return managedVersionMap;,     }, ,     @Override,     public boolean equals( Object other ),     {,         if ( other == this ),         {,             return true;,         },         else if ( !( other instanceof MavenProject ) ),         {,             return false;,         }, ,         MavenProject that = (MavenProject) other;, ,         return eq( getArtifactId(), that.getArtifactId() ),             && eq( getGroupId(), that.getGroupId() ),             && eq( getVersion(), that.getVersion() );,     }, ,     private static <T> boolean eq( T s1, T s2 ),     {,         return ( s1 != null ) ? s1.equals( s2 ) : s2 == null;,     }, ,     @Override,     public int hashCode(),     {,         int hash = 17;,         hash = 31 * hash + getGroupId().hashCode();,         hash = 31 * hash + getArtifactId().hashCode();,         hash = 31 * hash + getVersion().hashCode();,         return hash;,     }, ,     public List<Extension> getBuildExtensions(),     {,         Build build = getBuild();,         if ( ( build == null ) || ( build.getExtensions() == null ) ),         {,             return Collections.emptyList();,         },         else,         {,             return build.getExtensions();,         },     }, ,     public void addProjectReference( MavenProject project ),     {,         projectReferences.put( getProjectReferenceId( project.getGroupId(), project.getArtifactId(), project.getVersion() ), project );,     }, ,     /**,      * @deprecated Use MavenProjectHelper.attachArtifact(..) instead.,      */,     @Deprecated,     public void attachArtifact( String type, String classifier, File file ),     {,     }, ,     public Properties getProperties(),     {,         return getModel().getProperties();,     }, ,     public List<String> getFilters(),     {,         return getBuild().getFilters();,     }, ,     public Map<String, MavenProject> getProjectReferences(),     {,         return projectReferences;,     }, ,     public boolean isExecutionRoot(),     {,         return executionRoot;,     }, ,     public void setExecutionRoot( boolean executionRoot ),     {,         this.executionRoot = executionRoot;,     }, ,     public String getDefaultGoal(),     {,         return getBuild() != null ? getBuild().getDefaultGoal() : null;,     }, ,     public Plugin getPlugin( String pluginKey ),     {,         return getBuild().getPluginsAsMap().get( pluginKey );,     }, ,     /**,      * Default toString,      */,     @Override,     public String toString(),     {,         StringBuilder sb = new StringBuilder( 128 );,         sb.append( "MavenProject: " );,         sb.append( getGroupId() );,         sb.append( ":" );,         sb.append( getArtifactId() );,         sb.append( ":" );,         sb.append( getVersion() );,         sb.append( " @ " );, ,         try,         {,             sb.append( getFile().getPath() );,         },         catch ( NullPointerException e ),         {,             //don't log it.,         }, ,         return sb.toString();,     }, ,     /**,      * @deprecated Use {@link org.apache.maven.model.io.ModelWriter}.,      */,     @Deprecated,     public void writeModel( Writer writer ),         throws IOException,     {,         MavenXpp3Writer pomWriter = new MavenXpp3Writer();,         pomWriter.write( writer, getModel() );,     }, ,     /**,      * @deprecated Use {@link org.apache.maven.model.io.ModelWriter}.,      */,     @Deprecated,     public void writeOriginalModel( Writer writer ),         throws IOException,     {,         MavenXpp3Writer pomWriter = new MavenXpp3Writer();,         pomWriter.write( writer, getOriginalModel() );,     }, ,     /**,      * @throws CloneNotSupportedException,      * @since 2.0.9,      */,     @Override,     public MavenProject clone(),     {,         MavenProject clone;,         try,         {,             clone = (MavenProject) super.clone();,         },         catch ( CloneNotSupportedException e ),         {,             throw new UnsupportedOperationException( e );,         }, ,         clone.deepCopy( this );, ,         return clone;,     }, ,     protected void setModel( Model model ),     {,         this.model = model;,     }, ,     protected void setAttachedArtifacts( List<Artifact> attachedArtifacts ),     {,         this.attachedArtifacts = attachedArtifacts;,     }, ,     protected void setCompileSourceRoots( List<String> compileSourceRoots ),     {,         this.compileSourceRoots = compileSourceRoots;,     }, ,     protected void setTestCompileSourceRoots( List<String> testCompileSourceRoots ),     {,         this.testCompileSourceRoots = testCompileSourceRoots;,     }, ,     protected void setScriptSourceRoots( List<String> scriptSourceRoots ),     {,         this.scriptSourceRoots = scriptSourceRoots;,     }, ,     protected ArtifactRepository getReleaseArtifactRepository(),     {,         if ( releaseArtifactRepository == null ),         {,             if ( getDistributionManagement() != null && getDistributionManagement().getRepository() != null ),             {,                 checkProjectBuildingRequest();,                 try,                 {,                     ArtifactRepository repo =,                         repositorySystem.buildArtifactRepository( getDistributionManagement().getRepository() );,                     repositorySystem.injectProxy( projectBuilderConfiguration.getRepositorySession(),,                                                   Arrays.asList( repo ) );,                     repositorySystem.injectAuthentication( projectBuilderConfiguration.getRepositorySession(),,                                                            Arrays.asList( repo ) );,                     setReleaseArtifactRepository( repo );,                 },                 catch ( InvalidRepositoryException e ),                 {,                     throw new IllegalStateException( "Failed to create release distribution repository for " + getId(),,                                                      e );,                 },             },         }, ,         return releaseArtifactRepository;,     }, ,     protected ArtifactRepository getSnapshotArtifactRepository(),     {,         if ( snapshotArtifactRepository == null ),         {,             if ( getDistributionManagement() != null && getDistributionManagement().getSnapshotRepository() != null ),             {,                 checkProjectBuildingRequest();,                 try,                 {,                     ArtifactRepository repo =,                         repositorySystem.buildArtifactRepository( getDistributionManagement().getSnapshotRepository() );,                     repositorySystem.injectProxy( projectBuilderConfiguration.getRepositorySession(),,                                                   Arrays.asList( repo ) );,                     repositorySystem.injectAuthentication( projectBuilderConfiguration.getRepositorySession(),,                                                            Arrays.asList( repo ) );,                     setSnapshotArtifactRepository( repo );,                 },                 catch ( InvalidRepositoryException e ),                 {,                     throw new IllegalStateException(,                                                      "Failed to create snapshot distribution repository for " + getId(),,                                                      e );,                 },             },         }, ,         return snapshotArtifactRepository;,     }, ,     @Deprecated,     public Artifact replaceWithActiveArtifact( Artifact pluginArtifact ),     {,         return pluginArtifact;,     }, ,     private void deepCopy( MavenProject project ),     {,         // disown the parent, ,         // copy fields,         setFile( project.getFile() );, ,         // don't need a deep copy, they don't get modified or added/removed to/from - but make them unmodifiable to be,         // sure!,         if ( project.getDependencyArtifacts() != null ),         {,             setDependencyArtifacts( Collections.unmodifiableSet( project.getDependencyArtifacts() ) );,         }, ,         if ( project.getArtifacts() != null ),         {,             setArtifacts( Collections.unmodifiableSet( project.getArtifacts() ) );,         }, ,         if ( project.getParentFile() != null ),         {,             parentFile = new File( project.getParentFile().getAbsolutePath() );,         }, ,         if ( project.getPluginArtifacts() != null ),         {,             setPluginArtifacts( Collections.unmodifiableSet( project.getPluginArtifacts() ) );,         }, ,         if ( project.getReportArtifacts() != null ),         {,             setReportArtifacts( Collections.unmodifiableSet( project.getReportArtifacts() ) );,         }, ,         if ( project.getExtensionArtifacts() != null ),         {,             setExtensionArtifacts( Collections.unmodifiableSet( project.getExtensionArtifacts() ) );,         }, ,         setParentArtifact( ( project.getParentArtifact() ) );, ,         if ( project.getRemoteArtifactRepositories() != null ),         {,             setRemoteArtifactRepositories( Collections.unmodifiableList( project.getRemoteArtifactRepositories() ) );,         }, ,         if ( project.getPluginArtifactRepositories() != null ),         {,             setPluginArtifactRepositories( ( Collections.unmodifiableList( project.getPluginArtifactRepositories() ) ) );,         }, ,         if ( project.getActiveProfiles() != null ),         {,             setActiveProfiles( ( Collections.unmodifiableList( project.getActiveProfiles() ) ) );,         }, ,         if ( project.getAttachedArtifacts() != null ),         {,             // clone properties modifyable by plugins in a forked lifecycle,             setAttachedArtifacts( new ArrayList<Artifact>( project.getAttachedArtifacts() ) );,         }, ,         if ( project.getCompileSourceRoots() != null ),         {,             // clone source roots,             setCompileSourceRoots( ( new ArrayList<String>( project.getCompileSourceRoots() ) ) );,         }, ,         if ( project.getTestCompileSourceRoots() != null ),         {,             setTestCompileSourceRoots( ( new ArrayList<String>( project.getTestCompileSourceRoots() ) ) );,         }, ,         if ( project.getScriptSourceRoots() != null ),         {,             setScriptSourceRoots( ( new ArrayList<String>( project.getScriptSourceRoots() ) ) );,         }, ,         if ( project.getModel() != null ),         {,             setModel( project.getModel().clone() );,         }, ,         if ( project.getOriginalModel() != null ),         {,             setOriginalModel( project.getOriginalModel() );,         }, ,         setExecutionRoot( project.isExecutionRoot() );, ,         if ( project.getArtifact() != null ),         {,             setArtifact( ArtifactUtils.copyArtifact( project.getArtifact() ) );,         }, ,         if ( project.getManagedVersionMap() != null ),         {,             setManagedVersionMap( new HashMap<String, Artifact>( project.getManagedVersionMap() ) );,         }, ,         lifecyclePhases.addAll( project.lifecyclePhases );,     }, ,     private void addArtifactPath( Artifact artifact, List<String> classpath ),     {,         File file = artifact.getFile();,         if ( file != null ),         {,             classpath.add( file.getPath() );,         },     }, ,     private static String getProjectReferenceId( String groupId, String artifactId, String version ),     {,         StringBuilder buffer = new StringBuilder( 128 );,         buffer.append( groupId ).append( ':' ).append( artifactId ).append( ':' ).append( version );,         return buffer.toString();,     }, ,     /**,      * Sets the value of the context value of this project identified,      * by the given key. If the supplied value is <code>null</code>,,      * the context value is removed from this project.,      * ,      * Context values are intended to allow core extensions to associate,      * derived state with project instances. ,      */,     public void setContextValue( String key, Object value ),     {,         if ( context == null ),         {,             context = new HashMap<String, Object>();,         },         if ( value != null ),         {,             context.put( key, value );,         },         else,         {,             context.remove( key );,         },     }, ,     /**,      * Returns context value of this project associated with the given key ,      * or null if this project has no such value. ,      */,     public Object getContextValue( String key ),     {,         if ( context == null ),         {,             return null;,         },         return context.get( key );,     }, ,     /**,      * Sets the project's class realm. <strong>Warning:</strong> This is an internal utility method that is only public,      * for technical reasons, it is not part of the public API. In particular, this method can be changed or deleted,      * without prior notice and must not be used by plugins.,      * ,      * @param classRealm The class realm hosting the build extensions of this project, may be {@code null}.,      */,     public void setClassRealm( ClassRealm classRealm ),     {,         this.classRealm = classRealm;,     }, ,     /**,      * Gets the project's class realm. This class realm hosts the build extensions of the project.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @return The project's class realm or {@code null}.,      */,     public ClassRealm getClassRealm(),     {,         return classRealm;,     }, ,     /**,      * Sets the artifact filter used to exclude shared extension artifacts from plugin realms. <strong>Warning:</strong>,      * This is an internal utility method that is only public for technical reasons, it is not part of the public API.,      * In particular, this method can be changed or deleted without prior notice and must not be used by plugins.,      * ,      * @param extensionDependencyFilter The dependency filter to apply to plugins, may be {@code null}.,      */,     public void setExtensionDependencyFilter( DependencyFilter extensionDependencyFilter ),     {,         this.extensionDependencyFilter = extensionDependencyFilter;,     }, ,     /**,      * Gets the dependency filter used to exclude shared extension artifacts from plugin realms.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @return The dependency filter or {@code null}.,      */,     public DependencyFilter getExtensionDependencyFilter(),     {,         return extensionDependencyFilter;,     }, ,     /**,      * Sets the transitive dependency artifacts that have been resolved/collected for this project.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param artifacts The set of artifacts, may be {@code null}.,      */,     public void setResolvedArtifacts( Set<Artifact> artifacts ),     {,         this.resolvedArtifacts = ( artifacts != null ) ? artifacts : Collections.<Artifact> emptySet();,         this.artifacts = null;,         this.artifactMap = null;,     }, ,     /**,      * Sets the scope filter to select the artifacts being exposed to the currently executed mojo.,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param artifactFilter The artifact filter, may be {@code null} to exclude all artifacts.,      */,     public void setArtifactFilter( ArtifactFilter artifactFilter ),     {,         this.artifactFilter = artifactFilter;,         this.artifacts = null;,         this.artifactMap = null;,     }, ,     /**,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param phase The phase to check for, must not be {@code null}.,      * @return {@code true} if the phase has been seen.,      */,     public boolean hasLifecyclePhase( String phase ),     {,         return lifecyclePhases.contains( phase );,     }, ,     /**,      * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not,      * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be,      * used by plugins.,      * ,      * @param lifecyclePhase The lifecycle phase to add, must not be {@code null}.,      */,     public void addLifecyclePhase( String lifecyclePhase ),     {,         lifecyclePhases.add( lifecyclePhase );,     }, ,     /**,      * Gets the project building request from which this project instance was created. <strong>Warning:</strong> This is,      * an utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.,      * ,      * @return The project building request or {@code null}.,      * @since 2.1,      */,     public ProjectBuildingRequest getProjectBuildingRequest(),     {,         return projectBuilderConfiguration;,     }, ,     /**,      * Sets the project building request from which this project instance was created. <strong>Warning:</strong> This is,      * an utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.,      * ,      * @param projectBuildingRequest The project building request, may be {@code null}.,      * @since 2.1,      */,     public void setProjectBuildingRequest( ProjectBuildingRequest projectBuildingRequest ),     {,         projectBuilderConfiguration = projectBuildingRequest;,     }, ,     private void checkProjectBuildingRequest(),     {,         if ( projectBuilderConfiguration == null ),         {,             throw new IllegalStateException( "project building request missing" );,         },     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/project/ExtensionDescriptorBuilderTest.java,testCompleteDescriptor,94-94,[        ExtensionDescriptor ed = builder.build( toStream( xml ) );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/project/ExtensionDescriptorBuilderTest.java,testEmptyDescriptor,75-75,[        ExtensionDescriptor ed = builder.build( toStream( xml ) );],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/maven/project/validation/ModelValidationResult.java,,33-91,[    private static final String NEWLINE = System.getProperty( "line.separator" );, ,     /** */,     private List<String> messages;, ,     public ModelValidationResult(),     {,         messages = new ArrayList<String>();,     }, ,     public int getMessageCount(),     {,         return messages.size();,     }, ,     public String getMessage( int i ),     {,         return messages.get( i );,     }, ,     public List<String> getMessages(),     {,         return Collections.unmodifiableList( messages );,     }, ,     public void addMessage( String message ),     {,         messages.add( message );,     }, ,     public String toString(),     {,         return render( "" );,     }, ,     public String render( String indentation ),     {,         if ( messages.size() == 0 ),         {,             return indentation + "There were no validation errors.";,         }, ,         StringBuilder message = new StringBuilder();, , //        if ( messages.size() == 1 ), //        {, //            message.append( "There was 1 validation error: " );, //        }, //        else, //        {, //            message.append( "There was " + messages.size() + " validation errors: " + NEWLINE );, //        }, //,         for ( int i = 0; i < messages.size(); i++ ),         {,             message.append( indentation + "[" + i + "]  " + messages.get( i ) + NEWLINE );,         }, ,         return message.toString();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getBuild,1789-1789,[        return getBuild() != null ? getBuild().getDefaultGoal() : null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getArtifacts,1970-1970,[        if ( project.getArtifacts() != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getAttachedArtifacts,2012-2012,[        if ( project.getAttachedArtifacts() != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getPluginArtifactRepositories,2002-2002,[        if ( project.getPluginArtifactRepositories() != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getRemoteArtifactRepositories,1997-1997,[        if ( project.getRemoteArtifactRepositories() != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getBuild,1739-1739,[        if ( ( build == null ) || ( build.getExtensions() == null ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getBuildExtensions,1739-1739,[        if ( ( build == null ) || ( build.getExtensions() == null ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getArtifacts,570-570,[        if ( ( artifacts == null ) || artifacts.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getBuildExtensions,1262-1262,[        if ( extensions != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getManagedVersionMap,1678-1678,[            if ( ( dependencyManagement != null ) && ( ( deps = dependencyManagement.getDependencies() ) != null ) && ( deps.size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getModules,294-294,[            if ( modules != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getArtifacts,721-721,[        if ( ( artifacts == null ) || artifacts.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getArtifacts,798-798,[        if ( ( artifacts == null ) || artifacts.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/MavenProject.java,getArtifacts,648-648,[        if ( ( artifacts == null ) || artifacts.isEmpty() )],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/maven/project/MavenProjectTest.java,testIdentityProtoInheritance,84-84,[        project.getId();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/project/MavenProjectTest.java,,192-198,[        class L extends LoggerStub,         {,             @Override,             public void error( String s, Throwable throwable ),             {,                 logged.incrementAndGet();,             }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/ModelUtils.java,mergePluginDefinitions,223-223,[        if ( ( parentExecutions != null ) && !parentExecutions.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/ModelUtils.java,mergePluginExecutionDefinitions,287-287,[        if ( ( childGoals != null ) && !childGoals.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/ModelUtils.java,mergePluginExecutionDefinitions,292-292,[        if ( parentGoals != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/ModelUtils.java,mergePluginLists,64-64,[        if ( ( parentPlugins != null ) && !parentPlugins.isEmpty() )],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/project/PomConstructionTest.java,buildPom,1859-1859,[        return new PomTestWrapper( pomFile, projectBuilder.build( pomFile, config ).getProject() );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/project/PomConstructionTest.java,buildPom,1847-1847,[        config.setLocalRepository( repositorySystem.createArtifactRepository( "local", localRepoUrl, new DefaultRepositoryLayout(), null, null ) );],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/maven/project/ProjectModelResolver.java,,60-60,[    private final String context = "project";],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/ProjectSorter.java,<init>,146-146,[            if ( buildExtensions != null )],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/ProjectSorterTest.java,testMatchingIdsAndVersions,204-204,[            projects = new ProjectSorter( projects ).getSortedProjects();],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/maven/artifact/DefaultArtifact.java,equals,324-359,[        if ( o == this ),         {,             return true;,         }, ,         if ( !( o instanceof Artifact ) ),         {,             return false;,         }, ,         Artifact a = (Artifact) o;, ,         if ( !a.getGroupId().equals( groupId ) ),         {,             return false;,         },         else if ( !a.getArtifactId().equals( artifactId ) ),         {,             return false;,         },         else if ( !a.getVersion().equals( version ) ),         {,             return false;,         },         else if ( !a.getType().equals( type ) ),         {,             return false;,         },         else if ( a.getClassifier() == null ? classifier != null : !a.getClassifier().equals( classifier ) ),         {,             return false;,         }, ,         // We don't consider the version range in the comparison, just the resolved version, ,         return true;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/maven/project/artifact/DefaultMavenMetadataCache.java,,214-290,[        {,             this.pomArtifact = ArtifactUtils.copyArtifact( pomArtifact );,             this.relocatedArtifact = ArtifactUtils.copyArtifactSafe( relocatedArtifact );,             this.artifacts = ArtifactUtils.copyArtifacts( artifacts, new ArrayList<Artifact>() );,             this.remoteRepositories = new ArrayList<ArtifactRepository>( remoteRepositories );, ,             this.managedVersions = managedVersions;,             if ( managedVersions != null ),             {,                 this.managedVersions =,                     ArtifactUtils.copyArtifacts( managedVersions, new LinkedHashMap<String, Artifact>() );,             }, ,             File pomFile = pomArtifact.getFile();,             if ( pomFile != null && pomFile.canRead() ),             {,                 this.length = pomFile.length();,                 this.timestamp = pomFile.lastModified();,             },             else,             {,                 this.length = -1;,                 this.timestamp = -1;,             },         }, ,         public Artifact getArtifact(),         {,             return pomArtifact;,         }, ,         public Artifact getRelocatedArtifact(),         {,             return relocatedArtifact;,         }, ,         public List<Artifact> getArtifacts(),         {,             return artifacts;,         }, ,         public Map<String, Artifact> getManagedVersions(),         {,             return managedVersions;,         }, ,         public List<ArtifactRepository> getRemoteRepositories(),         {,             return remoteRepositories;,         }, ,         public boolean isStale(),         {,             File pomFile = pomArtifact.getFile();,             if ( pomFile != null ),             {,                 if ( pomFile.canRead() ),                 {,                     return length != pomFile.length() || timestamp != pomFile.lastModified();,                 },                 else,                 {,                     // if the POM didn't exist, retry if any repo is configured to always update,                     boolean snapshot = pomArtifact.isSnapshot();,                     for ( ArtifactRepository repository : remoteRepositories ),                     {,                         ArtifactRepositoryPolicy policy =,                             snapshot ? repository.getSnapshots() : repository.getReleases();,                         if ( ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS.equals( policy.getUpdatePolicy() ) ),                         {,                             return true;,                         },                     },                 },             }, ,             return length != -1 || timestamp != -1;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/project/artifact/DefaultMavenMetadataCacheTest.java,testCacheKey,59-59,[        Artifact a1 = repositorySystem.createArtifact( "testGroup", "testArtifact", "1.2.3", "jar" );],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/maven/project/artifact/MavenMetadataSource.java,hasMissingParentPom,718-718,[            ModelBuildingException mbe = (ModelBuildingException) e.getCause();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/maven/project/artifact/MavenMetadataSourceTest.java,,34-34,[        repositorySystem = lookup( RepositorySystem.class );],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/maven/artifact/DefaultArtifact.java,equals,324-359,[        if ( o == this ),         {,             return true;,         }, ,         if ( !( o instanceof Artifact ) ),         {,             return false;,         }, ,         Artifact a = (Artifact) o;, ,         if ( !a.getGroupId().equals( groupId ) ),         {,             return false;,         },         else if ( !a.getArtifactId().equals( artifactId ) ),         {,             return false;,         },         else if ( !a.getVersion().equals( version ) ),         {,             return false;,         },         else if ( !a.getType().equals( type ) ),         {,             return false;,         },         else if ( a.getClassifier() == null ? classifier != null : !a.getClassifier().equals( classifier ) ),         {,             return false;,         }, ,         // We don't consider the version range in the comparison, just the resolved version, ,         return true;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/maven/artifact/DefaultArtifact.java,equals,324-359,[        if ( o == this ),         {,             return true;,         }, ,         if ( !( o instanceof Artifact ) ),         {,             return false;,         }, ,         Artifact a = (Artifact) o;, ,         if ( !a.getGroupId().equals( groupId ) ),         {,             return false;,         },         else if ( !a.getArtifactId().equals( artifactId ) ),         {,             return false;,         },         else if ( !a.getVersion().equals( version ) ),         {,             return false;,         },         else if ( !a.getType().equals( type ) ),         {,             return false;,         },         else if ( a.getClassifier() == null ? classifier != null : !a.getClassifier().equals( classifier ) ),         {,             return false;,         }, ,         // We don't consider the version range in the comparison, just the resolved version, ,         return true;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/maven/project/artifact/ProjectArtifactMetadata.java,merge,119-119,[        ProjectArtifactMetadata m = (ProjectArtifactMetadata) metadata;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java,assembleBuildInheritance,108-108,[        if ( ( resources == null ) || resources.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java,assembleBuildInheritance,114-114,[        if ( ( resources == null ) || resources.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java,assembleDependencyInheritance,543-543,[        if ( deps != null )],,assembleDependencyInheritance,553-553,[        if ( deps != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java,mergeReportPluginDefinitions,485-485,[        if ( ( parentReportSets != null ) && !parentReportSets.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java,mergeReportPluginLists,377-377,[        if ( ( parentPlugins != null ) && !parentPlugins.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java,mergeReportSetDefinitions,435-435,[        if ( ( childReports != null ) && !childReports.isEmpty() )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java,mergeReportSetDefinitions,440-440,[        if ( parentReports != null )],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t02/ProjectInheritanceTest.java,testProjectInheritance,79-79,[        MavenProject project0 = getProject( pom0 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t02/ProjectInheritanceTest.java,testProjectInheritance,80-80,[        MavenProject project1 = getProject( pom1 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t02/ProjectInheritanceTest.java,testProjectInheritance,81-81,[        MavenProject project2 = getProject( pom2 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t02/ProjectInheritanceTest.java,testProjectInheritance,82-82,[        MavenProject project3 = getProject( pom3 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t02/ProjectInheritanceTest.java,testProjectInheritance,84-84,[        MavenProject project5 = getProject( pom5 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t03/ProjectInheritanceTest.java,testProjectInheritance,63-63,[        MavenProject project0 = getProject( pom0 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t04/ProjectInheritanceTest.java,testDependencyManagementOverridesTransitiveDependencyVersion,64-64,[        MavenProject project0 = getProjectWithDependencies( pom0 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t05/ProjectInheritanceTest.java,testDependencyManagement,60-60,[        MavenProject project0 = getProjectWithDependencies( pom0 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t06/ProjectInheritanceTest.java,testDependencyManagement,60-60,[        MavenProject project0 = getProjectWithDependencies( pom0 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t08/ProjectInheritanceTest.java,testDependencyManagement,60-60,[        MavenProject project0 = getProjectWithDependencies( pom0 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t09/ProjectInheritanceTest.java,testDependencyManagementExclusionDoesNotOverrideGloballyForTransitives,105-105,[        MavenProject project0 = getProjectWithDependencies( pom0 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t09/ProjectInheritanceTest.java,testDependencyManagementExclusionsExcludeTransitively,69-69,[        MavenProject project0 = getProjectWithDependencies( pom0 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t10/ProjectInheritanceTest.java,testDependencyManagementOverridesTransitiveDependencyVersion,65-65,[        MavenProject project0 = getProjectWithDependencies( pom0 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/project/inheritance/t11/ProjectInheritanceTest.java,testDependencyManagementDoesNotOverrideScopeOfCurrentArtifact,57-57,[        MavenProject project0 = getProjectWithDependencies( pom0 );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/interpolation/AbstractStringBasedModelInterpolator.java,createValueSources,225-225,[        if ( modelProperties != null )],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/project/interpolation/AbstractStringBasedModelInterpolator.java,,234-241,[        {,             public Object getValue( String expression ),             {,                 if ( projectDir != null && "basedir".equals( expression ) ),                 {,                     return projectDir.getAbsolutePath();,                 },                 return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/project/interpolation/AbstractStringBasedModelInterpolator.java,,245-252,[        {,             public Object getValue( String expression ),             {,                 if ( projectDir != null && "baseUri".equals( expression ) ),                 {,                     return projectDir.getAbsoluteFile().toURI().toString();,                 },                 return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/project/interpolation/AbstractStringBasedModelInterpolator.java,,267-270,[        {,             public Object getValue( String expression ),             {,                 return config.getExecutionProperties().getProperty( "env." + expression );],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/maven/project/interpolation/BuildTimestampValueSource.java,<init>,44-44,[        this.startTime = startTime;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/maven/project/interpolation/StringSearchModelInterpolator.java,traverseObjectWithParents,255-255,[                                                c.add( value );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/path/DefaultPathTranslator.java,alignToBaseDirectory,66-66,[            if ( build.getFilters() != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/project/path/DefaultPathTranslator.java,unalignFromBaseDirectory,204-204,[            if ( build.getFilters() != null )],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/maven/properties/internal/EnvironmentUtils.java,addEnvVars,53-63,[            if ( envVars == null ),             {,                 Properties tmp = new Properties();,                 boolean caseSensitive = !Os.isFamily( Os.FAMILY_WINDOWS );,                 for ( Map.Entry<String, String> entry : System.getenv().entrySet() ),                 {,                     String key =,                         "env." + ( caseSensitive ? entry.getKey() : entry.getKey().toUpperCase( Locale.ENGLISH ) );,                     tmp.setProperty( key, entry.getValue() );,                 },                 envVars = tmp;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/maven/repository/ArtifactTransferEvent.java,getDataBuffer,218-218,[        return dataBuffer;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/maven/repository/ArtifactTransferEvent.java,setDataBuffer,223-223,[        this.dataBuffer = dataBuffer;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/repository/ArtifactTransferEvent.java,,91-340,[        super( wagon );, ,         setEventType( eventType );, ,         setRequestType( requestType );, ,         this.artifact = artifact;,     }, ,     public ArtifactTransferEvent( String wagon, final Exception exception, final int requestType,,                                   ArtifactTransferResource artifact ),     {,         this( wagon, TRANSFER_ERROR, requestType, artifact );, ,         this.exception = exception;,     }, ,     public ArtifactTransferResource getResource(),     {,         return artifact;,     }, ,     /**,      * @return Returns the exception.,      */,     public Exception getException(),     {,         return exception;,     }, ,     /**,      * Returns the request type.,      *,      * @return Returns the request type. The Request type is one of,      *         <code>TransferEvent.REQUEST_GET<code> or <code>TransferEvent.REQUEST_PUT<code>,      */,     public int getRequestType(),     {,         return requestType;,     }, ,     /**,      * Sets the request type,      *,      * @param requestType The requestType to set.,      *                    The Request type value should be either,      *                    <code>TransferEvent.REQUEST_GET<code> or <code>TransferEvent.REQUEST_PUT<code>.,      * @throws IllegalArgumentException when,      */,     public void setRequestType( final int requestType ),     {,         switch ( requestType ),         {, ,             case REQUEST_PUT:,                 break;,             case REQUEST_GET:,                 break;, ,             default :,                 throw new IllegalArgumentException( "Illegal request type: " + requestType );,         }, ,         this.requestType = requestType;,     }, ,     /**,      * @return Returns the eventType.,      */,     public int getEventType(),     {,         return eventType;,     }, ,     /**,      * @param eventType The eventType to set.,      */,     public void setEventType( final int eventType ),     {,         switch ( eventType ),         {, ,             case TRANSFER_INITIATED:,                 break;,             case TRANSFER_STARTED:,                 break;,             case TRANSFER_COMPLETED:,                 break;,             case TRANSFER_PROGRESS:,                 break;,             case TRANSFER_ERROR:,                 break;,             default :,                 throw new IllegalArgumentException( "Illegal event type: " + eventType );,         }, ,         this.eventType = eventType;,     }, ,     /**,      * @return Returns the local file.,      */,     public File getLocalFile(),     {,         return localFile;,     }, ,     /**,      * @param localFile The local file to set.,      */,     public void setLocalFile( File localFile ),     {,         this.localFile = localFile;,     }, ,     public long getTransferredBytes(),     {,         return transferredBytes;,     }, ,     public void setTransferredBytes( long transferredBytes ),     {,         this.transferredBytes = transferredBytes;,     }, ,     public byte[] getDataBuffer(),     {,         return dataBuffer;,     }, ,     public void setDataBuffer( byte[] dataBuffer ),     {,         this.dataBuffer = dataBuffer;,     }, ,     public int getDataOffset(),     {,         return dataOffset;,     }, ,     public void setDataOffset( int dataOffset ),     {,         this.dataOffset = dataOffset;,     }, ,     public int getDataLength(),     {,         return dataLength;,     }, ,     public void setDataLength( int dataLength ),     {,         this.dataLength = dataLength;,     }, ,     public String toString(),     {,         StringBuffer sb = new StringBuffer();, ,         sb.append( "TransferEvent[" );, ,         switch ( this.getRequestType() ),         {,             case REQUEST_GET:,                 sb.append( "GET" );,                 break;,             case REQUEST_PUT:,                 sb.append( "PUT" );,                 break;,             default:,                 sb.append( this.getRequestType() );,                 break;,         }, ,         sb.append( "|" );,         switch ( this.getEventType() ),         {,             case TRANSFER_COMPLETED:,                 sb.append( "COMPLETED" );,                 break;,             case TRANSFER_ERROR:,                 sb.append( "ERROR" );,                 break;,             case TRANSFER_INITIATED:,                 sb.append( "INITIATED" );,                 break;,             case TRANSFER_PROGRESS:,                 sb.append( "PROGRESS" );,                 break;,             case TRANSFER_STARTED:,                 sb.append( "STARTED" );,                 break;,             default:,                 sb.append( this.getEventType() );,                 break;,         }, ,         sb.append( "|" );,         sb.append( this.getLocalFile() ).append( "|" );,         sb.append( "]" );, ,         return sb.toString();,     }, ,     public int hashCode(),     {,         final int prime = 31;,         int result = 1;,         result = prime * result + eventType;,         result = prime * result + ( ( exception == null ) ? 0 : exception.hashCode() );,         result = prime * result + ( ( localFile == null ) ? 0 : localFile.hashCode() );,         result = prime * result + requestType;,         return result;,     }, ,     public boolean equals( Object obj ),     {,         if ( this == obj ),         {,             return true;,         },         if ( ( obj == null ) || ( getClass() != obj.getClass() ) ),         {,             return false;,         },         final ArtifactTransferEvent other = (ArtifactTransferEvent) obj;,         if ( eventType != other.eventType ),         {,             return false;,         },         if ( exception == null ),         {,             if ( other.exception != null ),             {,                 return false;,             },         },         else if ( !exception.getClass().equals( other.exception.getClass() ) ),         {,             return false;,         },         if ( requestType != other.requestType ),         {,             return false;,         },         else if ( !source.equals( other.source ) ),         {,             return false;,         },         return true;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/LegacyRepositorySystemTest.java,testThatASystemScopedDependencyIsNotResolvedFromRepositories,133-133,[        resolutionErrorHandler.throwErrors( request, result );        ],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/maven/repository/MetadataResolutionResult.java,ListOriginatingArtifact,79-81,[        this.originatingArtifact = originatingArtifact;, ,         return this;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/maven/repository/MetadataResolutionResult.java,addError,240-240,[        exceptions.add( e );],,addError,237-237,[            initList( exceptions );],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/maven/repository/MetadataResolutionResult.java,initList,237-237,[            initList( exceptions );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/MetadataResolutionResult.java,getCircularDependencyException,279-279,[        return circularDependencyExceptions.get( i );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/MetadataResolutionResult.java,getMetadataResolutionException,215-215,[        return metadataResolutionExceptions.get( i );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/MetadataResolutionResult.java,getVersionRangeViolation,183-183,[        return (OverConstrainedVersionException) versionRangeViolations.get( i );],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/maven/repository/MetadataResolutionResult.java,,230-230,[        return errorArtifactExceptions != null;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/maven/artifact/repository/MavenArtifactRepository.java,equals,327-342,[        if ( this == obj ),         {,             return true;,         },         if ( obj == null ),         {,             return false;,         },         if ( getClass() != obj.getClass() ),         {,             return false;,         }, ,         ArtifactRepository other = (ArtifactRepository) obj;, ,         return eq( getId(), other.getId() );],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/maven/repository/internal/DefaultArtifactDescriptorReader.java,loadPom,328-328,[                    missingDescriptor( session, trace, artifact, (Exception) e.getCause() );],,
STYLE,REC_CATCH_EXCEPTION,org/apache/maven/repository/internal/DefaultVersionRangeResolver.java,readVersions,297-297,[        catch ( Exception e )],,
STYLE,REC_CATCH_EXCEPTION,org/apache/maven/repository/internal/DefaultVersionResolver.java,readVersions,387-387,[        catch ( Exception e )],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/internal/DefaultVersionResolverTest.java,testResolveSeparateInstalledClassifiedNonUniqueVersionedArtifacts,59-59,[        VersionResult resultB = versionResolver.resolveVersion( session, requestB );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/internal/DefaultVersionResolverTest.java,testResolveSeparateInstalledClassifiedNonVersionedArtifacts,83-83,[        VersionResult resultA = versionResolver.resolveVersion( session, requestA );],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/internal/MavenMetadata.java,write,125-125,[            metadataFile.getParentFile().mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManager.java,touch,175-175,[            touchfile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testArtifact,73-73,[        file.createNewFile();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testArtifact,64-64,[        file.delete();],,testArtifact,68-68,[        touchFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testArtifact,72-72,[        file.getParentFile().mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testMetadata,186-186,[        file.createNewFile();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testMetadata,178-178,[        file.delete();],,testMetadata,181-181,[        touchFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testMetadata,185-185,[        file.getParentFile().mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testMissingArtifact,94-94,[        file.delete();],,testMissingArtifact,98-98,[        touchFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testMissingMetadata,205-205,[        file.delete();],,testMissingMetadata,208-208,[        touchFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testMissingPom,150-150,[        file.delete();],,testMissingPom,154-154,[        touchFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testPom,129-129,[        file.createNewFile();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testPom,120-120,[        file.delete();],,testPom,124-124,[        touchFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultUpdateCheckManagerTest.java,testPom,128-128,[        file.getParentFile().mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultWagonManager.java,getRemoteFile,508-508,[                    temp.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultWagonManager.java,getRemoteFile,370-370,[                                destination.setLastModified( System.currentTimeMillis() );],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultWagonManager.java,verifyChecksum,733-733,[                    checksumFile.delete();],,verifyChecksum,736-736,[                tempChecksumFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultWagonManager.java,cleanupTemporaryFiles,652-652,[                file.delete();],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/maven/repository/legacy/DefaultWagonManager.java,putRemoteFile,588-588,[                ChecksumObserver observer = checksums.get( extension );],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultWagonManagerTest.java,createTestArtifact,200-200,[        testData.mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/repository/legacy/DefaultWagonManagerTest.java,createTestPomArtifact,181-181,[        testData.mkdirs();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/repository/legacy/DefaultWagonManagerTest.java,getRepo,233-233,[        return getRepo( id, "http://something" );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/repository/legacy/DefaultWagonManagerTest.java,,97-106,[        class TransferListener,             extends AbstractTransferListener,         {,             public List<TransferEvent> events = new ArrayList<TransferEvent>();, ,             @Override,             public void transferInitiated( TransferEvent transferEvent ),             {,                 events.add( transferEvent );,             }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/maven/repository/legacy/DefaultWagonManagerTest.java,,404-424,[    private final class ArtifactRepositoryLayoutStub,         implements ArtifactRepositoryLayout,     {,         public String getId(),         {,             return "test";,         }, ,         public String pathOfRemoteRepositoryMetadata( ArtifactMetadata metadata ),         {,             return "path";,         }, ,         public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository ),         {,             return "path";,         }, ,         public String pathOf( Artifact artifact ),         {,             return "path";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/legacy/LegacyRepositorySystemTest.java,testAuthenticationHandling,78-78,[            repositorySystem.createArtifactRepository( "repository", "http://foo", null, null, null );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/legacy/LegacyRepositorySystemTest.java,testThatLocalRepositoryWithSpacesIsProperlyHandled,65-65,[        ArtifactRepository repo = repositorySystem.createLocalRepository( basedir );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java,testOverConstrainedVersionException,707-707,[        ArtifactSpec c = createArtifactSpec( "c", "3.2.1-v3235e" );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java,testOverConstrainedVersionException,711-711,[            ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact } ) );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java,testResolveRangeWithManagedVersion,305-305,[        ArtifactSpec b = a.addDependency( "b", "[1.0,3.0]" );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java,createArtifactSpec,792-792,[            artifactFactory.createDependencyArtifact( GROUP_ID, id, versionRange, "jar", null, scope, inheritedScope,],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/legacy/resolver/DefaultArtifactCollectorTest.java,createArtifactSpec,799-799,[            source.addArtifact( spec );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/legacy/resolver/conflict/AbstractConflictResolverTest.java,createArtifact,140-140,[        return artifactFactory.createDependencyArtifact( GROUP_ID, id, versionRange, "jar", null, scope,],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/legacy/resolver/conflict/DefaultConflictResolverFactory.java,getConflictResolver,61-61,[            return (ConflictResolver) container.lookup( ConflictResolver.ROLE, type );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/repository/metadata/DefaultClasspathTransformation.java,transform,73-73,[                ArtifactMetadata md = entry.getMd();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/maven/repository/metadata/DefaultClasspathTransformation.java,,101-175,[        {,             this.cpc = cpc;,             this.graph = cleanGraph;, ,             visited = new ArrayList<MetadataGraphVertex>( cleanGraph.getVertices().size() );,         }, ,         // -----------------------------------------------------------------------,         protected void visit( MetadataGraphVertex node ) // , String version, String artifactUri ),         {,             ArtifactMetadata md = node.getMd();,             if ( visited.contains( node ) ),             {,                 return;,             }, ,             cpc.add( md );, //, //            TreeSet<MetadataGraphEdge> deps = new TreeSet<MetadataGraphEdge>(, //                        new Comparator<MetadataGraphEdge>(), //                        {, //                            public int compare( MetadataGraphEdge e1, //                                              , MetadataGraphEdge e2, //                                              ), //                            {, //                                if( e1.getDepth() == e2.getDepth() ), //                                {, //                                    if( e2.getPomOrder() == e1.getPomOrder() ), //                                        return e1.getTarget().toString().compareTo(e2.getTarget().toString() );, //, //                                    return e2.getPomOrder() - e1.getPomOrder();, //                                }, //, //                                return e2.getDepth() - e1.getDepth();, //                            }, //                        }, //                    );, ,             List<MetadataGraphEdge> exits = graph.getExcidentEdges( node );, ,             if ( exits != null && exits.size() > 0 ),             {,                 MetadataGraphEdge[] sortedExits = exits.toArray( new MetadataGraphEdge[exits.size()] );,                 Arrays.sort( sortedExits,                         ,,                         new Comparator<MetadataGraphEdge>(),                         {,                             public int compare( MetadataGraphEdge e1,                                             , MetadataGraphEdge e2,                                             ),                             {,                                 if ( e1.getDepth() == e2.getDepth() ),                                 {,                                     if ( e2.getPomOrder() == e1.getPomOrder() ),                                     {,                                         return e1.getTarget().toString().compareTo( e2.getTarget().toString() );,                                     },                                     return e2.getPomOrder() - e1.getPomOrder();,                                 }, ,                                 return e2.getDepth() - e1.getDepth();,                             },                         },                 );, ,                 for ( MetadataGraphEdge e : sortedExits ),                 {,                     MetadataGraphVertex targetNode = e.getTarget();,                     targetNode.getMd().setArtifactScope( e.getScope() );,                     targetNode.getMd().setWhy( e.getSource().getMd().toString() );,                     visit( targetNode );,                 },             }, ,         }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/metadata/DefaultClasspathTransformationTest.java,testCompileClasspathTransform,82-82,[    	res = transform.transform( graph, ArtifactScopeEnum.compile, false );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/metadata/DefaultClasspathTransformationTest.java,testRuntimeClasspathTransform,94-94,[    	res = transform.transform( graph, ArtifactScopeEnum.runtime, false );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/metadata/DefaultClasspathTransformationTest.java,testTestClasspathTransform,109-109,[    	res = transform.transform( graph, ArtifactScopeEnum.test, false );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/metadata/DefaultGraphConflictResolutionPolicyTest.java,testDefaultPolicy,51-51,[    	res = policy.apply( e1, e2 );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java,testCompileResolution,84-84,[    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.compile );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java,testRuntimeResolution,109-109,[    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.runtime );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/repository/metadata/DefaultGraphConflictResolverTest.java,testTestResolution,133-133,[    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.test );],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/maven/repository/metadata/MetadataGraphEdge.java,equals,86-94,[        if ( o instanceof MetadataGraphEdge ),         {,             MetadataGraphEdge e = (MetadataGraphEdge) o;, ,             return objectsEqual( version, e.version ),                 && ArtifactScopeEnum.checkScope( scope ).getScope().equals( ArtifactScopeEnum.checkScope( e.scope ).getScope() ),                 && depth == e.depth;,         },         return false;],,
STYLE,NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE,org/apache/maven/repository/metadata/MetadataGraphEdge.java,objectsEqual,76-76,[        return o1.equals( o2 );],,objectsEqual,72-72,[        if ( ( o1 == null && o2 != null ) || ( o1 != null && o2 == null ) )],,
STYLE,NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE,org/apache/maven/repository/metadata/MetadataGraphVertex.java,compareStrings,107-107,[        return s1.compareTo( s2 );],,compareStrings,97-97,[        if ( s1 == null && s2 != null )],,compareStrings,102-102,[        if ( s1 != null && s2 == null )],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/maven/repository/metadata/ArtifactMetadata.java,,57-349,[    protected boolean resolved = false;, ,     /** does the actual artifact for this metadata exists */,     protected boolean artifactExists = false;,     /** artifact URI */,     protected String artifactUri;, ,     /** error message  */,     private String error;, ,     //------------------------------------------------------------------,     /**,      *,      */,     public ArtifactMetadata( String name ),     {,         if ( name == null ),         {,             return;,         },         int ind1 = name.indexOf( ':' );,         int ind2 = name.lastIndexOf( ':' );, ,         if ( ind1 == -1 || ind2 == -1 ),         {,             return;,         }, ,         this.groupId = name.substring( 0, ind1 );,         if ( ind1 == ind2 ),         {,             this.artifactId = name.substring( ind1 + 1 );,         },         else,         {,             this.artifactId = name.substring( ind1 + 1, ind2 );,             this.version = name.substring( ind2 + 1 );,         },     }, ,     // ------------------------------------------------------------------,     public ArtifactMetadata( String groupId, String name, String version ),     {,         this( groupId, name, version, null );,     },     //------------------------------------------------------------------,     public ArtifactMetadata( String groupId, String name, String version, String type ),     {,         this( groupId, name, version, type, null );,     }, ,     //------------------------------------------------------------------,     public ArtifactMetadata( String groupId, String name, String version, String type, ArtifactScopeEnum artifactScope ),     {,         this( groupId, name, version, type, artifactScope, null );,     }, ,     //------------------------------------------------------------------,     public ArtifactMetadata( String groupId, String name, String version, String type, ArtifactScopeEnum artifactScope,,                              String classifier ),     {,         this( groupId, name, version, type, artifactScope, classifier, null );,     },     //------------------------------------------------------------------,     public ArtifactMetadata( String groupId, String name, String version, String type, ArtifactScopeEnum artifactScope,,                              String classifier, String artifactUri ),     {,         this( groupId, name, version, type, artifactScope, classifier, artifactUri, null, true, null );,     },     //------------------------------------------------------------------,     public ArtifactMetadata( String groupId, String name, String version, String type, ArtifactScopeEnum artifactScope,,                              String classifier, String artifactUri, String why, boolean resolved, String error ),     {,         this.groupId = groupId;,         this.artifactId = name;,         this.version = version;,         this.type = type;,         this.artifactScope = artifactScope;,         this.classifier = classifier;,         this.artifactUri = artifactUri;,         this.why = why;,         this.resolved = resolved;,         this.error = error;,     },     //------------------------------------------------------------------,     public ArtifactMetadata( String groupId, String name, String version, String type, String scopeString,,                              String classifier, String artifactUri, String why, boolean resolved, String error ),     {,         this( groupId, name, version, type,,               scopeString == null ? ArtifactScopeEnum.DEFAULT_SCOPE : ArtifactScopeEnum.valueOf( scopeString ),,               classifier, artifactUri, why, resolved, error );,     }, ,     //------------------------------------------------------------------,     public ArtifactMetadata( Artifact af ),     {,         /*,         if ( af != null ),         {,             init( af );,         },         */,     },     //------------------------------------------------------------------, //    public void init( ArtifactMetadata af ), //    {, //        setGroupId( af.getGroupId() );, //        setArtifactId( af.getArtifactId() );, //        setVersion( af.getVersion() );, //        setType( af.getType() );, //        setScope( af.getScope() );, //        setClassifier( af.getClassifier() );, //        //setUri( af.getDownloadUrl() );, //, //        this.resolved = af.isResolved();, //    }, ,     //------------------------------------------------------------------,     @Override,     public String toString(),     {,         return groupId + ":" + artifactId + ":" + version;,     }, ,     //------------------------------------------------------------------,     public String toDomainString(),     {,         return groupId + ":" + artifactId;,     }, ,     //------------------------------------------------------------------,     public String getGroupId(),     {,         return groupId;,     }, ,     public void setGroupId( String groupId ),     {,         this.groupId = groupId;,     }, ,     public String getArtifactId(),     {,         return artifactId;,     }, ,     public void setArtifactId( String name ),     {,         this.artifactId = name;,     }, ,     public String getVersion(),     {,         return version;,     }, ,     public void setVersion( String version ),     {,         this.version = version;,     }, ,     public String getType(),     {,         return type;,     }, ,     public String getCheckedType(),     {,         return type == null ? "jar" : type;,     }, ,     public void setType( String type ),     {,         this.type = type;,     }, ,     public ArtifactScopeEnum getArtifactScope(),     {,         return artifactScope == null ? ArtifactScopeEnum.DEFAULT_SCOPE : artifactScope;,     }, ,     public void setArtifactScope( ArtifactScopeEnum artifactScope ),     {,         this.artifactScope = artifactScope;,     }, ,     public void setScope( String scope ),     {,         this.artifactScope = scope == null ? ArtifactScopeEnum.DEFAULT_SCOPE : ArtifactScopeEnum.valueOf( scope );,     }, ,     public String getClassifier(),     {,         return classifier;,     }, ,     public void setClassifier( String classifier ),     {,         this.classifier = classifier;,     }, ,     public boolean isResolved(),     {,         return resolved;,     }, ,     public void setResolved( boolean resolved ),     {,         this.resolved = resolved;,     }, ,     public String getUri(),     {,         return uri;,     }, ,     public void setUri( String uri ),     {,         this.uri = uri;,     }, ,     public String getScope(),     {,         return getArtifactScope().getScope();,     }, ,     public ArtifactScopeEnum getScopeAsEnum(),     {,         return artifactScope == null ? ArtifactScopeEnum.DEFAULT_SCOPE : artifactScope;,     }, ,     public boolean isArtifactExists(),     {,         return artifactExists;,     }, ,     public void setArtifactExists( boolean artifactExists ),     {,         this.artifactExists = artifactExists;,     }, , ,     public Collection<ArtifactMetadata> getDependencies(),     {,         return dependencies;,     }, ,     public void setDependencies( Collection<ArtifactMetadata> dependencies ),     {,         this.dependencies = dependencies;,     }, ,     public String getArtifactUri(),     {,         return artifactUri;,     }, ,     public void setArtifactUri( String artifactUri ),     {,         this.artifactUri = artifactUri;,     }, , ,     public String getWhy(),     {,         return why;,     }, ,     public void setWhy( String why ),     {,         this.why = why;,     }, ,     //-------------------------------------------------------------------,     public String getError(),     {,         return error;,     }, ,     public void setError( String error ),     {,         this.error = error;,     }, ,     public boolean isError(),     {,         return error == null;,     }, ,     //------------------------------------------------------------------,     public String getDependencyConflictId(),     {,         return groupId + ":" + artifactId;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/maven/repository/metadata/MetadataTreeNode.java,getChildren,138-138,[        return children;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/maven/repository/metadata/MetadataTreeNode.java,setChildren,143-143,[        this.children = children;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/Activation.java,,19-224,[@SuppressWarnings( "all" ), public class Activation,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             Flag specifying whether this profile is active,      * as a default.,      *           ,      */,     private boolean activeByDefault = false;, ,     /**,      * ,      *             ,      *             Specifies that this profile will be activated,      * when a matching JDK is detected.,      *             ,      *           ,      */,     private String jdk;, ,     /**,      * ,      *             ,      *             Specifies that this profile will be activated,      * when matching OS attributes are detected.,      *             ,      *           ,      */,     private ActivationOS os;, ,     /**,      * ,      *             ,      *             Specifies that this profile will be activated,      * when this System property is specified.,      *             ,      *           ,      */,     private ActivationProperty property;, ,     /**,      * ,      *             ,      *             Specifies that this profile will be activated,      * based on existence of a file.,      *             ,      *           ,      */,     private ActivationFile file;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Activation,      */,     public Activation clone(),     {,         try,         {,             Activation copy = (Activation) super.clone();, ,             if ( this.os != null ),             {,                 copy.os = (ActivationOS) this.os.clone();,             }, ,             if ( this.property != null ),             {,                 copy.property = (ActivationProperty) this.property.clone();,             }, ,             if ( this.file != null ),             {,                 copy.file = (ActivationFile) this.file.clone();,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Activation clone(), ,     /**,      * Get specifies that this profile will be activated based on,      * existence of a file.,      * ,      * @return ActivationFile,      */,     public ActivationFile getFile(),     {,         return this.file;,     } //-- ActivationFile getFile(), ,     /**,      * Get specifies that this profile will be activated when a,      * matching JDK is detected.,      * ,      * @return String,      */,     public String getJdk(),     {,         return this.jdk;,     } //-- String getJdk(), ,     /**,      * Get specifies that this profile will be activated when,      * matching OS attributes are detected.,      * ,      * @return ActivationOS,      */,     public ActivationOS getOs(),     {,         return this.os;,     } //-- ActivationOS getOs(), ,     /**,      * Get specifies that this profile will be activated when this,      * System property is specified.,      * ,      * @return ActivationProperty,      */,     public ActivationProperty getProperty(),     {,         return this.property;,     } //-- ActivationProperty getProperty(), ,     /**,      * Get flag specifying whether this profile is active as a,      * default.,      * ,      * @return boolean,      */,     public boolean isActiveByDefault(),     {,         return this.activeByDefault;,     } //-- boolean isActiveByDefault(), ,     /**,      * Set flag specifying whether this profile is active as a,      * default.,      * ,      * @param activeByDefault,      */,     public void setActiveByDefault( boolean activeByDefault ),     {,         this.activeByDefault = activeByDefault;,     } //-- void setActiveByDefault( boolean ), ,     /**,      * Set specifies that this profile will be activated based on,      * existence of a file.,      * ,      * @param file,      */,     public void setFile( ActivationFile file ),     {,         this.file = file;,     } //-- void setFile( ActivationFile ), ,     /**,      * Set specifies that this profile will be activated when a,      * matching JDK is detected.,      * ,      * @param jdk,      */,     public void setJdk( String jdk ),     {,         this.jdk = jdk;,     } //-- void setJdk( String ), ,     /**,      * Set specifies that this profile will be activated when,      * matching OS attributes are detected.,      * ,      * @param os,      */,     public void setOs( ActivationOS os ),     {,         this.os = os;,     } //-- void setOs( ActivationOS ), ,     /**,      * Set specifies that this profile will be activated when this,      * System property is specified.,      * ,      * @param property,      */,     public void setProperty( ActivationProperty property ),     {,         this.property = property;,     } //-- void setProperty( ActivationProperty )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/ActivationFile.java,,22-117,[@SuppressWarnings( "all" ), public class ActivationFile,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             The name of the file that should be missing to,      * activate a,      *             profile.,      *           ,      */,     private String missing;, ,     /**,      * ,      *             The name of the file that should exist to,      * activate a profile.,      *           ,      */,     private String exists;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return ActivationFile,      */,     public ActivationFile clone(),     {,         try,         {,             ActivationFile copy = (ActivationFile) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ActivationFile clone(), ,     /**,      * Get the name of the file that should exist to activate a,      * profile.,      * ,      * @return String,      */,     public String getExists(),     {,         return this.exists;,     } //-- String getExists(), ,     /**,      * Get the name of the file that should be missing to activate,      * a,      *             profile.,      * ,      * @return String,      */,     public String getMissing(),     {,         return this.missing;,     } //-- String getMissing(), ,     /**,      * Set the name of the file that should exist to activate a,      * profile.,      * ,      * @param exists,      */,     public void setExists( String exists ),     {,         this.exists = exists;,     } //-- void setExists( String ), ,     /**,      * Set the name of the file that should be missing to activate,      * a,      *             profile.,      * ,      * @param missing,      */,     public void setMissing( String missing ),     {,         this.missing = missing;,     } //-- void setMissing( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/ActivationOS.java,,19-168,[@SuppressWarnings( "all" ), public class ActivationOS,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             The name of the OS to be used to activate a,      * profile.,      *           ,      */,     private String name;, ,     /**,      * ,      *             The general family of the OS to be used to,      * activate a,      *             profile (e.g. 'windows'),      *           .,      */,     private String family;, ,     /**,      * ,      *             The architecture of the OS to be used to,      * activate a profile.,      *           ,      */,     private String arch;, ,     /**,      * ,      *             The version of the OS to be used to activate a,      * profile.,      *           ,      */,     private String version;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return ActivationOS,      */,     public ActivationOS clone(),     {,         try,         {,             ActivationOS copy = (ActivationOS) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ActivationOS clone(), ,     /**,      * Get the architecture of the OS to be used to activate a,      * profile.,      * ,      * @return String,      */,     public String getArch(),     {,         return this.arch;,     } //-- String getArch(), ,     /**,      * Get the general family of the OS to be used to activate a,      *             profile (e.g. 'windows').,      * ,      * @return String,      */,     public String getFamily(),     {,         return this.family;,     } //-- String getFamily(), ,     /**,      * Get the name of the OS to be used to activate a profile.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the version of the OS to be used to activate a profile.,      * ,      * @return String,      */,     public String getVersion(),     {,         return this.version;,     } //-- String getVersion(), ,     /**,      * Set the architecture of the OS to be used to activate a,      * profile.,      * ,      * @param arch,      */,     public void setArch( String arch ),     {,         this.arch = arch;,     } //-- void setArch( String ), ,     /**,      * Set the general family of the OS to be used to activate a,      *             profile (e.g. 'windows').,      * ,      * @param family,      */,     public void setFamily( String family ),     {,         this.family = family;,     } //-- void setFamily( String ), ,     /**,      * Set the name of the OS to be used to activate a profile.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the version of the OS to be used to activate a profile.,      * ,      * @param version,      */,     public void setVersion( String version ),     {,         this.version = version;,     } //-- void setVersion( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/ActivationProperty.java,,21-113,[@SuppressWarnings( "all" ), public class ActivationProperty,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             The name of the property to be used to activate,      * a profile.,      *           ,      */,     private String name;, ,     /**,      * ,      *             The value of the property to be used to activate,      * a profile.,      *           ,      */,     private String value;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return ActivationProperty,      */,     public ActivationProperty clone(),     {,         try,         {,             ActivationProperty copy = (ActivationProperty) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- ActivationProperty clone(), ,     /**,      * Get the name of the property to be used to activate a,      * profile.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the value of the property to be used to activate a,      * profile.,      * ,      * @return String,      */,     public String getValue(),     {,         return this.value;,     } //-- String getValue(), ,     /**,      * Set the name of the property to be used to activate a,      * profile.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the value of the property to be used to activate a,      * profile.,      * ,      * @param value,      */,     public void setValue( String value ),     {,         this.value = value;,     } //-- void setValue( String )],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/settings/IdentifiableBase.java,,18-76,[@SuppressWarnings( "all" ), public class IdentifiableBase,     extends TrackableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field id.,      */,     private String id = "default";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return IdentifiableBase,      */,     public IdentifiableBase clone(),     {,         try,         {,             IdentifiableBase copy = (IdentifiableBase) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- IdentifiableBase clone(), ,     /**,      * Get the id field.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Set the id field.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/IdentifiableBase.java,,18-76,[@SuppressWarnings( "all" ), public class IdentifiableBase,     extends TrackableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field id.,      */,     private String id = "default";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return IdentifiableBase,      */,     public IdentifiableBase clone(),     {,         try,         {,             IdentifiableBase copy = (IdentifiableBase) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- IdentifiableBase clone(), ,     /**,      * Get the id field.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Set the id field.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String )],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/settings/Mirror.java,,15-206,[@SuppressWarnings( "all" ), public class Mirror,     extends IdentifiableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             The server ID of the repository being mirrored,,      * eg,      *             "central". This MUST NOT match the mirror id.,      *           ,      */,     private String mirrorOf;, ,     /**,      * ,      *             The optional name that describes the mirror.,      *           ,      */,     private String name;, ,     /**,      * The URL of the mirror repository.,      */,     private String url;, ,     /**,      * The layout of the mirror repository. Since Maven 3.,      */,     private String layout = "default";, ,     /**,      * ,      *             The layouts of repositories being mirrored. This,      * value can be used to restrict the usage,      *             of the mirror to repositories with a matching,      * layout (apart from a matching id). Since Maven 3.,      *           ,      */,     private String mirrorOfLayouts = "default,legacy";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Mirror,      */,     public Mirror clone(),     {,         try,         {,             Mirror copy = (Mirror) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Mirror clone(), ,     /**,      * Get the layout of the mirror repository. Since Maven 3.,      * ,      * @return String,      */,     public String getLayout(),     {,         return this.layout;,     } //-- String getLayout(), ,     /**,      * Get the server ID of the repository being mirrored, eg,      *             "central". This MUST NOT match the mirror id.,      * ,      * @return String,      */,     public String getMirrorOf(),     {,         return this.mirrorOf;,     } //-- String getMirrorOf(), ,     /**,      * Get the layouts of repositories being mirrored. This value,      * can be used to restrict the usage,      *             of the mirror to repositories with a matching,      * layout (apart from a matching id). Since Maven 3.,      * ,      * @return String,      */,     public String getMirrorOfLayouts(),     {,         return this.mirrorOfLayouts;,     } //-- String getMirrorOfLayouts(), ,     /**,      * Get the optional name that describes the mirror.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the URL of the mirror repository.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Set the layout of the mirror repository. Since Maven 3.,      * ,      * @param layout,      */,     public void setLayout( String layout ),     {,         this.layout = layout;,     } //-- void setLayout( String ), ,     /**,      * Set the server ID of the repository being mirrored, eg,      *             "central". This MUST NOT match the mirror id.,      * ,      * @param mirrorOf,      */,     public void setMirrorOf( String mirrorOf ),     {,         this.mirrorOf = mirrorOf;,     } //-- void setMirrorOf( String ), ,     /**,      * Set the layouts of repositories being mirrored. This value,      * can be used to restrict the usage,      *             of the mirror to repositories with a matching,      * layout (apart from a matching id). Since Maven 3.,      * ,      * @param mirrorOfLayouts,      */,     public void setMirrorOfLayouts( String mirrorOfLayouts ),     {,         this.mirrorOfLayouts = mirrorOfLayouts;,     } //-- void setMirrorOfLayouts( String ), ,     /**,      * Set the optional name that describes the mirror.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the URL of the mirror repository.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String ), ,     ,             , ,     public String toString(),     {,         StringBuilder sb = new StringBuilder( 128 );,         sb.append( "Mirror[" );,         sb.append( "id=" ).append( this.getId() );,         sb.append( ",mirrorOf=" ).append( mirrorOf );,         sb.append( ",url=" ).append( this.url );,         sb.append( ",name=" ).append( this.name );,         sb.append( "]" );,         return sb.toString();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/Mirror.java,,15-206,[@SuppressWarnings( "all" ), public class Mirror,     extends IdentifiableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             The server ID of the repository being mirrored,,      * eg,      *             "central". This MUST NOT match the mirror id.,      *           ,      */,     private String mirrorOf;, ,     /**,      * ,      *             The optional name that describes the mirror.,      *           ,      */,     private String name;, ,     /**,      * The URL of the mirror repository.,      */,     private String url;, ,     /**,      * The layout of the mirror repository. Since Maven 3.,      */,     private String layout = "default";, ,     /**,      * ,      *             The layouts of repositories being mirrored. This,      * value can be used to restrict the usage,      *             of the mirror to repositories with a matching,      * layout (apart from a matching id). Since Maven 3.,      *           ,      */,     private String mirrorOfLayouts = "default,legacy";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Mirror,      */,     public Mirror clone(),     {,         try,         {,             Mirror copy = (Mirror) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Mirror clone(), ,     /**,      * Get the layout of the mirror repository. Since Maven 3.,      * ,      * @return String,      */,     public String getLayout(),     {,         return this.layout;,     } //-- String getLayout(), ,     /**,      * Get the server ID of the repository being mirrored, eg,      *             "central". This MUST NOT match the mirror id.,      * ,      * @return String,      */,     public String getMirrorOf(),     {,         return this.mirrorOf;,     } //-- String getMirrorOf(), ,     /**,      * Get the layouts of repositories being mirrored. This value,      * can be used to restrict the usage,      *             of the mirror to repositories with a matching,      * layout (apart from a matching id). Since Maven 3.,      * ,      * @return String,      */,     public String getMirrorOfLayouts(),     {,         return this.mirrorOfLayouts;,     } //-- String getMirrorOfLayouts(), ,     /**,      * Get the optional name that describes the mirror.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the URL of the mirror repository.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Set the layout of the mirror repository. Since Maven 3.,      * ,      * @param layout,      */,     public void setLayout( String layout ),     {,         this.layout = layout;,     } //-- void setLayout( String ), ,     /**,      * Set the server ID of the repository being mirrored, eg,      *             "central". This MUST NOT match the mirror id.,      * ,      * @param mirrorOf,      */,     public void setMirrorOf( String mirrorOf ),     {,         this.mirrorOf = mirrorOf;,     } //-- void setMirrorOf( String ), ,     /**,      * Set the layouts of repositories being mirrored. This value,      * can be used to restrict the usage,      *             of the mirror to repositories with a matching,      * layout (apart from a matching id). Since Maven 3.,      * ,      * @param mirrorOfLayouts,      */,     public void setMirrorOfLayouts( String mirrorOfLayouts ),     {,         this.mirrorOfLayouts = mirrorOfLayouts;,     } //-- void setMirrorOfLayouts( String ), ,     /**,      * Set the optional name that describes the mirror.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the URL of the mirror repository.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String ), ,     ,             , ,     public String toString(),     {,         StringBuilder sb = new StringBuilder( 128 );,         sb.append( "Mirror[" );,         sb.append( "id=" ).append( this.getId() );,         sb.append( ",mirrorOf=" ).append( mirrorOf );,         sb.append( ",url=" ).append( this.url );,         sb.append( ",name=" ).append( this.name );,         sb.append( "]" );,         return sb.toString();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/settings/PomConstructionWithSettingsTest.java,buildPom,132-132,[        return new PomTestWrapper( pomFile, projectBuilder.build( pomFile, config ).getProject() );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/settings/PomConstructionWithSettingsTest.java,buildPom,123-123,[        config.setLocalRepository( repositorySystem.createArtifactRepository( "local", localRepoUrl,],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/settings/Profile.java,,19-265,[@SuppressWarnings( "all" ), public class Profile,     extends IdentifiableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The conditional logic which will automatically,      *             trigger the inclusion of this profile.,      *             ,      *           ,      */,     private Activation activation;, ,     /**,      * Field properties.,      */,     private java.util.Properties properties;, ,     /**,      * Field repositories.,      */,     private java.util.List<Repository> repositories;, ,     /**,      * ,      *             ,      *             This may be removed or relocated in the near,      *             future. It is undecided whether plugins really,      * need a remote,      *             repository set of their own.,      *             ,      *           ,      */,     private java.util.List<Repository> pluginRepositories;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addPluginRepository.,      * ,      * @param repository,      */,     public void addPluginRepository( Repository repository ),     {,         getPluginRepositories().add( repository );,     } //-- void addPluginRepository( Repository ), ,     /**,      * Method addProperty.,      * ,      * @param key,      * @param value,      */,     public void addProperty( String key, String value ),     {,         getProperties().put( key, value );,     } //-- void addProperty( String, String ), ,     /**,      * Method addRepository.,      * ,      * @param repository,      */,     public void addRepository( Repository repository ),     {,         getRepositories().add( repository );,     } //-- void addRepository( Repository ), ,     /**,      * Method clone.,      * ,      * @return Profile,      */,     public Profile clone(),     {,         try,         {,             Profile copy = (Profile) super.clone();, ,             if ( this.activation != null ),             {,                 copy.activation = (Activation) this.activation.clone();,             }, ,             if ( this.properties != null ),             {,                 copy.properties = (java.util.Properties) this.properties.clone();,             }, ,             if ( this.repositories != null ),             {,                 copy.repositories = new java.util.ArrayList<Repository>();,                 for ( Repository item : this.repositories ),                 {,                     copy.repositories.add( ( (Repository) item).clone() );,                 },             }, ,             if ( this.pluginRepositories != null ),             {,                 copy.pluginRepositories = new java.util.ArrayList<Repository>();,                 for ( Repository item : this.pluginRepositories ),                 {,                     copy.pluginRepositories.add( ( (Repository) item).clone() );,                 },             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Profile clone(), ,     /**,      * Get the conditional logic which will automatically,      *             trigger the inclusion of this profile.,      * ,      * @return Activation,      */,     public Activation getActivation(),     {,         return this.activation;,     } //-- Activation getActivation(), ,     /**,      * Method getPluginRepositories.,      * ,      * @return List,      */,     public java.util.List<Repository> getPluginRepositories(),     {,         if ( this.pluginRepositories == null ),         {,             this.pluginRepositories = new java.util.ArrayList<Repository>();,         }, ,         return this.pluginRepositories;,     } //-- java.util.List<Repository> getPluginRepositories(), ,     /**,      * Method getProperties.,      * ,      * @return Properties,      */,     public java.util.Properties getProperties(),     {,         if ( this.properties == null ),         {,             this.properties = new java.util.Properties();,         }, ,         return this.properties;,     } //-- java.util.Properties getProperties(), ,     /**,      * Method getRepositories.,      * ,      * @return List,      */,     public java.util.List<Repository> getRepositories(),     {,         if ( this.repositories == null ),         {,             this.repositories = new java.util.ArrayList<Repository>();,         }, ,         return this.repositories;,     } //-- java.util.List<Repository> getRepositories(), ,     /**,      * Method removePluginRepository.,      * ,      * @param repository,      */,     public void removePluginRepository( Repository repository ),     {,         getPluginRepositories().remove( repository );,     } //-- void removePluginRepository( Repository ), ,     /**,      * Method removeRepository.,      * ,      * @param repository,      */,     public void removeRepository( Repository repository ),     {,         getRepositories().remove( repository );,     } //-- void removeRepository( Repository ), ,     /**,      * Set the conditional logic which will automatically,      *             trigger the inclusion of this profile.,      * ,      * @param activation,      */,     public void setActivation( Activation activation ),     {,         this.activation = activation;,     } //-- void setActivation( Activation ), ,     /**,      * Set the lists of the remote repositories for discovering,      * plugins.,      * ,      * @param pluginRepositories,      */,     public void setPluginRepositories( java.util.List<Repository> pluginRepositories ),     {,         this.pluginRepositories = pluginRepositories;,     } //-- void setPluginRepositories( java.util.List ), ,     /**,      * Set extended configuration specific to this profile goes,      * here.,      *             Contents take the form of,      *            ,      * <code>&lt;property.name&gt;property.value&lt;/property.name&gt;</code>,      * ,      * @param properties,      */,     public void setProperties( java.util.Properties properties ),     {,         this.properties = properties;,     } //-- void setProperties( java.util.Properties ), ,     /**,      * Set the lists of the remote repositories.,      * ,      * @param repositories,      */,     public void setRepositories( java.util.List<Repository> repositories ),     {,         this.repositories = repositories;,     } //-- void setRepositories( java.util.List )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/Profile.java,,19-265,[@SuppressWarnings( "all" ), public class Profile,     extends IdentifiableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The conditional logic which will automatically,      *             trigger the inclusion of this profile.,      *             ,      *           ,      */,     private Activation activation;, ,     /**,      * Field properties.,      */,     private java.util.Properties properties;, ,     /**,      * Field repositories.,      */,     private java.util.List<Repository> repositories;, ,     /**,      * ,      *             ,      *             This may be removed or relocated in the near,      *             future. It is undecided whether plugins really,      * need a remote,      *             repository set of their own.,      *             ,      *           ,      */,     private java.util.List<Repository> pluginRepositories;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addPluginRepository.,      * ,      * @param repository,      */,     public void addPluginRepository( Repository repository ),     {,         getPluginRepositories().add( repository );,     } //-- void addPluginRepository( Repository ), ,     /**,      * Method addProperty.,      * ,      * @param key,      * @param value,      */,     public void addProperty( String key, String value ),     {,         getProperties().put( key, value );,     } //-- void addProperty( String, String ), ,     /**,      * Method addRepository.,      * ,      * @param repository,      */,     public void addRepository( Repository repository ),     {,         getRepositories().add( repository );,     } //-- void addRepository( Repository ), ,     /**,      * Method clone.,      * ,      * @return Profile,      */,     public Profile clone(),     {,         try,         {,             Profile copy = (Profile) super.clone();, ,             if ( this.activation != null ),             {,                 copy.activation = (Activation) this.activation.clone();,             }, ,             if ( this.properties != null ),             {,                 copy.properties = (java.util.Properties) this.properties.clone();,             }, ,             if ( this.repositories != null ),             {,                 copy.repositories = new java.util.ArrayList<Repository>();,                 for ( Repository item : this.repositories ),                 {,                     copy.repositories.add( ( (Repository) item).clone() );,                 },             }, ,             if ( this.pluginRepositories != null ),             {,                 copy.pluginRepositories = new java.util.ArrayList<Repository>();,                 for ( Repository item : this.pluginRepositories ),                 {,                     copy.pluginRepositories.add( ( (Repository) item).clone() );,                 },             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Profile clone(), ,     /**,      * Get the conditional logic which will automatically,      *             trigger the inclusion of this profile.,      * ,      * @return Activation,      */,     public Activation getActivation(),     {,         return this.activation;,     } //-- Activation getActivation(), ,     /**,      * Method getPluginRepositories.,      * ,      * @return List,      */,     public java.util.List<Repository> getPluginRepositories(),     {,         if ( this.pluginRepositories == null ),         {,             this.pluginRepositories = new java.util.ArrayList<Repository>();,         }, ,         return this.pluginRepositories;,     } //-- java.util.List<Repository> getPluginRepositories(), ,     /**,      * Method getProperties.,      * ,      * @return Properties,      */,     public java.util.Properties getProperties(),     {,         if ( this.properties == null ),         {,             this.properties = new java.util.Properties();,         }, ,         return this.properties;,     } //-- java.util.Properties getProperties(), ,     /**,      * Method getRepositories.,      * ,      * @return List,      */,     public java.util.List<Repository> getRepositories(),     {,         if ( this.repositories == null ),         {,             this.repositories = new java.util.ArrayList<Repository>();,         }, ,         return this.repositories;,     } //-- java.util.List<Repository> getRepositories(), ,     /**,      * Method removePluginRepository.,      * ,      * @param repository,      */,     public void removePluginRepository( Repository repository ),     {,         getPluginRepositories().remove( repository );,     } //-- void removePluginRepository( Repository ), ,     /**,      * Method removeRepository.,      * ,      * @param repository,      */,     public void removeRepository( Repository repository ),     {,         getRepositories().remove( repository );,     } //-- void removeRepository( Repository ), ,     /**,      * Set the conditional logic which will automatically,      *             trigger the inclusion of this profile.,      * ,      * @param activation,      */,     public void setActivation( Activation activation ),     {,         this.activation = activation;,     } //-- void setActivation( Activation ), ,     /**,      * Set the lists of the remote repositories for discovering,      * plugins.,      * ,      * @param pluginRepositories,      */,     public void setPluginRepositories( java.util.List<Repository> pluginRepositories ),     {,         this.pluginRepositories = pluginRepositories;,     } //-- void setPluginRepositories( java.util.List ), ,     /**,      * Set extended configuration specific to this profile goes,      * here.,      *             Contents take the form of,      *            ,      * <code>&lt;property.name&gt;property.value&lt;/property.name&gt;</code>,      * ,      * @param properties,      */,     public void setProperties( java.util.Properties properties ),     {,         this.properties = properties;,     } //-- void setProperties( java.util.Properties ), ,     /**,      * Set the lists of the remote repositories.,      * ,      * @param repositories,      */,     public void setRepositories( java.util.List<Repository> repositories ),     {,         this.repositories = repositories;,     } //-- void setRepositories( java.util.List )],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/settings/Proxy.java,,17-254,[@SuppressWarnings( "all" ), public class Proxy,     extends IdentifiableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             Whether this proxy configuration is the active,      * one.,      *             ,      *           ,      */,     private boolean active = true;, ,     /**,      * ,      *             ,      *             The proxy protocol.,      *             ,      *           ,      */,     private String protocol = "http";, ,     /**,      * ,      *             ,      *             The proxy user.,      *             ,      *           ,      */,     private String username;, ,     /**,      * ,      *             ,      *             The proxy password.,      *             ,      *           ,      */,     private String password;, ,     /**,      * ,      *             ,      *             The proxy port.,      *             ,      *           ,      */,     private int port = 8080;, ,     /**,      * ,      *             ,      *             The proxy host.,      *             ,      *           ,      */,     private String host;, ,     /**,      * ,      *             ,      *             The list of non-proxied hosts (delimited by |).,      *             ,      *           ,      */,     private String nonProxyHosts;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Proxy,      */,     public Proxy clone(),     {,         try,         {,             Proxy copy = (Proxy) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Proxy clone(), ,     /**,      * Get the proxy host.,      * ,      * @return String,      */,     public String getHost(),     {,         return this.host;,     } //-- String getHost(), ,     /**,      * Get the list of non-proxied hosts (delimited by |).,      * ,      * @return String,      */,     public String getNonProxyHosts(),     {,         return this.nonProxyHosts;,     } //-- String getNonProxyHosts(), ,     /**,      * Get the proxy password.,      * ,      * @return String,      */,     public String getPassword(),     {,         return this.password;,     } //-- String getPassword(), ,     /**,      * Get the proxy port.,      * ,      * @return int,      */,     public int getPort(),     {,         return this.port;,     } //-- int getPort(), ,     /**,      * Get the proxy protocol.,      * ,      * @return String,      */,     public String getProtocol(),     {,         return this.protocol;,     } //-- String getProtocol(), ,     /**,      * Get the proxy user.,      * ,      * @return String,      */,     public String getUsername(),     {,         return this.username;,     } //-- String getUsername(), ,     /**,      * Get whether this proxy configuration is the active one.,      * ,      * @return boolean,      */,     public boolean isActive(),     {,         return this.active;,     } //-- boolean isActive(), ,     /**,      * Set whether this proxy configuration is the active one.,      * ,      * @param active,      */,     public void setActive( boolean active ),     {,         this.active = active;,     } //-- void setActive( boolean ), ,     /**,      * Set the proxy host.,      * ,      * @param host,      */,     public void setHost( String host ),     {,         this.host = host;,     } //-- void setHost( String ), ,     /**,      * Set the list of non-proxied hosts (delimited by |).,      * ,      * @param nonProxyHosts,      */,     public void setNonProxyHosts( String nonProxyHosts ),     {,         this.nonProxyHosts = nonProxyHosts;,     } //-- void setNonProxyHosts( String ), ,     /**,      * Set the proxy password.,      * ,      * @param password,      */,     public void setPassword( String password ),     {,         this.password = password;,     } //-- void setPassword( String ), ,     /**,      * Set the proxy port.,      * ,      * @param port,      */,     public void setPort( int port ),     {,         this.port = port;,     } //-- void setPort( int ), ,     /**,      * Set the proxy protocol.,      * ,      * @param protocol,      */,     public void setProtocol( String protocol ),     {,         this.protocol = protocol;,     } //-- void setProtocol( String ), ,     /**,      * Set the proxy user.,      * ,      * @param username,      */,     public void setUsername( String username ),     {,         this.username = username;,     } //-- void setUsername( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/Proxy.java,,17-254,[@SuppressWarnings( "all" ), public class Proxy,     extends IdentifiableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             Whether this proxy configuration is the active,      * one.,      *             ,      *           ,      */,     private boolean active = true;, ,     /**,      * ,      *             ,      *             The proxy protocol.,      *             ,      *           ,      */,     private String protocol = "http";, ,     /**,      * ,      *             ,      *             The proxy user.,      *             ,      *           ,      */,     private String username;, ,     /**,      * ,      *             ,      *             The proxy password.,      *             ,      *           ,      */,     private String password;, ,     /**,      * ,      *             ,      *             The proxy port.,      *             ,      *           ,      */,     private int port = 8080;, ,     /**,      * ,      *             ,      *             The proxy host.,      *             ,      *           ,      */,     private String host;, ,     /**,      * ,      *             ,      *             The list of non-proxied hosts (delimited by |).,      *             ,      *           ,      */,     private String nonProxyHosts;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Proxy,      */,     public Proxy clone(),     {,         try,         {,             Proxy copy = (Proxy) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Proxy clone(), ,     /**,      * Get the proxy host.,      * ,      * @return String,      */,     public String getHost(),     {,         return this.host;,     } //-- String getHost(), ,     /**,      * Get the list of non-proxied hosts (delimited by |).,      * ,      * @return String,      */,     public String getNonProxyHosts(),     {,         return this.nonProxyHosts;,     } //-- String getNonProxyHosts(), ,     /**,      * Get the proxy password.,      * ,      * @return String,      */,     public String getPassword(),     {,         return this.password;,     } //-- String getPassword(), ,     /**,      * Get the proxy port.,      * ,      * @return int,      */,     public int getPort(),     {,         return this.port;,     } //-- int getPort(), ,     /**,      * Get the proxy protocol.,      * ,      * @return String,      */,     public String getProtocol(),     {,         return this.protocol;,     } //-- String getProtocol(), ,     /**,      * Get the proxy user.,      * ,      * @return String,      */,     public String getUsername(),     {,         return this.username;,     } //-- String getUsername(), ,     /**,      * Get whether this proxy configuration is the active one.,      * ,      * @return boolean,      */,     public boolean isActive(),     {,         return this.active;,     } //-- boolean isActive(), ,     /**,      * Set whether this proxy configuration is the active one.,      * ,      * @param active,      */,     public void setActive( boolean active ),     {,         this.active = active;,     } //-- void setActive( boolean ), ,     /**,      * Set the proxy host.,      * ,      * @param host,      */,     public void setHost( String host ),     {,         this.host = host;,     } //-- void setHost( String ), ,     /**,      * Set the list of non-proxied hosts (delimited by |).,      * ,      * @param nonProxyHosts,      */,     public void setNonProxyHosts( String nonProxyHosts ),     {,         this.nonProxyHosts = nonProxyHosts;,     } //-- void setNonProxyHosts( String ), ,     /**,      * Set the proxy password.,      * ,      * @param password,      */,     public void setPassword( String password ),     {,         this.password = password;,     } //-- void setPassword( String ), ,     /**,      * Set the proxy port.,      * ,      * @param port,      */,     public void setPort( int port ),     {,         this.port = port;,     } //-- void setPort( int ), ,     /**,      * Set the proxy protocol.,      * ,      * @param protocol,      */,     public void setProtocol( String protocol ),     {,         this.protocol = protocol;,     } //-- void setProtocol( String ), ,     /**,      * Set the proxy user.,      * ,      * @param username,      */,     public void setUsername( String username ),     {,         this.username = username;,     } //-- void setUsername( String )],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/maven/settings/Repository.java,equals,129-129,[        return super.equals( obj );],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/settings/Repository.java,,17-129,[@SuppressWarnings( "all" ), public class Repository,     extends RepositoryBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             How to handle downloading of releases from this,      * repository,      *           .,      */,     private RepositoryPolicy releases;, ,     /**,      * ,      *             How to handle downloading of snapshots from this,      * repository,      *           .,      */,     private RepositoryPolicy snapshots;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Repository,      */,     public Repository clone(),     {,         try,         {,             Repository copy = (Repository) super.clone();, ,             if ( this.releases != null ),             {,                 copy.releases = (RepositoryPolicy) this.releases.clone();,             }, ,             if ( this.snapshots != null ),             {,                 copy.snapshots = (RepositoryPolicy) this.snapshots.clone();,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Repository clone(), ,     /**,      * Get how to handle downloading of releases from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getReleases(),     {,         return this.releases;,     } //-- RepositoryPolicy getReleases(), ,     /**,      * Get how to handle downloading of snapshots from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getSnapshots(),     {,         return this.snapshots;,     } //-- RepositoryPolicy getSnapshots(), ,     /**,      * Set how to handle downloading of releases from this,      * repository.,      * ,      * @param releases,      */,     public void setReleases( RepositoryPolicy releases ),     {,         this.releases = releases;,     } //-- void setReleases( RepositoryPolicy ), ,     /**,      * Set how to handle downloading of snapshots from this,      * repository.,      * ,      * @param snapshots,      */,     public void setSnapshots( RepositoryPolicy snapshots ),     {,         this.snapshots = snapshots;,     } //-- void setSnapshots( RepositoryPolicy ), ,     ,             ,     /**,      * @see org.apache.maven.settings.RepositoryBase#equals(java.lang.Object),      */,     public boolean equals( Object obj ),     {,         return super.equals( obj );],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/Repository.java,,17-129,[@SuppressWarnings( "all" ), public class Repository,     extends RepositoryBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             How to handle downloading of releases from this,      * repository,      *           .,      */,     private RepositoryPolicy releases;, ,     /**,      * ,      *             How to handle downloading of snapshots from this,      * repository,      *           .,      */,     private RepositoryPolicy snapshots;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Repository,      */,     public Repository clone(),     {,         try,         {,             Repository copy = (Repository) super.clone();, ,             if ( this.releases != null ),             {,                 copy.releases = (RepositoryPolicy) this.releases.clone();,             }, ,             if ( this.snapshots != null ),             {,                 copy.snapshots = (RepositoryPolicy) this.snapshots.clone();,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Repository clone(), ,     /**,      * Get how to handle downloading of releases from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getReleases(),     {,         return this.releases;,     } //-- RepositoryPolicy getReleases(), ,     /**,      * Get how to handle downloading of snapshots from this,      * repository.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy getSnapshots(),     {,         return this.snapshots;,     } //-- RepositoryPolicy getSnapshots(), ,     /**,      * Set how to handle downloading of releases from this,      * repository.,      * ,      * @param releases,      */,     public void setReleases( RepositoryPolicy releases ),     {,         this.releases = releases;,     } //-- void setReleases( RepositoryPolicy ), ,     /**,      * Set how to handle downloading of snapshots from this,      * repository.,      * ,      * @param snapshots,      */,     public void setSnapshots( RepositoryPolicy snapshots ),     {,         this.snapshots = snapshots;,     } //-- void setSnapshots( RepositoryPolicy ), ,     ,             ,     /**,      * @see org.apache.maven.settings.RepositoryBase#equals(java.lang.Object),      */,     public boolean equals( Object obj ),     {,         return super.equals( obj );],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/maven/settings/RepositoryBase.java,equals,180-180,[        RepositoryBase other =  (RepositoryBase) obj;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/maven/settings/RepositoryBase.java,equals,180-189,[        RepositoryBase other =  (RepositoryBase) obj;, ,         boolean retValue = false;, ,         if ( id != null ),         {,             retValue = id.equals( other.id );,         }, ,         return retValue;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/RepositoryBase.java,,18-189,[@SuppressWarnings( "all" ), public class RepositoryBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             A unique identifier for a repository.,      *             ,      *           ,      */,     private String id;, ,     /**,      * ,      *             ,      *             Human readable name of the repository.,      *             ,      *           ,      */,     private String name;, ,     /**,      * ,      *             ,      *             The url of the repository.,      *             ,      *           ,      */,     private String url;, ,     /**,      * ,      *             The type of layout this repository uses for,      * locating and,      *             storing artifacts - can be "legacy" or,      * "default".,      *           ,      */,     private String layout = "default";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return RepositoryBase,      */,     public RepositoryBase clone(),     {,         try,         {,             RepositoryBase copy = (RepositoryBase) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- RepositoryBase clone(), ,     /**,      * Get a unique identifier for a repository.,      * ,      * @return String,      */,     public String getId(),     {,         return this.id;,     } //-- String getId(), ,     /**,      * Get the type of layout this repository uses for locating and,      *             storing artifacts - can be "legacy" or,      * "default".,      * ,      * @return String,      */,     public String getLayout(),     {,         return this.layout;,     } //-- String getLayout(), ,     /**,      * Get human readable name of the repository.,      * ,      * @return String,      */,     public String getName(),     {,         return this.name;,     } //-- String getName(), ,     /**,      * Get the url of the repository.,      * ,      * @return String,      */,     public String getUrl(),     {,         return this.url;,     } //-- String getUrl(), ,     /**,      * Set a unique identifier for a repository.,      * ,      * @param id,      */,     public void setId( String id ),     {,         this.id = id;,     } //-- void setId( String ), ,     /**,      * Set the type of layout this repository uses for locating and,      *             storing artifacts - can be "legacy" or,      * "default".,      * ,      * @param layout,      */,     public void setLayout( String layout ),     {,         this.layout = layout;,     } //-- void setLayout( String ), ,     /**,      * Set human readable name of the repository.,      * ,      * @param name,      */,     public void setName( String name ),     {,         this.name = name;,     } //-- void setName( String ), ,     /**,      * Set the url of the repository.,      * ,      * @param url,      */,     public void setUrl( String url ),     {,         this.url = url;,     } //-- void setUrl( String ), ,     ,             ,     /**,      * @see java.lang.Object#equals(java.lang.Object),      */,     public boolean equals( Object obj ),     {,         RepositoryBase other =  (RepositoryBase) obj;, ,         boolean retValue = false;, ,         if ( id != null ),         {,             retValue = id.equals( other.id );,         }, ,         return retValue;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/RepositoryPolicy.java,,13-151,[@SuppressWarnings( "all" ), public class RepositoryPolicy,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             Whether to use this repository for downloading,      * this type of,      *             artifact.,      *           ,      */,     private boolean enabled = true;, ,     /**,      * ,      *             The frequency for downloading updates - can be,      * "always",,      *             "daily" (default), "interval:XXX" (in minutes),      * or "never",      *             (only if it doesn't exist locally).,      *           ,      */,     private String updatePolicy;, ,     /**,      * ,      *             What to do when verification of an artifact,      * checksum fails -,      *             warn, fail, etc. Valid values are "fail" or,      * "warn".,      *           ,      */,     private String checksumPolicy;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return RepositoryPolicy,      */,     public RepositoryPolicy clone(),     {,         try,         {,             RepositoryPolicy copy = (RepositoryPolicy) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- RepositoryPolicy clone(), ,     /**,      * Get what to do when verification of an artifact checksum,      * fails -,      *             warn, fail, etc. Valid values are "fail" or,      * "warn".,      * ,      * @return String,      */,     public String getChecksumPolicy(),     {,         return this.checksumPolicy;,     } //-- String getChecksumPolicy(), ,     /**,      * Get the frequency for downloading updates - can be "always",,      *             "daily" (default), "interval:XXX" (in minutes),      * or "never",      *             (only if it doesn't exist locally).,      * ,      * @return String,      */,     public String getUpdatePolicy(),     {,         return this.updatePolicy;,     } //-- String getUpdatePolicy(), ,     /**,      * Get whether to use this repository for downloading this type,      * of,      *             artifact.,      * ,      * @return boolean,      */,     public boolean isEnabled(),     {,         return this.enabled;,     } //-- boolean isEnabled(), ,     /**,      * Set what to do when verification of an artifact checksum,      * fails -,      *             warn, fail, etc. Valid values are "fail" or,      * "warn".,      * ,      * @param checksumPolicy,      */,     public void setChecksumPolicy( String checksumPolicy ),     {,         this.checksumPolicy = checksumPolicy;,     } //-- void setChecksumPolicy( String ), ,     /**,      * Set whether to use this repository for downloading this type,      * of,      *             artifact.,      * ,      * @param enabled,      */,     public void setEnabled( boolean enabled ),     {,         this.enabled = enabled;,     } //-- void setEnabled( boolean ), ,     /**,      * Set the frequency for downloading updates - can be "always",,      *             "daily" (default), "interval:XXX" (in minutes),      * or "never",      *             (only if it doesn't exist locally).,      * ,      * @param updatePolicy,      */,     public void setUpdatePolicy( String updatePolicy ),     {,         this.updatePolicy = updatePolicy;,     } //-- void setUpdatePolicy( String )],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/settings/Server.java,,17-265,[@SuppressWarnings( "all" ), public class Server,     extends IdentifiableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The username used to authenticate.,      *             ,      *           ,      */,     private String username;, ,     /**,      * ,      *             ,      *             The password used in conjunction with the,      * username to authenticate.,      *             ,      *           ,      */,     private String password;, ,     /**,      * ,      *             ,      *             The private key location used to authenticate.,      *             ,      *           ,      */,     private String privateKey;, ,     /**,      * ,      *             ,      *             The passphrase used in conjunction with the,      * privateKey to authenticate.,      *             ,      *           ,      */,     private String passphrase;, ,     /**,      * ,      *             ,      *             The permissions for files when they are created.,      *             ,      *           ,      */,     private String filePermissions;, ,     /**,      * ,      *             ,      *             The permissions for directories when they are,      * created.,      *             ,      *           ,      */,     private String directoryPermissions;, ,     /**,      * ,      *             ,      *             Extra configuration for the transport layer.,      *             ,      *           ,      */,     private Object configuration;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Server,      */,     public Server clone(),     {,         try,         {,             Server copy = (Server) super.clone();, ,             if ( this.configuration != null ),             {,                 copy.configuration = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.configuration );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Server clone(), ,     /**,      * Get extra configuration for the transport layer.,      * ,      * @return Object,      */,     public Object getConfiguration(),     {,         return this.configuration;,     } //-- Object getConfiguration(), ,     /**,      * Get the permissions for directories when they are created.,      * ,      * @return String,      */,     public String getDirectoryPermissions(),     {,         return this.directoryPermissions;,     } //-- String getDirectoryPermissions(), ,     /**,      * Get the permissions for files when they are created.,      * ,      * @return String,      */,     public String getFilePermissions(),     {,         return this.filePermissions;,     } //-- String getFilePermissions(), ,     /**,      * Get the passphrase used in conjunction with the privateKey,      * to authenticate.,      * ,      * @return String,      */,     public String getPassphrase(),     {,         return this.passphrase;,     } //-- String getPassphrase(), ,     /**,      * Get the password used in conjunction with the username to,      * authenticate.,      * ,      * @return String,      */,     public String getPassword(),     {,         return this.password;,     } //-- String getPassword(), ,     /**,      * Get the private key location used to authenticate.,      * ,      * @return String,      */,     public String getPrivateKey(),     {,         return this.privateKey;,     } //-- String getPrivateKey(), ,     /**,      * Get the username used to authenticate.,      * ,      * @return String,      */,     public String getUsername(),     {,         return this.username;,     } //-- String getUsername(), ,     /**,      * Set extra configuration for the transport layer.,      * ,      * @param configuration,      */,     public void setConfiguration( Object configuration ),     {,         this.configuration = configuration;,     } //-- void setConfiguration( Object ), ,     /**,      * Set the permissions for directories when they are created.,      * ,      * @param directoryPermissions,      */,     public void setDirectoryPermissions( String directoryPermissions ),     {,         this.directoryPermissions = directoryPermissions;,     } //-- void setDirectoryPermissions( String ), ,     /**,      * Set the permissions for files when they are created.,      * ,      * @param filePermissions,      */,     public void setFilePermissions( String filePermissions ),     {,         this.filePermissions = filePermissions;,     } //-- void setFilePermissions( String ), ,     /**,      * Set the passphrase used in conjunction with the privateKey,      * to authenticate.,      * ,      * @param passphrase,      */,     public void setPassphrase( String passphrase ),     {,         this.passphrase = passphrase;,     } //-- void setPassphrase( String ), ,     /**,      * Set the password used in conjunction with the username to,      * authenticate.,      * ,      * @param password,      */,     public void setPassword( String password ),     {,         this.password = password;,     } //-- void setPassword( String ), ,     /**,      * Set the private key location used to authenticate.,      * ,      * @param privateKey,      */,     public void setPrivateKey( String privateKey ),     {,         this.privateKey = privateKey;,     } //-- void setPrivateKey( String ), ,     /**,      * Set the username used to authenticate.,      * ,      * @param username,      */,     public void setUsername( String username ),     {,         this.username = username;,     } //-- void setUsername( String )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/Server.java,,17-265,[@SuppressWarnings( "all" ), public class Server,     extends IdentifiableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The username used to authenticate.,      *             ,      *           ,      */,     private String username;, ,     /**,      * ,      *             ,      *             The password used in conjunction with the,      * username to authenticate.,      *             ,      *           ,      */,     private String password;, ,     /**,      * ,      *             ,      *             The private key location used to authenticate.,      *             ,      *           ,      */,     private String privateKey;, ,     /**,      * ,      *             ,      *             The passphrase used in conjunction with the,      * privateKey to authenticate.,      *             ,      *           ,      */,     private String passphrase;, ,     /**,      * ,      *             ,      *             The permissions for files when they are created.,      *             ,      *           ,      */,     private String filePermissions;, ,     /**,      * ,      *             ,      *             The permissions for directories when they are,      * created.,      *             ,      *           ,      */,     private String directoryPermissions;, ,     /**,      * ,      *             ,      *             Extra configuration for the transport layer.,      *             ,      *           ,      */,     private Object configuration;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return Server,      */,     public Server clone(),     {,         try,         {,             Server copy = (Server) super.clone();, ,             if ( this.configuration != null ),             {,                 copy.configuration = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.configuration );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Server clone(), ,     /**,      * Get extra configuration for the transport layer.,      * ,      * @return Object,      */,     public Object getConfiguration(),     {,         return this.configuration;,     } //-- Object getConfiguration(), ,     /**,      * Get the permissions for directories when they are created.,      * ,      * @return String,      */,     public String getDirectoryPermissions(),     {,         return this.directoryPermissions;,     } //-- String getDirectoryPermissions(), ,     /**,      * Get the permissions for files when they are created.,      * ,      * @return String,      */,     public String getFilePermissions(),     {,         return this.filePermissions;,     } //-- String getFilePermissions(), ,     /**,      * Get the passphrase used in conjunction with the privateKey,      * to authenticate.,      * ,      * @return String,      */,     public String getPassphrase(),     {,         return this.passphrase;,     } //-- String getPassphrase(), ,     /**,      * Get the password used in conjunction with the username to,      * authenticate.,      * ,      * @return String,      */,     public String getPassword(),     {,         return this.password;,     } //-- String getPassword(), ,     /**,      * Get the private key location used to authenticate.,      * ,      * @return String,      */,     public String getPrivateKey(),     {,         return this.privateKey;,     } //-- String getPrivateKey(), ,     /**,      * Get the username used to authenticate.,      * ,      * @return String,      */,     public String getUsername(),     {,         return this.username;,     } //-- String getUsername(), ,     /**,      * Set extra configuration for the transport layer.,      * ,      * @param configuration,      */,     public void setConfiguration( Object configuration ),     {,         this.configuration = configuration;,     } //-- void setConfiguration( Object ), ,     /**,      * Set the permissions for directories when they are created.,      * ,      * @param directoryPermissions,      */,     public void setDirectoryPermissions( String directoryPermissions ),     {,         this.directoryPermissions = directoryPermissions;,     } //-- void setDirectoryPermissions( String ), ,     /**,      * Set the permissions for files when they are created.,      * ,      * @param filePermissions,      */,     public void setFilePermissions( String filePermissions ),     {,         this.filePermissions = filePermissions;,     } //-- void setFilePermissions( String ), ,     /**,      * Set the passphrase used in conjunction with the privateKey,      * to authenticate.,      * ,      * @param passphrase,      */,     public void setPassphrase( String passphrase ),     {,         this.passphrase = passphrase;,     } //-- void setPassphrase( String ), ,     /**,      * Set the password used in conjunction with the username to,      * authenticate.,      * ,      * @param password,      */,     public void setPassword( String password ),     {,         this.password = password;,     } //-- void setPassword( String ), ,     /**,      * Set the private key location used to authenticate.,      * ,      * @param privateKey,      */,     public void setPrivateKey( String privateKey ),     {,         this.privateKey = privateKey;,     } //-- void setPrivateKey( String ), ,     /**,      * Set the username used to authenticate.,      * ,      * @param username,      */,     public void setUsername( String username ),     {,         this.username = username;,     } //-- void setUsername( String )],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/maven/settings/Settings.java,,582-582,[        this.activeProxy = null;],,,590-590,[        if ( activeProxy == null )],,,606-606,[        return activeProxy;],,,599-599,[                        activeProxy = proxy;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/maven/settings/Settings.java,clone,226-226,[        catch ( java.lang.Exception ex )],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/maven/settings/Settings.java,,15-699,[@SuppressWarnings( "all" ), public class Settings,     extends TrackableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The local repository.<br /><b>Default value,      * is:</b> <tt>${user.home}/.m2/repository</tt>,      *             ,      *           ,      */,     private String localRepository;, ,     /**,      * ,      *             ,      *             Whether Maven should attempt to interact with,      * the user for input.,      *             ,      *           ,      */,     private boolean interactiveMode = true;, ,     /**,      * ,      *             ,      *             Whether Maven should use the plugin-registry.xml,      * file to manage plugin versions.,      *             ,      *           ,      */,     private boolean usePluginRegistry = false;, ,     /**,      * ,      *             ,      *             Indicate whether maven should operate in offline,      * mode full-time.,      *             ,      *           ,      */,     private boolean offline = false;, ,     /**,      * Field proxies.,      */,     private java.util.List<Proxy> proxies;, ,     /**,      * Field servers.,      */,     private java.util.List<Server> servers;, ,     /**,      * Field mirrors.,      */,     private java.util.List<Mirror> mirrors;, ,     /**,      * Field profiles.,      */,     private java.util.List<Profile> profiles;, ,     /**,      * Field activeProfiles.,      */,     private java.util.List<String> activeProfiles;, ,     /**,      * Field pluginGroups.,      */,     private java.util.List<String> pluginGroups;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addActiveProfile.,      * ,      * @param string,      */,     public void addActiveProfile( String string ),     {,         getActiveProfiles().add( string );,     } //-- void addActiveProfile( String ), ,     /**,      * Method addMirror.,      * ,      * @param mirror,      */,     public void addMirror( Mirror mirror ),     {,         getMirrors().add( mirror );,     } //-- void addMirror( Mirror ), ,     /**,      * Method addPluginGroup.,      * ,      * @param string,      */,     public void addPluginGroup( String string ),     {,         getPluginGroups().add( string );,     } //-- void addPluginGroup( String ), ,     /**,      * Method addProfile.,      * ,      * @param profile,      */,     public void addProfile( Profile profile ),     {,         getProfiles().add( profile );,     } //-- void addProfile( Profile ), ,     /**,      * Method addProxy.,      * ,      * @param proxy,      */,     public void addProxy( Proxy proxy ),     {,         getProxies().add( proxy );,     } //-- void addProxy( Proxy ), ,     /**,      * Method addServer.,      * ,      * @param server,      */,     public void addServer( Server server ),     {,         getServers().add( server );,     } //-- void addServer( Server ), ,     /**,      * Method clone.,      * ,      * @return Settings,      */,     public Settings clone(),     {,         try,         {,             Settings copy = (Settings) super.clone();, ,             if ( this.proxies != null ),             {,                 copy.proxies = new java.util.ArrayList<Proxy>();,                 for ( Proxy item : this.proxies ),                 {,                     copy.proxies.add( ( (Proxy) item).clone() );,                 },             }, ,             if ( this.servers != null ),             {,                 copy.servers = new java.util.ArrayList<Server>();,                 for ( Server item : this.servers ),                 {,                     copy.servers.add( ( (Server) item).clone() );,                 },             }, ,             if ( this.mirrors != null ),             {,                 copy.mirrors = new java.util.ArrayList<Mirror>();,                 for ( Mirror item : this.mirrors ),                 {,                     copy.mirrors.add( ( (Mirror) item).clone() );,                 },             }, ,             if ( this.profiles != null ),             {,                 copy.profiles = new java.util.ArrayList<Profile>();,                 for ( Profile item : this.profiles ),                 {,                     copy.profiles.add( ( (Profile) item).clone() );,                 },             }, ,             if ( this.activeProfiles != null ),             {,                 copy.activeProfiles = new java.util.ArrayList<String>();,                 copy.activeProfiles.addAll( this.activeProfiles );,             }, ,             if ( this.pluginGroups != null ),             {,                 copy.pluginGroups = new java.util.ArrayList<String>();,                 copy.pluginGroups.addAll( this.pluginGroups );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Settings clone(), ,     /**,      * Method getActiveProfiles.,      * ,      * @return List,      */,     public java.util.List<String> getActiveProfiles(),     {,         if ( this.activeProfiles == null ),         {,             this.activeProfiles = new java.util.ArrayList<String>();,         }, ,         return this.activeProfiles;,     } //-- java.util.List<String> getActiveProfiles(), ,     /**,      * Get the local repository.<br /><b>Default value is:</b>,      * <tt>${user.home}/.m2/repository</tt>,      * ,      * @return String,      */,     public String getLocalRepository(),     {,         return this.localRepository;,     } //-- String getLocalRepository(), ,     /**,      * Method getMirrors.,      * ,      * @return List,      */,     public java.util.List<Mirror> getMirrors(),     {,         if ( this.mirrors == null ),         {,             this.mirrors = new java.util.ArrayList<Mirror>();,         }, ,         return this.mirrors;,     } //-- java.util.List<Mirror> getMirrors(), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Method getPluginGroups.,      * ,      * @return List,      */,     public java.util.List<String> getPluginGroups(),     {,         if ( this.pluginGroups == null ),         {,             this.pluginGroups = new java.util.ArrayList<String>();,         }, ,         return this.pluginGroups;,     } //-- java.util.List<String> getPluginGroups(), ,     /**,      * Method getProfiles.,      * ,      * @return List,      */,     public java.util.List<Profile> getProfiles(),     {,         if ( this.profiles == null ),         {,             this.profiles = new java.util.ArrayList<Profile>();,         }, ,         return this.profiles;,     } //-- java.util.List<Profile> getProfiles(), ,     /**,      * Method getProxies.,      * ,      * @return List,      */,     public java.util.List<Proxy> getProxies(),     {,         if ( this.proxies == null ),         {,             this.proxies = new java.util.ArrayList<Proxy>();,         }, ,         return this.proxies;,     } //-- java.util.List<Proxy> getProxies(), ,     /**,      * Method getServers.,      * ,      * @return List,      */,     public java.util.List<Server> getServers(),     {,         if ( this.servers == null ),         {,             this.servers = new java.util.ArrayList<Server>();,         }, ,         return this.servers;,     } //-- java.util.List<Server> getServers(), ,     /**,      * Get whether Maven should attempt to interact with the user,      * for input.,      * ,      * @return boolean,      */,     public boolean isInteractiveMode(),     {,         return this.interactiveMode;,     } //-- boolean isInteractiveMode(), ,     /**,      * Get indicate whether maven should operate in offline mode,      * full-time.,      * ,      * @return boolean,      */,     public boolean isOffline(),     {,         return this.offline;,     } //-- boolean isOffline(), ,     /**,      * Get whether Maven should use the plugin-registry.xml file to,      * manage plugin versions.,      * ,      * @return boolean,      */,     public boolean isUsePluginRegistry(),     {,         return this.usePluginRegistry;,     } //-- boolean isUsePluginRegistry(), ,     /**,      * Method removeActiveProfile.,      * ,      * @param string,      */,     public void removeActiveProfile( String string ),     {,         getActiveProfiles().remove( string );,     } //-- void removeActiveProfile( String ), ,     /**,      * Method removeMirror.,      * ,      * @param mirror,      */,     public void removeMirror( Mirror mirror ),     {,         getMirrors().remove( mirror );,     } //-- void removeMirror( Mirror ), ,     /**,      * Method removePluginGroup.,      * ,      * @param string,      */,     public void removePluginGroup( String string ),     {,         getPluginGroups().remove( string );,     } //-- void removePluginGroup( String ), ,     /**,      * Method removeProfile.,      * ,      * @param profile,      */,     public void removeProfile( Profile profile ),     {,         getProfiles().remove( profile );,     } //-- void removeProfile( Profile ), ,     /**,      * Method removeProxy.,      * ,      * @param proxy,      */,     public void removeProxy( Proxy proxy ),     {,         getProxies().remove( proxy );,     } //-- void removeProxy( Proxy ), ,     /**,      * Method removeServer.,      * ,      * @param server,      */,     public void removeServer( Server server ),     {,         getServers().remove( server );,     } //-- void removeServer( Server ), ,     /**,      * Set list of manually-activated build profiles, specified in,      * the order in which,      *             they should be applied.,      * ,      * @param activeProfiles,      */,     public void setActiveProfiles( java.util.List<String> activeProfiles ),     {,         this.activeProfiles = activeProfiles;,     } //-- void setActiveProfiles( java.util.List ), ,     /**,      * Set whether Maven should attempt to interact with the user,      * for input.,      * ,      * @param interactiveMode,      */,     public void setInteractiveMode( boolean interactiveMode ),     {,         this.interactiveMode = interactiveMode;,     } //-- void setInteractiveMode( boolean ), ,     /**,      * Set the local repository.<br /><b>Default value is:</b>,      * <tt>${user.home}/.m2/repository</tt>,      * ,      * @param localRepository,      */,     public void setLocalRepository( String localRepository ),     {,         this.localRepository = localRepository;,     } //-- void setLocalRepository( String ), ,     /**,      * Set configuration of download mirrors for repositories.,      * ,      * @param mirrors,      */,     public void setMirrors( java.util.List<Mirror> mirrors ),     {,         this.mirrors = mirrors;,     } //-- void setMirrors( java.util.List ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String ), ,     /**,      * Set indicate whether maven should operate in offline mode,      * full-time.,      * ,      * @param offline,      */,     public void setOffline( boolean offline ),     {,         this.offline = offline;,     } //-- void setOffline( boolean ), ,     /**,      * Set list of groupIds to search for a plugin when that plugin,      *             groupId is not explicitly provided.,      * ,      * @param pluginGroups,      */,     public void setPluginGroups( java.util.List<String> pluginGroups ),     {,         this.pluginGroups = pluginGroups;,     } //-- void setPluginGroups( java.util.List ), ,     /**,      * Set configuration of build profiles for adjusting the build,      *             according to environmental parameters.,      * ,      * @param profiles,      */,     public void setProfiles( java.util.List<Profile> profiles ),     {,         this.profiles = profiles;,     } //-- void setProfiles( java.util.List ), ,     /**,      * Set configuration for different proxy profiles. Multiple,      * proxy profiles,      *             might come in handy for anyone working from a,      * notebook or other,      *             mobile platform, to enable easy switching of,      * entire proxy,      *             configurations by simply specifying the profile,      * id, again either from,      *             the command line or from the defaults section,      * below.,      * ,      * @param proxies,      */,     public void setProxies( java.util.List<Proxy> proxies ),     {,         this.proxies = proxies;,     } //-- void setProxies( java.util.List ), ,     /**,      * Set configuration of server-specific settings, mainly,      * authentication,      *             method. This allows configuration of,      * authentication on a per-server,      *             basis.,      * ,      * @param servers,      */,     public void setServers( java.util.List<Server> servers ),     {,         this.servers = servers;,     } //-- void setServers( java.util.List ), ,     /**,      * Set whether Maven should use the plugin-registry.xml file to,      * manage plugin versions.,      * ,      * @param usePluginRegistry,      */,     public void setUsePluginRegistry( boolean usePluginRegistry ),     {,         this.usePluginRegistry = usePluginRegistry;,     } //-- void setUsePluginRegistry( boolean ), ,     ,             ,     public Boolean getInteractiveMode(),     {,         return Boolean.valueOf( isInteractiveMode() );,     }, ,     private Proxy activeProxy;, ,     /**,      * Reset the <code>activeProxy</code> field to <code>null</code>,      */,     public void flushActiveProxy(),     {,         this.activeProxy = null;,     }, ,     /**,      * @return the first active proxy,      */,     public synchronized Proxy getActiveProxy(),     {,         if ( activeProxy == null ),         {,             java.util.List<Proxy> proxies = getProxies();,             if ( proxies != null && !proxies.isEmpty() ),             {,                 for ( Proxy proxy : proxies ),                 {,                     if ( proxy.isActive() ),                     {,                         activeProxy = proxy;,                         break;,                     },                 },             },         }, ,         return activeProxy;,     }, ,     public Server getServer( String serverId ),     {,         Server match = null;, ,         java.util.List<Server> servers = getServers();,         if ( servers != null && serverId != null ),         {,             for ( Server server : servers ),             {,                 if ( serverId.equals( server.getId() ) ),                 {,                     match = server;,                     break;,                 },             },         }, ,         return match;,     }, ,     @Deprecated,     public Mirror getMirrorOf( String repositoryId ),     {,         Mirror match = null;, ,         java.util.List<Mirror> mirrors = getMirrors();,         if ( mirrors != null && repositoryId != null ),         {,             for ( Mirror mirror : mirrors ),             {,                 if ( repositoryId.equals( mirror.getMirrorOf() ) ),                 {,                     match = mirror;,                     break;,                 },             },         }, ,         return match;,     }, ,     private java.util.Map<String, Profile> profileMap;, ,     /**,      * Reset the <code>profileMap</code> field to <code>null</code>,      */,     public void flushProfileMap(),     {,         this.profileMap = null;,     }, ,     /**,      * @return a Map of profiles field with <code>Profile#getId()</code> as key,      * @see org.apache.maven.settings.Profile#getId(),      */,     public java.util.Map<String, Profile> getProfilesAsMap(),     {,         if ( profileMap == null ),         {,             profileMap = new java.util.LinkedHashMap<String, Profile>();, ,             if ( getProfiles() != null ),             {,                 for ( Profile profile : getProfiles() ),                 {,                     profileMap.put( profile.getId(), profile );,                 },             },         }, ,         return profileMap;,     }, ,     //[MNG-3954] :: this is required for the release plugin, ,     private RuntimeInfo runtimeInfo;, ,     @Deprecated,     public void setRuntimeInfo( RuntimeInfo runtimeInfo ),     {,         this.runtimeInfo = runtimeInfo;,     }, ,     @Deprecated,     public RuntimeInfo getRuntimeInfo(),     {,         if ( runtimeInfo == null ),         {,             runtimeInfo = new RuntimeInfo();,         },         return runtimeInfo;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/maven/settings/RuntimeInfo.java,,31-51,[    public static final String userHome = System.getProperty( "user.home" );, ,     public static final File userMavenConfigurationHome = new File( userHome, ".m2" );, ,     public static final File DEFAULT_USER_SETTINGS_FILE = new File( userMavenConfigurationHome, "settings.xml" );, ,     private File settings;, ,     public RuntimeInfo(),     {,         this.settings = DEFAULT_USER_SETTINGS_FILE;,     }, ,     public RuntimeInfo( File settings ),     {,         this.settings = settings;,     }, ,     public File getFile(),     {,         return settings;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/Settings.java,,15-699,[@SuppressWarnings( "all" ), public class Settings,     extends TrackableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *             ,      *             The local repository.<br /><b>Default value,      * is:</b> <tt>${user.home}/.m2/repository</tt>,      *             ,      *           ,      */,     private String localRepository;, ,     /**,      * ,      *             ,      *             Whether Maven should attempt to interact with,      * the user for input.,      *             ,      *           ,      */,     private boolean interactiveMode = true;, ,     /**,      * ,      *             ,      *             Whether Maven should use the plugin-registry.xml,      * file to manage plugin versions.,      *             ,      *           ,      */,     private boolean usePluginRegistry = false;, ,     /**,      * ,      *             ,      *             Indicate whether maven should operate in offline,      * mode full-time.,      *             ,      *           ,      */,     private boolean offline = false;, ,     /**,      * Field proxies.,      */,     private java.util.List<Proxy> proxies;, ,     /**,      * Field servers.,      */,     private java.util.List<Server> servers;, ,     /**,      * Field mirrors.,      */,     private java.util.List<Mirror> mirrors;, ,     /**,      * Field profiles.,      */,     private java.util.List<Profile> profiles;, ,     /**,      * Field activeProfiles.,      */,     private java.util.List<String> activeProfiles;, ,     /**,      * Field pluginGroups.,      */,     private java.util.List<String> pluginGroups;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addActiveProfile.,      * ,      * @param string,      */,     public void addActiveProfile( String string ),     {,         getActiveProfiles().add( string );,     } //-- void addActiveProfile( String ), ,     /**,      * Method addMirror.,      * ,      * @param mirror,      */,     public void addMirror( Mirror mirror ),     {,         getMirrors().add( mirror );,     } //-- void addMirror( Mirror ), ,     /**,      * Method addPluginGroup.,      * ,      * @param string,      */,     public void addPluginGroup( String string ),     {,         getPluginGroups().add( string );,     } //-- void addPluginGroup( String ), ,     /**,      * Method addProfile.,      * ,      * @param profile,      */,     public void addProfile( Profile profile ),     {,         getProfiles().add( profile );,     } //-- void addProfile( Profile ), ,     /**,      * Method addProxy.,      * ,      * @param proxy,      */,     public void addProxy( Proxy proxy ),     {,         getProxies().add( proxy );,     } //-- void addProxy( Proxy ), ,     /**,      * Method addServer.,      * ,      * @param server,      */,     public void addServer( Server server ),     {,         getServers().add( server );,     } //-- void addServer( Server ), ,     /**,      * Method clone.,      * ,      * @return Settings,      */,     public Settings clone(),     {,         try,         {,             Settings copy = (Settings) super.clone();, ,             if ( this.proxies != null ),             {,                 copy.proxies = new java.util.ArrayList<Proxy>();,                 for ( Proxy item : this.proxies ),                 {,                     copy.proxies.add( ( (Proxy) item).clone() );,                 },             }, ,             if ( this.servers != null ),             {,                 copy.servers = new java.util.ArrayList<Server>();,                 for ( Server item : this.servers ),                 {,                     copy.servers.add( ( (Server) item).clone() );,                 },             }, ,             if ( this.mirrors != null ),             {,                 copy.mirrors = new java.util.ArrayList<Mirror>();,                 for ( Mirror item : this.mirrors ),                 {,                     copy.mirrors.add( ( (Mirror) item).clone() );,                 },             }, ,             if ( this.profiles != null ),             {,                 copy.profiles = new java.util.ArrayList<Profile>();,                 for ( Profile item : this.profiles ),                 {,                     copy.profiles.add( ( (Profile) item).clone() );,                 },             }, ,             if ( this.activeProfiles != null ),             {,                 copy.activeProfiles = new java.util.ArrayList<String>();,                 copy.activeProfiles.addAll( this.activeProfiles );,             }, ,             if ( this.pluginGroups != null ),             {,                 copy.pluginGroups = new java.util.ArrayList<String>();,                 copy.pluginGroups.addAll( this.pluginGroups );,             }, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- Settings clone(), ,     /**,      * Method getActiveProfiles.,      * ,      * @return List,      */,     public java.util.List<String> getActiveProfiles(),     {,         if ( this.activeProfiles == null ),         {,             this.activeProfiles = new java.util.ArrayList<String>();,         }, ,         return this.activeProfiles;,     } //-- java.util.List<String> getActiveProfiles(), ,     /**,      * Get the local repository.<br /><b>Default value is:</b>,      * <tt>${user.home}/.m2/repository</tt>,      * ,      * @return String,      */,     public String getLocalRepository(),     {,         return this.localRepository;,     } //-- String getLocalRepository(), ,     /**,      * Method getMirrors.,      * ,      * @return List,      */,     public java.util.List<Mirror> getMirrors(),     {,         if ( this.mirrors == null ),         {,             this.mirrors = new java.util.ArrayList<Mirror>();,         }, ,         return this.mirrors;,     } //-- java.util.List<Mirror> getMirrors(), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Method getPluginGroups.,      * ,      * @return List,      */,     public java.util.List<String> getPluginGroups(),     {,         if ( this.pluginGroups == null ),         {,             this.pluginGroups = new java.util.ArrayList<String>();,         }, ,         return this.pluginGroups;,     } //-- java.util.List<String> getPluginGroups(), ,     /**,      * Method getProfiles.,      * ,      * @return List,      */,     public java.util.List<Profile> getProfiles(),     {,         if ( this.profiles == null ),         {,             this.profiles = new java.util.ArrayList<Profile>();,         }, ,         return this.profiles;,     } //-- java.util.List<Profile> getProfiles(), ,     /**,      * Method getProxies.,      * ,      * @return List,      */,     public java.util.List<Proxy> getProxies(),     {,         if ( this.proxies == null ),         {,             this.proxies = new java.util.ArrayList<Proxy>();,         }, ,         return this.proxies;,     } //-- java.util.List<Proxy> getProxies(), ,     /**,      * Method getServers.,      * ,      * @return List,      */,     public java.util.List<Server> getServers(),     {,         if ( this.servers == null ),         {,             this.servers = new java.util.ArrayList<Server>();,         }, ,         return this.servers;,     } //-- java.util.List<Server> getServers(), ,     /**,      * Get whether Maven should attempt to interact with the user,      * for input.,      * ,      * @return boolean,      */,     public boolean isInteractiveMode(),     {,         return this.interactiveMode;,     } //-- boolean isInteractiveMode(), ,     /**,      * Get indicate whether maven should operate in offline mode,      * full-time.,      * ,      * @return boolean,      */,     public boolean isOffline(),     {,         return this.offline;,     } //-- boolean isOffline(), ,     /**,      * Get whether Maven should use the plugin-registry.xml file to,      * manage plugin versions.,      * ,      * @return boolean,      */,     public boolean isUsePluginRegistry(),     {,         return this.usePluginRegistry;,     } //-- boolean isUsePluginRegistry(), ,     /**,      * Method removeActiveProfile.,      * ,      * @param string,      */,     public void removeActiveProfile( String string ),     {,         getActiveProfiles().remove( string );,     } //-- void removeActiveProfile( String ), ,     /**,      * Method removeMirror.,      * ,      * @param mirror,      */,     public void removeMirror( Mirror mirror ),     {,         getMirrors().remove( mirror );,     } //-- void removeMirror( Mirror ), ,     /**,      * Method removePluginGroup.,      * ,      * @param string,      */,     public void removePluginGroup( String string ),     {,         getPluginGroups().remove( string );,     } //-- void removePluginGroup( String ), ,     /**,      * Method removeProfile.,      * ,      * @param profile,      */,     public void removeProfile( Profile profile ),     {,         getProfiles().remove( profile );,     } //-- void removeProfile( Profile ), ,     /**,      * Method removeProxy.,      * ,      * @param proxy,      */,     public void removeProxy( Proxy proxy ),     {,         getProxies().remove( proxy );,     } //-- void removeProxy( Proxy ), ,     /**,      * Method removeServer.,      * ,      * @param server,      */,     public void removeServer( Server server ),     {,         getServers().remove( server );,     } //-- void removeServer( Server ), ,     /**,      * Set list of manually-activated build profiles, specified in,      * the order in which,      *             they should be applied.,      * ,      * @param activeProfiles,      */,     public void setActiveProfiles( java.util.List<String> activeProfiles ),     {,         this.activeProfiles = activeProfiles;,     } //-- void setActiveProfiles( java.util.List ), ,     /**,      * Set whether Maven should attempt to interact with the user,      * for input.,      * ,      * @param interactiveMode,      */,     public void setInteractiveMode( boolean interactiveMode ),     {,         this.interactiveMode = interactiveMode;,     } //-- void setInteractiveMode( boolean ), ,     /**,      * Set the local repository.<br /><b>Default value is:</b>,      * <tt>${user.home}/.m2/repository</tt>,      * ,      * @param localRepository,      */,     public void setLocalRepository( String localRepository ),     {,         this.localRepository = localRepository;,     } //-- void setLocalRepository( String ), ,     /**,      * Set configuration of download mirrors for repositories.,      * ,      * @param mirrors,      */,     public void setMirrors( java.util.List<Mirror> mirrors ),     {,         this.mirrors = mirrors;,     } //-- void setMirrors( java.util.List ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String ), ,     /**,      * Set indicate whether maven should operate in offline mode,      * full-time.,      * ,      * @param offline,      */,     public void setOffline( boolean offline ),     {,         this.offline = offline;,     } //-- void setOffline( boolean ), ,     /**,      * Set list of groupIds to search for a plugin when that plugin,      *             groupId is not explicitly provided.,      * ,      * @param pluginGroups,      */,     public void setPluginGroups( java.util.List<String> pluginGroups ),     {,         this.pluginGroups = pluginGroups;,     } //-- void setPluginGroups( java.util.List ), ,     /**,      * Set configuration of build profiles for adjusting the build,      *             according to environmental parameters.,      * ,      * @param profiles,      */,     public void setProfiles( java.util.List<Profile> profiles ),     {,         this.profiles = profiles;,     } //-- void setProfiles( java.util.List ), ,     /**,      * Set configuration for different proxy profiles. Multiple,      * proxy profiles,      *             might come in handy for anyone working from a,      * notebook or other,      *             mobile platform, to enable easy switching of,      * entire proxy,      *             configurations by simply specifying the profile,      * id, again either from,      *             the command line or from the defaults section,      * below.,      * ,      * @param proxies,      */,     public void setProxies( java.util.List<Proxy> proxies ),     {,         this.proxies = proxies;,     } //-- void setProxies( java.util.List ), ,     /**,      * Set configuration of server-specific settings, mainly,      * authentication,      *             method. This allows configuration of,      * authentication on a per-server,      *             basis.,      * ,      * @param servers,      */,     public void setServers( java.util.List<Server> servers ),     {,         this.servers = servers;,     } //-- void setServers( java.util.List ), ,     /**,      * Set whether Maven should use the plugin-registry.xml file to,      * manage plugin versions.,      * ,      * @param usePluginRegistry,      */,     public void setUsePluginRegistry( boolean usePluginRegistry ),     {,         this.usePluginRegistry = usePluginRegistry;,     } //-- void setUsePluginRegistry( boolean ), ,     ,             ,     public Boolean getInteractiveMode(),     {,         return Boolean.valueOf( isInteractiveMode() );,     }, ,     private Proxy activeProxy;, ,     /**,      * Reset the <code>activeProxy</code> field to <code>null</code>,      */,     public void flushActiveProxy(),     {,         this.activeProxy = null;,     }, ,     /**,      * @return the first active proxy,      */,     public synchronized Proxy getActiveProxy(),     {,         if ( activeProxy == null ),         {,             java.util.List<Proxy> proxies = getProxies();,             if ( proxies != null && !proxies.isEmpty() ),             {,                 for ( Proxy proxy : proxies ),                 {,                     if ( proxy.isActive() ),                     {,                         activeProxy = proxy;,                         break;,                     },                 },             },         }, ,         return activeProxy;,     }, ,     public Server getServer( String serverId ),     {,         Server match = null;, ,         java.util.List<Server> servers = getServers();,         if ( servers != null && serverId != null ),         {,             for ( Server server : servers ),             {,                 if ( serverId.equals( server.getId() ) ),                 {,                     match = server;,                     break;,                 },             },         }, ,         return match;,     }, ,     @Deprecated,     public Mirror getMirrorOf( String repositoryId ),     {,         Mirror match = null;, ,         java.util.List<Mirror> mirrors = getMirrors();,         if ( mirrors != null && repositoryId != null ),         {,             for ( Mirror mirror : mirrors ),             {,                 if ( repositoryId.equals( mirror.getMirrorOf() ) ),                 {,                     match = mirror;,                     break;,                 },             },         }, ,         return match;,     }, ,     private java.util.Map<String, Profile> profileMap;, ,     /**,      * Reset the <code>profileMap</code> field to <code>null</code>,      */,     public void flushProfileMap(),     {,         this.profileMap = null;,     }, ,     /**,      * @return a Map of profiles field with <code>Profile#getId()</code> as key,      * @see org.apache.maven.settings.Profile#getId(),      */,     public java.util.Map<String, Profile> getProfilesAsMap(),     {,         if ( profileMap == null ),         {,             profileMap = new java.util.LinkedHashMap<String, Profile>();, ,             if ( getProfiles() != null ),             {,                 for ( Profile profile : getProfiles() ),                 {,                     profileMap.put( profile.getId(), profile );,                 },             },         }, ,         return profileMap;,     }, ,     //[MNG-3954] :: this is required for the release plugin, ,     private RuntimeInfo runtimeInfo;, ,     @Deprecated,     public void setRuntimeInfo( RuntimeInfo runtimeInfo ),     {,         this.runtimeInfo = runtimeInfo;,     }, ,     @Deprecated,     public RuntimeInfo getRuntimeInfo(),     {,         if ( runtimeInfo == null ),         {,             runtimeInfo = new RuntimeInfo();,         },         return runtimeInfo;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/settings/SettingsUtils.java,convertFromSettingsProfile,207-207,[        if ( pluginRepos != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/settings/SettingsUtils.java,convertFromSettingsProfile,198-198,[        if ( repos != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/settings/SettingsUtils.java,convertToSettingsProfile,121-121,[        if ( pluginRepos != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/settings/SettingsUtils.java,convertToSettingsProfile,112-112,[        if ( repos != null )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/settings/TrackableBase.java,,17-73,[@SuppressWarnings( "all" ), public class TrackableBase,     implements java.io.Serializable, java.lang.Cloneable, {, ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method clone.,      * ,      * @return TrackableBase,      */,     public TrackableBase clone(),     {,         try,         {,             TrackableBase copy = (TrackableBase) super.clone();, ,             return copy;,         },         catch ( java.lang.Exception ex ),         {,             throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName(),                 + " does not support clone()" ).initCause( ex );,         },     } //-- TrackableBase clone(), ,     ,             ,     public static final String USER_LEVEL = "user-level";,     public static final String GLOBAL_LEVEL = "global-level";, ,     private String sourceLevel = USER_LEVEL;,     private boolean sourceLevelSet = false;, ,     public void setSourceLevel( String sourceLevel ),     {,         if ( sourceLevelSet ),         {,             throw new IllegalStateException( "Cannot reset sourceLevel attribute; it is already set to: " + sourceLevel );,         },         else if ( !( USER_LEVEL.equals( sourceLevel ) || GLOBAL_LEVEL.equals( sourceLevel ) ) ),         {,             throw new IllegalArgumentException( "sourceLevel must be one of: {" + USER_LEVEL + "," + GLOBAL_LEVEL + "}" );,         },         else,         {,             this.sourceLevel = sourceLevel;,             this.sourceLevelSet = true;,         },     }, ,     public String getSourceLevel(),     {,         return sourceLevel;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/settings/building/DefaultSettingsBuilder.java,interpolate,260-260,[            result = settingsReader.read( new StringReader( serializedSettings ), options );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/settings/building/DefaultSettingsBuilder.java,readSettings,169-169,[                settings = settingsReader.read( settingsSource.getInputStream(), options );],,readSettings,175-175,[                settings = settingsReader.read( settingsSource.getInputStream(), options );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/settings/building/DefaultSettingsBuilder.java,readSettings,194-194,[        settingsValidator.validate( settings, problems );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/maven/settings/building/DefaultSettingsBuilder.java,interpolate,205-205,[            settingsWriter.write( writer, null, settings );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/maven/settings/building/DefaultSettingsBuilder.java,,231-240,[        {,             public Object execute( String expression, Object value ),             {,                 if ( value != null ),                 {,                     // we're going to parse this back in as XML so we need to escape XML markup,                     value = value.toString().replace( "&", "&amp;" ).replace( "<", "&lt;" ).replace( ">", "&gt;" );,                     return value;,                 },                 return null;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/maven/settings/building/SettingsBuildingException.java,<init>,47-47,[        super( toMessage( problems ) );],,<init>,50-50,[        if ( problems != null )],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/maven/settings/io/DefaultSettingsWriter.java,write,58-58,[        output.getParentFile().mkdirs();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseTrackableBase,1470-1470,[        java.util.Set parsed = new java.util.HashSet();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseActivation,591-591,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseActivationFile,650-650,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseActivationOS,697-697,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseActivationProperty,752-752,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseIdentifiableBase,799-799,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseMirror,842-842,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseProfile,905-905,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseProxy,993-993,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseRepository,1064-1064,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseRepositoryBase,1127-1127,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseRepositoryPolicy,1182-1182,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseServer,1233-1233,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseSettings,1304-1304,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseTrackableBase,1459-1459,[            String value = parser.getAttributeValue( i );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getIntegerValue,377-377,[                return Integer.valueOf( s ).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getLongValue,407-407,[                return Long.valueOf( s ).longValue();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getBooleanValue,162-162,[        return getBooleanValue( s, attribute, parser, null );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getDateValue,250-250,[        return getDateValue( s, attribute, null, parser );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getByteValue,202-216,[        if ( s != null ),         {,             try,             {,                 return Byte.valueOf( s ).byteValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getCharacterValue,231-235,[        if ( s != null ),         {,             return s.charAt( 0 );,         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getDoubleValue,313-327,[        if ( s != null ),         {,             try,             {,                 return Double.valueOf( s ).doubleValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getFloatValue,343-357,[        if ( s != null ),         {,             try,             {,                 return Float.valueOf( s ).floatValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getLongValue,403-417,[        if ( s != null ),         {,             try,             {,                 return Long.valueOf( s ).longValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getRequiredAttributeValue,433-440,[        if ( s == null ),         {,             if ( strict ),             {,                 throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );,             },         },         return s;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,getShortValue,456-470,[        if ( s != null ),         {,             try,             {,                 return Short.valueOf( s ).shortValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseIdentifiableBase,794-822,[        String tagName = parser.getName();,         IdentifiableBase identifiableBase = new IdentifiableBase();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "id", null, parsed ) ),             {,                 identifiableBase.setId( getTrimmedValue( parser.nextText() ) );,             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return identifiableBase;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseRepositoryBase,1122-1162,[        String tagName = parser.getName();,         RepositoryBase repositoryBase = new RepositoryBase();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             if ( checkFieldWithDuplicate( parser, "id", null, parsed ) ),             {,                 repositoryBase.setId( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) ),             {,                 repositoryBase.setName( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) ),             {,                 repositoryBase.setUrl( getTrimmedValue( parser.nextText() ) );,             },             else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) ),             {,                 repositoryBase.setLayout( getTrimmedValue( parser.nextText() ) );,             },             else,             {,                 checkUnknownElement( parser, strict );,             },         },         return repositoryBase;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Reader.java,parseTrackableBase,1454-1475,[        String tagName = parser.getName();,         TrackableBase trackableBase = new TrackableBase();,         for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- ),         {,             String name = parser.getAttributeName( i );,             String value = parser.getAttributeValue( i );, ,             if ( name.indexOf( ':' ) >= 0 ),             {,                 // just ignore attributes with non-default namespace (for example: xmlns:xsi),             },             else,             {,                 checkUnknownAttribute( parser, name, tagName, strict );,             },         },         java.util.Set parsed = new java.util.HashSet();,         while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG ),         {,             checkUnknownElement( parser, strict );,         },         return trackableBase;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java,writeProfile,301-301,[        if ( ( profile.getPluginRepositories() != null ) && ( profile.getPluginRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java,writeProfile,280-280,[        if ( ( profile.getProperties() != null ) && ( profile.getProperties().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java,writeProfile,291-291,[        if ( ( profile.getRepositories() != null ) && ( profile.getRepositories().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java,writeSettings,570-570,[        if ( ( settings.getProfiles() != null ) && ( settings.getProfiles().size() > 0 ) )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java,writeIdentifiableBase,217-223,[        serializer.startTag( NAMESPACE, tagName );,         if ( ( identifiableBase.getId() != null ) && !identifiableBase.getId().equals( "default" ) ),         {,             serializer.startTag( NAMESPACE, "id" ).text( identifiableBase.getId() ).endTag( NAMESPACE, "id" );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writeIdentifiableBase( IdentifiableBase, String, XmlSerializer )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java,writeRepositoryBase,415-433,[        serializer.startTag( NAMESPACE, tagName );,         if ( repositoryBase.getId() != null ),         {,             serializer.startTag( NAMESPACE, "id" ).text( repositoryBase.getId() ).endTag( NAMESPACE, "id" );,         },         if ( repositoryBase.getName() != null ),         {,             serializer.startTag( NAMESPACE, "name" ).text( repositoryBase.getName() ).endTag( NAMESPACE, "name" );,         },         if ( repositoryBase.getUrl() != null ),         {,             serializer.startTag( NAMESPACE, "url" ).text( repositoryBase.getUrl() ).endTag( NAMESPACE, "url" );,         },         if ( ( repositoryBase.getLayout() != null ) && !repositoryBase.getLayout().equals( "default" ) ),         {,             serializer.startTag( NAMESPACE, "layout" ).text( repositoryBase.getLayout() ).endTag( NAMESPACE, "layout" );,         },         serializer.endTag( NAMESPACE, tagName );,     } //-- void writeRepositoryBase( RepositoryBase, String, XmlSerializer )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/settings/io/xpp3/SettingsXpp3Writer.java,writeTrackableBase,614-616,[        serializer.startTag( NAMESPACE, tagName );,         serializer.endTag( NAMESPACE, tagName );,     } //-- void writeTrackableBase( TrackableBase, String, XmlSerializer )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/settings/validation/DefaultSettingsValidator.java,validate,124-124,[        if ( profiles != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/toolchain/DefaultToolchainManagerPrivate.java,getToolchainsForType,54-54,[            if ( lst != null )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/toolchain/model/PersistedToolchains.java,,19-105,[public class PersistedToolchains,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field toolchains.,      */,     private java.util.List<ToolchainModel> toolchains;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addToolchain.,      * ,      * @param toolchainModel,      */,     public void addToolchain( ToolchainModel toolchainModel ),     {,         getToolchains().add( toolchainModel );,     } //-- void addToolchain( ToolchainModel ), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Method getToolchains.,      * ,      * @return List,      */,     public java.util.List<ToolchainModel> getToolchains(),     {,         if ( this.toolchains == null ),         {,             this.toolchains = new java.util.ArrayList<ToolchainModel>();,         }, ,         return this.toolchains;,     } //-- java.util.List<ToolchainModel> getToolchains(), ,     /**,      * Method removeToolchain.,      * ,      * @param toolchainModel,      */,     public void removeToolchain( ToolchainModel toolchainModel ),     {,         getToolchains().remove( toolchainModel );,     } //-- void removeToolchain( ToolchainModel ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String ), ,     /**,      * Set the toolchain definition.,      * ,      * @param toolchains,      */,     public void setToolchains( java.util.List<ToolchainModel> toolchains ),     {,         this.toolchains = toolchains;,     } //-- void setToolchains( java.util.List )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/toolchain/model/ToolchainModel.java,,14-101,[public class ToolchainModel,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * ,      *                     Type of toolchain.,      */,     private String type;, ,     /**,      * Field provides.,      */,     private Object provides;, ,     /**,      * Field configuration.,      */,     private Object configuration;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Get the configuration field.,      * ,      * @return Object,      */,     public Object getConfiguration(),     {,         return this.configuration;,     } //-- Object getConfiguration(), ,     /**,      * Get the provides field.,      * ,      * @return Object,      */,     public Object getProvides(),     {,         return this.provides;,     } //-- Object getProvides(), ,     /**,      * Get type of toolchain.,      * ,      * @return String,      */,     public String getType(),     {,         return this.type;,     } //-- String getType(), ,     /**,      * Set the configuration field.,      * ,      * @param configuration,      */,     public void setConfiguration( Object configuration ),     {,         this.configuration = configuration;,     } //-- void setConfiguration( Object ), ,     /**,      * Set the provides field.,      * ,      * @param provides,      */,     public void setProvides( Object provides ),     {,         this.provides = provides;,     } //-- void setProvides( Object ), ,     /**,      * Set type of toolchain.,      * ,      * @param type,      */,     public void setType( String type ),     {,         this.type = type;,     } //-- void setType( String )],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,parsePersistedToolchains,594-594,[        java.util.Set parsed = new java.util.HashSet();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,parsePersistedToolchains,579-579,[            String value = parser.getAttributeValue( i );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,parseToolchainModel,632-632,[            String value = parser.getAttributeValue( i );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getIntegerValue,365-365,[                return Integer.valueOf( s ).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getLongValue,395-395,[                return Long.valueOf( s ).longValue();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,parsePersistedToolchains,600-600,[                if ( toolchains == null )],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getBooleanValue,150-150,[        return getBooleanValue( s, attribute, parser, null );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getDateValue,238-238,[        return getDateValue( s, attribute, null, parser );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getByteValue,190-204,[        if ( s != null ),         {,             try,             {,                 return Byte.valueOf( s ).byteValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getCharacterValue,219-223,[        if ( s != null ),         {,             return s.charAt( 0 );,         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getDoubleValue,301-315,[        if ( s != null ),         {,             try,             {,                 return Double.valueOf( s ).doubleValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getFloatValue,331-345,[        if ( s != null ),         {,             try,             {,                 return Float.valueOf( s ).floatValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getIntegerValue,361-375,[        if ( s != null ),         {,             try,             {,                 return Integer.valueOf( s ).intValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getLongValue,391-405,[        if ( s != null ),         {,             try,             {,                 return Long.valueOf( s ).longValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getRequiredAttributeValue,421-428,[        if ( s == null ),         {,             if ( strict ),             {,                 throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );,             },         },         return s;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Reader.java,getShortValue,444-458,[        if ( s != null ),         {,             try,             {,                 return Short.valueOf( s ).shortValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );,                 },             },         },         return 0;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/toolchain/model/io/xpp3/MavenToolchainsXpp3Writer.java,writePersistedToolchains,97-97,[        if ( ( persistedToolchains.getToolchains() != null ) && ( persistedToolchains.getToolchains().size() > 0 ) )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/usability/plugin/Expression.java,,14-271,[public class Expression,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * The syntax of the expression.,      */,     private String syntax;, ,     /**,      * The description of what this expression references, and what,      * it's generally used for.,      */,     private String description;, ,     /**,      * The place and syntax used to change the value of this,      * expression.,      */,     private String configuration;, ,     /**,      * Field cliOptions.,      */,     private java.util.Properties cliOptions;, ,     /**,      * Field apiMethods.,      */,     private java.util.Properties apiMethods;, ,     /**,      * A preferred alternative to this expression, in the case,      * where it's deprecated.,      */,     private String deprecation;, ,     /**,      * A preferred alternative to this expression, in the case,      * where it's banned from use.,      */,     private String ban;, ,     /**,      * Whether the value of this expression can be changed.,      */,     private boolean editable = true;, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addApiMethod.,      * ,      * @param key,      * @param value,      */,     public void addApiMethod( String key, String value ),     {,         getApiMethods().put( key, value );,     } //-- void addApiMethod( String, String ), ,     /**,      * Method addCliOption.,      * ,      * @param key,      * @param value,      */,     public void addCliOption( String key, String value ),     {,         getCliOptions().put( key, value );,     } //-- void addCliOption( String, String ), ,     /**,      * Method getApiMethods.,      * ,      * @return Properties,      */,     public java.util.Properties getApiMethods(),     {,         if ( this.apiMethods == null ),         {,             this.apiMethods = new java.util.Properties();,         }, ,         return this.apiMethods;,     } //-- java.util.Properties getApiMethods(), ,     /**,      * Get a preferred alternative to this expression, in the case,      * where it's banned from use.,      * ,      * @return String,      */,     public String getBan(),     {,         return this.ban;,     } //-- String getBan(), ,     /**,      * Method getCliOptions.,      * ,      * @return Properties,      */,     public java.util.Properties getCliOptions(),     {,         if ( this.cliOptions == null ),         {,             this.cliOptions = new java.util.Properties();,         }, ,         return this.cliOptions;,     } //-- java.util.Properties getCliOptions(), ,     /**,      * Get the place and syntax used to change the value of this,      * expression.,      * ,      * @return String,      */,     public String getConfiguration(),     {,         return this.configuration;,     } //-- String getConfiguration(), ,     /**,      * Get a preferred alternative to this expression, in the case,      * where it's deprecated.,      * ,      * @return String,      */,     public String getDeprecation(),     {,         return this.deprecation;,     } //-- String getDeprecation(), ,     /**,      * Get the description of what this expression references, and,      * what it's generally used for.,      * ,      * @return String,      */,     public String getDescription(),     {,         return this.description;,     } //-- String getDescription(), ,     /**,      * Get the syntax of the expression.,      * ,      * @return String,      */,     public String getSyntax(),     {,         return this.syntax;,     } //-- String getSyntax(), ,     /**,      * Get whether the value of this expression can be changed.,      * ,      * @return boolean,      */,     public boolean isEditable(),     {,         return this.editable;,     } //-- boolean isEditable(), ,     /**,      * Set the programmatic methods used to change the value of,      * this expression.,      * ,      * @param apiMethods,      */,     public void setApiMethods( java.util.Properties apiMethods ),     {,         this.apiMethods = apiMethods;,     } //-- void setApiMethods( java.util.Properties ), ,     /**,      * Set a preferred alternative to this expression, in the case,      * where it's banned from use.,      * ,      * @param ban,      */,     public void setBan( String ban ),     {,         this.ban = ban;,     } //-- void setBan( String ), ,     /**,      * Set the command-line switches used to change the value of,      * this expression.,      * ,      * @param cliOptions,      */,     public void setCliOptions( java.util.Properties cliOptions ),     {,         this.cliOptions = cliOptions;,     } //-- void setCliOptions( java.util.Properties ), ,     /**,      * Set the place and syntax used to change the value of this,      * expression.,      * ,      * @param configuration,      */,     public void setConfiguration( String configuration ),     {,         this.configuration = configuration;,     } //-- void setConfiguration( String ), ,     /**,      * Set a preferred alternative to this expression, in the case,      * where it's deprecated.,      * ,      * @param deprecation,      */,     public void setDeprecation( String deprecation ),     {,         this.deprecation = deprecation;,     } //-- void setDeprecation( String ), ,     /**,      * Set the description of what this expression references, and,      * what it's generally used for.,      * ,      * @param description,      */,     public void setDescription( String description ),     {,         this.description = description;,     } //-- void setDescription( String ), ,     /**,      * Set whether the value of this expression can be changed.,      * ,      * @param editable,      */,     public void setEditable( boolean editable ),     {,         this.editable = editable;,     } //-- void setEditable( boolean ), ,     /**,      * Set the syntax of the expression.,      * ,      * @param syntax,      */,     public void setSyntax( String syntax ),     {,         this.syntax = syntax;,     } //-- void setSyntax( String )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/usability/plugin/ExpressionDocumentation.java,getExpressions,114-114,[            if ( expressions != null && !expressions.isEmpty() )],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/maven/usability/plugin/ExpressionDocumentation.java,,14-131,[public class ExpressionDocumentation,     implements java.io.Serializable, {, ,       //--------------------------/,      //- Class/Member Variables -/,     //--------------------------/, ,     /**,      * Field expressions.,      */,     private java.util.List<Expression> expressions;, ,     /**,      * Field modelEncoding.,      */,     private String modelEncoding = "UTF-8";, , ,       //-----------/,      //- Methods -/,     //-----------/, ,     /**,      * Method addExpression.,      * ,      * @param expression,      */,     public void addExpression( Expression expression ),     {,         getExpressions().add( expression );,     } //-- void addExpression( Expression ), ,     /**,      * Method getExpressions.,      * ,      * @return List,      */,     public java.util.List<Expression> getExpressions(),     {,         if ( this.expressions == null ),         {,             this.expressions = new java.util.ArrayList<Expression>();,         }, ,         return this.expressions;,     } //-- java.util.List<Expression> getExpressions(), ,     /**,      * Get the modelEncoding field.,      * ,      * @return String,      */,     public String getModelEncoding(),     {,         return this.modelEncoding;,     } //-- String getModelEncoding(), ,     /**,      * Method removeExpression.,      * ,      * @param expression,      */,     public void removeExpression( Expression expression ),     {,         getExpressions().remove( expression );,     } //-- void removeExpression( Expression ), ,     /**,      * Set the list of plugin parameter expressions described by,      * this,      *             document.,      * ,      * @param expressions,      */,     public void setExpressions( java.util.List<Expression> expressions ),     {,         this.expressions = expressions;,     } //-- void setExpressions( java.util.List ), ,     /**,      * Set the modelEncoding field.,      * ,      * @param modelEncoding,      */,     public void setModelEncoding( String modelEncoding ),     {,         this.modelEncoding = modelEncoding;,     } //-- void setModelEncoding( String ), ,         private java.util.Map expressionsBySyntax;, ,     public java.util.Map getExpressionsBySyntax(),     {,         if ( expressionsBySyntax == null ),         {,             expressionsBySyntax = new java.util.HashMap();, ,             java.util.List expressions = getExpressions();, ,             if ( expressions != null && !expressions.isEmpty() ),             {,                 for ( java.util.Iterator it = expressions.iterator(); it.hasNext(); ),                 {,                     Expression expr = (Expression) it.next();, ,                     expressionsBySyntax.put( expr.getSyntax(), expr );,                 },             },         }, ,         return expressionsBySyntax;,     }, ,     public void flushExpressionsBySyntax(),     {,         expressionsBySyntax = null;,     }],,
MT_CORRECTNESS,LI_LAZY_INIT_UPDATE_STATIC,org/apache/maven/usability/plugin/ExpressionDocumenter.java,load,51-53,[        if ( expressionDocumentation == null ),         {,             expressionDocumentation = new HashMap();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/usability/plugin/ExpressionDocumenter.java,parseExpressionDocumentation,130-130,[        if ( expressions != null && !expressions.isEmpty() )],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,parseExpressionDocumentation,700-700,[            String value = parser.getAttributeValue( i );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getIntegerValue,365-365,[                return Integer.valueOf( s ).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getLongValue,395-395,[                return Long.valueOf( s ).longValue();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getBooleanValue,150-150,[        return getBooleanValue( s, attribute, parser, null );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getDateValue,238-238,[        return getDateValue( s, attribute, null, parser );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getByteValue,190-204,[        if ( s != null ),         {,             try,             {,                 return Byte.valueOf( s ).byteValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a byte", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getCharacterValue,219-223,[        if ( s != null ),         {,             return s.charAt( 0 );,         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getDoubleValue,301-315,[        if ( s != null ),         {,             try,             {,                 return Double.valueOf( s ).doubleValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getFloatValue,331-345,[        if ( s != null ),         {,             try,             {,                 return Float.valueOf( s ).floatValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a floating point number", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getIntegerValue,361-375,[        if ( s != null ),         {,             try,             {,                 return Integer.valueOf( s ).intValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be an integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getLongValue,391-405,[        if ( s != null ),         {,             try,             {,                 return Long.valueOf( s ).longValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a long integer", parser, nfe );,                 },             },         },         return 0;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getRequiredAttributeValue,421-428,[        if ( s == null ),         {,             if ( strict ),             {,                 throw new XmlPullParserException( "Missing required value for attribute '" + attribute + "'", parser, null );,             },         },         return s;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Reader.java,getShortValue,444-458,[        if ( s != null ),         {,             try,             {,                 return Short.valueOf( s ).shortValue();,             },             catch ( NumberFormatException nfe ),             {,                 if ( strict ),                 {,                     throw new XmlPullParserException( "Unable to parse element '" + attribute + "', must be a short integer", parser, nfe );,                 },             },         },         return 0;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Writer.java,writeExpression,119-119,[        if ( ( expression.getApiMethods() != null ) && ( expression.getApiMethods().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Writer.java,writeExpression,105-105,[        if ( ( expression.getCliOptions() != null ) && ( expression.getCliOptions().size() > 0 ) )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/maven/usability/plugin/io/xpp3/ParamdocXpp3Writer.java,writeExpressionDocumentation,163-163,[        if ( ( expressionDocumentation.getExpressions() != null ) && ( expressionDocumentation.getExpressions().size() > 0 ) )],,

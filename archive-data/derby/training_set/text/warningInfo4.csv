BAD_PRACTICE,NM_CONFUSING,java/sql/SQLException.java,getSQLState,137-137,[],,getSqlState,241-241,[        return sqlState_;],,
BAD_PRACTICE,NM_CONFUSING,javax/sql/rowset/BaseRowSet.java,getUrl,69-69,[],,getURL,944-949,[            checkForClosedConnection();,             return getURL_();,         },         catch ( SqlException se ),         {,             throw se.getSQLException();],,
BAD_PRACTICE,NM_CONFUSING,javax/sql/rowset/BaseRowSet.java,getUsername,70-70,[],,getUserName,954-955,[        checkForClosedConnection();,         return connection_.user_;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/catalog/GetProcedureColumns.java,<init>,138-138,[			procedure = (RoutineAliasInfo) aliasInfo;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/catalog/GetProcedureColumns.java,,136-136,[			isProcedure = aliasType.equals("P");],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/catalog/SystemProcedures.java,SYSCS_SET_XPLAIN_SCHEMA,2015-2015,[        TransactionController     tc        = lcc.getTransactionExecute();],,
BAD_PRACTICE,DMI_RANDOM_USED_ONLY_ONCE,org/apache/derby/catalog/SystemProcedures.java,RAND,1829-1829,[		return (new Random(seed)).nextDouble();],,
I18N,DM_CONVERT_CASE,org/apache/derby/catalog/SystemProcedures.java,isForODBC,668-668,[		return ((optionValue != null) && optionValue.toUpperCase().equals(ODBC_DRIVER_OPTION));],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/catalog/SystemProcedures.java,SYSCS_GET_USER_ACCESS,1916-1916,[                throw StandardException.newException(SQLState.AUTH_INVALID_USER_NAME,],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/catalog/SystemProcedures.java,SYSCS_SET_USER_ACCESS,1847-1847,[                 throw StandardException.newException(SQLState.AUTH_INVALID_USER_NAME,],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/catalog/SystemProcedures.java,SYSCS_BULK_INSERT,1757-1757,[		PreparedStatement ps = conn.prepareStatement(binsertSql);],,SYSCS_BULK_INSERT,1758-1758,[		ps.executeUpdate();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/catalog/SystemProcedures.java,SYSCS_COMPRESS_TABLE,897-897,[        PreparedStatement ps = conn.prepareStatement(query.toString());],,SYSCS_COMPRESS_TABLE,898-898,[		ps.executeUpdate();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/catalog/SystemProcedures.java,SYSCS_DROP_STATISTICS,817-817,[        PreparedStatement ps = conn.prepareStatement(query.toString());],,SYSCS_DROP_STATISTICS,818-818,[        ps.executeUpdate();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/catalog/SystemProcedures.java,SYSCS_INPLACE_COMPRESS_TABLE,1260-1260,[        PreparedStatement ps = conn.prepareStatement(query);],,SYSCS_INPLACE_COMPRESS_TABLE,1261-1261,[		ps.executeUpdate();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/catalog/SystemProcedures.java,SYSCS_UPDATE_STATISTICS,765-765,[        PreparedStatement ps = conn.prepareStatement(query.toString());],,SYSCS_UPDATE_STATISTICS,766-766,[        ps.executeUpdate();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/catalog/SystemProcedures.java,createXplainSchema,2068-2068,[            Statement s = conn.createStatement();],,createXplainSchema,2069-2069,[            s.executeUpdate("CREATE SCHEMA " + escapedSchema);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/catalog/SystemProcedures.java,createXplainTable,2090-2090,[            Statement s = conn.createStatement();],,createXplainTable,2091-2091,[            for (int i = 0; i < ddl.length; i++)],,createXplainTable,2092-2092,[                s.executeUpdate(ddl[i]);],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/catalog/SystemProcedures.java,SYSCS_BULK_INSERT,1757-1757,[		PreparedStatement ps = conn.prepareStatement(binsertSql);],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/catalog/SystemProcedures.java,SYSCS_COMPRESS_TABLE,897-897,[        PreparedStatement ps = conn.prepareStatement(query.toString());],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/catalog/SystemProcedures.java,SYSCS_DROP_STATISTICS,817-817,[        PreparedStatement ps = conn.prepareStatement(query.toString());],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/catalog/SystemProcedures.java,SYSCS_INPLACE_COMPRESS_TABLE,1260-1260,[        PreparedStatement ps = conn.prepareStatement(query);],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/catalog/SystemProcedures.java,SYSCS_UPDATE_STATISTICS,765-765,[        PreparedStatement ps = conn.prepareStatement(query.toString());],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/catalog/SystemProcedures.java,createXplainSchema,2068-2068,[            Statement s = conn.createStatement();],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/catalog/SystemProcedures.java,createXplainTable,2090-2090,[            Statement s = conn.createStatement();],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/catalog/SystemProcedures.java,createXplainSchema,2069-2069,[            s.executeUpdate("CREATE SCHEMA " + escapedSchema);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/catalog/SystemProcedures.java,createXplainTable,2092-2092,[                s.executeUpdate(ddl[i]);],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/catalog/SystemProcedures.java,SYSCS_BULK_INSERT,1757-1757,[		PreparedStatement ps = conn.prepareStatement(binsertSql);],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/catalog/SystemProcedures.java,SYSCS_COMPRESS_TABLE,897-897,[        PreparedStatement ps = conn.prepareStatement(query.toString());],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/catalog/SystemProcedures.java,SYSCS_DROP_STATISTICS,817-817,[        PreparedStatement ps = conn.prepareStatement(query.toString());],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/catalog/SystemProcedures.java,SYSCS_INPLACE_COMPRESS_TABLE,1260-1260,[        PreparedStatement ps = conn.prepareStatement(query);],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/catalog/SystemProcedures.java,SYSCS_UPDATE_STATISTICS,765-765,[        PreparedStatement ps = conn.prepareStatement(query.toString());],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/catalog/SystemProcedures.java,createXplainTable,2096-2096,[        conn.prepareStatement(ins).close();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/catalog/types/AggregateAliasInfo.java,readExternal,129-129,[        int oldVersion = in.readInt();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/catalog/types/BaseTypeIdImpl.java,toParsableString,171-188,[        switch (getTypeFormatId()),         {,           case StoredFormatIds.BIT_TYPE_ID_IMPL:,           case StoredFormatIds.VARBIT_TYPE_ID_IMPL:, 			  int rparen = retval.indexOf(')');, 			  String lead = retval.substring(0, rparen);, 			  retval = lead + td.getMaximumWidth() + retval.substring(rparen);, 			  break;, ,           case StoredFormatIds.CHAR_TYPE_ID_IMPL:,           case StoredFormatIds.VARCHAR_TYPE_ID_IMPL:,           case StoredFormatIds.BLOB_TYPE_ID_IMPL:,           case StoredFormatIds.CLOB_TYPE_ID_IMPL:,                 retval += "(" + td.getMaximumWidth() + ")";,                 break;, ,           case StoredFormatIds.DECIMAL_TYPE_ID_IMPL:,                 retval += "(" + td.getPrecision() + "," + td.getScale() + ")";],,
BAD_PRACTICE,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,org/apache/derby/catalog/types/OldRoutineType.java,,44-72,[final class OldRoutineType implements Formatable {,     ,     private TypeDescriptor catalogType;, ,     public void readExternal(ObjectInput in) throws IOException,,             ClassNotFoundException {,         ,         // Redundant old TypeId object, just ignore,,         // comprised of two parts the old wrapper format number,         // and then a BaseTypeId. Information was duplicated,         // in the catalog type.,         FormatIdUtil.readFormatIdInteger(in);,         in.readObject(); ,         catalogType = (TypeDescriptor) in.readObject();,     }, ,     public void writeExternal(ObjectOutput out) throws IOException {,         if (SanityManager.DEBUG),         {,             SanityManager.THROWASSERT("OldRoutineType must be read only!");,         },     }, ,     public int getTypeFormatId() {,         return StoredFormatIds.DATA_TYPE_IMPL_DESCRIPTOR_V01_ID;,     }, ,     TypeDescriptor getCatalogType() {,         return catalogType;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/catalog/types/RoutineAliasInfo.java,toString,428-432,[		switch( parameterStyle ), 		{, 		    case PS_JAVA:    sb.append( "JAVA " ); break;, 		    case PS_DERBY_JDBC_RESULT_SET:    sb.append( "DERBY_JDBC_RESULT_SET " ); break;, 		    case PS_DERBY:    sb.append( "DERBY " ); break;],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/derby/catalog/types/RowMultiSetImpl.java,<init>,99-99,[            throw new IllegalArgumentException( "Bad args: columnNames = " + columnNames + ". types = " + types );],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/derby/catalog/types/RowMultiSetImpl.java,<init>,99-99,[            throw new IllegalArgumentException( "Bad args: columnNames = " + columnNames + ". types = " + types );],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/derby/catalog/types/BaseTypeIdImpl.java,equals,218-224,[        if (that instanceof BaseTypeIdImpl),         {,             return this.getSQLTypeName().equals(((BaseTypeIdImpl)that).getSQLTypeName());,         },         else,         {,             return false;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/derby/catalog/types/TypeDescriptorImpl.java,equals,472-472,[		TypeDescriptor typeDescriptor = (TypeDescriptor)object;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/catalog/types/TypeDescriptorImpl.java,getRowColumnNames,597-597,[        return ((RowMultiSetImpl) typeId).getColumnNames();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/catalog/types/TypeDescriptorImpl.java,getRowTypes,604-604,[        return ((RowMultiSetImpl) typeId).getTypes();],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/derby/catalog/types/TypeDescriptorImpl.java,equals,472-496,[		TypeDescriptor typeDescriptor = (TypeDescriptor)object;, , 		if(!this.getTypeName().equals(typeDescriptor.getTypeName()) ||, 		   this.precision != typeDescriptor.getPrecision() ||, 		   this.scale != typeDescriptor.getScale() ||, 		   this.isNullable != typeDescriptor.isNullable() ||, 		   this.maximumWidth != typeDescriptor.getMaximumWidth()), 		   return false;, 	    else, 	    {, 			switch (typeId.getJDBCTypeId()) {, 			case Types.CHAR:, 			case Types.VARCHAR:, 			case Types.LONGVARCHAR:, 			case Types.CLOB:, 				//if we are dealing with character types, then we should , 				//also compare the collation information on them., 				if(this.collationType != typeDescriptor.getCollationType()), 					return false;, 				else, 					return true;, 			default:, 				//no collation checking required if we are dealing with , 				//non-char datatypes., 				return true;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/derby/catalog/types/TypeDescriptorImpl.java,equals,472-496,[		TypeDescriptor typeDescriptor = (TypeDescriptor)object;, , 		if(!this.getTypeName().equals(typeDescriptor.getTypeName()) ||, 		   this.precision != typeDescriptor.getPrecision() ||, 		   this.scale != typeDescriptor.getScale() ||, 		   this.isNullable != typeDescriptor.isNullable() ||, 		   this.maximumWidth != typeDescriptor.getMaximumWidth()), 		   return false;, 	    else, 	    {, 			switch (typeId.getJDBCTypeId()) {, 			case Types.CHAR:, 			case Types.VARCHAR:, 			case Types.LONGVARCHAR:, 			case Types.CLOB:, 				//if we are dealing with character types, then we should , 				//also compare the collation information on them., 				if(this.collationType != typeDescriptor.getCollationType()), 					return false;, 				else, 					return true;, 			default:, 				//no collation checking required if we are dealing with , 				//non-char datatypes., 				return true;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/catalog/types/TypeDescriptorImpl.java,getRowColumnNames,595-595,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/catalog/types/TypeDescriptorImpl.java,getRowTypes,602-602,[            return null;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/catalog/types/UDTAliasInfo.java,readExternal,90-90,[        int oldVersion = in.readInt();],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/catalog/types/UserDefinedTypeIdImpl.java,<init>,96-96,[            className = null;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/derby/catalog/types/BaseTypeIdImpl.java,equals,218-224,[        if (that instanceof BaseTypeIdImpl),         {,             return this.getSQLTypeName().equals(((BaseTypeIdImpl)that).getSQLTypeName());,         },         else,         {,             return false;],,
STYLE,DB_DUPLICATE_BRANCHES,org/apache/derby/client/ClientPooledConnection.java,<init>,168-168,[            this.statementCache = null;],,<init>,171-171,[            this.statementCache = null;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/client/ClientXAConnection.java,,47-47,[    private NetXAConnection controlCon_ = null;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/client/ClientXid.java,setFormatID,163-164,[        formatID_ = formatID;,     }],,setFormatId,59-60,[		this.fmtId = fmtId;, 	}],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/client/am/BlobLocatorOutputStream.java,,66-66,[        this.connection = connection;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/client/am/ByteArrayCombinerStream.java,nextArray,203-203,[            return null;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/client/am/ClientBlob.java,<init>,53-53,[        binaryString_ = binaryString;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/am/ClientCallableStatement.java,getArray,694-694,[                    singletonRowData_.getArray(parameterIndex);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/am/ClientCallableStatement.java,getRef,723-723,[                    singletonRowData_.getRef(parameterIndex);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/client/am/ClientCallableStatement.java,,58-1502,[    public MaterialPreparedStatement materialCallableStatement_ = null;, ,     //-----------------------------state------------------------------------------, ,     // last retrieved result was a sql NULL, NOT_NULL, or UNSET.,     private int wasNull_ = WAS_NULL_UNSET;,     static final private int WAS_NULL = 1;,     static final private int WAS_NOT_NULL = 2;,     static final private int WAS_NULL_UNSET = 0;, ,     //---------------------constructors/finalizer---------------------------------, ,     private void initCallableStatement() {,         materialCallableStatement_ = null;,         wasNull_ = WAS_NULL_UNSET;,     }, ,     public void reset(boolean fullReset) throws SqlException {,         if (fullReset) {,             connection_.resetPrepareCall(this);,         } else {,             super.reset(fullReset);,         },         wasNull_ = WAS_NULL_UNSET;,     }, ,     /**,      * Common constructor for jdbc 2 callable statements with scroll attributes.,      * Called by material statement constructor.,      *,      * @param agent       The instance of NetAgent associated with this,      *                    CallableStatement object.,      * @param connection  The connection object associated with this,      *                    PreparedStatement Object.,      * @param sql         A String object that is the SQL statement to be sent ,      *                    to the database.,      * @param type        One of the ResultSet type constants,      * @param concurrency One of the ResultSet concurrency constants,      * @param holdability One of the ResultSet holdability constants,      * @param cpc         The PooledConnection object that will be used to ,      *                    notify the PooledConnection reference of the Error ,      *                    Occurred and the Close events.,      * @throws SqlException,      */,     public ClientCallableStatement(Agent agent,,                              ClientConnection connection,,                              String sql,,                              int type, int concurrency, int holdability,,                              ClientPooledConnection cpc) throws SqlException {,         super(agent,,               connection,,               sql,,               type,,               concurrency,,               holdability,,               ClientStatement.NO_GENERATED_KEYS,,               null,,               null,,               cpc);,         initCallableStatement();,     }, ,     public void resetCallableStatement(Agent agent,,                                        ClientConnection connection,,                                        String sql,,                                        int type, int concurrency, int holdability) throws SqlException {,         super.resetPreparedStatement(,             agent,,             connection,,             sql,,             type,,             concurrency,,             holdability,,             ClientStatement.NO_GENERATED_KEYS,,             null,,             null);,         initCallableStatement();,     }, ,     protected void finalize() throws Throwable {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "finalize");,         },         super.finalize();,     }, ,     //---------------------------entry points-------------------------------------, ,     public void clearParameters() throws SQLException {,         synchronized (connection_) {,             if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceEntry(this, "clearParameters");,             },             super.clearParameters();,             outputRegistered_ = false; // this variable is only used by Batch,         },     }, ,     public void registerOutParameter(int parameterIndex, int jdbcType) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType);,                 },                 registerOutParameterX(parameterIndex, jdbcType);,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     // also used by Sqlca,     void registerOutParameterX(int parameterIndex, int jdbcType) throws SqlException {,         super.checkForClosedStatement();,         int scale = 0; // default scale to 0 for non numeric and non decimal type,         registerOutParameterX(parameterIndex, jdbcType, scale);,     }, ,     public void registerOutParameter(int parameterIndex, int jdbcType, int scale) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType, scale);,                 },                 super.checkForClosedStatement();,                 registerOutParameterX(parameterIndex, jdbcType, scale);,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     private void registerOutParameterX(int parameterIndex, int jdbcType, int scale) throws SqlException {,         super.checkForValidParameterIndex(parameterIndex);,         agent_.checkForSupportedDataType( jdbcType );,         checkForValidScale(scale);,         outputRegistered_ = true; // this variable is only used by Batch,         //parameterSetOrRegistered_[parameterIndex - 1] = true;,         parameterRegistered_[parameterIndex - 1] = true;,     }, ,     /** Derby ignores the typeName argument because UDTs don't need it */,     public void registerOutParameter(int parameterIndex, int jdbcType, String typeName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType, typeName);,         },         registerOutParameter( parameterIndex, jdbcType );,     }, ,     public boolean wasNull() throws SQLException {,         try,         {,             if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceEntry(this, "wasNull");,             },             boolean result = wasNullX();,             if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceExit(this, "wasNull", result);,             },             return result;,         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     private boolean wasNullX() throws SqlException {,         super.checkForClosedStatement();,         if (wasNull_ == WAS_NULL_UNSET) {,             throw new SqlException(agent_.logWriter_, ,                 new ClientMessageId(SQLState.WASNULL_INVALID));,         },         return wasNull_ == WAS_NULL;,     }, ,     //--------------------------------getter methods------------------------------, ,     public boolean getBoolean(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getBoolean", parameterIndex);,                 },                 super.checkForClosedStatement();,                 boolean result;,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 result = wasNullX() ? false : singletonRowData_.getBoolean(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getBoolean", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public byte getByte(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getByte", parameterIndex);,                 },                 super.checkForClosedStatement();,                 byte result;,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 result = wasNullX() ? 0 : singletonRowData_.getByte(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getByte", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public short getShort(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getShort", parameterIndex);,                 },                 super.checkForClosedStatement();,                 short result;,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 result = wasNullX() ? 0 : singletonRowData_.getShort(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getShort", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public int getInt(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getInt", parameterIndex);,                 },                 int result = getIntX(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getInt", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     // also used by SQLCA,     int getIntX(int parameterIndex) throws SqlException {,         super.checkForClosedStatement();,         checkGetterPreconditions(parameterIndex);,         setWasNull(parameterIndex);,         return wasNullX() ? 0 : singletonRowData_.getInt(parameterIndex);,     }, ,     public long getLong(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getLong", parameterIndex);,                 },                 long result = getLongX(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getLong", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     long getLongX(int parameterIndex) throws SqlException {,         super.checkForClosedStatement();,         checkGetterPreconditions(parameterIndex);,         setWasNull(parameterIndex);,         return wasNullX() ? 0 : singletonRowData_.getLong(parameterIndex);,     }, ,     public float getFloat(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getFloat", parameterIndex);,                 },                 super.checkForClosedStatement();,                 float result;,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 result = wasNullX() ? 0 : singletonRowData_.getFloat(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getFloat", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public double getDouble(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getDouble", parameterIndex);,                 },                 super.checkForClosedStatement();,                 double result;,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 result = wasNullX() ? 0 : singletonRowData_.getDouble(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getDouble", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     /** @deprecated */,     public BigDecimal getBigDecimal(int parameterIndex, int scale),             throws SQLException, ArithmeticException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceDeprecatedEntry(this, "getBigDecimal", parameterIndex, scale);,                 },                 super.checkForClosedStatement();,                 checkForValidScale(scale);,                 BigDecimal result;,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 result = wasNullX() ? null : singletonRowData_.getBigDecimal(parameterIndex);,                 if (result != null) {,                     result = result.setScale(scale, BigDecimal.ROUND_DOWN);,                 },                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceDeprecatedExit(this, "getBigDecimal", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getBigDecimal", parameterIndex);,                 },                 super.checkForClosedStatement();,                 BigDecimal result;,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 result = wasNullX() ? null : singletonRowData_.getBigDecimal(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getBigDecimal", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public Date getDate(int parameterIndex, Calendar cal) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(,                             this, "getDate", parameterIndex, cal);,                 },                 super.checkForClosedStatement();,                 checkGetterPreconditions(parameterIndex);, ,                 if (cal == null) {,                     throw new SqlException(agent_.logWriter_,,                         new ClientMessageId(SQLState.CALENDAR_IS_NULL));,                 }, ,                 setWasNull(parameterIndex);,                 Date result = wasNullX() ?,                         null :,                         singletonRowData_.getDate(parameterIndex, cal);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getDate", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public Date getDate(int parameterIndex) throws SQLException {,         return getDate(parameterIndex, Calendar.getInstance());,     }, ,     public Time getTime(int parameterIndex, Calendar cal) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(,                             this, "getTime", parameterIndex, cal);,                 },                 super.checkForClosedStatement();,                 checkGetterPreconditions(parameterIndex);, ,                 if (cal == null) {,                     throw new SqlException(agent_.logWriter_,,                         new ClientMessageId(SQLState.CALENDAR_IS_NULL));,                 }, ,                 setWasNull(parameterIndex);,                 Time result = wasNullX() ?,                         null :,                         singletonRowData_.getTime(parameterIndex, cal);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getTime", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public Time getTime(int parameterIndex) throws SQLException {,         return getTime(parameterIndex, Calendar.getInstance());,     }, ,     public Timestamp getTimestamp(int parameterIndex, Calendar cal),             throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(,                             this, "getTimestamp", parameterIndex, cal);,                 },                 super.checkForClosedStatement();,                 checkGetterPreconditions(parameterIndex);, ,                 if (cal == null) {,                     throw new SqlException(agent_.logWriter_,,                         new ClientMessageId(SQLState.CALENDAR_IS_NULL));,                 }, ,                 setWasNull(parameterIndex);,                 Timestamp result = wasNullX() ?,                         null :,                         singletonRowData_.getTimestamp(parameterIndex, cal);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getTimestamp", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public Timestamp getTimestamp(int parameterIndex) throws SQLException {,         return getTimestamp(parameterIndex, Calendar.getInstance());,     }, ,     public String getString(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getString", parameterIndex);,                 },                 String result = getStringX(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getString", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     // also used by SQLCA,     String getStringX(int parameterIndex) throws SqlException {,         super.checkForClosedStatement();,         checkGetterPreconditions(parameterIndex);,         setWasNull(parameterIndex);,         return wasNullX() ? null : singletonRowData_.getString(parameterIndex);,     }, ,     public byte[] getBytes(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getBytes", parameterIndex);,                 },                 byte[] result = getBytesX(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getBytes", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     byte[] getBytesX(final int parameterIndex) throws SqlException ,     {,         super.checkForClosedStatement();,         checkGetterPreconditions(parameterIndex);,         setWasNull(parameterIndex);,         return  wasNullX() ? null : singletonRowData_.getBytes(parameterIndex);,      }, ,     public Blob getBlob(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getBlob", parameterIndex);,                 },                 super.checkForClosedStatement();,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 Blob result = wasNullX() ? null :,                     singletonRowData_.getBlob(parameterIndex);, ,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getBlob", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public Clob getClob(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 super.checkForClosedStatement();,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 Clob result = wasNullX() ? null :,                     singletonRowData_.getClob(parameterIndex);, ,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getClob", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public Array getArray(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getArray", parameterIndex);,                 },                 super.checkForClosedStatement();,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 Array result = wasNullX() ? null :,                     singletonRowData_.getArray(parameterIndex);, ,                 if (true) {,                     throw new SqlException(agent_.logWriter_, ,                         new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));,                 },                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getArray", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public Ref getRef(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getRef", parameterIndex);,                 },                 super.checkForClosedStatement();,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 Ref result = wasNullX() ? null :,                     singletonRowData_.getRef(parameterIndex);, ,                 if (true) {,                     throw new SqlException(agent_.logWriter_, ,                         new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));,                 },                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getRef", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public Object getObject(int parameterIndex) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getObject", parameterIndex);,                 },                 super.checkForClosedStatement();,                 Object result;,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 result = wasNullX() ? null : singletonRowData_.getObject(parameterIndex);,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getObject", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     public Object getObject(int parameterIndex, Map map) throws SQLException {,         try,         {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getObject", parameterIndex, map);,                 },                 super.checkForClosedStatement();,                 Object result;,                 checkGetterPreconditions(parameterIndex);,                 if (true) {,                     throw new SqlException(agent_.logWriter_, ,                         new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));,                 },                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getObject", result);,                 },                 return result;,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }, ,     //--------------------------JDBC 3.0------------------------------------------, ,     public void registerOutParameter(String parameterName, int sqlType) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterName, sqlType);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterName, sqlType, scale);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterName, sqlType, typeName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public URL getURL(int parameterIndex) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getURL", parameterIndex);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setURL(String parameterName, URL x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setURL", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setNull(String parameterName, int sqlType) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setNull", parameterName, sqlType);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setBoolean(String parameterName, boolean x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setBoolean", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setByte(String parameterName, byte x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setByte", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setShort(String parameterName, short x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setShort", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setInt(String parameterName, int x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setInt", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setLong(String parameterName, long x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setLong", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setFloat(String parameterName, float x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setFloat", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setDouble(String parameterName, double x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setDouble", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setBigDecimal(String parameterName, BigDecimal x),             throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setBigDecimal", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setString(String parameterName, String x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setString", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setBytes(String parameterName, byte x[]) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setBytes", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setDate(String parameterName, Date x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setDate", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setTime(String parameterName, Time x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setTime", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setTimestamp(String parameterName, Timestamp x),             throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setTimestamp", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setAsciiStream(String parameterName, InputStream x, int length),             throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setAsciiStream", parameterName, x, length);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setBinaryStream(String parameterName, InputStream x, int length),             throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setBinaryStream", parameterName, x, length);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setObject", parameterName, x, targetSqlType, scale);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setObject", parameterName, x, targetSqlType);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setObject(String parameterName, Object x) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setObject", parameterName, x);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setCharacterStream(String parameterName,,                                    Reader reader,,                                    int length) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setCharacterStream", parameterName, reader, length);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setDate(String parameterName, Date x, Calendar calendar),             throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setDate", parameterName, x, calendar);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setTime(String parameterName, Time x, Calendar calendar),             throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setTime", parameterName, x, calendar);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setTimestamp(String parameterName,,                              Timestamp x,,                              Calendar calendar) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setTimestamp", parameterName, x, calendar);,         },         throw jdbcMethodNotImplemented();,     }, ,     public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setNull", parameterName, sqlType, typeName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public String getString(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getString", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public boolean getBoolean(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getBoolean", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public byte getByte(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getByte", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public short getShort(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getShort", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public int getInt(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getInt", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public long getLong(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getLong", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public float getFloat(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getFloat", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public double getDouble(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getDouble", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public byte[] getBytes(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getBytes", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Date getDate(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getDate", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Time getTime(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getTime", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Timestamp getTimestamp(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getTimestamp", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Object getObject(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getObject", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public BigDecimal getBigDecimal(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getBigDecimal", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Object getObject(String parameterName, Map map) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getObject", parameterName, map);,             },         throw jdbcMethodNotImplemented();,     }, ,     public Ref getRef(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getRef", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Blob getBlob(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getBlob", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Clob getClob(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getClob", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Array getArray(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getArray", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Date getDate(String parameterName, Calendar calendar),             throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getDate", parameterName, calendar);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Time getTime(String parameterName, Calendar calendar),             throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getTime", parameterName, calendar);,         },         throw jdbcMethodNotImplemented();,     }, ,     public Timestamp getTimestamp(String parameterName, Calendar calendar),             throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getTimestamp", parameterName, calendar);,         },         throw jdbcMethodNotImplemented();,     }, ,     public URL getURL(String parameterName) throws SQLException {,         if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getURL", parameterName);,         },         throw jdbcMethodNotImplemented();,     }, ,     //-------------------------- JDBC 4.0 methods --------------------------------,     ,     public Reader getCharacterStream(int parameterIndex),         throws SQLException {,         try {,             synchronized (connection_) {,                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceEntry(this, "getCharacterStream", parameterIndex);,                 },                 super.checkForClosedStatement();,                 checkGetterPreconditions(parameterIndex);,                 setWasNull(parameterIndex);,                 Reader reader = null;,                 if (this.wasNull_ == WAS_NOT_NULL) {,                     reader = singletonRowData_.getCharacterStream(parameterIndex);,                 },                 if (agent_.loggingEnabled()) {,                     agent_.logWriter_.traceExit(this, "getCharacterStream", reader);,                 },                 return reader;,             },              ,         } catch (SqlException se) {,             throw se.getSQLException();,         },     }, ,     public final void setAsciiStream(String parameterName, InputStream x, long length),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setAsciiStream(String,InputStream,long)");,     }, ,     public final void setBinaryStream(String parameterName, InputStream x, long length),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setBinaryStream(String,InputStream,long)");,     }, ,     public final void setCharacterStream(String parameterName, Reader x, long length),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setCharacterStream(String,Reader,long)");,     }, ,     public Reader getCharacterStream(String parameterName),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("getCharacterStream(String)");,     }, ,     public Reader getNCharacterStream(int parameterIndex),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("getNCharacterStream(int)");,     }, ,     public Reader getNCharacterStream(String parameterName),             throws SQLException {,         throw SQLExceptionFactory.notImplemented(,                 "getNCharacterStream(String)");,     }, ,     public String getNString(int parameterIndex),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("getNString(int)");,     }, ,     public String getNString(String parameterIndex),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("getNString(String)");,     }, ,     public RowId getRowId(int parameterIndex) throws SQLException {,         throw SQLExceptionFactory.notImplemented("getRowId (int)");,     }, ,     public RowId getRowId(String parameterName) throws SQLException {,         throw SQLExceptionFactory.notImplemented("getRowId (String)");,     }, ,     public void setRowId(String parameterName, RowId x) throws SQLException {,         throw SQLExceptionFactory.notImplemented("setRowId (String, RowId)");,     }, ,     public void setBlob(String parameterName, Blob x),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setBlob(String, Blob)");,     }, ,     public void setClob(String parameterName, Clob x),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setClob(String, Clob)");,     }, ,     public void setNString(String parameterName, String value),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setNString (String, String)");,     }, ,     public void setNCharacterStream(String parameterName, Reader value, long length),             throws SQLException {,         throw SQLExceptionFactory.notImplemented(,                 "setNString (String, Reader, long)");,     }, ,     public void setNClob(String parameterName, NClob value) throws SQLException {,         throw SQLExceptionFactory.notImplemented("setNClob (String, NClob)");,     }, ,     public void setClob(String parameterName, Reader reader, long length),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setClob (String, Reader, long)");,     }, ,     public void setBlob(String parameterName, InputStream inputStream, long length),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setBlob (String, InputStream, long)");,     }, ,     public void setNClob(String parameterName, Reader reader, long length),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setNClob (String, Reader, long)");,     }, ,     public NClob getNClob(int i) throws SQLException {,         throw SQLExceptionFactory.notImplemented("setNClob (int)");,     }, ,     public NClob getNClob(String parameterName) throws SQLException {,         throw SQLExceptionFactory.notImplemented("setNClob (String)");,     }, ,     public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {,         throw SQLExceptionFactory.notImplemented("setSQLXML (String, SQLXML)");,     }, ,     public SQLXML getSQLXML(int parameterIndex) throws SQLException {,         throw SQLExceptionFactory.notImplemented("getSQLXML (int)");,     }, ,     public SQLXML getSQLXML(String parametername) throws SQLException {,         throw SQLExceptionFactory.notImplemented("getSQLXML (String)");,     },     public void setAsciiStream(String parameterName, InputStream x),             throws SQLException {,         throw SQLExceptionFactory.notImplemented(,                 "setAsciiStream(String,InputStream)");,     }, ,     public void setBinaryStream(String parameterName, InputStream x),             throws SQLException {,         throw SQLExceptionFactory.notImplemented(,                 "setBinaryStream(String,InputStream)");,     }, ,     public void setBlob(String parameterName, InputStream inputStream),             throws SQLException {,         throw SQLExceptionFactory.notImplemented(,                 "setBlob(String,InputStream)");,     }, ,     public void setCharacterStream(String parameterName, Reader reader),             throws SQLException {,         throw SQLExceptionFactory.notImplemented(,                 "setCharacterStream(String,Reader)");,     }, ,     public void setClob(String parameterName, Reader reader),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setClob(String,Reader)");,     }, ,     public void setNCharacterStream(String parameterName, Reader value),             throws SQLException {,         throw SQLExceptionFactory.notImplemented(,                 "setNCharacterStream(String,Reader)");,     }, ,     public void setNClob(String parameterName, Reader reader),             throws SQLException {,         throw SQLExceptionFactory.notImplemented("setNClob(String,Reader)");,     }, ,     ////////////////////////////////////////////////////////////////////,     //,     // INTRODUCED BY JDBC 4.1 IN JAVA 7,     //,     ////////////////////////////////////////////////////////////////////, ,     public <T> T getObject( int parameterIndex, Class<T> type ),         throws SQLException,     {,         // checkForClosedStatement() should be called by all of the,         // more specific methods to which we forward this call, ,         if ( type == null ),         {,             throw mismatchException( "NULL", parameterIndex );,         }, ,         Object   retval;, ,         if ( String.class.equals( type ) ) { retval = getString( parameterIndex ); },         else if ( BigDecimal.class.equals( type ) ) { retval = getBigDecimal( parameterIndex ); },         else if ( Boolean.class.equals( type ) ) { retval = Boolean.valueOf( getBoolean(parameterIndex ) ); },         else if ( Byte.class.equals( type ) ) { retval = Byte.valueOf( getByte( parameterIndex ) ); },         else if ( Short.class.equals( type ) ) { retval = Short.valueOf( getShort( parameterIndex ) ); },         else if ( Integer.class.equals( type ) ) { retval = Integer.valueOf( getInt( parameterIndex ) ); },         else if ( Long.class.equals( type ) ) { retval = Long.valueOf( getLong( parameterIndex ) ); },         else if ( Float.class.equals( type ) ) { retval = Float.valueOf( getFloat( parameterIndex ) ); },         else if ( Double.class.equals( type ) ) { retval = Double.valueOf( getDouble( parameterIndex ) ); },         else if ( Date.class.equals( type ) ) { retval = getDate( parameterIndex ); },         else if ( Time.class.equals( type ) ) { retval = getTime( parameterIndex ); },         else if ( Timestamp.class.equals( type ) ) { retval = getTimestamp( parameterIndex ); },         else if ( Blob.class.equals( type ) ) { retval = getBlob( parameterIndex ); },         else if ( Clob.class.equals( type ) ) { retval = getClob( parameterIndex ); },         else if ( type.isArray() && type.getComponentType().equals( byte.class ) ) { retval = getBytes( parameterIndex ); },         else { retval = getObject( parameterIndex ); }, ,         if ( wasNull() ) { retval = null; }, ,         if ( (retval == null) || (type.isInstance( retval )) ) { return type.cast( retval ); }, ,         throw mismatchException( type.getName(), parameterIndex );,     },     private SQLException    mismatchException( String targetTypeName, int parameterIndex ),         throws SQLException,     {,         String sourceTypeName = getParameterMetaData().getParameterTypeName( parameterIndex );,         ClientMessageId cmi = new ClientMessageId( SQLState.LANG_DATA_TYPE_GET_MISMATCH );,         SqlException se = new SqlException( agent_.logWriter_, cmi, targetTypeName, sourceTypeName );, ,         return se.getSQLException();,     }, ,     public <T> T getObject(String parameterName, Class<T> type),         throws SQLException,     {,         throw jdbcMethodNotImplemented();,     }, ,     //----------------------------overrides----------------------------------, ,     public void completeExecuteCall(Sqlca sqlca, Cursor singletonParams) // no result sets returned,     {,         super.completeExecuteCall( sqlca, singletonParams );, ,         //,         // For INOUT parameters, propagate return values back to the input parameter array.,         // See DERBY-2515.,         //, ,         if ( singletonParams == null ) { return ; },         if ( parameterMetaData_ == null ) { return; }, ,         int     cursorParamCount = singletonParams.columns_;,         ,         for ( int i = 0; i < cursorParamCount; i++ ),         {,             if ( parameterMetaData_.sqlxParmmode_[ i ] ==,                  ClientParameterMetaData.parameterModeInOut ),             {,                 int jdbcParamNumber = i + 1;,                 Object  returnArg;,                 ,                 try {,                     returnArg = singletonParams.isNull_[ i ] ? null : singletonParams.getObject( jdbcParamNumber );,                 } catch (SqlException se),                 {,                     IllegalArgumentException iae = new IllegalArgumentException( se.getMessage() );,                     iae.initCause( se );,                     throw iae;,                 },                 ,                 //,                 // special case to coerce Integer to Short for SMALLINT,                 //,                 if ( parameterMetaData_.types_[ i ] == ClientTypes.SMALLINT ),                 {,                     if (returnArg instanceof Integer),                     {,                         returnArg = ((Integer) returnArg).shortValue();,                     },                 },                 ,                 setInput( jdbcParamNumber, returnArg );,             }   // end if INOUT arg,         }       // end loop through args,     }, ,     ,     //----------------------------helper methods----------------------------------, ,     /**,      * Returns the name of the java.sql interface implemented by this class.,      * @return name of java.sql interface,      */,     protected String getJdbcStatementInterfaceName() {,         return "java.sql.CallableStatement";,     }, ,     private void checkGetterPreconditions(int parameterIndex) throws SqlException {,         super.checkForValidParameterIndex(parameterIndex);,         checkForValidOutParameter(parameterIndex);,     }, ,     private void checkForValidOutParameter(int parameterIndex) throws SqlException {,         if (parameterMetaData_ == null ||,             parameterMetaData_.sqlxParmmode_[parameterIndex - 1] <,                 ClientParameterMetaData.parameterModeInOut) {, ,             throw new SqlException(agent_.logWriter_, ,                 new ClientMessageId(SQLState.PARAM_NOT_OUT_OR_INOUT), ,                 parameterIndex);,         },     }, ,     private void setWasNull(int parameterIndex) {,         if (singletonRowData_ == null) {,             wasNull_ = WAS_NULL_UNSET;,         } else {,             wasNull_ = singletonRowData_.isNull_[parameterIndex - 1] ? WAS_NULL : WAS_NOT_NULL;,         },     },     ,     SQLException jdbcMethodNotImplemented() throws SQLException,     {,         try,         {,             super.checkForClosedStatement();,         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },         return new SqlException(agent_.logWriter_, ,             new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED)).getSQLException();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/client/am/ClientCallableStatement42.java,setObject,154-154,[                agent_.logWriter_.traceEntry( this, "setObject", new Integer( parameterIndex ), x, sqlType, new Integer( scaleOrLength ) );],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/client/am/ClientClob.java,getUtf8String,960-960,[        return utf8String_;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/client/am/ClientConnection.java,,963-963,[    return !open_ && !availableForReuse_; ],,,816-816,[            availableForReuse_ = false;],,,815-815,[        if (open_ || (!open_ && availableForReuse_)) {],,,2369-2369,[        availableForReuse_ = false;],,,2365-2365,[        if (!open_ && !availableForReuse_) {],,,930-930,[        availableForReuse_ = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/client/am/ClientConnection.java,,2470-2470,[        return xaState_;],,,2474-2474,[        xaState_ = state;],,,2512-2512,[        if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED)],,,1871-1871,[        if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED)],,,1769-1769,[            int saveXaState = xaState_;],,,1823-1823,[                xaState_ = saveXaState;],,,1705-1705,[            int saveXaState = xaState_;],,,1756-1756,[                xaState_ = saveXaState;],,,1577-1577,[            if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED)],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/client/am/ClientConnection.java,setTypeMap,1549-1549,[                throw new SqlException(agent_.logWriter_,],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/client/am/ClientConnection.java,getCurrentSchemaName,1274-1274,[            ResultSet rs = s.executeQuery("VALUES CURRENT SCHEMA");],,getCurrentSchemaName,1275-1275,[            rs.next();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/client/am/ClientConnection.java,getCurrentSchemaName,1273-1273,[            Statement s = createStatement();],,getCurrentSchemaName,1274-1274,[            ResultSet rs = s.executeQuery("VALUES CURRENT SCHEMA");],,getCurrentSchemaName,1275-1275,[            rs.next();],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/client/am/ClientConnection.java,getCurrentSchemaName,1273-1273,[            Statement s = createStatement();],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/derby/client/am/ClientConnection.java,closeResources,815-815,[        if (open_ || (!open_ && availableForReuse_)) {],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/client/am/ClientConnection.java,closeResources,815-815,[        if (open_ || (!open_ && availableForReuse_)) {],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/client/am/ClientConnection.java,getAutoCommit,584-595,[            checkForClosedConnection();,             if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceExit(this, "getAutoCommit", autoCommit_);,             },             if (! allowLocalCommitRollback_()) { // autoCommit is always false between xars.start() and xars.end(),                 return false;,             },             return autoCommit_;,         },         catch ( SqlException se ),         {,             throw se.getSQLException();],,setAutoCommit,555-579,[            if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceEntry(this, "setAutoCommit", autoCommit);,             },             checkForClosedConnection();, ,             if (! allowLocalCommitRollback_()) {,                 if (autoCommit) { // can't toggle to autocommit mode when between xars.start() and xars.end(),                     throw new SqlException(agent_.logWriter_,,                             new ClientMessageId (SQLState.DRDA_NO_AUTOCOMMIT_UNDER_XA));                            ,                 },             } else {,                 if (autoCommit == autoCommit_) {,                     return; // don't flow a commit if nothing changed.,                 },                 if (inUnitOfWork_) {,                     flowCommit(); // we are not between xars.start() and xars.end(), can flow commit,                 },             },             autoCommit_ = autoCommit;,         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/client/am/ClientConnection.java,getCatalog,1410-1418,[            checkForClosedConnection();,             if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceExit(this, "getCatalog", (String) null);,             },             return null;,         },         catch ( SqlException se ),         {,             throw se.getSQLException();],,setCatalog,1395-1405,[            if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceEntry(this, "setCatalog", catalog);,             },             checkForClosedConnection();,             // Per jdbc spec: if the driver does not support catalogs, it will silently ignore this request.,         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/client/am/ClientConnection.java,getHoldability,1595-1603,[            checkForClosedConnection();,             if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceExit(this, "getHoldability", holdability());,             },             return holdability();,         },         catch ( SqlException se ),         {,             throw se.getSQLException();],,setHoldability,1570-1590,[            if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceEntry(this, "setHoldability", holdability);,             },             checkForClosedConnection();,             // In an XA global transaction do not allow the,             // holdability to be set to hold cursors across,             // commits, as the engine does not support it.,             if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED),             {,                 if (holdability == ResultSet.HOLD_CURSORS_OVER_COMMIT),                     throw new SqlException(agent_.logWriter_, ,                             new ClientMessageId(SQLState.CANNOT_HOLD_CURSOR_XA));,             },             this.holdability = holdability;,             ,        },         catch ( SqlException se ),         {,             throw se.getSQLException();,         },     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/client/am/ClientConnection.java,getTransactionIsolation,1112-1120,[        if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "getTransactionIsolation", isolation_);,         },         try {,             // Per jdbc spec (see Connection.close() javadoc).,             checkForClosedConnection();,             return getTransactionIsolationX();,         } catch (SqlException se) {,             throw se.getSQLException();],,setTransactionIsolation,985-1010,[        if (agent_.loggingEnabled()) {,             agent_.logWriter_.traceEntry(this, "setTransactionIsolation", level);,         },         //This avoids assertion like DERBY-4343 by short-circuiting,         //setTransactionIsolation. Before this check, for case as users,         //obtaining the pooled connection for the third time, the variable,         //isolation_ is reset Connection.completeReset. ,         //Isolation_ remain as UNKNOWN until getTransactionIsolation is called,         //or a different statement causing a change of the isolation level,         //is executed.We might think about change the default value for Isolation_,         //to DERBY_TRANSACTION_READ_COMMITTED. With introducing ,         //getTransactionIsolationX and this check, assertion is never reach. ,         //As part of DERBY-4314 fix, the client driver should act as embedded ,         //and return here, otherwise setTransactionIsolation will commit ,         //the transaction which is not the intention.,         if (level == getTransactionIsolationX()) ,         return;, ,         try {,             // Per jdbc spec (see Connection.close() javadoc).,             checkForClosedConnection();,             setTransactionIsolationX(level);,         } catch (SqlException se) {,             throw se.getSQLException();,         },     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/client/am/ClientConnection.java,getTypeMap,1525-1537,[            if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceEntry(this, "getTypeMap");,             },             checkForClosedConnection();,             Map<String, Class<?>> map = Collections.emptyMap();,             if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceExit(this, "getTypeMap", map);,             },             return map;,         },         catch ( SqlException se ),         {,             throw se.getSQLException();],,setTypeMap,1544-1563,[            if (agent_.loggingEnabled()) {,                 agent_.logWriter_.traceEntry(this, "setTypeMap", map);,             },             checkForClosedConnection();,             if (map == null) {,                 throw new SqlException(agent_.logWriter_,,                         new ClientMessageId (SQLState.INVALID_API_PARAMETER),,                         map, "map", "setTypeMap");,             }, ,             if (!(map.isEmpty())) {,                 throw new SqlException(agent_.logWriter_, new ClientMessageId(,                         SQLState.NOT_IMPLEMENTED), "setTypeMap");,             },         },         catch ( SqlException se ),         {,             throw se.getSQLException();,         }        ,     }],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/client/am/ClientConnection.java,,1382-1382,[                agent_.logWriter_.traceExit(this, "isReadOnly", jdbcReadOnly_);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/client/am/ClientPreparedStatement.java,setDouble,689-689,[                setInput(parameterIndex, new Double(x));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/client/am/ClientPreparedStatement.java,executeBatchRequestX,2244-2244,[            throw ClientDriver.getFactory().newBatchUpdateException(agent_.logWriter_, ],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/client/am/ClientPreparedStatement.java,flowExecute,2032-2094,[            switch (sqlMode_) {,             case isUpdate__:,                 if (positionedUpdateCursorName_ != null) {,                     scrollableRS = agent_.sectionManager_.getPositionedUpdateResultSet(positionedUpdateCursorName_);,                 },                 if (scrollableRS != null && !scrollableRS.isRowsetCursor_) {,                     repositionedCursor =,                             scrollableRS.repositionScrollableResultSetBeforeJDBC1PositionedUpdateDelete();,                     if (!repositionedCursor) {,                         scrollableRS = null;,                     },                 }, ,                 chainAutoCommit = connection_.willAutoCommitGenerateFlow() && isAutoCommittableStatement_;, ,                 boolean chainOpenQueryForAutoGeneratedKeys = (sqlUpdateMode_ == isInsertSql__ && autoGeneratedKeys_ == RETURN_GENERATED_KEYS);,                 writeExecute(getSection(),,                         parameterMetaData_,,                         parameters_,,                         numInputColumns,,                         outputExpected,,                         (chainAutoCommit || chainOpenQueryForAutoGeneratedKeys)// chain flag,                 ); // chain flag, ,                 if (chainOpenQueryForAutoGeneratedKeys) {,                     if (preparedStatementForAutoGeneratedKeys_ == null) {,                         preparedStatementForAutoGeneratedKeys_ =,                                 prepareAutoGeneratedKeysStatement(connection_);,                         prepareSentForAutoGeneratedKeys = true;,                     },                   ,                     writeOpenQuery(preparedStatementForAutoGeneratedKeys_.getSection(),,                             preparedStatementForAutoGeneratedKeys_.fetchSize_,,                             preparedStatementForAutoGeneratedKeys_.resultSetType_);,                 },                 , ,                 if (chainAutoCommit) {,                     // we have encountered an error in writing the execute, so do not,                     // flow an autocommit,                     if (agent_.accumulatedReadExceptions_ != null) {,                         // currently, the only write exception we encounter is for,                         // data truncation: SQLSTATE 01004, so we don't bother checking for this,                         connection_.writeCommitSubstitute_();,                         commitSubstituted = true;,                     } else {,                         // there is no write error, so flow the commit,                         connection_.writeCommit();,                     },                 },                 break;, ,             case isQuery__:,                 writeOpenQuery(getSection(),,                         fetchSize_,,                         resultSetType_,,                         numInputColumns,,                         parameterMetaData_,,                         parameters_);,                 break;, ,             case isCall__:,                 writeExecuteCall(outputRegistered_, // if no out/inout parameter, outputExpected = false],,flowExecute,2121-2175,[            switch (sqlMode_) {,             case isUpdate__:,                 // do not need to reposition for a rowset cursor,                 if (scrollableRS != null && !scrollableRS.isRowsetCursor_) {,                     scrollableRS.readPositioningFetch_();,                 }, ,                 else {,                     readExecute();, ,                     if (sqlUpdateMode_ == isInsertSql__ && autoGeneratedKeys_ == RETURN_GENERATED_KEYS) {,                         if (prepareSentForAutoGeneratedKeys) {,                             preparedStatementForAutoGeneratedKeys_.materialPreparedStatement_.readPrepareDescribeOutput_();,                         },           ,                         preparedStatementForAutoGeneratedKeys_.readOpenQuery();,                         generatedKeysResultSet_ = preparedStatementForAutoGeneratedKeys_.resultSet_;,                         preparedStatementForAutoGeneratedKeys_.resultSet_ = null;,                     },                 }, ,                 if (chainAutoCommit) {,                     if (commitSubstituted) {,                         connection_.readCommitSubstitute_();,                     } else {,                         connection_.readCommit();,                     },                 },                 break;, ,             case isQuery__:,                 try {,                     readOpenQuery();,                 } catch (DisconnectException dise) {,                     throw dise;,                 } catch (SqlException e) {,                     throw e;,                 },                 // resultSet_ is null if open query failed.,                 // check for null resultSet_ before using it.,                 if (resultSet_ != null) {,                     resultSet_.parseScrollableRowset();,                     //if (resultSet_.scrollable_) resultSet_.getRowCount();, ,                     // DERBY-1183: If we set it up earlier, the entry in,                     // clientCursorNameCache_ gets wiped out by the closing of,                     // result sets happening during readCloseResultSets above,                     // because ResultSet#markClosed calls,                     // Statement#removeClientCursorNameFromCache.,                     setupCursorNameCacheAndMappings();,                 },                 break;, ,             case isCall__:,                 readExecuteCall();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/client/am/ClientPreparedStatement.java,resetPreparedStatement,193-196,[        super.resetStatement(agent, connection);,         initPreparedStatement();,         initPreparedStatement(sql, section);,     }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/client/am/ClientPreparedStatement42.java,setObject,92-92,[                agent_.logWriter_.traceEntry],,
STYLE,DB_DUPLICATE_BRANCHES,org/apache/derby/client/am/ClientResultSet.java,readClose,531-531,[                readCursorClose_();],,readClose,533-533,[                readCursorClose_();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/am/ClientResultSet.java,getArray,1369-1369,[            Array result = isNull(column) ? null : cursor_.getArray(column);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/am/ClientResultSet.java,getRef,1342-1342,[            Ref result = isNull(column) ? null : cursor_.getRef(column);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/am/ClientResultSet.java,getObject,1436-1436,[                result = updatedColumns_[column - 1];],,getObject,1438-1438,[                result = isNull(column) ? null : cursor_.getObject(column);],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/derby/client/am/ClientResultSet.java,insertRowX,3529-3529,[                    if (updatedColumns_[i] != null ||],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/derby/client/am/ClientResultSet.java,positionToCurrentRowAndDelete,4185-4185,[        if (resultSetType_ != ResultSet.TYPE_FORWARD_ONLY &&],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/derby/client/am/ClientResultSet.java,positionToCurrentRowAndDelete,4204-4204,[        if (resultSetType_ != ResultSet.TYPE_FORWARD_ONLY &&],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/derby/client/am/ClientResultSet.java,positionToCurrentRowAndUpdate,4096-4096,[        if (resultSetType_ != ResultSet.TYPE_FORWARD_ONLY &&],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/derby/client/am/ClientResultSet.java,positionToCurrentRowAndUpdate,4116-4116,[        if (resultSetType_ != ResultSet.TYPE_FORWARD_ONLY &&],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/derby/client/am/ClientResultSet.java,updateRowX,3621-3621,[                if (updatedColumns_[i] != null ||],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/client/am/ClientResultSet.java,positionToCurrentRowAndDelete,4185-4185,[        if (resultSetType_ != ResultSet.TYPE_FORWARD_ONLY &&],,positionToCurrentRowAndDelete,4204-4204,[        if (resultSetType_ != ResultSet.TYPE_FORWARD_ONLY &&],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/client/am/ClientResultSet.java,positionToCurrentRowAndUpdate,4096-4096,[        if (resultSetType_ != ResultSet.TYPE_FORWARD_ONLY &&],,positionToCurrentRowAndUpdate,4116-4116,[        if (resultSetType_ != ResultSet.TYPE_FORWARD_ONLY &&],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/am/ClientStatement.java,escape,3062-3062,[        String nativeSQL = sql;],,
I18N,DM_CONVERT_CASE,org/apache/derby/client/am/ClientStatement.java,extractCursorNameFromWhereCurrentOf,2956-2956,[        String lowerSql = sql.toLowerCase();],,extractCursorNameFromWhereCurrentOf,2977-2977,[                            cursorName = cursorName.toUpperCase();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/client/am/ClientStatement.java,extractCursorNameFromWhereCurrentOf,2991-2991,[        return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/client/am/ClientStatement.java,cacheCursorAttributesToSendOnPrepare,3094-3094,[        return],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/client/am/ClientStatement.java,completeExecuteCall,1832-1832,[        resultSetList_ = resultSets.clone();],,completeExecuteCall,1833-1833,[        if (resultSets != null) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/client/am/ClientStatement.java,flowExecute,2278-2347,[            switch (sqlMode_) {,             case isQuery__:,                 newSection = agent_.sectionManager_.getDynamicSection(resultSetHoldability_);, ,                 writePrepareDescribeOutput(sql, newSection);,                 writeOpenQuery(newSection,,                         fetchSize_,,                         resultSetType_);,                 break;,             case isUpdate__:,                 String cursorName = null;,                 if (sqlUpdateMode_ == isDeleteSql__ || sqlUpdateMode_ == isUpdateSql__) {,                     String[] sqlAndCursorName = extractCursorNameFromWhereCurrentOf(sql);,                     if (sqlAndCursorName != null) {,                         cursorName = sqlAndCursorName[0];,                         sql = sqlAndCursorName[1];,                     },                 },                 if (cursorName != null) {,                     newSection = agent_.sectionManager_.getPositionedUpdateSection(cursorName, true); // true means get an execute immediate section,                     if (newSection == null) {,                         throw new SqlException(agent_.logWriter_, ,                             new ClientMessageId(SQLState.LANG_CURSOR_NOT_FOUND),,                             cursorName);,                     },                     scrollableRS = agent_.sectionManager_.getPositionedUpdateResultSet(cursorName);,                     // do not need to reposition for rowset cursors,                     if (scrollableRS != null && !scrollableRS.isRowsetCursor_) {,                         repositionedCursor =,                                 scrollableRS.repositionScrollableResultSetBeforeJDBC1PositionedUpdateDelete();,                         if (!repositionedCursor) {,                             scrollableRS = null;,                         },                     }, ,                     // if client's cursor name is set, and the cursor name in the positioned update,                     // string is the same as the client's cursor name, replace client's cursor name,                     // with the server's cursor name.,                     if (newSection.getClientCursorName() != null &&,                             cursorName.compareTo(newSection.getClientCursorName()) == 0) {,                         // substitute cusor name in pass thru sql string,                         sql = substituteClientCursorNameWithServerCursorName(sql, newSection);,                     },                     writeExecuteImmediate(sql, newSection);,                 },             ,                else {,                     newSection = agent_.sectionManager_.getDynamicSection(resultSetHoldability_);, ,                     writeExecuteImmediate(sql, newSection);,                     if (sqlUpdateMode_ == isInsertSql__ && autoGeneratedKeys_ == RETURN_GENERATED_KEYS) {,                         // chain a "select from identity_val_local()" to the insert statement,                         if (preparedStatementForAutoGeneratedKeys_ == null) {,                             preparedStatementForAutoGeneratedKeys_ =,                                  prepareAutoGeneratedKeysStatement(connection_);,                             prepareSentForAutoGeneratedKeys = true;,                         },                         writeOpenQuery(preparedStatementForAutoGeneratedKeys_.getSection(),,                                 preparedStatementForAutoGeneratedKeys_.fetchSize_,,                                 preparedStatementForAutoGeneratedKeys_.resultSetType_);,                     },                 }, ,                 // maybe duplicate a commit here if the sql is a "commit",                 if (connection_.autoCommit_) {,                     connection_.writeAutoCommit();,                 },                 break;,             case isCall__:,                 newSection = writeExecuteCall(sql, false);],,flowExecute,2370-2419,[            switch (sqlMode_) {,             case isQuery__:,                 // parse out the reply to a chained prepare and open request,                 readPrepareDescribeOutput();,                 // This establishes statement.resultSet,                 readOpenQuery();, ,                 // resultSet_ is null if open query failed.,                 // check for null resultSet_ before using it.,                 // the first rowset comes back on OPEN for static non-rowset cursors.,                 // no row is returned on open for rowset cursors.,                 if (resultSet_ != null) {,                     resultSet_.parseScrollableRowset();, ,                     // DERBY-1183: If we set it up it earlier, the entry in,                     // clientCursorNameCache_ gets wiped out by the closing of,                     // result sets happening during readCloseResultSets above,                     // because ResultSet#markClosed calls,                     // Statement#removeClientCursorNameFromCache.,                     setupCursorNameCacheAndMappings();,                 }, ,                 break;, ,             case isUpdate__:, ,                 // do not need to reposition for rowset cursors.,                 if (scrollableRS != null && !scrollableRS.isRowsetCursor_) {,                     scrollableRS.readPositioningFetch_();,                 },                 readExecuteImmediate();, ,                 if (sqlUpdateMode_ == isInsertSql__ && autoGeneratedKeys_ == RETURN_GENERATED_KEYS) {,                     if (prepareSentForAutoGeneratedKeys) {,                         preparedStatementForAutoGeneratedKeys_.materialPreparedStatement_.readPrepareDescribeOutput_();,                     },                     preparedStatementForAutoGeneratedKeys_.readOpenQuery();,                     generatedKeysResultSet_ = preparedStatementForAutoGeneratedKeys_.resultSet_;,                     preparedStatementForAutoGeneratedKeys_.resultSet_ = null;,                     generatedKeysResultSet_.outerStatement_ = this;,                 }, ,                 if (connection_.autoCommit_) {,                     connection_.readAutoCommit();,                 },                 break;, ,             case isCall__:,                 readPrepare();,                 readExecuteCall();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/client/am/ClobLocatorWriter.java,,79-79,[        this.connection = connection;],,
CORRECTNESS,DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE,org/apache/derby/client/am/CrossConverters.java,<clinit>,90-90,[    private final static BigDecimal bdMinDoubleValue__ =],,
CORRECTNESS,DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE,org/apache/derby/client/am/CrossConverters.java,<clinit>,86-86,[    private final static BigDecimal bdMinFloatValue__ =],,
CORRECTNESS,DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE,org/apache/derby/client/am/CrossConverters.java,<clinit>,88-88,[    private final static BigDecimal bdMaxDoubleValue__ =],,
CORRECTNESS,DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE,org/apache/derby/client/am/CrossConverters.java,<clinit>,84-84,[    private final static BigDecimal bdMaxFloatValue__ =],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/client/am/Cursor.java,allocateCharBuffer,1213-1218,[            switch (jdbcTypes_[i]) {,             case ClientTypes.CHAR:,             case ClientTypes.VARCHAR:,             case ClientTypes.LONGVARCHAR:,                 if (fdocaLength_[i] > maxCharLength) {,                     maxCharLength = fdocaLength_[i];],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/client/am/FailedProperties40.java,makeProperties,57-57,[            p.setProperty(name, value);],,makeProperties,56-56,[        if (name != null || value != null)],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/client/am/Lob.java,,354-354,[        return updateCount;],,,347-347,[        updateCount++;],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/client/am/LogWriter.java,run,700-700,[                        return new PrintWriter(],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/client/am/LogicalConnection.java,,701-701,[            return physicalConnection_.createNClob();],,,713-713,[            return physicalConnection_.createSQLXML();],,,955-955,[            physicalConnection_.setNetworkTimeout( executor, milliseconds );],,,665-665,[            return physicalConnection_.createArrayOf( typeName, elements );],,,158-158,[        if (physicalConnection_ == null) {],,,161-161,[        return physicalConnection_.isClosed();],,,769-769,[            return physicalConnection_.getClientInfo(name);],,,943-943,[            return physicalConnection_.getNetworkTimeout();],,,856-856,[            physicalConnection_.setClientInfo(name, value);],,,638-638,[        if (physicalConnection_ == null) {],,,641-641,[            return physicalConnection_.getTransactionID();],,,648-648,[        if (physicalConnection_ == null) {],,,651-651,[            return physicalConnection_.getServerVersion();],,,177-177,[        if (physicalConnection_ == null) {],,,830-830,[            physicalConnection_.setClientInfo(properties);],,,747-747,[            return physicalConnection_.getClientInfo();],,,677-677,[            return physicalConnection_.createBlob();],,,725-725,[            return physicalConnection_.createStruct( typeName, attributes );],,,195-195,[        if (physicalConnection_ != null) ],,,928-928,[            if ( physicalConnection_ != null )],,,930-930,[                physicalConnection_.abort( executor );],,,689-689,[            return physicalConnection_.createClob();],,,364-364,[        return new LogicalDatabaseMetaData(],,,613-613,[            physicalConnection_.rollback(savepoint);],,,458-458,[            return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency);],,,423-423,[            return physicalConnection_.getCatalog();],,,297-297,[            return physicalConnection_.getTransactionIsolation();],,,277-277,[            physicalConnection_.rollback();],,,507-507,[            return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);],,,522-522,[            return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency,],,,257-257,[            return physicalConnection_.getAutoCommit();],,,317-317,[            physicalConnection_.clearWarnings();],,,536-536,[            return physicalConnection_.prepareStatement(sql, autoGeneratedKeys);],,,917-917,[            physicalConnection_.setSchema( schemaName );],,,413-413,[            physicalConnection_.setCatalog(catalog);],,,624-624,[            physicalConnection_.releaseSavepoint(savepoint);],,,403-403,[            return physicalConnection_.isReadOnly();],,,93-93,[        physicalConnection_ = null;],,,572-572,[            physicalConnection_.setHoldability(holdability);],,,227-227,[            return physicalConnection_.prepareCall(sql);],,,138-138,[        if (physicalConnection_ == null) {],,,141-141,[        physicalConnection_.checkForTransactionInProgress();],,,143-143,[            if (physicalConnection_.isClosed()) // connection is closed or has become stale],,,151-151,[            physicalConnection_.closeForReuse(],,,153-153,[            physicalConnection_ = null;],,,237-237,[            return physicalConnection_.nativeSQL(sql);],,,592-592,[            return physicalConnection_.setSavepoint();],,,216-216,[            return physicalConnection_.prepareStatement(sql);],,,794-794,[            if (physicalConnection_ == null) {],,,797-797,[            return physicalConnection_.isValid(timeout);],,,478-478,[            physicalConnection_.setTypeMap(map);],,,307-307,[            return physicalConnection_.getWarnings();],,,393-393,[            physicalConnection_.setReadOnly(readOnly);],,,446-446,[            return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency);],,,247-247,[            physicalConnection_.setAutoCommit(autoCommit);],,,468-468,[            return physicalConnection_.getTypeMap();],,,205-205,[            return physicalConnection_.createStatement();],,,434-434,[            return physicalConnection_.createStatement(resultSetType, resultSetConcurrency);],,,582-582,[            return physicalConnection_.getHoldability();],,,492-492,[            return physicalConnection_.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);],,,549-549,[            return physicalConnection_.prepareStatement(sql, columnIndexes);],,,903-903,[            return physicalConnection_.getSchema();],,,387-387,[        return this.physicalConnection_.getMetaData();],,,379-379,[            throw new SqlException(],,,562-562,[            return physicalConnection_.prepareStatement(sql, columnNames);],,,603-603,[            return physicalConnection_.setSavepoint(name);],,,267-267,[            physicalConnection_.commit();],,,287-287,[            physicalConnection_.setTransactionIsolation(level);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/client/am/SQLExceptionFactory.java,notImplemented,121-121,[        return (SQLFeatureNotSupportedException) sqlException.getSQLException();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/client/am/SQLExceptionFactory.java,getSQLException,66-66,[            ex = new SQLException(message, sqlState, errCode); ],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/client/am/Section.java,getPKGNAMCBytes,101-101,[               PKGNAMCBytes.clone() :],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derby/client/am/SectionManager.java,,79-79,[    private final int maxNumSections_ = 32768;],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/client/am/SqlException.java,getMessageUtil,120-121,[        if ( msgutil_ == null ) {,             msgutil_ = new MessageUtil(CLIENT_MESSAGE_RESOURCE_NAME);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/client/am/SqlWarning.java,getSQLWarning,63-63,[            return (SQLWarning) wrappedException_;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/client/am/SqlWarning.java,,39-79,[        super(logwriter, msgid, args);,     },     ,     public SqlWarning(LogWriter logWriter, Sqlca sqlca),     {,         super(logWriter, sqlca);,     },     ,     void setNextWarning(SqlWarning warning),     {,         // Add this warning to the end of the chain,         SqlWarning theEnd = this;,         while (theEnd.nextWarning_ != null) {,             theEnd = theEnd.nextWarning_;,         },         theEnd.nextWarning_ = warning;,     },     ,     /**,      * Get the java.sql.SQLWarning for this SqlWarning,      */,     public SQLWarning getSQLWarning(),     {,         if (wrappedException_ != null) {,             return (SQLWarning) wrappedException_;,         }, ,         SQLWarning sqlw = new SQLWarning(getMessage(), getSQLState(), ,             getErrorCode());, ,         sqlw.initCause(this);, ,         // Set up the nextException chain,         if ( nextWarning_ != null ),         {,             // The warning chain gets constructed automatically through,             // the beautiful power of recursion,             sqlw.setNextWarning(nextWarning_.getSQLWarning());,         },         ,         return sqlw;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/client/am/Sqlca.java,,487-487,[        connection_ = connection;],,,265-265,[        if (connection_ == null || connection_.isClosedX() || returnTokensOnlyInMessageText_) {],,,270-270,[        synchronized (connection_) {],,,272-272,[                cs = connection_.prepareMessageProc("call SYSIBM.SQLCAMESSAGE(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");],,,393-393,[                connection_.accumulate440WarningForMessageProcFailure(warningForStoredProcFailure);],,,398-398,[                connection_.accumulate444WarningForMessageProcFailure(warningForStoredProcFailure);],,,344-344,[        if (connection_ != null && connection_.retrieveMessageText_) {],,,141-141,[        if (errorCode == ExceptionSeverity.STATEMENT_SEVERITY &&],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/client/am/Sqlca.java,,488-488,[        sqlCode_ = sqlCode;],,,108-108,[        return sqlCode_;],,,133-133,[        if (sqlCode_ >= 0) return sqlCode_;],,,137-137,[        int errorCode = -(sqlCode_ + 1);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/client/am/Sqlca.java,,490-490,[        sqlErrpBytes_ = null;],,,206-206,[        if (sqlErrpBytes_ == null) {],,,210-210,[        sqlErrp_ = bytes2String(sqlErrpBytes_, 0, sqlErrpBytes_.length);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/client/am/Sqlca.java,,489-489,[        sqlState_ = sqlState;],,,241-241,[        return sqlState_;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/client/am/stmtcache/JDBCStatementCache.java,,137-167,[            super();,             this.maxSize = maxCapacity;,         }, ,         /**,          * Tells if an entry should be removed from the map.,          * <p>,          * If the cache has exceeded its maximum size, the oldest element will,          * be marked for removal. The oldest element will be removed after the,          * new element has been inserted.,          *,          * @param eldest the element picked out for removal,          * @return <code>true</code> if the element is to be removed,,          *      <code>false</code> if not.,          */,         protected boolean removeEldestEntry(,                 Map.Entry<StatementKey, PreparedStatement> eldest) {,             final boolean remove = size() > maxSize;,             if (remove && eldest != null) {,                 try {,                     eldest.getValue().close();,                 } catch (SQLException ex) {,                     // Ignore this exception in insane mode, throw an assertion,                     // error if a sane build is run.,                     if (SanityManager.DEBUG) {,                         SanityManager.THROWASSERT("Failed to close prepared " +,                                 "statement marked for cache removal", ex);,                     },                 },             },             return remove;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/client/am/stmtcache/StatementKey.java,equals,128-128,[        if (!this.sql.equals(other.sql)) {],,equals,125-125,[        if (this.sql == null && other.sql != null) {],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/client/net/CodePointNameTable.java,,34-97,[    CodePointNameTable() {,         put(CodePoint.ACCSECRD, "ACCSECRD");,         put(CodePoint.TYPDEFNAM, "TYPDEFNAM");,         put(CodePoint.TYPDEFOVR, "TYPDEFOVR");,         put(CodePoint.EXCSAT, "EXCSAT");,         put(CodePoint.SYNCCTL, "SYNCCTL");,         put(CodePoint.SYNCCRD, "SYNCCRD");,         put(CodePoint.SYNCRSY, "SYNCRSY");,         put(CodePoint.ACCSEC, "ACCSEC");,         put(CodePoint.SECCHK, "SECCHK");,         put(CodePoint.MGRLVLRM, "MGRLVLRM");,         put(CodePoint.SECCHKRM, "SECCHKRM");,         put(CodePoint.CMDNSPRM, "CMDNSPRM");,         put(CodePoint.OBJNSPRM, "OBJNSPRM");,         put(CodePoint.CMDCHKRM, "CMDCHKRM");,         put(CodePoint.SYNTAXRM, "SYNTAXRM");,         put(CodePoint.VALNSPRM, "VALNSPRM");,         put(CodePoint.EXCSATRD, "EXCSATRD");,         put(CodePoint.ACCRDB, "ACCRDB");,         put(CodePoint.CLSQRY, "CLSQRY");,         put(CodePoint.CNTQRY, "CNTQRY");,         put(CodePoint.DSCSQLSTT, "DSCSQLSTT");,         put(CodePoint.EXCSQLIMM, "EXCSQLIMM");,         put(CodePoint.EXCSQLSTT, "EXCSQLSTT");,         put(CodePoint.OPNQRY, "OPNQRY");,         put(CodePoint.OUTOVR, "OUTOVR");,         put(CodePoint.PRPSQLSTT, "PRPSQLSTT");,         put(CodePoint.RDBCMM, "RDBCMM");,         put(CodePoint.RDBRLLBCK, "RDBRLLBCK");,         put(CodePoint.DSCRDBTBL, "DSCRDBTBL");,         put(CodePoint.ACCRDBRM, "ACCRDBRM");,         put(CodePoint.QRYNOPRM, "QRYNOPRM");,         put(CodePoint.RDBATHRM, "RDBATHRM");,         put(CodePoint.RDBNACRM, "RDBNACRM");,         put(CodePoint.OPNQRYRM, "OPNQRYRM");,         put(CodePoint.RDBACCRM, "RDBACCRM");,         put(CodePoint.ENDQRYRM, "ENDQRYRM");,         put(CodePoint.ENDUOWRM, "ENDUOWRM");,         put(CodePoint.ABNUOWRM, "ABNUOWRM");,         put(CodePoint.DTAMCHRM, "DTAMCHRM");,         put(CodePoint.QRYPOPRM, "QRYPOPRM");,         put(CodePoint.RDBNFNRM, "RDBNFNRM");,         put(CodePoint.OPNQFLRM, "OPNQFLRM");,         put(CodePoint.SQLERRRM, "SQLERRRM");,         put(CodePoint.RDBUPDRM, "RDBUPDRM");,         put(CodePoint.RSLSETRM, "RSLSETRM");,         put(CodePoint.RDBAFLRM, "RDBAFLRM");,         put(CodePoint.SQLCARD, "SQLCARD");,         put(CodePoint.SQLDARD, "SQLDARD");,         put(CodePoint.SQLDTA, "SQLDTA");,         put(CodePoint.SQLDTARD, "SQLDTARD");,         put(CodePoint.SQLSTT, "SQLSTT");,         put(CodePoint.QRYDSC, "QRYDSC");,         put(CodePoint.QRYDTA, "QRYDTA");,         put(CodePoint.PRCCNVRM, "PRCCNVRM");,         put(CodePoint.EXCSQLSET, "EXCSQLSET");,         put(CodePoint.EXTDTA, "EXTDTA");,         put(CodePoint.PBSD, "PBSD");,         put(CodePoint.PBSD_ISO, "PBSD_ISO");,         put(CodePoint.PBSD_SCHEMA, "PBSD_SCHEMA");,     }, ,     String lookup(int codePoint) {,         return get(codePoint);],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/client/net/NaiveTrustManager.java,getSocketFactory,72-73,[        if (thisManager == null) {,             thisManager = new TrustManager [] {new NaiveTrustManager()};],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/client/net/NaiveTrustManager.java,getSocketFactory,94-94,[            ks.load(new FileInputStream(keyStore),],,getSocketFactory,95-95,[                    keyStorePassword.toCharArray());],,getSocketFactory,97-97,[            KeyManagerFactory kmf = ],,getSocketFactory,98-98,[                KeyManagerFactory.getInstance("SunX509", "SunJSSE");],,getSocketFactory,99-99,[            kmf.init(ks, keyStorePassword.toCharArray());],,getSocketFactory,101-101,[            ctx.init(kmf.getKeyManagers(),],,getSocketFactory,104-104,[        } else {],,getSocketFactory,110-110,[        return ctx.getSocketFactory();],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/client/net/NaiveTrustManager.java,getSocketFactory,94-94,[            ks.load(new FileInputStream(keyStore),],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/client/net/NetAgent.java,<init>,158-158,[            if (exceptionOpeningSocket_ == null) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/client/net/NetCallableStatement.java,,39-89,[        callableStatement_ = null;,     }, ,     // Relay constructor for all NetCallableStatement, constructors,     private NetCallableStatement(ClientCallableStatement statement,,                          NetAgent netAgent,,                          NetConnection netConnection) throws SqlException {,         super(statement, netAgent, netConnection);,         initNetCallableStatement();,         initNetCallableStatement(statement);,     }, ,     private void resetNetCallableStatement(ClientCallableStatement statement,,                                    NetAgent netAgent,,                                    NetConnection netConnection) throws SqlException {,         super.resetNetPreparedStatement(statement, netAgent, netConnection);,         initNetCallableStatement();,         initNetCallableStatement(statement);,     }, ,     private void initNetCallableStatement(ClientCallableStatement statement) {,         callableStatement_ = statement;,         callableStatement_.materialCallableStatement_ = this;, ,     }, , ,     // Called by abstract Connection.prepareCall().newCallableStatement(),     // for jdbc 2 callable statements with scroll attributes.,     NetCallableStatement(NetAgent netAgent,,                          NetConnection netConnection,,                          String sql,,                          int type,,                          int concurrency,,                          int holdability,,                          ClientPooledConnection cpc) throws SqlException {,         this(ClientDriver.getFactory().newCallableStatement(netAgent,,                 netConnection, sql, type, concurrency, holdability,cpc),,                 netAgent,,                 netConnection);,     }, ,     void resetNetCallableStatement(NetAgent netAgent,,                                    NetConnection netConnection,,                                    String sql,,                                    int type,,                                    int concurrency,,                                    int holdability) throws SqlException {,         callableStatement_.resetCallableStatement(netAgent, netConnection, sql, type, concurrency, holdability);,         resetNetCallableStatement(callableStatement_, netAgent, netConnection);,     }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/client/net/NetConnection.java,flowReconnect,497-500,[                checkUserPassword(user_, password);,                 resetConnectionAtFirstSql_ = true;,                 setDeferredResetPassword(password);,                 return true;],,flowReconnect,506-509,[                checkUserPassword(user_, password);,                 resetConnectionAtFirstSql_ = true;,                 setDeferredResetPassword(password);,                 return true;],,flowReconnect,511-514,[                checkUserPassword(user_, password);,                 resetConnectionAtFirstSql_ = true;,                 setDeferredResetPassword(password);,                 return true;],,flowReconnect,516-519,[                checkUserPassword(user_, password);,                 resetConnectionAtFirstSql_ = true;,                 setDeferredResetPassword(password);,                 return true;],,flowReconnect,521-524,[                checkUserPassword(user_, password);,                 resetConnectionAtFirstSql_ = true;,                 setDeferredResetPassword(password);,                 return true;],,flowReconnect,526-529,[                checkUserPassword(user_, password);,                 resetConnectionAtFirstSql_ = true;,                 setDeferredResetPassword(password);,                 return true;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/client/net/NetConnection.java,mapSecchkcd,1156-1158,[            return new SqlException(agent_.logWriter_,,                 new ClientMessageId(SQLState.NET_CONNECT_AUTH_FAILED),,                 msgutil.getTextMessage(MessageId.CONN_USERID_OR_PASSWORD_INVALID));],,mapSecchkcd,1180-1182,[            return new SqlException(agent_.logWriter_,,                 new ClientMessageId(SQLState.NET_CONNECT_AUTH_FAILED),,                 msgutil.getTextMessage(MessageId.CONN_USERID_OR_PASSWORD_INVALID));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/client/net/NetConnection.java,getTargetPublicKey,1616-1616,[               targetPublicKey_.clone() :],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/client/net/NetConnection.java,flowSimpleConnect,424-470,[        netAgent_ = (NetAgent) super.agent_;,         constructExtnam();,         // these calls need to be after newing up the agent,         // because they require the ccsid manager,         constructPrddta();  // construct product data, ,         netAgent_.typdef_ = new Typdef(netAgent_, 1208, NetConfiguration.SYSTEM_ASC, 1200, 1208);,         netAgent_.targetTypdef_ = new Typdef(netAgent_);,         netAgent_.originalTargetTypdef_ = netAgent_.targetTypdef_;, ,         try {,             flowServerAttributes();,         } catch (Throwable e) {,             // If *anything* goes wrong, make sure the connection is,             // destroyed.,             // Always mark the connection closed in case of an error.,             // This prevents attempts to use this closed connection,             // to retrieve error message text if an error SQLCA,             // is returned in one of the connect flows.,             open_ = false;, ,             handleLoginTimeout( e );,             ,             // logWriter may be closed in agent_.close(),,             // so SqlException needs to be created before that,             // but to be thrown after.,             SqlException exceptionToBeThrown;,             if (e instanceof SqlException) // rethrow original exception if it's an SqlException,             {,                 exceptionToBeThrown = (SqlException) e;,             } else // any other exceptions will be wrapped by an SqlException first,             {,                 exceptionToBeThrown = new SqlException(agent_.logWriter_,,                     new ClientMessageId(SQLState.JAVA_EXCEPTION),,                     e, e.getClass().getName(), e.getMessage());,             }, ,             try {,                 if (agent_ != null) {,                     agent_.close();,                 },             } catch (SqlException ignoreMe) {,             }, ,             throw exceptionToBeThrown;,         },     }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/client/net/NetConnectionReply.java,doValnsprmSemantics,2824-2825,[                cpValue = netAgent_.typdef_.getCcsidSbc();,                 break;],,doValnsprmSemantics,2830-2831,[                cpValue = netAgent_.typdef_.getCcsidSbc();,                 break;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLCAXGRP,2699-2699,[            sqlerrmcCcsid = netAgent_.targetTypdef_.getCcsidMbc();],,parseSQLCAXGRP,2703-2703,[            sqlerrmcCcsid = netAgent_.targetTypdef_.getCcsidSbc();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLCNGRP,3077-3077,[        String sqlcnAuthid = parseFastVCS(); // AUTHID],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLCNGRP,3076-3076,[        String sqlcnClass = parseFastVCS();  // CLASS_NAME],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLCNGRP,3075-3075,[        String sqlcnRDB = parseFastVCS();    // RDBNAM],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLDCGRP,3111-3111,[        int sqldcLinen = readFastInt(); // LINE_NUMBER],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLDCGRP,3145-3145,[        String sqldcMsg = parseFastNVCMorNVCS(); // MESSAGE_TEXT],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLDCGRP,3142-3142,[        String sqldcRdb = parseFastVCS(); // RDBNAM],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLDCGRP,3110-3110,[        int sqldcReason = readFastInt();  // REASON_CODE],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLDCXGRP,3196-3196,[        String sqldcxCrdb = parseFastVCS();        // CONSTRAINT_RDBNAM],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLDIAGSTT,3050-3050,[        int sqldsCost = readFastInt(); // COST_ESTIMATE],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLDIAGSTT,3049-3049,[        int sqldsFcod = readFastInt(); // FUNCTION_CODE],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSQLDIAGSTT,3051-3051,[        int sqldsLrow = readFastInt(); // LAST_ROW],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseABNUOWRM,1753-1753,[                String rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseACCRDBRM,667-667,[                usrid = parseUSRID(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseCMDCHKRM,827-827,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseCMDNSPRM,1686-1686,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseDummyEXCSATRD,1901-1901,[                String extnam = parseEXTNAM();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseDummyEXCSATRD,1920-1920,[                srvclsnm = parseSRVCLSNM();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseDummyEXCSATRD,1934-1934,[                srvnam = parseSRVNAM();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseDummyEXCSATRD,1946-1946,[                srvrlslv = parseSRVRLSLV();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseENDUOWRM,743-743,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseEXCSATRD,1812-1812,[                String extnam = parseEXTNAM();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseOBJNSPRM,1531-1531,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parsePRCCNVRM,1463-1463,[                prccnvcd = parsePRCCNVCD();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parsePRCCNVRM,1456-1456,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseRDBACCRM,1200-1200,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseRDBAFLRM,1274-1274,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseRDBATHRM,1035-1035,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseRDBNACRM,915-915,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseRDBNFNRM,974-974,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSECCHKRM,569-569,[                sectkn = parseSECTKN(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSYNTAXRM,1122-1122,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseSYNTAXRM,1115-1115,[                synerrcd = parseSYNERRCD();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetConnectionReply.java,parseVALNSPRM,1371-1371,[                rdbnam = parseRDBNAM(true);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/client/net/NetConnectionReply.java,parseCRRTKN,2392-2392,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/client/net/NetConnectionReply.java,parseSECTKN,2340-2340,[            return null;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetCursor.java,parseSQLCAXGRP,697-697,[            sqlerrmcCcsid = typdef.getCcsidMbc();],,parseSQLCAXGRP,702-702,[            sqlerrmcCcsid = typdef.getCcsidSbc();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetCursor.java,parseSQLDCGRP,801-801,[        int sqldcReason = readFdocaInt();  // REASON_CODE],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/client/net/NetCursor.java,parseSQLDCGRP,817-817,[            sqlca.setSqlerrmcBytes(sqldcMsg.getBytes());],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/client/net/NetCursor.java,parseSQLCAGRP,601-601,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/client/net/NetCursor.java,parseSQLDIAGGRP,713-713,[            return null;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetPackageReply.java,parseDTAMCHRM,65-65,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetPackageReply.java,parseSQLERRRM,170-170,[                rdbnam = parseRDBNAM(true);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/client/net/NetResultSet.java,,89-89,[        netConnection_ = netStatement.netConnection_;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/client/net/NetResultSet.java,,88-88,[        netStatement_ = netStatement;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetResultSetReply.java,parseCNTQRYreply,119-119,[                int daNullIndicator = readFastByte();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetResultSetReply.java,parseQRYNOPRM,346-346,[                pkgnamcsn = parsePKGNAMCSN(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetResultSetReply.java,parseQRYNOPRM,339-339,[                rdbnam = parseRDBNAM(true);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/client/net/NetResultSetReply.java,parseCNTQRYreply,155-155,[                    if (longBufferForDecryption_ != null && count_ > longBufferForDecryption_.length) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parsePKGNAMCSN,1615-1615,[            pkgcnstkn = readFastBytes(8);  // Package Consistency Token],,parsePKGNAMCSN,1671-1671,[            pkgcnstkn = readFastBytes(8);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parsePKGNAMCSN,1613-1613,[            rdbcolid = readFastString(18); // RDB Collection ID],,parsePKGNAMCSN,1654-1654,[            rdbcolid = readFastString(scldtaLen);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parsePKGNAMCSN,1612-1612,[            rdbnam = readFastString(18);   // RDB name],,parsePKGNAMCSN,1641-1641,[            rdbnam = readFastString(scldtaLen);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseSQLRSGRP,2281-2281,[        int rsLocator = readInt();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseSQLRSGRP,2283-2283,[        int rsNumRows = readInt();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseENDQRYRM,993-993,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseEXCSQLSTTreply,358-358,[            peekCP = peekCodePoint();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseOPNQFLRM,1134-1134,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parsePKGNAMCSN,1609-1609,[            offset = peekFastBytes(pkgnamcsnBytes, offset, pkgnamcsnLength);],,parsePKGNAMCSN,1670-1670,[            offset = peekFastBytes(pkgnamcsnBytes, offset, 8);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseQRYPOPRM,1074-1074,[                pkgnamcsn = parsePKGNAMCSN(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseQRYPOPRM,1068-1068,[                rdbnam = parseRDBNAM(true);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseSQLDTARDarray,1294-1294,[                int mddClass = readFastUnsignedByte();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseSQLDTARDarray,1296-1296,[                int mddRefType = readFastUnsignedByte();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementReply.java,parseSQLDTARDarray,1295-1295,[                int mddType = readFastUnsignedByte();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/client/net/NetStatementReply.java,parseDSCSQLSTTreply,161-161,[            if (columnMetaData == null) {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/client/net/NetStatementReply.java,parsePRPSQLSTTreply,133-133,[                netSqlca = parseSQLDARD(columnMetaData, true); // true means to skip the rest of SQLDARD bytes],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/client/net/NetStatementReply.java,readDescribeInput,87-87,[            if (longBufferForDecryption_ != null && count_ > longBufferForDecryption_.length) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/client/net/NetStatementReply.java,parseDSCSQLSTTreply,161-161,[            if (columnMetaData == null) {],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/derby/client/net/NetStatementReply.java,parseEXCSQLIMMreply,204-206,[            parseTypdefsOrMgrlvlovrs();,         case CodePoint.SQLCARD:,             NetSqlca netSqlca = parseSQLCARD(null);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementRequest.java,setFDODTALobLengthUnknown,1810-1810,[        writeShort( v <<= 15 );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementRequest.java,writeExecute,161-161,[            boolean overrideExists = buildSQLDTAcommandData(numInputColumns,],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementRequest.java,writeExecuteCall,314-314,[            boolean overrideExists = buildSQLDTAcommandData(numParameters,],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetStatementRequest.java,writeOpenQuery,205-205,[            boolean overrideExists = buildSQLDTAcommandData(numInputColumns,],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/derby/client/net/NetStatementRequest.java,buildFDODTA,703-703,[                    if ((protocolTypesAndLengths[i][0] % 2) == 1) {],,buildFDODTA,709-709,[                    if ((protocolTypesAndLengths[i][0] % 2) == 1) {],,
CORRECTNESS,IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN,org/apache/derby/client/net/NetStatementRequest.java,writeExecuteCall,288-288,[        outputExpected = numParameters > 0;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/client/net/NetStatementRequest.java,buildSQLDTAcommandData,550-550,[        buildFDODSC(numInputColumns,],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/client/net/NetStatementRequest.java,buildSQLDTAcommandData,544-544,[        protocolTypeToOverrideLidMapping =],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/client/net/NetStatementRequest.java,calculateOUTOVRLidAndLengthOverrides,657-669,[            switch (resultSetMetaData.types_[i]) {,                 case Types.BLOB:,                     lidAndLengths[i][0] = (resultSetMetaData.nullable_[i]),                             ? DRDAConstants.DRDA_TYPE_NLOBLOC,                             : DRDAConstants.DRDA_TYPE_LOBLOC;,                     lidAndLengths[i][1] = 4;,                     break;,  ,                 case Types.CLOB:,                     lidAndLengths[i][0] = (resultSetMetaData.nullable_[i]),                             ? DRDAConstants.DRDA_TYPE_NCLOBLOC,                             : DRDAConstants.DRDA_TYPE_CLOBLOC;,                     lidAndLengths[i][1] = 4;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnection.java,writeTransactionStart,110-110,[        int xaState = netCon.getXAState();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnectionReply.java,parseSQLSTTGRPNOCMorNOCS,264-264,[            singleNullInd = readUnsignedByte();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnectionReply.java,readLocalXACommit,51-51,[        NetXACallInfo callInfo =],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnectionReply.java,readXaCommit,106-106,[        NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnectionReply.java,readXaRollback,115-115,[        NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnectionReply.java,parseSYNCCRD,143-143,[        int svrcod = CodePoint.SVRCOD_INFO;],,parseSYNCCRD,159-159,[                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnectionReply.java,parseSYNCCRD,173-173,[                synctype = parseSYNCTYPE();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnectionReply.java,parseSYNCCTLreply,220-220,[            String s = parseSQLSTT();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnectionRequest.java,writeLocalXARollback,48-48,[        NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/client/net/NetXAConnectionRequest.java,writeXID,245-245,[        len += (gtrid.length + 4);  // gtrid length],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/derby/client/net/NetXAResource.java,start,564-564,[                callInfo.xaTimeoutMillis_ = 1000*timeoutSeconds;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/client/net/NetXAResource.java,,505-505,[        timeoutSeconds = seconds;],,,308-308,[        return timeoutSeconds;],,,306-306,[            conn_.agent_.logWriter_.traceExit(this, "getTransactionTimeout", timeoutSeconds);],,,559-559,[            if (timeoutSeconds == Integer.MAX_VALUE) {],,,562-562,[            } else if (timeoutSeconds > 0) {],,,565-565,[            } else if (timeoutSeconds == 0) {],,,564-564,[                callInfo.xaTimeoutMillis_ = 1000*timeoutSeconds;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/client/net/Reply.java,fill,177-177,[                    ((NetLogWriter) netAgent_.logWriter_).traceProtocolFlow(buffer_,],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/derby/client/net/Reply.java,decryptData,454-454,[            if (clearedByte.length >= 32767) {],,decryptData,436-436,[            byte[] clearedByte = null;],,decryptData,442-442,[            } catch (SqlException e) {],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/derby/client/net/Reply.java,decryptData,498-498,[            dssLength_ -= (encryptedByte.length - clearedByte.length);],,decryptData,489-489,[            byte[] clearedByte = null;],,decryptData,495-495,[            } catch (SqlException e) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/client/net/Reply.java,readFastLDBytes,1219-1219,[            return null;],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/client/net/Reply.java,peekCodePoint,943-943,[            } else if (ddmCollectionLenStack_[topDdmCollectionStack_] < 4) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/client/net/Request.java,sendBytes,1209-1209,[                ((NetLogWriter) netAgent_.logWriter_).traceProtocolFlow(],,
STYLE,ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT,org/apache/derby/client/net/Request.java,updateLengthBytes,888-888,[                buffer.put(extendedLengthLocation++,],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/client/net/Request.java,writePlainScalarStream,483-483,[        } catch (Exception e) {],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/derby/client/net/Typdef.java,updateColumn,1066-1066,[        netCursor.nullable_[columnIndex] = ((sda.protocolType_ % 2) == 1);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/diag/ErrorLogReader.java,next,170-170,[		        inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName));],,
STYLE,NP_DEREFERENCE_OF_READLINE_VALUE,org/apache/derby/diag/ErrorLogReader.java,getString,300-300,[					endIndex = line.indexOf(END_EXECUTING_STRING);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/diag/ErrorLogReader.java,,128-131,[             {,                  public String run(),                  {,                      return System.getProperty( Property.SYSTEM_HOME_PROPERTY );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/diag/LockTable.java,dumpLock,298-298,[			conglomId = new Long(tc.findConglomid(value.longValue()));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/diag/LockTable.java,getString,187-187,[		String val = (String)currentRow.get(columnInfo[columnNumber-1].getName());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/diag/LockTable.java,dumpLock,312-312,[		String tableName = tabInfo.getTableName(conglomId);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/diag/LockTable.java,dumpLock,298-298,[			conglomId = new Long(tc.findConglomid(value.longValue()));],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/diag/SpaceTable.java,getLong,278-278,[        ConglomInfo conglomInfo = conglomTable[currentRow];],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/diag/SpaceTable.java,getSpaceInfo,194-194,[            cc = null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/diag/SpaceTable.java,getSpaceInfo,185-185,[            ConglomerateController cc = tc.openConglomerate(],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/diag/StatementDuration.java,next,162-162,[		        inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName));],,
STYLE,NP_DEREFERENCE_OF_READLINE_VALUE,org/apache/derby/diag/StatementDuration.java,setupColumn,358-358,[					endIndex = line.indexOf(END_EXECUTING_STRING);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/diag/StatementDuration.java,setupColumn,352-352,[						line = bufferedReader.readLine();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/diag/StatementDuration.java,getString,304-304,[		return currentRow[columnNumber - 1];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/diag/StatementDuration.java,close,282-282,[				inputFileStreamReader.close();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/diag/StatementDuration.java,,120-123,[             {,                  public String run(),                  {,                      return System.getProperty( Property.SYSTEM_HOME_PROPERTY );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/diag/TransactionTable.java,getString,153-153,[		TransactionInfo info = transactionTable[currentRow];],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/drda/NetServlet.java,doGet,431-431,[                maxThreads= (new Integer(val)).intValue();],,doGet,433-433,[                timeSlice= (new Integer(val)).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/drda/NetServlet.java,getIntParameter,923-923,[            retval = (new Integer(val)).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_TOSTRING,org/apache/derby/drda/NetServlet.java,doGet,461-461,[            out.println( "<h4>"+langUtil.getTextMessage("SRV_MaxThreads", new Integer(maxThreads).toString()) +"</h4>");],,doGet,462-462,[            out.println( "<h4>"+langUtil.getTextMessage("SRV_TimeSlice", new Integer(timeSlice).toString()) +"</h4>");],,
PERFORMANCE,DM_BOXED_PRIMITIVE_TOSTRING,org/apache/derby/drda/NetServlet.java,runServer,590-590,[                    new Integer(MAX_CONNECT_TRYS).toString()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/drda/NetServlet.java,doGet,461-461,[            out.println( "<h4>"+langUtil.getTextMessage("SRV_MaxThreads", new Integer(maxThreads).toString()) +"</h4>");],,doGet,462-462,[            out.println( "<h4>"+langUtil.getTextMessage("SRV_TimeSlice", new Integer(timeSlice).toString()) +"</h4>");],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/drda/NetServlet.java,doGet,431-431,[                maxThreads= (new Integer(val)).intValue();],,doGet,433-433,[                timeSlice= (new Integer(val)).intValue();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/drda/NetServlet.java,getIntParameter,923-923,[            retval = (new Integer(val)).intValue();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/drda/NetServlet.java,runServer,589-589,[                throw new Exception(localUtil.getTextMessage("SRV_MaxTrys",],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/drda/NetServlet.java,,557-560,[                                new PrivilegedExceptionAction<Thread>() {,                                     public Thread run() throws Exception,                                     {,                                         return new Thread(service);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/iapi/db/ConsistencyChecker.java,checkTable,141-141,[            dvf = lcc.getDataValueFactory();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/iapi/db/ConsistencyChecker.java,checkTable,244-244,[					scanRL = scan.newRowLocationTemplate();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/error/ExceptionUtil.java,getSeverityFromIdentifier,77-86,[                switch (messageID.charAt(1)) {,                 case '1':,                     lseverity = ExceptionSeverity.WARNING_SEVERITY;,                     break;,                 case 'A':,                 case '7':,                     lseverity = ExceptionSeverity.STATEMENT_SEVERITY;,                     break;,                 case '8':,                     lseverity = ExceptionSeverity.SESSION_SEVERITY;],,getSeverityFromIdentifier,95-100,[                switch (messageID.charAt(1)) {,                 case '0':,                     lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;,                     break;,                 case '2':,                     lseverity = ExceptionSeverity.STATEMENT_SEVERITY;],,getSeverityFromIdentifier,108-125,[            switch (messageID.charAt(6)) {,             case 'M':,                 lseverity = ExceptionSeverity.SYSTEM_SEVERITY;,                 break;,             case 'D':,                 lseverity = ExceptionSeverity.DATABASE_SEVERITY;,                 break;,             case 'C':,                 lseverity = ExceptionSeverity.SESSION_SEVERITY;,                 break;,             case 'T':,                 lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;,                 break;,             case 'S':,                 lseverity = ExceptionSeverity.STATEMENT_SEVERITY;,                 break;,             case 'U':,                 lseverity = ExceptionSeverity.NO_APPLICABLE_SEVERITY;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/error/StandardException.java,getSeverityFromIdentifier,202-211,[				switch (messageID.charAt(1)) {, 				case '1':, 					lseverity = ExceptionSeverity.WARNING_SEVERITY;, 					break;, 				case 'A':, 				case '7':, 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;, 					break;, 				case '8':, 					lseverity = ExceptionSeverity.SESSION_SEVERITY;],,getSeverityFromIdentifier,220-225,[				switch (messageID.charAt(1)) {, 				case '0':, 					lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;, 					break;, 				case '2':, 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;],,getSeverityFromIdentifier,233-250,[			switch (messageID.charAt(6)) {, 			case 'M':, 				lseverity = ExceptionSeverity.SYSTEM_SEVERITY;, 				break;, 			case 'D':, 				lseverity = ExceptionSeverity.DATABASE_SEVERITY;, 				break;, 			case 'C':, 				lseverity = ExceptionSeverity.SESSION_SEVERITY;, 				break;, 			case 'T':, 				lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;, 				break;, 			case 'S':, 				lseverity = ExceptionSeverity.STATEMENT_SEVERITY;, 				break;, 			case 'U':, 				lseverity = ExceptionSeverity.NO_APPLICABLE_SEVERITY;],,
BAD_PRACTICE,NM_CLASS_NOT_EXCEPTION,org/apache/derby/iapi/error/StandardException.java,,305-305,[    public static class BadMessageArgumentException extends Throwable {}],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredConnection.java,createStatement,106-106,[			return control.wrapStatement(getRealConnection().createStatement());],,createStatement,107-107,[		} catch (SQLException sqle) {],,createStatement,108-108,[			notifyException(sqle);],,createStatement,109-109,[			throw sqle;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredConnection.java,createStatement,304-304,[				createStatement(resultSetType, resultSetConcurrency));],,createStatement,306-306,[		catch (SQLException se)],,createStatement,308-308,[			notifyException(se);],,createStatement,309-309,[			throw se;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredConnection.java,createStatement,381-381,[                    getRealConnection().createStatement(resultSetType,],,createStatement,383-383,[        } catch (SQLException se) {],,createStatement,384-384,[            notifyException(se);],,createStatement,385-385,[            throw se;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredConnection.java,prepareStatement,117-117,[			return control.wrapStatement(getRealConnection().prepareStatement(sql), sql, null);],,prepareStatement,118-118,[		} catch (SQLException sqle) {],,prepareStatement,119-119,[			notifyException(sqle);],,prepareStatement,120-120,[			throw sqle;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredConnection.java,prepareStatement,466-466,[            return control.wrapStatement(getRealConnection().prepareStatement(],,prepareStatement,467-467,[                sql, autoGeneratedKeys), sql, autoGeneratedKeys);],,prepareStatement,468-468,[        } catch (SQLException se) {],,prepareStatement,469-469,[            notifyException(se);],,prepareStatement,470-470,[            throw se;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredConnection.java,prepareStatement,321-321,[				prepareStatement(sql, resultSetType, resultSetConcurrency), sql, null);],,prepareStatement,323-323,[		catch (SQLException se)],,prepareStatement,325-325,[			notifyException(se);],,prepareStatement,326-326,[			throw se;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredConnection.java,prepareStatement,712-712,[    			getRealConnection().prepareStatement(sql, resultSetType,],,prepareStatement,715-715,[    	catch (SQLException se)],,prepareStatement,717-717,[    		notifyException(se);],,prepareStatement,718-718,[    		throw se;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredConnection.java,prepareStatement,479-479,[            return control.wrapStatement(getRealConnection().prepareStatement(],,prepareStatement,481-481,[        } catch (SQLException se) {],,prepareStatement,482-482,[            notifyException(se);],,prepareStatement,483-483,[            throw se;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredConnection.java,prepareStatement,492-492,[            return control.wrapStatement(getRealConnection().prepareStatement(],,prepareStatement,494-494,[        } catch (SQLException se) {],,prepareStatement,495-495,[            notifyException(se);],,prepareStatement,496-496,[            throw se;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredPreparedStatement.java,createDuplicateStatement,717-717,[            newStatement = conn.prepareStatement(],,createDuplicateStatement,734-734,[		setStatementState(oldStatement, newStatement);],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/iapi/jdbc/BrokeredPreparedStatement.java,createDuplicateStatement,717-717,[            newStatement = conn.prepareStatement(],,createDuplicateStatement,723-723,[                newStatement = conn.prepareStatement(],,createDuplicateStatement,729-729,[                newStatement = conn.prepareStatement(],,createDuplicateStatement,727-727,[                    conn.prepareStatement(sql, (int[]) generatedKeys);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,createDuplicateStatement,479-479,[		newStatement = conn.createStatement(resultSetType, resultSetConcurrency,],,createDuplicateStatement,482-482,[		setStatementState(oldStatement, newStatement);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,addBatch,71-71,[		getStatement().addBatch( sql);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,execute,95-95,[		return getStatement().execute(sql);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,execute,376-376,[        return  getStatement().execute( sql, autoGeneratedKeys);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,execute,384-384,[        return getStatement().execute( sql, columnIndexes);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,execute,391-391,[        return getStatement().execute( sql, columnNames);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,executeQuery,100-100,[ 		return wrapResultSet(getStatement().executeQuery(sql));],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,executeUpdate,105-105,[		return getStatement().executeUpdate(sql);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,executeUpdate,398-398,[                int retVal =  getStatement().executeUpdate( sql, autoGeneratedKeys);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,executeUpdate,406-406,[             return  getStatement().executeUpdate( sql, columnIndexes);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/iapi/jdbc/BrokeredStatement.java,executeUpdate,414-414,[        return getStatement().executeUpdate( sql, columnNames);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/iapi/jdbc/CharacterStreamDescriptor.java,toString,432-432,[                    maxCharLength + ", stream=" + stream.getClass();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/jdbc/DRDAServerStarter.java,boot,214-214,[				server = serverConstructor.newInstance(new Object[]],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/iapi/jdbc/DRDAServerStarter.java,setStartInfo,127-127,[            this.consoleWriter = consoleWriter;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/iapi/jdbc/DRDAServerStarter.java,boot,222-222,[        catch( Exception e)],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/iapi/jdbc/FailedProperties40.java,makeProperties,56-56,[	    p.setProperty(name, value);],,makeProperties,55-55,[	if (name != null || value != null)],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/iapi/security/SecurityUtil.java,run,133-133,[                        Subject.doAsPrivileged(subject, runCheck, acc);],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/iapi/services/cache/ClassSize.java,fetchRefSizeFromSystemProperties,311-311,[            return (new Integer(dataModel).intValue() / 8);],,
PERFORMANCE,DM_GC,org/apache/derby/iapi/services/cache/ClassSize.java,<clinit>,66-66,[            runtime.gc();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/services/cache/ClassSize.java,fetchRefSizeFromSystemProperties,311-311,[            return (new Integer(dataModel).intValue() / 8);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/iapi/services/cache/ClassSize.java,getSizeCoefficients,129-129,[            if( null != field)],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/iapi/services/cache/ClassSizeCatalog.java,<clinit>,43-43,[        put( "org.apache.derby.iapi.types.SQLTime", new int[]{8,2});],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/services/cache/ClassSizeCatalogImpl.java,,22-72,[    {,         put( "org.apache.derby.iapi.types.SQLBit", new int[]{4,5});,         put( "org.apache.derby.iapi.types.SQLBlob", new int[]{4,5});,         put( "java.util.Vector", new int[]{12,3});,         put( "org.apache.derby.iapi.types.SQLLongvarchar", new int[]{4,9});,         put( "org.apache.derby.iapi.types.SQLLongVarbit", new int[]{4,5});,         put( "org.apache.derby.impl.store.access.heap.HeapRowLocation", new int[]{12,3});,         put( "java.util.ArrayList", new int[]{8,3});,         put( "org.apache.derby.iapi.types.SQLTimestamp", new int[]{12,2});,         put( "org.apache.derby.impl.store.raw.data.RecordId", new int[]{8,3});,         put( "org.apache.derby.iapi.types.UserType", new int[]{0,3});,         put( "org.apache.derby.iapi.types.CollatorSQLLongvarchar", new int[]{4,10});,         put( "org.apache.derby.iapi.types.DataType", new int[]{0,2});,         put( "org.apache.derby.iapi.types.SQLInteger", new int[]{8,2});,         put( "org.apache.derby.impl.store.access.btree.index.B2I", new int[]{40,6});,         put( "org.apache.derby.iapi.types.BinaryDecimal", new int[]{4,3});,         put( "org.apache.derby.impl.store.access.btree.BTree", new int[]{28,6});,         put( "org.apache.derby.iapi.types.SQLChar", new int[]{4,9});,         put( "org.apache.derby.iapi.types.SQLTinyint", new int[]{5,2});,         put( "org.apache.derby.iapi.types.CollatorSQLChar", new int[]{4,10});,         put( "org.apache.derby.iapi.types.SQLTime", new int[]{8,2});,         put( "org.apache.derby.iapi.types.SQLClob", new int[]{4,11});,         put( "org.apache.derby.iapi.types.SQLBinary", new int[]{4,5});,         put( "org.apache.derby.iapi.types.SQLVarchar", new int[]{4,9});,         put( "org.apache.derby.iapi.types.SQLVarbit", new int[]{4,5});,         put( "org.apache.derby.iapi.types.SQLDate", new int[]{4,2});,         put( "org.apache.derby.impl.store.access.StorableFormatId", new int[]{4,2});,         put( "org.apache.derby.iapi.types.NumberDataType", new int[]{0,2});,         put( "org.apache.derby.iapi.types.CollatorSQLClob", new int[]{4,12});,         put( "org.apache.derby.iapi.types.XML", new int[]{8,4});,         put( "org.apache.derby.impl.store.access.conglomerate.GenericConglomerate", new int[]{0,2});,         put( "org.apache.derby.iapi.types.SQLDecimal", new int[]{4,4});,         put( "org.apache.derby.iapi.types.SQLBoolean", new int[]{12,2});,         put( "org.apache.derby.iapi.types.CollatorSQLVarchar", new int[]{4,10});,         put( "org.apache.derby.iapi.types.SQLRef", new int[]{0,3});,         put( "org.apache.derby.iapi.types.SQLDouble", new int[]{12,2});,         put( "java.lang.ref.WeakReference", new int[]{0,6});,         put( "org.apache.derby.impl.store.access.heap.Heap", new int[]{8,5});,         put( "java.math.BigDecimal", new int[]{16,4});,         put( "org.apache.derby.impl.store.access.btree.index.B2I_v10_2", new int[]{40,6});,         put( "org.apache.derby.iapi.types.SQLSmallint", new int[]{8,2});,         put( "org.apache.derby.impl.store.access.UTF", new int[]{0,3});,         put( "java.util.GregorianCalendar", new int[]{76,11});,         put( "org.apache.derby.iapi.store.raw.ContainerKey", new int[]{16,2});,         put( "org.apache.derby.impl.store.access.btree.index.B2I_10_3", new int[]{40,6});,         put( "org.apache.derby.iapi.types.SQLReal", new int[]{8,2});,         put( "org.apache.derby.iapi.types.BigIntegerDecimal", new int[]{4,3});,         put( "org.apache.derby.impl.services.cache.CachedItem", new int[]{24,3});,         put( "org.apache.derby.impl.store.access.heap.Heap_v10_2", new int[]{8,5});,         put( "org.apache.derby.iapi.types.SQLLongint", new int[]{12,2});,     }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/services/classfile/Attributes.java,,32-52,[		super(count);, 	}, , 	void put(ClassFormatOutput out) throws IOException {, 		int size = size();, 		for (int i = 0; i < size; i++) {, 			elementAt(i).put(out);, 		}, 	}, , 	int classFileSize() {, 		return classFileSize;, 	}, , 	/**, 	*/, , 	void addEntry(AttributeEntry item) {, 		addElement(item);, 		classFileSize += item.classFileSize();, 	}],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/services/classfile/ClassHolder.java,convertToInternal,800-835,[		switch (len) {, 			case 7 :, 		        if ("boolean".equals(internalName)) {, 					retVal = makeDesc(VMDescriptor.C_BOOLEAN, arity);, 				}, 				break;, 			case 4 :, 		        if ("void".equals(internalName)) {, 					retVal = makeDesc(VMDescriptor.C_VOID, arity);, 				}, 		        else if ("long".equals(internalName)) {, 					retVal = makeDesc(VMDescriptor.C_LONG, arity);, 				}, 		        else if ("byte".equals(internalName)) {, 					retVal = makeDesc(VMDescriptor.C_BYTE, arity);, 				}, 		        else if ("char".equals(internalName)) {, 					retVal = makeDesc(VMDescriptor.C_CHAR, arity);, 				}, 				break;, 			case 3 :, 		        if ("int".equals(internalName)) {, 					retVal = makeDesc(VMDescriptor.C_INT, arity);, 				}, 				break;, 			case 6 :, 		        if ("double".equals(internalName)) {, 					retVal = makeDesc(VMDescriptor.C_DOUBLE, arity);, 				}, 				break;, 			case 5 :, 		        if ("short".equals(internalName)) {, 					retVal = makeDesc(VMDescriptor.C_SHORT, arity);, 				}, 		        else if ("float".equals(internalName)) {, 					retVal = makeDesc(VMDescriptor.C_FLOAT, arity);],,
BAD_PRACTICE,DM_EXIT,org/apache/derby/iapi/services/classfile/ClassInvestigator.java,processCodeAttribute,338-338,[			System.exit(1);],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/derby/iapi/services/classfile/MemberTable.java,equals,128-128,[		MemberTableHash mth = (MemberTableHash) other;],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/derby/iapi/services/context/ContextManager.java,getContext,166-166,[								  idStack.top().getIdName() == contextId);],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/derby/iapi/services/context/ContextManager.java,popContext,192-192,[								  idStack.top().getIdName() == contextId);],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/iapi/services/context/ContextService.java,<init>,184-184,[		ContextService.factory = this;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/iapi/services/context/ContextService.java,,565-568,[                                new PrivilegedAction<Void>() {,                                     public Void run()  {,                                         fActive.interrupt();,                                         return null;],,
CORRECTNESS,SIC_THREADLOCAL_DEADLY_EMBRACE,org/apache/derby/iapi/services/context/ContextService.java,<init>,161-161,[	private ThreadLocal<Object> threadContextList = new ThreadLocal<Object>();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/services/context/ContextService.java,,608-608,[    private static class ContextManagerStack extends Stack<ContextManager> {],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/iapi/services/context/SystemContext.java,cleanupOnError,54-54,[		} else if (t instanceof ThreadDeath) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/iapi/services/diag/DiagnosticUtil.java,findDiagnostic,104-104,[			catch (Exception e)],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/iapi/services/info/ProductVersionHolder.java,loadProperties,535-535,[		InputStream is = getClass().getResourceAsStream(resourceName);],,loadProperties,536-536,[		if (is==null) {],,loadProperties,540-540,[		Properties p = new Properties();],,loadProperties,542-542,[			p.load(is);],,loadProperties,543-543,[			return p;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/iapi/services/info/ProductVersionHolder.java,loadProperties,535-535,[		InputStream is = getClass().getResourceAsStream(resourceName);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/iapi/services/io/AccessibleByteArrayOutputStream.java,getInternalByteArray,58-58,[		return buf;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/iapi/services/io/ArrayInputStream.java,getData,91-91,[		return pageData;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/services/io/ArrayInputStream.java,setData,80-80,[		pageData = data;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/services/io/ArrayOutputStream.java,setData,46-46,[		pageData = data;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/services/io/ArrayUtil.java,readIntArray,256-256,[			return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/services/io/ArrayUtil.java,readObjectArray,211-211,[		if ( size == 0 ) { return null; }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/iapi/services/io/DynamicByteArrayOutputStream.java,getByteArray,137-137,[		return buf;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/services/io/DynamicByteArrayOutputStream.java,<init>,58-58,[		buf = data;],,
I18N,DM_CONVERT_CASE,org/apache/derby/iapi/services/io/FileUtil.java,assertTrue,573-573,[                    PropertyUtil.getSystemProperty("os.name").toLowerCase();],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/iapi/services/io/FormatIdInputStream.java,,166-166,[        if (myNestedException != null)],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/iapi/services/io/FormatIdOutputStream.java,writeObject,209-209,[			ObjectOutputStream oos = new ObjectOutputStream(this);],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/iapi/services/io/FormatableHashtable.java,put,80-80,[			if (!value.getClass().isArray()) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/services/io/FormatableIntHolder.java,getFormatableIntHolders,99-99,[			return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/services/io/FormatableLongHolder.java,getFormatableLongHolders,86-86,[			return null;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/services/loader/ClassInspector.java,getParameterTypes,598-598,[			parameterClasses = ((Constructor) method).getParameterTypes();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/services/loader/ClassInspector.java,boundType,1195-1195,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/services/loader/ClassInspector.java,getGenericParameterTypes,578-578,[            return null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/services/locks/ShExLockable.java,lockAttributes,104-104,[		attributes.put(VirtualLockTable.CONTAINERID, new Long(-1) ); ],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/iapi/services/memory/LowMemory.java,,82-82,[        if (lowMemory == 0L) {],,,110-110,[            if (lowMemory == 0L) {],,,111-111,[                lowMemory = Runtime.getRuntime().freeMemory();],,,123-123,[            long lm = lowMemory;],,,138-138,[                lowMemory = 0L;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/services/property/PropertyUtil.java,booleanProperty,495-495,[		String vS = ((String) v).trim();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/services/property/PropertyUtil.java,intPropertyValue,518-518,[		String vs = ((String)v).trim();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/iapi/services/property/PropertyUtil.java,getServiceProperty,319-319,[                (value != null ? value.trim() : value)).booleanValue();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/iapi/services/property/PropertyUtil.java,isDBOnly,142-142,[                    (value != null ? value.trim() : value)).booleanValue();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/services/property/PropertyValidation.java,doValidateApplyAndMap,82-82,[						((TransactionManager) tc).addPostCommitWork(s);],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/iapi/sql/compile/OptimizerPlan.java,,318-348,[        public ConglomerateRS( String schemaName, String rowSourceName ) { super( schemaName, rowSourceName ); }, ,         public ConglomerateRS( ConglomerateDescriptor cd, DataDictionary dataDictionary ),             throws StandardException,         {,             _descriptor = cd;,             _schema = dataDictionary.getSchemaDescriptor( cd.getSchemaID(), null );,             _schemaName = _schema.getSchemaName();,             _rowSourceName = cd.getConglomerateName();,         },         ,         public void    bind,             (,              DataDictionary dataDictionary,,              LanguageConnectionContext lcc,,              CompilerContext cc,              ),             throws StandardException,         {,             super.bind( dataDictionary, lcc, cc );, ,             if ( _descriptor == null ),             {,                 _descriptor = dataDictionary.getConglomerateDescriptor( _rowSourceName, _schema, false );,             },             if ( _descriptor == null ),             {,                 throw StandardException.newException,                     ( SQLState.LANG_INDEX_NOT_FOUND, _schemaName + "." + _rowSourceName );,             },         }],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/derby/iapi/sql/compile/OptimizerPlan.java,equals,210-217,[            if ( other == null ) { return false; },             if ( !(other instanceof Join) ) { return false; }, ,             Join    that = (Join) other;, ,             if ( !this.strategy.getOperatorSymbol().equals( that.strategy.getOperatorSymbol() ) ) { return false; }, ,             return this.leftChild.equals( that.leftChild) && this.rightChild.equals( that.rightChild );],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/derby/iapi/sql/compile/OptimizerPlan.java,equals,305-312,[            if ( other == null ) { return false; },             if ( other.getClass() != this.getClass() ) { return false; }, ,             RowSource   that = (RowSource) other;, ,             if ( !( this.isBound() && that.isBound() ) ) { return false; }, ,             return this._schemaName.equals( that._schemaName ) && this._rowSourceName.equals( that._rowSourceName );],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/iapi/sql/compile/OptimizerPlan.java,,353-388,[        public TableFunctionRS( String schemaName, String rowSourceName ) { super( schemaName, rowSourceName ); }, ,         public TableFunctionRS( AliasDescriptor ad ),         {,             _descriptor = ad;,             _schemaName = ad.getSchemaName();,             _rowSourceName = ad.getName();,         },         ,         public void    bind,             (,              DataDictionary dataDictionary,,              LanguageConnectionContext lcc,,              CompilerContext cc,              ),             throws StandardException,         {,             super.bind( dataDictionary, lcc, cc );, ,             if ( _descriptor == null ),             {,                 _descriptor = dataDictionary.getAliasDescriptor,                     ( _schema.getUUID().toString(), _rowSourceName, AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR );,             },             if ( _descriptor == null ),             {,                 throw StandardException.newException,                     (,                      SQLState.LANG_OBJECT_NOT_FOUND,,                      AliasDescriptor.getAliasType( AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR ),,                      _schemaName + "." + _rowSourceName,                      );,             },         }, ,         public  String  toString()  { return super.toString() + "()"; }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/sql/depend/ProviderList.java,,33-43,[public class ProviderList extends Hashtable<UUID,Provider>, {, 	/**, 	 * Add a Provider to the list., 	 *, 	 * @param prov	The Provider to add to the list., 	 */, 	public void addProvider(Provider prov), 	{, 		put (prov.getObjectID(), prov);, 	}],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/iapi/sql/dictionary/AliasDescriptor.java,getObjectID,351-351,[		return aliasID;],,getObjectId,98-98,[		return uuid;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/iapi/sql/dictionary/AliasDescriptor.java,,97-558,[		super( dataDictionary );, , 		this.aliasID = aliasID;, 		this.aliasName = aliasName;, 		this.schemaID = schemaID;, 		this.schemaDescriptor = dataDictionary.getSchemaDescriptor(schemaID, null);, 		this.javaClassName = javaClassName;, 		this.aliasType = aliasType;, 		this.nameSpace = nameSpace;, 		this.systemAlias = systemAlias;, 		this.aliasInfo = aliasInfo;, 		if (specificName == null), 			specificName = dataDictionary.getSystemSQLName();, 		this.specificName = specificName;, 	}, , 	// Interface methods, , 	/**, 	 * Gets the UUID  of the method alias., 	 *, 	 * @return	The UUID String of the method alias., 	 */, 	public UUID getUUID(), 	{, 		return aliasID;, 	}, ,    /**, 	 * @see PrivilegedSQLObject#getObjectTypeName, 	 */, 	public String getObjectTypeName(), 	{,         if ( aliasInfo instanceof UDTAliasInfo ),         {,             return PermDescriptor.UDT_TYPE;,         },         else if ( aliasInfo instanceof AggregateAliasInfo ),         {,             return PermDescriptor.AGGREGATE_TYPE;,         },         else,         {,             if( SanityManager.DEBUG),             {,                 SanityManager.THROWASSERT( "Unsupported alias type: " + aliasInfo.getClass().getName() );,             }, ,             return null;  // should never get here,         }, 	}, , 	/**, 	 * Gets the UUID  of the schema for this method alias., 	 *, 	 * @return	The UUID String of the schema id., 	 */, 	public UUID getSchemaUUID(), 	{, 		return schemaID;, 	}, , 	/**, 	 * Gets the SchemaDescriptor for this alias., 	 *, 	 * @return SchemaDescriptor	The SchemaDescriptor., 	 */, 	public final SchemaDescriptor getSchemaDescriptor(), 	{, 		return schemaDescriptor;, 	}, , 	/**, 	 * Gets the name of the alias., 	 *, 	 * @return	A String containing the name of the statement., 	 */, 	public final String	getName(), 	{, 		return aliasName;, 	}, , 	/**, 	 * Gets the name of the schema that the alias lives in., 	 *, 	 * @return	A String containing the name of the schema that the alias, 	 *		lives in., 	 */, 	public String getSchemaName(), 	{, 		return schemaDescriptor.getSchemaName();, 	}, , 	/**, 	 * Gets the full, qualified name of the alias., 	 *, 	 * @return	A String containing the name of the table., 	 */, 	public String getQualifiedName(), 	{,         return IdUtil.mkQualifiedName(getSchemaName(), aliasName);, 	}, , 	/**, 	 * Gets the java class name of the alias., 	 *, 	 * @return	The java class name of the alias., 	 */, 	public String getJavaClassName(), 	{, 		return javaClassName;, 	}, , , 	/**, 	 * Gets the type of the alias., 	 *, 	 * @return The type of the alias., 	 */, 	public char getAliasType(), 	{, 		return aliasType;, 	}, , 	/**, 	 * Gets the name space of the alias., 	 *, 	 * @return The name space of the alias., 	 */, 	public char getNameSpace(), 	{, 		return nameSpace;, 	}, , 	/**, 	 * Gets whether or not the alias is a system alias., 	 *, 	 * @return Whether or not the alias is a system alias., 	 */, 	public boolean getSystemAlias(), 	{, 		return systemAlias;, 	}, , 	/**, 	 * Gests the AliasInfo for the alias., 	 *, 	 * @return	The AliasInfo for the alias., 	 */, 	public AliasInfo getAliasInfo(), 	{, 		return aliasInfo;, 	}, , , //  	/**, //  	 * Sets the ID of the method alias, //  	 *, //  	 * @param aliasID	The UUID of the method alias to be set in the descriptor, //  	 *, //  	 * @return	Nothing, //  	 */, //  	public void setAliasID(UUID aliasID), //  	{, //  		this.aliasID = aliasID;, //  	}, , 	/**, 	 * Convert the AliasDescriptor to a String., 	 *, 	 * @return	A String representation of this AliasDescriptor, 	 */, , 	public String	toString(), 	{, 		if (SanityManager.DEBUG), 		{, 			return "aliasID: " + aliasID + "\n" +, 				"aliasName: " + aliasName + "\n" +, 				"schemaID: " + schemaID + "\n" +, 				"javaClassName: " + javaClassName + "\n" +, 				"aliasType: " + aliasType + "\n" +, 				"nameSpace: " + nameSpace + "\n" +, 				"systemAlias: " + systemAlias + "\n" +, 				"aliasInfo: " + aliasInfo + "\n";, 		}, 		else, 		{, 			return "";, 		}, 	}, , 	//	Methods so that we can put AliasDescriptors on hashed lists, , 	/**, 	  *	Determine if two AliasDescriptors are the same., 	  *, 	  *	@param	otherObject	other descriptor, 	  *, 	  *	@return	true if they are the same, false otherwise, 	  */, , 	public boolean equals(Object otherObject), 	{, 		if (!(otherObject instanceof AliasDescriptor)), 		{	return false; }, , 		AliasDescriptor other = (AliasDescriptor) otherObject;, , 		return aliasID.equals( other.getUUID() );, 	}, , 	/**, 	  *	Get a hashcode for this AliasDescriptor, 	  *, 	  *	@return	hashcode, 	  */, 	public int hashCode(), 	{, 		return	aliasID.hashCode();, 	}, , 	//, 	// Provider interface, 	//, , 	/**		, 		@return the stored form of this provider, 			representation, , 			@see Dependable#getDependableFinder, 	 */, 	public DependableFinder getDependableFinder(), 	{, 	    return	getDependableFinder(StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID);, 	}, , 	/**, 	 * Return the name of this Provider.  (Useful for errors.), 	 *, 	 * @return String	The name of this provider., 	 */, 	public String getObjectName(), 	{, 		return aliasName;, 	}, , 	/**, 	 * Get the provider's UUID, 	 *, 	 * @return String	The provider's UUID, 	 */, 	public UUID getObjectID(), 	{, 		return aliasID;, 	}, , 	/**, 	 * Get the provider's type., 	 *, 	 * @return String		The provider's type., 	 */, 	public String getClassType(), 	{, 		return Dependable.ALIAS;, 	}, 	, 	/** @see TupleDescriptor#getDescriptorType */, 	public String getDescriptorType(), 	{, 		return getAliasType(aliasType);, 	}, 	, 	public static final String getAliasType(char nameSpace), 	{, 		switch (nameSpace), 		{, 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:, 				return "PROCEDURE";, 			case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:, 				return "FUNCTION";, 			case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:, 				return "SYNONYM";, 			case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:, 				return "TYPE";, 			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:, 				return "DERBY AGGREGATE";, 		}, 		return  null;, 	}, , 	/** @see TupleDescriptor#getDescriptorName */, 	public String getDescriptorName(), 	{, 		return aliasName;, 	}, , , 	/**, 		Return the specific name for this object., 	*/, 	public String getSpecificName(), 	{, 		return specificName;, 	},     ,     /**,      * Functions are persistent unless they are in the SYSFUN schema.,      *,      */,     public boolean isPersistent(),     {,         return !getSchemaUUID().toString().equals(SchemaDescriptor.SYSFUN_SCHEMA_UUID);,     },    ,     /**,      * Report whether this descriptor describes a Table Function.,      *,      */,     public boolean isTableFunction(),     {,         if ( getAliasType() != AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR ) { return false; }, ,         RoutineAliasInfo    rai = (RoutineAliasInfo) getAliasInfo();, ,         return rai.getReturnType().isRowMultiSet();,     },    ,     /**,      * Drop the routine or synonym.,      * For a routine its permission descriptors will be dropped as well.,      * For a synonym its TableDescriptor will be dropped as well.,      * @param lcc,      * @throws StandardException,      */,     public void drop(LanguageConnectionContext lcc) throws StandardException {,         ,         DataDictionary dd = getDataDictionary();,         TransactionController tc = lcc.getTransactionExecute();,         DependencyManager dm = dd.getDependencyManager();,         ,         ,         /* Prepare all dependents to invalidate.  (This is their chance,          * to say that they can't be invalidated.  For example, an open,          * cursor referencing a table/view that the user is attempting to,          * drop.) If no one objects, then invalidate any dependent objects.,          * We check for invalidation before we drop the descriptor,          * since the descriptor may be looked up as part of,          * decoding tuples in SYSDEPENDS.,          */,         int invalidationType = 0;,         switch (getAliasType()),         {,         case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:,         case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:,             invalidationType = DependencyManager.DROP_METHOD_ALIAS;,             break;,             ,         case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:,             invalidationType = DependencyManager.DROP_SYNONYM;,             break;,             ,         case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:,             invalidationType = DependencyManager.DROP_UDT;,             break;,             ,         case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:,             invalidationType = DependencyManager.DROP_AGGREGATE;,             break;,         },         ,         dm.invalidateFor(this, invalidationType, lcc);,         ,         if (getAliasType() == AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR),         {,             SchemaDescriptor sd = dd.getSchemaDescriptor(schemaID, tc);,             ,             // Drop the entry from SYSTABLES as well.,             DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();,             TableDescriptor td = ddg.newTableDescriptor(aliasName, sd,,                     TableDescriptor.SYNONYM_TYPE, TableDescriptor.DEFAULT_LOCK_GRANULARITY);,             dd.dropTableDescriptor(td, sd, tc);,         },         else,             dd.dropAllRoutinePermDescriptors(getUUID(), tc);,         ,         /* Drop the alias */,         dd.dropAliasDescriptor(this, tc);,     }, , 	//////////////////////////////////////////////////////, 	//, 	// DEPENDENT INTERFACE, 	//, 	//////////////////////////////////////////////////////, 	/**, 	 * Check that all of the dependent's dependencies are valid., 	 *, 	 * @return true if the dependent is currently valid, 	 */, 	public synchronized boolean isValid(), 	{, 		return true;, 	}, , 	/**, 	 * Prepare to mark the dependent as invalid (due to at least one of, 	 * its dependencies being invalid)., 	 *, 	 * @param action	The action causing the invalidation, 	 * @param p		the provider, 	 *, 	 * @exception StandardException thrown if unable to make it invalid, 	 */, 	public void prepareToInvalidate(Provider p, int action,, 					LanguageConnectionContext lcc) , 		throws StandardException, 	{, 		DependencyManager dm = getDataDictionary().getDependencyManager();, , 		switch (action), 		{, 			/*, 			** Currently, the only thing we are dependent, 			** on is an alias descriptor for an ANSI UDT., 			*/, 		    default:, , 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_ALIAS, , 									dm.getActionString(action), , 									p.getObjectName(),, 									getQualifiedName());, 		}, 	}, , 	/**, 	 * Mark the dependent as invalid (due to at least one of, 	 * its dependencies being invalid).  Always an error, 	 * for an alias -- should never have gotten here., 	 *, 	 * @param	action	The action causing the invalidation, 	 *, 	 * @exception StandardException thrown if called in sanity mode, 	 */, 	public void makeInvalid(int action, LanguageConnectionContext lcc) , 		throws StandardException, 	{, 		/* , 		** We should never get here, we should have barfed on , 		** prepareToInvalidate()., 		*/, 		if (SanityManager.DEBUG), 		{, 			DependencyManager dm;, 	, 			dm = getDataDictionary().getDependencyManager();, , 			SanityManager.THROWASSERT("makeInvalid("+, 				dm.getActionString(action)+, 				") not expected to get called");, 		}, 	}],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/sql/dictionary/AliasDescriptor.java,drop,448-464,[        switch (getAliasType()),         {,         case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:,         case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:,             invalidationType = DependencyManager.DROP_METHOD_ALIAS;,             break;,             ,         case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:,             invalidationType = DependencyManager.DROP_SYNONYM;,             break;,             ,         case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:,             invalidationType = DependencyManager.DROP_UDT;,             break;,             ,         case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:,             invalidationType = DependencyManager.DROP_AGGREGATE;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/iapi/sql/dictionary/CatalogRowFactory.java,getIndexColumnCount,143-143,[		return indexColumnPositions[indexNum].length;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/iapi/sql/dictionary/CatalogRowFactory.java,getIndexColumnPositions,357-357,[		return indexColumnPositions[indexNumber];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/iapi/sql/dictionary/CatalogRowFactory.java,getIndexName,163-163,[		return indexNames[indexNum];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/iapi/sql/dictionary/CatalogRowFactory.java,getCanonicalIndexUUID,131-131,[		return indexUUID[indexNumber];],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/sql/dictionary/ColumnDescriptorList.java,,32-134,[public class ColumnDescriptorList extends ArrayList<ColumnDescriptor>, {, 	/**, 	 * Add the column.  Currently, the table id is ignored., 	 *, 	 * @param tableID the table id (ignored), 	 * @param column the column to add, 	 */	, 	public void add(UUID tableID, ColumnDescriptor column), 	{, 		/*, 		** RESOLVE: The interface includes tableID because presumably, 		** the primary key for the columns table will be tableID +, 		** columnID (or possibly tableID + column name - both column, 		** name and ID must be unique within a table).  However, the, 		** ColumnDescriptor contains a reference to a tableID, so it, 		** seems like we don't need the parameter here.  I am going, 		** to leave it here just in case we decide we need it later., 		*/, 		add(column);, 	}, , 	/**, 	 * Get the column descriptor, 	 *, 	 * @param tableID the table id (ignored), 	 * @param columnName the column get, 	 *, 	 * @return the column descriptor if found, 	 */	, 	public ColumnDescriptor getColumnDescriptor(UUID tableID,, 							String columnName), 	{, 		ColumnDescriptor	returnValue = null;, ,         for (ColumnDescriptor columnDescriptor : this), 		{, 			if ( columnName.equals( columnDescriptor.getColumnName() ) &&, 			    tableID.equals( columnDescriptor.getReferencingUUID() ) ), 			{, 				returnValue = columnDescriptor;, 				break;, 			}, 		}, , 		return returnValue;, 	}, , 	/**, 	 * Get the column descriptor, 	 *, 	 * @param tableID the table id (ignored), 	 * @param columnID the column id, 	 *, 	 * @return the column descriptor if found, 	 */	, 	public ColumnDescriptor getColumnDescriptor(UUID tableID, int columnID), 	{, 		ColumnDescriptor	returnValue = null;, ,         for (ColumnDescriptor columnDescriptor : this), 		{, 			if ( ( columnID == columnDescriptor.getPosition() ) &&, 				tableID.equals( columnDescriptor.getReferencingUUID() ) ), 			{, 				returnValue = columnDescriptor;, 				break;, 			}, 		}, , 		return returnValue;, 	}, , 	/**, 	 * Return the nth (0-based) element in the list., 	 *, 	 * @param n	Which element to return., 	 *, 	 * @return The nth element in the list., 	 */, 	public ColumnDescriptor elementAt(int n), 	{,         return get(n);, 	}, , 	/**, 	 * Get an array of strings for all the columns, 	 * in this CDL., 	 *, 	 * @return the array of strings, 	 */, 	public String[] getColumnNames(), 	{, 		String strings[] = new String[size()];, , 		int size = size();, , 		for (int index = 0; index < size; index++), 		{,             ColumnDescriptor columnDescriptor = elementAt(index);, 			strings[index] = columnDescriptor.getColumnName();, 		}, 		return strings;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/iapi/sql/dictionary/ConglomerateDescriptor.java,getSchemaID,168-168,[		return schemaID;],,getSchemaId,285-285,[        return schemaId;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/iapi/sql/dictionary/ConglomerateDescriptor.java,getTableID,158-158,[		return	tableID;],,getTableId,119-119,[		return table.getUUID();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/sql/dictionary/ConglomerateDescriptorList.java,,32-215,[public class ConglomerateDescriptorList extends,         ArrayList<ConglomerateDescriptor>, {, , 	/**, 	 * Get a conglomerate descriptor by its number, 	 *, 	 * @param conglomerateNumber	The number of the conglomerate we're looking for, 	 *, 	 * @return	The ConglomerateDescriptor if found in this list,, 	 *		null if not found., 	 */, 	public ConglomerateDescriptor getConglomerateDescriptor(long conglomerateNumber), 	{, 		ConglomerateDescriptor	returnValue = null;, ,         for (ConglomerateDescriptor conglomerateDescriptor : this), 		{, 			if (conglomerateNumber == conglomerateDescriptor.getConglomerateNumber()), 			{, 				returnValue = conglomerateDescriptor;, 				break;, 			}, 		}, , 		return returnValue;, 	}, , 	/**, 	 * Get an array of conglomerate descriptors with the given conglomerate, 	 * number.  We get more than one descriptors if duplicate indexes share, 	 * one conglomerate., 	 *, 	 * @param conglomerateNumber	The number of the conglomerate, 	 *, 	 * @return	Array of ConglomerateDescriptors if found in this list,, 	 *		size 0 array if not found., 	 */, 	public ConglomerateDescriptor[] getConglomerateDescriptors(long conglomerateNumber), 	{, 		int size = size(), j = 0;, 		ConglomerateDescriptor[] draft = new ConglomerateDescriptor[size];, ,         for (ConglomerateDescriptor conglomerateDescriptor : this), 		{, 			if (conglomerateNumber == conglomerateDescriptor.getConglomerateNumber()), 				draft[j++] = conglomerateDescriptor;, 		}, , 		if (j == size), 			return draft;, ,         return Arrays.copyOf(draft, j);, 	}, , , 	/**, 	 * Get a conglomerate descriptor by its Name, 	 *, 	 * @param conglomerateName	The Name of the conglomerate we're looking for, 	 *, 	 * @return	The ConglomerateDescriptor if found in this list,, 	 *		null if not found., 	 */, , 	public ConglomerateDescriptor getConglomerateDescriptor(String conglomerateName), 	{, 		ConglomerateDescriptor	returnValue = null;, ,         for (ConglomerateDescriptor conglomerateDescriptor : this), 		{, 			if (conglomerateName.equals(conglomerateDescriptor.getConglomerateName())), 			{, 				returnValue = conglomerateDescriptor;, 				break;, 			}, 		}, , 		return returnValue;, 	}, , 	/**, 	 * Get a conglomerate descriptor by its UUID String, 	 *, 	 * @param uuid	The UUID of the conglomerate we're looking for, 	 *, 	 * @return	The ConglomerateDescriptor if found in this list,, 	 *		null if not found., 	 * @exception   StandardException thrown on failure, 	 */, , 	public ConglomerateDescriptor getConglomerateDescriptor(UUID uuid), 						throws StandardException, 	{, 		ConglomerateDescriptor	returnValue = null;, ,         for (ConglomerateDescriptor conglomerateDescriptor : this), 		{, 			if (uuid.equals(conglomerateDescriptor.getUUID())), 			{, 				returnValue = conglomerateDescriptor;, 				break;, 			}, 		}, , 		return returnValue;, 	}, , 	/**, 	 * Get an array of conglomerate descriptors by a UUID String.  We get, 	 * more than one descriptors if duplicate indexes share one conglomerate., 	 *, 	 * @param uuid	The UUID of the conglomerate, 	 *, 	 * @return	Array of ConglomerateDescriptors if found in this list,, 	 *		size 0 array if not found., 	 */, 	public ConglomerateDescriptor[] getConglomerateDescriptors(UUID uuid), 	{, 		int size = size(), j = 0;, 		ConglomerateDescriptor[] draft = new ConglomerateDescriptor[size];, ,         for (ConglomerateDescriptor conglomerateDescriptor : this), 		{, 			if (uuid.equals(conglomerateDescriptor.getUUID())), 				draft[j++] = conglomerateDescriptor;, 		}, , 		if (j == size), 			return draft;, ,         return Arrays.copyOf(draft, j);, 	}, , 	/**, 	 * Remove the specified conglomerate descriptor from the, 	 * conglomerate descriptor list.  If the descriptor, 	 * is not found, no errors are issued., 	 *, 	 * @param tableID table uuid, ignored, 	 * @param cgDesc the conglomerate, 	 *, 	 * @exception   StandardException thrown on failure, 	 */, 	public void dropConglomerateDescriptor(UUID tableID, ConglomerateDescriptor cgDesc) , 						throws StandardException, 	{,         Iterator<ConglomerateDescriptor> iterator = iterator();,         while (iterator.hasNext()), 		{,             ConglomerateDescriptor localCgDesc = iterator.next();, 			if (localCgDesc.getConglomerateNumber() == cgDesc.getConglomerateNumber() &&, 				localCgDesc.getConglomerateName().equals(cgDesc.getConglomerateName()) &&, 				localCgDesc.getSchemaID().equals(cgDesc.getSchemaID())), 			{, 				iterator.remove();, 				break;, 			}, 		}, 	}, , 	/**, 	 * Remove the specified conglomerate descriptor from the, 	 * conglomerate descriptor list.  If the descriptor, 	 * is not found, no errors are issued., 	 *, 	 * @param conglomerateID table uuid, ignored, 	 *, 	 * @exception   StandardException thrown on failure, 	 */, 	public void dropConglomerateDescriptorByUUID(UUID conglomerateID) , 						throws StandardException, 	{,         Iterator<ConglomerateDescriptor> iterator = iterator();,         while (iterator.hasNext()), 		{,             ConglomerateDescriptor localCgDesc = iterator.next();, 			if ( conglomerateID.equals( localCgDesc.getUUID() ) ), 			{, 				iterator.remove();, 				break;, 			}, 		}, 	}],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/sql/dictionary/ConstraintDescriptorList.java,,28-258,[public class ConstraintDescriptorList extends ArrayList<ConstraintDescriptor>, {, , 	private boolean scanned;, , 	/**, 	 * Mark whether or not the underlying system table has, 	 * been scanned.  (If a table does not have any, 	 * constraints then the size of its CDL will always, 	 * be 0.  We used these get/set methods to determine, 	 * when we need to scan the table., 	 *, 	 * @param scanned	Whether or not the underlying system table has been scanned., 	 */, 	public void setScanned(boolean scanned), 	{, 		this.scanned = scanned;, 	}, , 	/**, 	 * Return whether or not the underlying system table has been scanned., 	 *, 	 * @return		Where or not the underlying system table has been scanned., 	 */, 	public boolean getScanned(), 	{, 		return scanned;, 	}, , 	/**, 	 * Get the ConstraintDescriptor with the matching UUID String for the backing index., 	 *, 	 * @param indexUUID		The UUID  for the backing index., 	 *, 	 * @return The matching ConstraintDescriptor., 	 */, 	public ConstraintDescriptor getConstraintDescriptor(UUID indexUUID), 	{, 		ConstraintDescriptor retCD = null;, 		int size = size();, , 		for (int index = 0; index < size; index++), 		{, 			ConstraintDescriptor cd = elementAt(index);, , 			if (! (cd instanceof KeyConstraintDescriptor)), 			{, 				continue;, 			}, , 			KeyConstraintDescriptor keyCD = (KeyConstraintDescriptor) cd;, , 			if (keyCD.getIndexId().equals(indexUUID)), 			{, 				retCD = cd;, 				break;, 			}, 		}, 		return retCD;, 	}, , 	/**, 	 * Get the ConstraintDescriptor with the matching constraint id., 	 *, 	 * @param uuid		The constraint id., 	 *, 	 * @return The matching ConstraintDescriptor., 	 */, 	public ConstraintDescriptor getConstraintDescriptorById(UUID uuid), 	{, 		ConstraintDescriptor returnCD = null;, 		int size = size();, , 		for (int index = 0; index < size; index++), 		{, 			ConstraintDescriptor cd = elementAt(index);, , 			if (cd.getUUID().equals(uuid)), 			{, 				returnCD = cd;, 				break;, 			}, 		}, 		return returnCD;, 	}, , 	/**, 	  *	Drop the constraint with the given UUID., 	  *, 	  * @param uuid		The constraint id., 	  *, 	  * @return The matching ConstraintDescriptor., 	  */, 	public ConstraintDescriptor dropConstraintDescriptorById(UUID uuid), 	{, 		ConstraintDescriptor cd = null;, 		int size = size();, , 		for (int index = 0; index < size; index++), 		{, 			cd = elementAt(index);, , 			if (cd.getUUID().equals(uuid)), 			{, 				remove( cd );, 				break;, 			}, 		}, , 		return cd;, 	}, , , , 	/**, 	 * Get the ConstraintDescriptor with the matching constraint name., 	 *, 	 * @param sd		The constraint schema descriptor., 	 * @param name		The constraint name., 	 *, 	 * @return The matching ConstraintDescriptor., 	 */, 	public ConstraintDescriptor getConstraintDescriptorByName(SchemaDescriptor sd,, 																String name), 	{, 		ConstraintDescriptor retCD = null;, 		int size = size();, , 		for (int index = 0; index < size; index++), 		{, 			ConstraintDescriptor cd = elementAt(index);, , 			if (cd.getConstraintName().equals(name)), 			{, 				if ((sd == null) ||, 					(sd.equals(cd.getSchemaDescriptor()))), 				{, 					retCD = cd;, 					break;, 				}, 			}, 		}, 		return retCD;, 	}, , , 	/**, 	 * Get the ConstraintDescriptor with the matching constraint name., 	 *, 	 * @return The matching ConstraintDescriptor., 	 */, 	public ReferencedKeyConstraintDescriptor getPrimaryKey(), 	{, 		int size = size();, , 		for (int index = 0; index < size; index++), 		{, 			ConstraintDescriptor cd = elementAt(index);, , 			if (cd.getConstraintType() == DataDictionary.PRIMARYKEY_CONSTRAINT)	, 			{, 				return (ReferencedKeyConstraintDescriptor)cd;, 			}, 		}, 		return (ReferencedKeyConstraintDescriptor)null;, 	}, , 	/**,      * Return a list of constraints where enforced is, 	 * as passed in., 	 *,      * @param enforced true or false, 	 *, 	 * @return a constraint descriptor list built from this.  Always, 	 * a new list even if all the elements in this were of the correct, 	 * type (i.e. not optimized for the case where every element is, 	 * desired)., 	 */,     public ConstraintDescriptorList getConstraintDescriptorList(boolean enforced), 	{, 		ConstraintDescriptorList cdl = new ConstraintDescriptorList();, 		int size = size();, , 		for (int index = 0; index < size; index++), 		{, 			ConstraintDescriptor cd = elementAt(index);, ,             if (cd.enforced() == enforced), 			{, 				cdl.add(cd);, 			}, 		}, 		return cdl;, 	}, , 	/**, 	 * Return the nth (0-based) element in the list., 	 *, 	 * @param n	Which element to return., 	 *, 	 * @return The nth element in the list., 	 */, 	public ConstraintDescriptor elementAt(int n), 	{, 		return get(n);, 	}, , 	/**, 	 * Return a ConstraintDescriptorList containing the ConstraintDescriptors, 	 * of the specified type that are in this list., 	 *, 	 * @param type	The constraint type., 	 *, 	 * @return A ConstraintDescriptorList containing the ConstraintDescriptors, 	 * of the specified type that are in this list., 	 */, 	public ConstraintDescriptorList getSubList(int type), 	{, 		ConstraintDescriptorList cdl = new ConstraintDescriptorList();, 		int size = size();, , 		for (int index = 0; index < size; index++), 		{,             ConstraintDescriptor cd = elementAt(index);, , 			if (cd.getConstraintType() == type), 			{, 				cdl.add(cd);, 			}, 		}, 		return cdl;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/iapi/sql/dictionary/DDUtils.java,getCurrentDeleteConnections,288-288,[					String constraintName = fkcd.getConstraintName();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/iapi/sql/dictionary/DDUtils.java,getCurrentDeleteConnections,290-290,[					int raUpdateRule = fkcd.getRaUpdateRule();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/iapi/sql/dictionary/DDUtils.java,validateDeleteConnection,523-523,[				String constraintName = fkcd.getConstraintName();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/iapi/sql/dictionary/DDUtils.java,validateDeleteConnection,525-525,[				int raUpdateRule = fkcd.getRaUpdateRule();],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/iapi/sql/dictionary/DDUtils.java,validateDeleteConnection,444-444,[                if( isSelfReferencingFk &&],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/sql/dictionary/GenericDescriptorList.java,,28-74,[public class GenericDescriptorList<E extends UniqueTupleDescriptor>,        extends ArrayList<E>, {, 	private boolean scanned;, , 	/**, 	 * Mark whether or not the underlying system table has, 	 * been scanned.  (If a table does not have any, 	 * constraints then the size of its CDL will always, 	 * be 0.  We used these get/set methods to determine, 	 * when we need to scan the table., 	 *, 	 * @param scanned	Whether or not the underlying system table has been scanned., 	 */, 	public void setScanned(boolean scanned), 	{, 		this.scanned = scanned;, 	}, , 	/**, 	 * Return whether or not the underlying system table has been scanned., 	 *, 	 * @return		Where or not the underlying system table has been scanned., 	 */, 	public boolean getScanned(), 	{, 		return scanned;, 	}, , 	/**, 	 * Get the UniqueTupleDescriptor that matches the , 	 * input uuid., 	 *, 	 * @param uuid		The UUID for the object, 	 *, 	 * @return The matching UniqueTupleDescriptor., 	 */,     public E getUniqueTupleDescriptor(UUID uuid), 	{,         for (E ud : this), 		{, 			if (ud.getUUID().equals(uuid)), 			{, 				return ud;, 			}, 		}, 		return null;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/iapi/sql/dictionary/PermDescriptor.java,,71-215,[        super(dataDictionary, grantee, grantor);,         setUUID(permUUID);,         this.objectType = objectType;,         this.permObjectId = permObjectId;,         this.permission = permission;,         this.grantable = isGrantable;,     }, ,     public PermDescriptor(DataDictionary dd, UUID permUUID),             throws StandardException {,         /*,     TODO When merging all permisions catalogs to this master catalog at a future date,,     this pattern which uses a partially initialised key descriptor should be cleaned up.,      */,         this(dd, permUUID, null, null, null, null, null, false);,     }, ,     public String getObjectType() {,         return objectType;,     }, ,     public UUID getPermObjectId() {,         return permObjectId;,     }, ,     public String getPermission() {,         return permission;,     }, ,     public boolean isGrantable() {,         return grantable;,     }, ,     public int getCatalogNumber() {,         return DataDictionary.SYSPERMS_CATALOG_NUM;,     }, ,     public String toString() {,         if (SanityManager.DEBUG) {,             return "permUUID: " + oid + "\n" +,                     "objectType: " + objectType + "\n" +,                     "permObjectId: " + permObjectId + "\n" +,                     "permission: " + permission + "\n" +,                     "grantable: " + grantable + "\n";,         } else {,             return "";,         },     }, ,     /**,      * @return true iff the key part of this perm descriptor equals the key part of another perm,      *         descriptor.,      */,     public boolean equals(Object other) {,         if (!(other instanceof PermDescriptor)),             return false;,         PermDescriptor otherPerm = (PermDescriptor) other;,         return super.keyEquals(otherPerm) &&,                 permObjectId.equals(otherPerm.permObjectId);,     }, ,     /**,      * @return the hashCode for the key part of this permissions descriptor,      */,     public int hashCode() {,         return super.keyHashCode() + permObjectId.hashCode();,     }, ,     /**,      * @see PermissionsDescriptor#checkOwner,      */,     public boolean checkOwner( String authorizationId ) throws StandardException,     {,         DataDictionary dd = getDataDictionary();,         PrivilegedSQLObject pso = getProtectedObject( dd, permObjectId, objectType );,         ,         return pso.getSchemaDescriptor().getAuthorizationId().equals(authorizationId);,     }, ,     /**,      * Get the protected object.,      *,      * @param dd Metadata,      * @param objectID Unique handle on the protected object,      * @param objectType Type of the object,      */,     public static PrivilegedSQLObject getProtectedObject,         ( DataDictionary dd, UUID objectID, String objectType ) throws StandardException,     {,         if ( PermDescriptor.SEQUENCE_TYPE.equals( objectType ) ),         {,             return dd.getSequenceDescriptor( objectID );,         },         else if ( PermDescriptor.AGGREGATE_TYPE.equals( objectType ) ),         {,             return dd.getAliasDescriptor( objectID );,         },         else if ( PermDescriptor.UDT_TYPE.equals( objectType ) ),         {,             return dd.getAliasDescriptor( objectID );,         },         else,         {,             // oops, still need to implement support for this kind,             // of privileged object,             throw StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );,         },     }, ,     //////////////////////////////////////////////,     //,     // PROVIDER INTERFACE,     //,     //////////////////////////////////////////////, ,     /**,      * Return the name of this Provider.  (Useful for errors.),      *,      * @return String   The name of this provider.,      */,     public String getObjectName(),     {,         try {,             DataDictionary dd = getDataDictionary();,             PrivilegedSQLObject pso = getProtectedObject( dd, permObjectId, objectType );,         ,             return pso.getName();,         } catch (StandardException se) { return objectType; },     }, ,     /**,      * Get the provider's type.,      *,      * @return char         The provider's type.,      */,     public String getClassType() {,         return Dependable.PERM;,     }, ,     /**,      * @return the stored form of this provider,      * @see Dependable#getDependableFinder,      */,     public DependableFinder getDependableFinder() {,         return getDependableFinder(],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/iapi/sql/dictionary/ReferencedKeyConstraintDescriptor.java,,120-120,[		if (checkedSelfReferencing)],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/iapi/sql/dictionary/SPSDescriptor.java,,1089-1089,[		if (preparedStatement != null)],,,1091-1091,[			((StorablePreparedStatement)preparedStatement).loadGeneratedClass();],,,791-791,[		return preparedStatement;],,,682-682,[		if (recompIfInvalid &&],,,373-373,[			preparedStatement = (ExecPreparedStatement) stmt.prepareStorable(],,,393-393,[		if (preparedStatement.referencesSessionSchema())],,,397-397,[		setParams(preparedStatement.getParameterTypes());],,,419-419,[			dm.copyDependencies(preparedStatement, 	// from],,,1026-1026,[                    preparedStatement = null;],,,816-816,[				"\tname: "+sd.getSchemaName()+"."+name+"\n"+],,,266-266,[		preparedStatement.makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java,,73-313,[        super(dataDictionary);,         if (SanityManager.DEBUG) {,             if (sd.getSchemaName() == null) {,                 SanityManager.THROWASSERT("new SequenceDescriptor() schema " +,                         "name is null for Sequence " + sequenceName);,             },         },         this.sequenceUUID = sequenceUUID;,         this.schemaDescriptor = sd;,         this.sequenceName = sequenceName;,         this.schemaId = sd.getUUID();,         this.dataType = dataType;,         this.currentValue = currentValue;,         this.startValue = startValue;,         this.minimumValue = minimumValue;,         this.maximumValue = maximumValue;,         this.increment = increment;,         this.canCycle = canCycle;,     }, ,    /**, 	 * @see UniqueTupleDescriptor#getUUID, 	 */, 	public UUID	getUUID(), 	{, 		return sequenceUUID;, 	}, ,    /**, 	 * @see PrivilegedSQLObject#getObjectTypeName, 	 */, 	public String getObjectTypeName(), 	{, 		return PermDescriptor.SEQUENCE_TYPE;, 	}, ,     public String toString() {,         if (SanityManager.DEBUG) {,             return "sequenceUUID: " + sequenceUUID + "\n" +,                     "sequenceName: " + sequenceName + "\n" +,                     "schemaId: " + schemaId + "\n" +,                     "dataType: " + dataType.getTypeName() + "\n" +,                     "currentValue: " + currentValue + "\n" +,                     "startValue: " + startValue + "\n" +,                     "minimumValue: " + minimumValue + "\n" +,                     "maximumValue: " + maximumValue + "\n" +,                     "increment: " + increment + "\n" +,                     "canCycle: " + canCycle + "\n";,         } else {,             return "";,         },     }, ,     /**,      * Drop this sequence descriptor. Only restricted drops allowed right now.,      *,      * @throws StandardException Could not be dropped.,      */,     public void drop(LanguageConnectionContext lcc) throws StandardException,     {,         DataDictionary dd = getDataDictionary();,         DependencyManager dm = getDataDictionary().getDependencyManager();,         TransactionController tc = lcc.getTransactionExecute();, ,         // invalidate compiled statements which depend on this sequence,         dm.invalidateFor(this, DependencyManager.DROP_SEQUENCE, lcc);, ,         // drop the sequence,         dd.dropSequenceDescriptor(this, tc);, ,         // Clear the dependencies for the sequence,         dm.clearDependencies(lcc, this);, ,     }, ,     /**, 	 * Check that all of the dependent's dependencies are valid., 	 *, 	 * @return true if the dependent is currently valid, 	 */, 	public synchronized boolean isValid(), 	{, 		return true;, 	}, ,     /**, 	 * Prepare to mark the dependent as invalid (due to at least one of, 	 * its dependencies being invalid)., 	 *, 	 * @param action	The action causing the invalidation, 	 * @param p			the provider, 	 * @param lcc		the language connection context, 	 *, 	 * @exception StandardException thrown if unable to make it invalid, 	 */, 	public void prepareToInvalidate, 	(, 		Provider 					p,, 		int							action,, 		LanguageConnectionContext	lcc, 	) throws StandardException, 	{, 		switch (action), 		{   			, 			default:, 				break;, 		}, 	},     /**, 	 * Mark the dependent as invalid (due to at least one of, 	 * its dependencies being invalid)., 	 *, 	 * @param 	lcc the language connection context, 	 * @param	action	The action causing the invalidation, 	 *, 	 * @exception StandardException thrown if called in sanity mode, 	 */, 	public void makeInvalid(int action, LanguageConnectionContext lcc) throws StandardException, 	{, 		switch (action), 		{, 			// invalidate this sequence descriptor, 			case DependencyManager.USER_RECOMPILE_REQUEST:, 				DependencyManager dm = getDataDictionary().getDependencyManager();, 				dm.invalidateFor(this, DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);, 				break;, , 			default:, 				break;, 		}, , 	}, ,     public String getName() {,         return sequenceName;,     }, ,     public SchemaDescriptor getSchemaDescriptor() throws StandardException {,         return schemaDescriptor;,     }, ,     /**,      * @see TupleDescriptor#getDescriptorType,      */,     public String getDescriptorType() {,         return "Sequence";,     }, ,     /**,      * @see TupleDescriptor#getDescriptorName,      */,     public String getDescriptorName() {,         return sequenceName; }, ,     //////////////////////////////////////////////,     //,     // PROVIDER INTERFACE,     //,     //////////////////////////////////////////////, ,     /**,      * Get the provider's UUID,      *,      * @return The provider's UUID,      */,     public UUID getObjectID() {,         return sequenceUUID;,     }, ,     /**,      * Is this provider persistent?  A stored dependency will be required,      * if both the dependent and provider are persistent.,      *,      * @return boolean              Whether or not this provider is persistent.,      */,     public boolean isPersistent() {,         return true;,     }, ,     /**,      * Return the name of this Provider.  (Useful for errors.),      *,      * @return String   The name of this provider.,      */,     public String getObjectName() {,         return (sequenceName);,     }, ,     /**,      * Get the provider's type.,      *,      * @return char         The provider's type.,      */,     public String getClassType() {,         return Dependable.SEQUENCE;,     }, ,     /**,      * @return the stored form of this provider,      * @see Dependable#getDependableFinder,      */,     public DependableFinder getDependableFinder() {,         return getDependableFinder(,                 StoredFormatIds.SEQUENCE_DESCRIPTOR_FINDER_V01_ID);,     }, ,     /*Accessor methods*/,     public String getSequenceName() {,         return sequenceName;,     }, ,     public UUID getSchemaId() {,         return schemaId;,     }, ,     public DataTypeDescriptor getDataType() {,         return dataType;,     }, ,     public Long getCurrentValue() {,         return currentValue;,     }, ,     public long getStartValue() {,         return startValue;,     }, ,     public long getMinimumValue() {,         return minimumValue;,     }, ,     public long getMaximumValue() {,         return maximumValue;,     }, ,     public long getIncrement() {,         return increment;,     }, ,     public boolean canCycle() {,         return canCycle;],,
STYLE,UC_USELESS_VOID_METHOD,org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java,prepareToInvalidate,180-180,[	}],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/derby/iapi/sql/dictionary/StatementColumnPermission.java,equals,78-85,[		if( obj instanceof StatementColumnPermission), 		{, 			StatementColumnPermission other = (StatementColumnPermission) obj;, 			if( ! columns.equals( other.columns)), 				return false;, 			return super.equals( obj);, 		}, 		return false;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/iapi/sql/dictionary/StatementColumnPermission.java,check,108-108,[			permittedColumns = addPermittedColumns( dd,],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/iapi/sql/dictionary/StatementPermission.java,genericCheck,115-115,[		TransactionController tc = lcc.getTransactionExecute();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/iapi/sql/dictionary/StatementRolePermission.java,check,61-61,[        DataDictionary dd = lcc.getDataDictionary();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/iapi/sql/dictionary/StatementRolePermission.java,check,62-62,[        TransactionController tc = lcc.getTransactionExecute();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/sql/dictionary/StatementTablePermission.java,oneAuthHasPermissionOnTable,245-264,[		switch( privType), 		{, 		case Authorizer.SELECT_PRIV:, 		case Authorizer.MIN_SELECT_PRIV:, 			priv = perms.getSelectPriv();, 			break;, 		case Authorizer.UPDATE_PRIV:, 			priv = perms.getUpdatePriv();, 			break;, 		case Authorizer.REFERENCES_PRIV:, 			priv = perms.getReferencesPriv();, 			break;, 		case Authorizer.INSERT_PRIV:, 			priv = perms.getInsertPriv();, 			break;, 		case Authorizer.DELETE_PRIV:, 			priv = perms.getDeletePriv();, 			break;, 		case Authorizer.TRIGGER_PRIV:, 			priv = perms.getTriggerPriv();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/sql/dictionary/TableDescriptor.java,getAutoincIncrementArray,1282-1282,[			return null;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/sql/dictionary/TriggerDescriptorList.java,,26-27,[        super();,     }],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/iapi/sql/execute/ExecRowBuilder.java,setColumn,106-106,[            SanityManager.THROWASSERT(],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/store/access/BackingStoreHashtable.java,<init>,235-235,[        this.key_column_numbers    = key_column_numbers;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/store/access/BackingStoreHashtable.java,,1125-1129,[    private static class RowList extends ArrayList<Object> {, ,         private RowList(int initialCapacity) {,             super(initialCapacity);,         }],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/store/access/DiskHashtable.java,<init>,92-92,[        this.key_column_numbers         = key_column_numbers;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/iapi/store/access/DiskHashtable.java,nextElement,486-486,[                    catch( StandardException se1){};],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/iapi/store/access/GlobalXact.java,toString,89-89,[                    globalhex += Integer.toHexString(mask);],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/iapi/store/access/RowUtil.java,toString,500-500,[                    str += "\n";],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/iapi/store/access/RowUtil.java,toString,458-458,[                        str += "col[" + i + "]=" + row[i];],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/derby/iapi/store/access/xa/XAXactId.java,equals,248-279,[		if (other == this), 			return true;, , 		if (other == null), 			return false;, 	, 		try, 	    {, 			if (other instanceof GlobalXact), 				return super.equals(other);, 			// Just cast it and catch the exception rather than doing the type, 			// checking twice., 			Xid other_xid = (Xid) other;, 		, 			return(, 				   java.util.Arrays.equals(, 									other_xid.getGlobalTransactionId(),, 									this.global_id)          &&, 				   java.util.Arrays.equals(, 									other_xid.getBranchQualifier(),, 									this.branch_id)          &&, 				   other_xid.getFormatId() == this.format_id);, 		, 	    }, 		catch(ClassCastException cce), 	    {, 			// this class only knows how to compare with other Xids, 			if (SanityManager.DEBUG), 				SanityManager.THROWASSERT("comparing XAXactId with " + , 										  other.getClass().getName(), cce); , 		, 			return false;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/store/raw/ContainerKey.java,lockAttributes,180-180,[					   new Long(getContainerId()));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/iapi/store/raw/ContainerKey.java,getContainerId,59-59,[		return containerId;],,getContainerid,571-571,[        return(this.id.getContainerId());],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/iapi/store/raw/FetchDescriptor.java,getMaterializedColumns,171-171,[        return(materialized_cols);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/iapi/store/raw/FetchDescriptor.java,getQualifierList,162-162,[        return(qualifier_list);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/iapi/store/raw/FetchDescriptor.java,getValidColumnsArray,125-125,[        return(validColumnsArray);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/store/raw/FetchDescriptor.java,<init>,92-92,[        qualifier_list  = input_qualifier_list;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/store/raw/xact/RawTransaction.java,<clinit>,69-69,[	public static final Integer		COMMIT =             new Integer(0);],,<clinit>,70-70,[	public static final Integer		ABORT =              new Integer(1);],,<clinit>,71-71,[	public static final Integer     SAVEPOINT_ROLLBACK = new Integer(2);],,<clinit>,72-72,[	public static final Integer		LOCK_ESCALATE      = new Integer(3);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/iapi/tools/i18n/LocalizedInput.java,<init>,32-32,[		super(new InputStreamReader(i));],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/iapi/tools/i18n/LocalizedOutput.java,<init>,31-31,[		super(new OutputStreamWriter(o), true);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/iapi/tools/i18n/LocalizedResource.java,,426-426,[		String s = System.getProperty(resourceKey);],,,416-416,[				resourceKey =  key;],,,455-455,[			"locale=" + (locale==null?"null":locale.toString()) + "\n" +],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/iapi/tools/i18n/LocalizedResource.java,getInstance,75-76,[		if (local == null){, 			local = new  LocalizedResource();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/iapi/tools/i18n/LocalizedResource.java,InputReader,445-445,[		return getInstance().in;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/iapi/tools/i18n/LocalizedResource.java,OutputWriter,442-442,[		return getInstance().out;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/iapi/tools/i18n/LocalizedResource.java,getNewLocale,264-264,[			} catch (Exception e) {],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/iapi/tools/i18n/LocalizedResource.java,getTextMessage,277-277,[						tmpFormat = tmpFormat + ", <{" + (i) + "}>";],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/iapi/tools/run.java,,50-91,[      if (args.length < 1) {,           printUsage();,       } else if (args[0].equals("ij")) {,           ij.main(trimArgs(args));,       } else if (args[0].equals("sysinfo")) {,           sysinfo.main(trimArgs(args));,       } else if (args[0].equals("dblook")) {,           dblook.main(trimArgs(args));,       } else if (args[0].equals("server")) {,           NetworkServerControl.main(trimArgs(args));,       } else if (args[0].equals("SignatureChecker")) {,           SignatureChecker.main(trimArgs(args));,       } else printUsage();,   }, ,   /**,        Private constructor. No instances allowed.,    */,   private run() { ,   },   ,   /**,        Utility method to trim one element off of the argument array.,        @param args the arguments array,        @return trimmed the trimmed array,    */,   private static String[] trimArgs(String[] args),   {,       String [] trimmed = new String[args.length - 1];,       System.arraycopy(args, 1, trimmed, 0, args.length - 1);,       return trimmed; ,   }, ,   /**,        Print the usage statement if the user didn't enter a valid choice,        of tool.,    */,   public static void printUsage(),   {,       LocalizedResource locRes = LocalizedResource.getInstance();,       System.err.println(locRes.getTextMessage("RUN_Usage"));,   }],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/iapi/transaction/TransactionControl.java,preRollbackNotify,181-181,[                if (se.getSeverity() < ExceptionSeverity.TRANSACTION_SEVERITY)],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/derby/iapi/types/ClobStreamHeaderGenerator.java,generateInto,168-168,[        if (isPreDerbyTenFive == Boolean.FALSE) {],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/derby/iapi/types/ClobStreamHeaderGenerator.java,generateInto,132-132,[        if (isPreDerbyTenFive == Boolean.FALSE) {],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/CollatorSQLChar.java,hashCode,167-167,[         return hashCodeForCollation();],,
BAD_PRACTICE,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,org/apache/derby/iapi/types/CollatorSQLChar.java,,54-202,[    {,         setCollator(collatorForCharacterDatatypes);,     },     ,     /**,      * Create SQL CHAR value initially set to value that,      * performs collation according to collatorForCharacterDatatypes ,      */, 	CollatorSQLChar(String val, RuleBasedCollator collatorForCharacterDatatypes), 	{, 		super(val);,         setCollator(collatorForCharacterDatatypes);, 	}, , 	/**, 	 * Set the RuleBasedCollator for this instance of CollatorSQLChar. It will, 	 * be used to do the collation., 	 */, 	private void setCollator(RuleBasedCollator collatorForCharacterDatatypes), 	{, 		holderForCollationSensitiveInfo = , 			new WorkHorseForCollatorDatatypes(collatorForCharacterDatatypes, this);, 	}, , 	/**, 	 * Get the RuleBasedCollator for this instance of CollatorSQLChar. It , 	 * will be used to do the collation., 	 * , 	 * @return	The Collator object which should be used for collation , 	 * operation on this object, 	 */, 	protected RuleBasedCollator getCollatorForCollation() throws StandardException, 	{, 		return holderForCollationSensitiveInfo.getCollatorForCollation();, 	}, ,     // Implementation of CollationElementsInterface interface, ,     public boolean hasSingleCollationElement() throws StandardException {,         return holderForCollationSensitiveInfo.hasSingleCollationElement();,     }, , 	/*, 	 * DataValueDescriptor interface, 	 */, ,     /**,      * @see DataValueDescriptor#cloneValue,      */,     public DataValueDescriptor cloneValue(boolean forceMaterialization), 	{, 		try, 		{, 			return new CollatorSQLChar(getString(), , 					holderForCollationSensitiveInfo.getCollatorForCollation());, 		}, 		catch (StandardException se), 		{, 			if (SanityManager.DEBUG), 				SanityManager.THROWASSERT("Unexpected exception", se);, 			return null;, 		}, 	}, , 	/**, 	 * @see DataValueDescriptor#getNewNull, 	 */, 	public DataValueDescriptor getNewNull(), 	{, 		CollatorSQLChar result = new CollatorSQLChar(, 				holderForCollationSensitiveInfo.getCollatorForCollation());, 		return result;, 	}, , 	/**, 	 * We do not anticipate this method on collation sensitive DVD to be, 	 * ever called in Derby 10.3 In future, when Derby will start supporting, 	 * SQL standard COLLATE clause, this method might get called on the, 	 * collation sensitive DVDs., 	 *  , 	 * @see StringDataValue#getValue(RuleBasedCollator) , 	 */, 	public StringDataValue getValue(RuleBasedCollator collatorForComparison), 	{, 		if (collatorForComparison != null), 		{, 			//non-null collatorForComparison means use this collator sensitive, 			//implementation of SQLChar, 		    setCollator(collatorForComparison);, 		    return this;			, 		} else {, 			//null collatorForComparison means use UCS_BASIC for collation., 			//For that, we need to use the base class SQLChar, 			SQLChar s = new SQLChar();, 			s.copyState(this);, 			return s;, 		}, 	}, 	, 	/** @see SQLChar#stringCompare(SQLChar, SQLChar) */, 	 protected int stringCompare(SQLChar char1, SQLChar char2), 	 throws StandardException, 	 {, 		 return holderForCollationSensitiveInfo.stringCompare(char1, char2);, 	 }, ,      /**,       * Return a hash code that is consistent with,       * {@link #stringCompare(SQLChar, SQLChar)}.,       *,       * @return hash code,       */,      public int hashCode() {,          return hashCodeForCollation();,      }, , 	/**, 	 * This method implements the like function for char (with no escape value)., 	 * The difference in this method and the same method in superclass is that, 	 * here we use special Collator object to do the comparison rather than, 	 * using the Collator object associated with the default jvm locale., 	 *, 	 * @param pattern		The pattern to use, 	 *, 	 * @return	A SQL boolean value telling whether the first operand is, 	 *			like the second operand, 	 *, 	 * @exception StandardException		Thrown on error, 	 */, 	public BooleanDataValue like(DataValueDescriptor pattern), 								throws StandardException, 	{, 		return(holderForCollationSensitiveInfo.like(pattern));, 	}, 	, 	/**, 	 * This method implements the like function for char with an escape value., 	 * , 	 * @param pattern		The pattern to use, 	 * 								 , 	 * @return	A SQL boolean value telling whether the first operand is, 	 * like the second operand, 	 *, 	 * @exception StandardException		Thrown on error, 	 */, 	public BooleanDataValue like(DataValueDescriptor pattern,, 			DataValueDescriptor escape) throws StandardException, 	{, 		return(holderForCollationSensitiveInfo.like(pattern, escape));],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/CollatorSQLClob.java,hashCode,189-189,[         return hashCodeForCollation();],,
BAD_PRACTICE,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,org/apache/derby/iapi/types/CollatorSQLClob.java,,57-224,[    {,         setCollator(collatorForCharacterDatatypes);,     },     ,     /**,      * Create SQL CLOB value initially set to value that,      * performs collation according to collatorForCharacterDatatypes ,      */, 	CollatorSQLClob(String val, RuleBasedCollator collatorForCharacterDatatypes), 	{, 		super(val);,         setCollator(collatorForCharacterDatatypes);, 	}, ,     /**,      * Create SQL CLOB value initially set to value that,      * performs collation according to collatorForCharacterDatatypes ,      */, 	CollatorSQLClob(Clob val, RuleBasedCollator collatorForCharacterDatatypes), 	{, 		super(val);,         setCollator(collatorForCharacterDatatypes);, 	}, , 	/**, 	 * Set the RuleBasedCollator for this instance of CollatorSQLClob. It will, 	 * be used to do the collation., 	 */, 	private void setCollator(RuleBasedCollator collatorForCharacterDatatypes), 	{, 		holderForCollationSensitiveInfo = , 			new WorkHorseForCollatorDatatypes(collatorForCharacterDatatypes, this);, 	}, , 	/**, 	 * Get the RuleBasedCollator for this instance of CollatorSQLClob. It , 	 * will be used to do the collation., 	 * , 	 * @return	The Collator object which should be used for collation , 	 * operation on this object, 	 */, 	protected RuleBasedCollator getCollatorForCollation() throws StandardException, 	{, 		return holderForCollationSensitiveInfo.getCollatorForCollation();, 	}, 	,     // Implementation of CollationElementsInterface interface, ,     public boolean hasSingleCollationElement() throws StandardException {,         return holderForCollationSensitiveInfo.hasSingleCollationElement();,     }, , 	/*, 	 * DataValueDescriptor interface, 	 */, ,     /**,      * @see DataValueDescriptor#cloneValue,      */,     public DataValueDescriptor cloneValue(boolean forceMaterialization), 	{,         if (forceMaterialization) {,             try {,                 return new CollatorSQLClob(getString(),,                     holderForCollationSensitiveInfo.getCollatorForCollation());,             },             catch (StandardException se),             {,                 if (SanityManager.DEBUG),                     SanityManager.THROWASSERT("Unexpected exception", se);,                 return null;,             },         } else {,             // If materialization isn't forced, let SQLClob (super) decide how,             // to clone the value.,            SQLClob clob = (SQLClob)super.cloneValue(forceMaterialization);,            CollatorSQLClob clone = new CollatorSQLClob(,                    holderForCollationSensitiveInfo.getCollatorForCollation());,            clone.copyState(clob);,            return clone;,         }, 	}, , 	/**, 	 * @see DataValueDescriptor#getNewNull, 	 */, 	public DataValueDescriptor getNewNull(), 	{, 		CollatorSQLClob result = new CollatorSQLClob((String) null,, 				holderForCollationSensitiveInfo.getCollatorForCollation());, 		return result;, 	}, , 	/**, 	 * We do not anticipate this method on collation sensitive DVD to be, 	 * ever called in Derby 10.3 In future, when Derby will start supporting, 	 * SQL standard COLLATE clause, this method might get called on the, 	 * collation sensitive DVDs., 	 *  , 	 * @see StringDataValue#getValue(RuleBasedCollator) , 	 */, 	public StringDataValue getValue(RuleBasedCollator collatorForComparison), 	{, 		if (collatorForComparison != null), 		{, 			//non-null collatorForComparison means use this collator sensitive, 			//implementation of SQLClob, 		    setCollator(collatorForComparison);, 		    return this;			, 		} else {, 			//null collatorForComparison means use UCS_BASIC for collation., 			//For that, we need to use the base class SQLClob, 			SQLClob s = new SQLClob();, 			s.copyState(this);, 			return s;, 		}, 	}, 	, 	/** @see SQLChar#stringCompare(SQLChar, SQLChar) */, 	 protected int stringCompare(SQLChar char1, SQLChar char2), 	 throws StandardException, 	 {, 		 return holderForCollationSensitiveInfo.stringCompare(char1, char2);, 	 }, ,      /**,       * Return a hash code that is consistent with,       * {@link #stringCompare(SQLChar, SQLChar)}.,       *,       * @return hash code,       */,      public int hashCode() {,          return hashCodeForCollation();,      }, , 	/**, 	 * This method implements the like function for char (with no escape value)., 	 * The difference in this method and the same method in superclass is that, 	 * here we use special Collator object to do the comparison rather than, 	 * using the Collator object associated with the default jvm locale., 	 *, 	 * @param pattern		The pattern to use, 	 *, 	 * @return	A SQL boolean value telling whether the first operand is, 	 *			like the second operand, 	 *, 	 * @exception StandardException		Thrown on error, 	 */, 	public BooleanDataValue like(DataValueDescriptor pattern), 								throws StandardException, 	{, 		return(holderForCollationSensitiveInfo.like(pattern));, 	}, 	, 	/**, 	 * This method implements the like function for char with an escape value., 	 * , 	 * @param pattern		The pattern to use, 	 * 								 , 	 * @return	A SQL boolean value telling whether the first operand is, 	 * like the second operand, 	 *, 	 * @exception StandardException		Thrown on error, 	 */, 	public BooleanDataValue like(DataValueDescriptor pattern,, 			DataValueDescriptor escape) throws StandardException, 	{, 		return(holderForCollationSensitiveInfo.like(pattern, escape));],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/CollatorSQLLongvarchar.java,hashCode,169-169,[         return hashCodeForCollation();],,
BAD_PRACTICE,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,org/apache/derby/iapi/types/CollatorSQLLongvarchar.java,,56-204,[	{,         setCollator(collatorForCharacterDatatypes);, 	},     ,     /**,      * Create SQL LONG VARCHAR value initially set to value that,      * performs collation according to collatorForCharacterDatatypes ,      */, 	CollatorSQLLongvarchar(String val, RuleBasedCollator collatorForCharacterDatatypes), 	{, 		super(val);, 		setCollator(collatorForCharacterDatatypes);, 	}, , 	/**, 	 * Set the RuleBasedCollator for this instance of CollatorSQLLongvarchar. , 	 * It will be used to do the collation., 	 */, 	protected void setCollator(RuleBasedCollator collatorForCharacterDatatypes), 	{, 		holderForCollationSensitiveInfo = , 			new WorkHorseForCollatorDatatypes(collatorForCharacterDatatypes, this);, 	}, , 	/**, 	 * Get the RuleBasedCollator for this instance of CollatorSQLLongvarchar. , 	 * It will be used to do the collation., 	 * , 	 * @return	The Collator object which should be used for collation , 	 * operation on this object, 	 */, 	protected RuleBasedCollator getCollatorForCollation() throws StandardException, 	{, 		return holderForCollationSensitiveInfo.getCollatorForCollation();, 	}, 	,     // Implementation of CollationElementsInterface interface, ,     public boolean hasSingleCollationElement() throws StandardException {,         return holderForCollationSensitiveInfo.hasSingleCollationElement();,     }, , 	/*, 	 * DataValueDescriptor interface, 	 */, ,     /**,      * @see DataValueDescriptor#cloneValue,      */,     public DataValueDescriptor cloneValue(boolean forceMaterialization), 	{, 		try, 		{, 			return new CollatorSQLLongvarchar(getString(), , 					holderForCollationSensitiveInfo.getCollatorForCollation());, 		}, 		catch (StandardException se), 		{, 			if (SanityManager.DEBUG), 				SanityManager.THROWASSERT("Unexpected exception", se);, 			return null;, 		}, 	}, , 	/**, 	 * @see DataValueDescriptor#getNewNull, 	 */, 	public DataValueDescriptor getNewNull(), 	{, 		CollatorSQLLongvarchar result = new CollatorSQLLongvarchar(, 				holderForCollationSensitiveInfo.getCollatorForCollation());, 		return result;, 	}, , 	/**, 	 * We do not anticipate this method on collation sensitive DVD to be, 	 * ever called in Derby 10.3 In future, when Derby will start supporting, 	 * SQL standard COLLATE clause, this method might get called on the, 	 * collation sensitive DVDs., 	 *  , 	 * @see StringDataValue#getValue(RuleBasedCollator) , 	 */, 	public StringDataValue getValue(RuleBasedCollator collatorForComparison), 	{, 		if (collatorForComparison != null), 		{, 			//non-null collatorForComparison means use this collator sensitive, 			//implementation of SQLLongvarchar, 		    setCollator(collatorForComparison);, 		    return this;			, 		} else {, 			//null collatorForComparison means use UCS_BASIC for collation., 			//For that, we need to use the base class SQLLongvarchar, 			SQLLongvarchar s = new SQLLongvarchar();, 			s.copyState(this);, 			return s;, 		}, 	}, 	, 	/** @see SQLChar#stringCompare(SQLChar, SQLChar) */, 	 protected int stringCompare(SQLChar char1, SQLChar char2), 	 throws StandardException, 	 {, 		 return holderForCollationSensitiveInfo.stringCompare(char1, char2);, 	 }, ,     /**,       * Return a hash code that is consistent with,       * {@link #stringCompare(SQLChar, SQLChar)}.,       *,       * @return hash code,       */,      public int hashCode() {,          return hashCodeForCollation();,      }, , 	/**, 	 * This method implements the like function for char (with no escape value)., 	 * The difference in this method and the same method in superclass is that, 	 * here we use special Collator object to do the comparison rather than, 	 * using the Collator object associated with the default jvm locale., 	 *, 	 * @param pattern		The pattern to use, 	 *, 	 * @return	A SQL boolean value telling whether the first operand is, 	 *			like the second operand, 	 *, 	 * @exception StandardException		Thrown on error, 	 */, 	public BooleanDataValue like(DataValueDescriptor pattern), 								throws StandardException, 	{, 		return(holderForCollationSensitiveInfo.like(pattern));, 	}, 	, 	/**, 	 * This method implements the like function for char with an escape value., 	 * , 	 * @param pattern		The pattern to use, 	 * 								 , 	 * @return	A SQL boolean value telling whether the first operand is, 	 * like the second operand, 	 *, 	 * @exception StandardException		Thrown on error, 	 */, 	public BooleanDataValue like(DataValueDescriptor pattern,, 			DataValueDescriptor escape) throws StandardException, 	{, 		return(holderForCollationSensitiveInfo.like(pattern, escape));],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/CollatorSQLVarchar.java,hashCode,175-175,[         return hashCodeForCollation();],,
BAD_PRACTICE,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,org/apache/derby/iapi/types/CollatorSQLVarchar.java,,55-210,[    {,         setCollator(collatorForCharacterDatatypes);,     },     ,     /**,      * Create SQL VARCHAR value initially set to value that,      * performs collation according to collatorForCharacterDatatypes ,      */, 	CollatorSQLVarchar(String val, RuleBasedCollator collatorForCharacterDatatypes), 	{, 		super(val);,         setCollator(collatorForCharacterDatatypes);, 	}, , 	/**, 	 * Set the RuleBasedCollator for this instance of CollatorSQLVarchar. It will, 	 * be used to do the collation., 	 */, 	private void setCollator(RuleBasedCollator collatorForCharacterDatatypes), 	{, 		holderForCollationSensitiveInfo = , 			new WorkHorseForCollatorDatatypes(collatorForCharacterDatatypes, this);, 	}, , 	/**, 	 * Get the RuleBasedCollator for this instance of CollatorSQLVarchar. It , 	 * will be used to do the collation., 	 * , 	 * @return	The Collator object which should be used for collation , 	 * operation on this object, 	 */, 	protected RuleBasedCollator getCollatorForCollation() throws StandardException, 	{, 		return holderForCollationSensitiveInfo.getCollatorForCollation();, 	}, 	,     // Implementation of CollationElementsInterface interface, ,     public boolean hasSingleCollationElement() throws StandardException {,         return holderForCollationSensitiveInfo.hasSingleCollationElement();,     }, , 	/*, 	 * DataValueDescriptor interface, 	 */, ,     /**,      * @see DataValueDescriptor#cloneValue,      */,     public DataValueDescriptor cloneValue(boolean forceMaterialization), 	{, 		try, 		{, 			return new CollatorSQLVarchar(getString(), , 					holderForCollationSensitiveInfo.getCollatorForCollation());, 		}, 		catch (StandardException se), 		{, 			if (SanityManager.DEBUG), 				SanityManager.THROWASSERT("Unexpected exception", se);, 			return null;, 		}, 	}, , 	/**, 	 * @see DataValueDescriptor#getNewNull, 	 */, 	public DataValueDescriptor getNewNull(), 	{, 		CollatorSQLVarchar result = new CollatorSQLVarchar(, 				holderForCollationSensitiveInfo.getCollatorForCollation());, 		return result;, 	}, , 	protected StringDataValue getNewVarchar() throws StandardException, 	{, 		CollatorSQLVarchar result = new CollatorSQLVarchar(, 				holderForCollationSensitiveInfo.getCollatorForCollation());, 		return result;, 	}, , 	/**, 	 * We do not anticipate this method on collation sensitive DVD to be, 	 * ever called in Derby 10.3 In future, when Derby will start supporting, 	 * SQL standard COLLATE clause, this method might get called on the, 	 * collation sensitive DVDs., 	 *  , 	 * @see StringDataValue#getValue(RuleBasedCollator) , 	 */, 	public StringDataValue getValue(RuleBasedCollator collatorForComparison), 	{, 		if (collatorForComparison != null), 		{, 			//non-null collatorForComparison means use this collator sensitive, 			//implementation of SQLVarchar, 		    setCollator(collatorForComparison);, 		    return this;			, 		} else {, 			//null collatorForComparison means use UCS_BASIC for collation., 			//For that, we need to use the base class SQLVarchar, 			SQLVarchar s = new SQLVarchar();, 			s.copyState(this);, 			return s;, 		}, 	}, 	, 	/** @see SQLChar#stringCompare(SQLChar, SQLChar) */, 	 protected int stringCompare(SQLChar char1, SQLChar char2), 	 throws StandardException, 	 {, 		 return holderForCollationSensitiveInfo.stringCompare(char1, char2);, 	 }, ,      /**,       * Return a hash code that is consistent with,       * {@link #stringCompare(SQLChar, SQLChar)}.,       *,       * @return hash code,       */,      public int hashCode() {,          return hashCodeForCollation();,      }, , 	/**, 	 * This method implements the like function for char (with no escape value)., 	 * The difference in this method and the same method in superclass is that, 	 * here we use special Collator object to do the comparison rather than, 	 * using the Collator object associated with the default jvm locale., 	 *, 	 * @param pattern		The pattern to use, 	 *, 	 * @return	A SQL boolean value telling whether the first operand is, 	 *			like the second operand, 	 *, 	 * @exception StandardException		Thrown on error, 	 */, 	public BooleanDataValue like(DataValueDescriptor pattern), 								throws StandardException, 	{, 		return(holderForCollationSensitiveInfo.like(pattern));, 	}, 	, 	/**, 	 * This method implements the like function for char with an escape value., 	 * , 	 * @param pattern		The pattern to use, 	 * 								 , 	 * @return	A SQL boolean value telling whether the first operand is, 	 * like the second operand, 	 *, 	 * @exception StandardException		Thrown on error, 	 */, 	public BooleanDataValue like(DataValueDescriptor pattern,, 			DataValueDescriptor escape) throws StandardException, 	{, 		return(holderForCollationSensitiveInfo.like(pattern, escape));],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/derby/iapi/types/DataType.java,equals,1226-1237,[		if (! (other instanceof DataValueDescriptor)), 		{, 			return false;, 		}, , 		try, 		{, 			return compare(ORDER_OP_EQUALS, (DataValueDescriptor) other, true, false);, 		}, 		catch (StandardException se), 		{, 			return false;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/iapi/types/DataTypeDescriptor.java,readExternal,1784-1784,[                    ((UserDefinedTypeIdImpl) typeDescriptor.getTypeId())],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/derby/iapi/types/DataTypeDescriptor.java,equals,1303-1307,[        if (!(other instanceof DataTypeDescriptor)),             return false;,         ,         DataTypeDescriptor odtd = (DataTypeDescriptor) other;,         return typeDescriptor.equals(odtd.typeDescriptor)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/iapi/types/DataValueFactoryImpl.java,verifyCollatorSupport,1053-1053,[					databaseLocale.toString());],,
BAD_PRACTICE,CN_IDIOM,org/apache/derby/iapi/types/HarmonySerialBlob.java,,63-265,[    public HarmonySerialBlob(Blob blob) throws SQLException {,         if (blob == null) { throw new IllegalArgumentException(); },         ,         this.blob = blob;,         buf = blob.getBytes(1, (int) blob.length());,         len = buf.length;,         origLen = len;,     }, ,     /**,      * Constructs an instance by the given <code>buf</code>,      * ,      * @param buf,      *            the given buffer,      */,     public HarmonySerialBlob(byte[] buf) {,         this.buf = new byte[buf.length];,         len = buf.length;,         origLen = len;,         System.arraycopy(buf, 0, this.buf, 0, (int) len);,     }, ,     /**,      * Returns an input stream of this SerialObject.,      * ,      * @throws SQLException,      *             if an error is encountered,      */,     public InputStream getBinaryStream() throws SQLException {,         return new ByteArrayInputStream(buf);,     }, ,     /**,      * Returns a copied array of this SerialObject, starting at the,      * <code> pos </code> with the given <code> length</code> number. If,      * <code> pos </code> + <code> length </code> - 1 is larger than the length,      * of this SerialObject array, the <code> length </code> will be shortened,      * to the length of array - <code>pos</code> + 1.,      * ,      * @param pos,      *            the starting position of the array to be copied.,      * @param length,      *            the total length of bytes to be copied,      * @throws SQLException,      *             if an error is encountered,      */,     public byte[] getBytes(long pos, int length) throws SQLException {, ,         if (pos < 1 || pos > len),         {,             throw makeSQLException( SQLState.BLOB_BAD_POSITION, new Object[] {new Long(pos)} );,         },         if (length < 0),         {,             throw makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Integer(length)} );,         }, ,         if (length > len - pos + 1) {,             length = (int) (len - pos + 1);,         },         byte[] copiedArray = new byte[length];,         System.arraycopy(buf, (int) pos - 1, copiedArray, 0, length);,         return copiedArray;,     }, ,     /**,      * Gets the number of bytes in this SerialBlob object.,      * ,      * @return an long value with the length of the SerialBlob in bytes,      * @throws SQLException,      *             if an error is encoutnered,      */,     public long length() throws SQLException {,         return len;,     }, ,     /**,      * Search for the position in this Blob at which a specified pattern begins,,      * starting at a specified position within the Blob.,      * ,      * @param pattern,      *            a Blob containing the pattern of data to search for in this,      *            Blob,      * @param start,      *            the position within this Blob to start the search, where the,      *            first position in the Blob is 1,      * @return a long value with the position at which the pattern begins. -1 if,      *         the pattern is not found in this Blob.,      * @throws SQLException,      *             if an error occurs accessing the Blob, or,      *             if an error is encountered,      */,     public long position(Blob pattern, long start) throws SQLException {,         byte[] patternBytes = pattern.getBytes(1, (int) pattern.length());,         return position(patternBytes, start);,     }, ,     /**,      * Search for the position in this Blob at which the specified pattern,      * begins, starting at a specified position within the Blob.,      * ,      * @param pattern,      *            a byte array containing the pattern of data to search for in,      *            this Blob,      * @param start,      *            the position within this Blob to start the search, where the,      *            first position in the Blob is 1,      * @return a long value with the position at which the pattern begins. -1 if,      *         the pattern is not found in this Blob.,      * @throws SQLException,      *             if an error is encountered, or,      *             if an error occurs accessing the Blob,      */,     public long position(byte[] pattern, long start) throws SQLException {,         if (start < 1 || len - (start - 1) < pattern.length) {,             return -1;,         }, ,         for (int i = (int) (start - 1); i <= (len - pattern.length); ++i) {,             if (match(buf, i, pattern)) {,                 return i + 1;,             },         },         return -1;,     }, ,     /*,      * Returns true if the bytes array contains exactly the same elements from,      * start position to start + subBytes.length as subBytes. Otherwise returns,      * false.,      */,     private boolean match(byte[] bytes, int start, byte[] subBytes) {,         for (int i = 0; i < subBytes.length;) {,             if (bytes[start++] != subBytes[i++]) {,                 return false;,             },         },         return true;,     }, ,     public OutputStream setBinaryStream(long pos) throws SQLException {,         if (blob == null) { throw new IllegalStateException(); },         OutputStream os = blob.setBinaryStream(pos);,         if (os == null) { throw new IllegalStateException(); },         return os;,     }, ,     public int setBytes(long pos, byte[] theBytes) throws SQLException {,         return setBytes(pos, theBytes, 0, theBytes.length);,     }, ,     public int setBytes(long pos, byte[] theBytes, int offset, int length),             throws SQLException {,         if (pos < 1 || length < 0 || pos > (len - length + 1)),         {,             throw makeSQLException( SQLState.BLOB_BAD_POSITION, new Object[] {new Long(pos)} );,         },         if (offset < 0 || length < 0 || offset > (theBytes.length - length)),         {,             throw makeSQLException( SQLState.BLOB_INVALID_OFFSET, new Object[] {new Integer(offset)} );,         },         System.arraycopy(theBytes, offset, buf, (int) pos - 1, length);,         return length;,     }, ,     public void truncate(long length) throws SQLException {,         if (length > this.len),         {,             throw makeSQLException( SQLState.BLOB_LENGTH_TOO_LONG, new Object[] {new Long(len)} );,         },         buf = getBytes(1, (int) length);,         len = length;,     }, ,     public void free() throws SQLException {,         throw new UnsupportedOperationException("Not supported");,     }, ,     public InputStream getBinaryStream(long pos, long length),             throws SQLException {,         if (len < 0),         {,             throw makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Long(len)} );,         },         if (length < 0),         {,             throw makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Long(length)} );,         },         if (pos < 1 || pos + length > len),         {,             throw makeSQLException( SQLState.POS_AND_LENGTH_GREATER_THAN_LOB, new Object[] {new Long(pos), new Long(length)} );,         },         return new ByteArrayInputStream(buf, (int) (pos - 1), (int) length);,     }, ,     /**,      * Create a SQLException from Derby message arguments.,      */,     public static SQLException makeSQLException( String messageID, Object[] args ),     {,         StandardException se = StandardException.newException( messageID, args );, ,         return new SQLException( se.getMessage(), se.getSQLState() );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/HarmonySerialBlob.java,getBinaryStream,245-245,[            throw makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Long(len)} );],,getBinaryStream,249-249,[            throw makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Long(length)} );],,getBinaryStream,253-253,[            throw makeSQLException( SQLState.POS_AND_LENGTH_GREATER_THAN_LOB, new Object[] {new Long(pos), new Long(length)} );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/HarmonySerialBlob.java,getBytes,117-117,[            throw makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Integer(length)} );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/HarmonySerialBlob.java,getBytes,113-113,[            throw makeSQLException( SQLState.BLOB_BAD_POSITION, new Object[] {new Long(pos)} );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/HarmonySerialBlob.java,setBytes,222-222,[            throw makeSQLException( SQLState.BLOB_INVALID_OFFSET, new Object[] {new Integer(offset)} );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/HarmonySerialBlob.java,setBytes,218-218,[            throw makeSQLException( SQLState.BLOB_BAD_POSITION, new Object[] {new Long(pos)} );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/HarmonySerialBlob.java,truncate,231-231,[            throw makeSQLException( SQLState.BLOB_LENGTH_TOO_LONG, new Object[] {new Long(len)} );],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE,org/apache/derby/iapi/types/HarmonySerialBlob.java,setBytes,220-220,[        if (offset < 0 || length < 0 || offset > (theBytes.length - length))],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/iapi/types/HarmonySerialBlob.java,setBytes,220-220,[        if (offset < 0 || length < 0 || offset > (theBytes.length - length))],,
BAD_PRACTICE,CN_IDIOM,org/apache/derby/iapi/types/HarmonySerialClob.java,,56-238,[    public HarmonySerialClob( String raw ) { this( raw.toCharArray() ); }, ,     public HarmonySerialClob(char[] ch) {,         buf = new char[ch.length];,         origLen = ch.length;,         len = origLen;,         System.arraycopy(ch, 0, buf, 0, (int) len);,     }, ,     public HarmonySerialClob(Clob clob) throws SQLException {,         Reader characterStream;, ,         if (clob == null) { throw new IllegalArgumentException(); },         if ((characterStream = clob.getCharacterStream()) == null,                 && clob.getAsciiStream() == null) { throw new IllegalArgumentException(); }, ,         this.clob = clob;,         origLen = clob.length();,         len = origLen;,         buf = new char[(int) len];,         try {,             characterStream.read(buf);,         } catch (IOException e) {,             SQLException se = new SQLException("SerialClob: ",                     + e.getMessage());, ,             se.initCause(e);,             throw se;,         },     }, ,     public long length() throws SQLException {,         checkValidation();,         return len;,     }, ,     public InputStream getAsciiStream() throws SQLException {,         checkValidation();,         if (clob == null) { throw new IllegalStateException(); },         return clob.getAsciiStream();,     }, ,     public Reader getCharacterStream() throws SQLException {,         checkValidation();,         return new CharArrayReader(buf);,     }, ,     public String getSubString(long pos, int length) throws SQLException {,         checkValidation();,         if (length < 0),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Integer(length)} );,         },         if (pos < 1 || pos > len || pos + length > len + 1),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_BAD_POSITION, new Object[] {new Long(pos)} );,         },         try {,             return new String(buf, (int) (pos - 1), length);,         } catch (StringIndexOutOfBoundsException e) {,             throw new SQLException();,         },     }, ,     public long position(Clob searchClob, long start) throws SQLException {,         checkValidation();,         String searchString = searchClob.getSubString(1, (int) searchClob,                 .length());,         return position(searchString, start);,     }, ,     public long position(String searchString, long start),             throws SQLException, SQLException {,         checkValidation();,         if (start < 1 || len - (start - 1) < searchString.length()) {,             return -1;,         },         char[] pattern = searchString.toCharArray();,         for (int i = (int) start - 1; i < len; i++) {,             if (match(buf, i, pattern)) {,                 return i + 1;,             },         },         return -1;,     }, ,     /*,      * Returns true if the chars array contains exactly the same elements from,      * start position to start + pattern.length as pattern. Otherwise returns,      * false.,      */,     private boolean match(char[] chars, int start, char[] pattern) {,         for (int i = 0; i < pattern.length;) {,             if (chars[start++] != pattern[i++]) {,                 return false;,             },         },         return true;,     }, ,     public OutputStream setAsciiStream(long pos) throws SQLException {,         checkValidation();,         if (clob == null) { throw new IllegalStateException(); },         OutputStream os = clob.setAsciiStream(pos);,         if (os == null) { throw new IllegalStateException(); },         return os;,     }, ,     public Writer setCharacterStream(long pos) throws SQLException {,         checkValidation();,         if (clob == null) { throw new IllegalStateException(); },         Writer writer = clob.setCharacterStream(pos);,         if (writer == null) { throw new IllegalStateException(); },         return writer;,     }, ,     public int setString(long pos, String str) throws SQLException {,         checkValidation();,         return setString(pos, str, 0, str.length());,     }, ,     public int setString(long pos, String str, int offset, int length),             throws SQLException {,         checkValidation();,         if (pos < 1),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_BAD_POSITION, new Object[] {new Long(pos)} );,         },         if (length < 0),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, null );,         },         if (pos > (len - length + 1)),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_POSITION_TOO_LARGE, null );,         },         if (offset < 0 || offset > (str.length() - length)),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_INVALID_OFFSET, null );,         },         if (length > len + offset),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_INVALID_OFFSET, null );,         },         str.getChars(offset, offset + length, buf, (int) pos - 1);,         return length;,     }, ,     public void truncate(long length) throws SQLException {,         checkValidation();,         if (length < 0),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Long(length)} );,         },         if (length > len),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_LENGTH_TOO_LONG, new Object[] {new Long(length)} );,         },         char[] truncatedBuffer = new char[(int) length];,         System.arraycopy(buf, 0, truncatedBuffer, 0, (int) length);,         buf = truncatedBuffer;,         len = length;,     }, ,     public void free() throws SQLException {,         if (this.len != -1) {,             this.len = -1;,             this.clob = null;,             this.buf = null;,         },     }, ,     public Reader getCharacterStream(long pos, long length) throws SQLException {,         checkValidation();,         return new CharArrayReader(buf, (int) pos, (int) length);,     }, ,     private void checkValidation() throws SQLException {,         if (len == -1),         {,             throw HarmonySerialBlob.makeSQLException( SQLState.LOB_OBJECT_INVALID, null );,         },     }],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/iapi/types/HarmonySerialClob.java,<init>,77-77,[            characterStream.read(buf);],,<init>,69-69,[        if ((characterStream = clob.getCharacterStream()) == null],,<init>,70-70,[                && clob.getAsciiStream() == null) { throw new IllegalArgumentException(); }],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/derby/iapi/types/HarmonySerialClob.java,<init>,77-77,[            characterStream.read(buf);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/types/JSQLType.java,readExternal,229-243,[		switch ( frozenCategory ), 		{, 		    case SQLTYPE:, , 				initialize( (DataTypeDescriptor) in.readObject() );, 				break;, , 		    case JAVA_CLASS:, , 				initialize( (String) in.readObject() );, 				break;, , 		    case JAVA_PRIMITIVE:, , 				initialize( in.readByte() );],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/types/JSQLType.java,writeExternal,257-271,[		switch ( category ), 		{, 		    case SQLTYPE:, , 				out.writeObject( sqlType );, 				break;, , 		    case JAVA_CLASS:, , 				out.writeObject( javaClassName );, 				break;, , 		    case JAVA_PRIMITIVE:, , 				out.writeByte( primitiveKind );],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/derby/iapi/types/Like.java,checkLengths,342-342,[		else return null; // still have strings to match, not done],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/derby/iapi/types/Like.java,like,110-110,[		if (val == null) return null;],,like,111-111,[		if (pat == null) return null;],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/derby/iapi/types/Like.java,like,352-352,[		if (value == null || pattern == null) return null;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/iapi/types/LocatedRow.java,columnValues,87-87,[    public  DataValueDescriptor[]   columnValues() { return _columnValues; }],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/types/LocatedRow.java,<init>,59-59,[        _columnValues = columnValues;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/iapi/types/NumberDataType.java,sqrt,96-96,[            if( (new Double(doubleValue)).equals(new Double(-0.0d)) )],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/iapi/types/NumberDataType.java,compare,294-294,[			return - (arg.compare(this));],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/iapi/types/ReaderToUTF8Stream.java,<init>,144-144,[                    typeName.equals(TypeId.LONGVARCHAR_NAME));],,<init>,140-140,[            SanityManager.ASSERT(typeName != null && (],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLBinary.java,hashCode,1166-1192,[			if (getValue() == null), 				{, 					return 0;, 				}, 		}, 		catch (StandardException se), 		{, 			if (SanityManager.DEBUG), 				SanityManager.THROWASSERT("Unexpected exception", se);, 			return 0;, 		}, , 		// Hash code should ignore trailing PAD bytes., 		byte[] bytes = dataValue;,         int lastNonPadByte = bytes.length - 1;,         while (lastNonPadByte >= 0 && bytes[lastNonPadByte] == PAD) {,             lastNonPadByte--;,         }, ,         // Build the hash code in a way similar to String.hashCode() and,         // SQLChar.hashCode(),         int hashcode = 0;,         for (int i = 0; i <= lastNonPadByte; i++) {,             hashcode = hashcode * 31 + bytes[i];,         }, , 		return hashcode;],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE,org/apache/derby/iapi/types/SQLBinary.java,substring,1047-1047,[		if (lengthInt < 0)],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE,org/apache/derby/iapi/types/SQLBinary.java,substring,1054-1054,[		if (startInt < 0)],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/iapi/types/SQLBinary.java,compare,576-576,[			return - (other.compare(this));],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/iapi/types/SQLBinary.java,substring,1049-1049,[			varbitResult.setToNull();],,substring,1047-1047,[		if (lengthInt < 0)],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/iapi/types/SQLBinary.java,substring,1056-1056,[			startInt += getLength();],,substring,1054-1054,[		if (startInt < 0)],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/iapi/types/SQLBinary.java,substring,1071-1071,[		else if (startInt > 0)],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/types/SQLBit.java,<init>,135-135,[		dataValue = val;],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/iapi/types/SQLBoolean.java,getObject,165-165,[			return new Boolean(value);],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLBoolean.java,hashCode,1072-1077,[		if (isNull()), 		{, 			return -1;, 		}, , 		return (value) ? 1 : 0;],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/derby/iapi/types/SQLBoolean.java,truthValue,981-981,[		if (truth == Boolean.TRUE)],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/iapi/types/SQLBoolean.java,compare,255-255,[			return - (other.compare(this));],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/types/SQLChar.java,compare,1390-1390,[        return stringCompare(this, (SQLChar)other);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/types/SQLChar.java,like,2277-2277,[        char[] patternCharArray = ((SQLChar)pattern).getCharArray();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/types/SQLChar.java,like,2329-2329,[        char[] escapeCharArray = (((SQLChar) escape).getCharArray());],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/types/SQLChar.java,like,2328-2328,[        char[] patternCharArray = ((SQLChar)pattern).getCharArray();],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/iapi/types/SQLChar.java,getDouble,495-495,[            return new Double(getString().trim()).doubleValue();],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/iapi/types/SQLChar.java,getFloat,469-469,[            return new Float(getString().trim()).floatValue();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/SQLChar.java,locate,2398-2398,[                    getString(), mySearchFrom,],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/iapi/types/SQLChar.java,getCharArray,808-808,[            return rawData;],,getCharArray,819-819,[            return rawData;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLChar.java,hashCode,2990-3036,[            SanityManager.ASSERT(!(this instanceof CollationElementsInterface),,                     "SQLChar.hashCode() does not work with collation");,         }, ,         try {,             if (getString() == null),             {,                 return 0;,             },         },         catch (StandardException se),         {,             if (SanityManager.DEBUG),                 SanityManager.THROWASSERT("Unexpected exception", se);,             return 0;,         }, , ,         /* value.hashCode() doesn't work because of the SQL blank padding ,          * behavior.,          * We want the hash code to be based on the value after the ,          * trailing blanks have been trimmed.  Calling trim() is too expensive,          * since it will create a new object, so here's what we do:,          *      o  Walk from the right until we've found the 1st,          *         non-blank character.,          *      o  Calculate the hash code based on the characters from the,          *         start up to the first non-blank character from the right.,          */, ,         // value will have been set by the getString() above,         String lvalue = value;, ,         // Find 1st non-blank from the right,         int lastNonPadChar = lvalue.length() - 1;,         while (lastNonPadChar >= 0 && lvalue.charAt(lastNonPadChar) == PAD) {,             lastNonPadChar--;,         }, ,         // Build the hash code. It should be identical to what we get from,         // lvalue.substring(0, lastNonPadChar+1).hashCode(), but it should be,         // cheaper this way since we don't allocate a new string.,         int hashcode = 0;,         for (int i = 0; i <= lastNonPadChar; i++) {,             hashcode = hashcode * 31 + lvalue.charAt(i);,         }, ,         return hashcode;],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE,org/apache/derby/iapi/types/SQLChar.java,substring,2477-2477,[        if (lengthInt < 0)],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE,org/apache/derby/iapi/types/SQLChar.java,substring,2484-2484,[        if (startInt < 0)],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/types/SQLChar.java,getRawDataAndZeroIt,287-287,[        if ( rawData == null ) { return null; }],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/iapi/types/SQLChar.java,compare,1386-1386,[            return - (other.compare(this));],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/iapi/types/SQLChar.java,substring,2479-2479,[            stringResult.setToNull();],,substring,2477-2477,[        if (lengthInt < 0)],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/iapi/types/SQLChar.java,substring,2487-2487,[            if (startInt + getLength() < 0 &&],,substring,2484-2484,[        if (startInt < 0)],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/iapi/types/SQLChar.java,substring,2503-2503,[        else if (startInt > 0)],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/derby/iapi/types/SQLClob.java,getStreamHeaderGenerator,671-671,[            if (inSoftUpgradeMode == Boolean.TRUE) {],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLDate.java,hashCode,676-676,[		return encodedDate;],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/iapi/types/SQLDate.java,compare,266-266,[			return - (other.compare(this));],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/types/SQLDate.java,computeEncodedDate,764-775,[        switch( m),         {,         case 4:,         case 6:,         case 9:,         case 11:,             maxDay = 30;,             break;,                 ,         case 2:,             // leap years are every 4 years except for century years not divisble by 400.,             maxDay = ((y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0)) ? 29 : 28;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/iapi/types/SQLDecimal.java,hashCode,944-944,[			if (longVal != doubleVal)],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLDecimal.java,hashCode,927-950,[		BigDecimal localValue = getBigDecimal();, , 		double doubleVal = (localValue != null) ? localValue.doubleValue() : 0;, , 		if (Double.isInfinite(doubleVal)), 		{, 			/*, 			 ** This loses the fractional part, but it probably doesn't, 			 ** matter for numbers that are big enough to overflow a double -, 			 ** it's probably rare for numbers this big to be different only in, 			 ** their fractional parts., 			 */, 			longVal = localValue.longValue();, 		}, 		else, 		{, 			longVal = (long) doubleVal;, 			if (longVal != doubleVal), 			{, 				longVal = Double.doubleToLongBits(doubleVal);, 			}, 		}, , 		return (int) (longVal ^ (longVal >> 32));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/iapi/types/SQLDouble.java,getObject,167-167,[			return new Double(value);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/iapi/types/SQLDouble.java,equals,510-510,[									 left.getDouble() == right.getDouble());],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/iapi/types/SQLDouble.java,hashCode,880-880,[		if (doubleLongVal != value)],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/iapi/types/SQLDouble.java,notEquals,533-533,[									 left.getDouble() != right.getDouble());],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/iapi/types/SQLDouble.java,typeCompare,255-255,[		if (thisValue == otherValue)],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLDouble.java,hashCode,863-885,[		long longVal = (long) value;, 		double doubleLongVal = (double) longVal;, , 		/*, 		** NOTE: This is coded to work around a bug in Visual Cafe 3.0., 		** If longVal is compared directly to value on that platform, 		** with the JIT enabled, the values will not always compare, 		** as equal even when they should be equal. This happens with, 		** the value Long.MAX_VALUE, for example., 		**, 		** Assigning the long value back to a double and then doing, 		** the comparison works around the bug., 		**, 		** This fixes Cloudscape bug number 1757., 		**, 		**		-	Jeff Lichtman, 		*/, 		if (doubleLongVal != value),         {, 			longVal = Double.doubleToLongBits(value);, 		}, , 		return (int) (longVal ^ (longVal >> 32));	],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/SQLInteger.java,getObject,118-118,[			return new Integer(value);],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLInteger.java,hashCode,673-673,[		return value;],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/iapi/types/SQLLongint.java,setValue,321-321,[		        value = Long.valueOf(theValue.trim()).longValue();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/SQLLongint.java,getObject,135-135,[			return new Long(value);],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLLongint.java,hashCode,871-871,[		return (int) (value ^ (value >> 32));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/iapi/types/SQLReal.java,getObject,188-188,[			return new Float(value);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/iapi/types/SQLReal.java,equals,527-527,[									 left.getFloat() == right.getFloat());],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/iapi/types/SQLReal.java,hashCode,874-874,[		if (longVal != value)],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/iapi/types/SQLReal.java,notEquals,549-549,[									 left.getFloat() != right.getFloat());],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/iapi/types/SQLReal.java,typeCompare,257-257,[		if (thisValue == otherValue)],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLReal.java,hashCode,872-879,[		long longVal = (long) value;, , 		if (longVal != value), 		{, 			longVal = Double.doubleToLongBits(value);, 		}, , 		return (int) (longVal ^ (longVal >> 32));	],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/types/SQLRef.java,compare,157-157,[		return value.compare(op,],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/types/SQLRef.java,compare,166-166,[		return value.compare(((SQLRef) other).value);],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLRef.java,hashCode,252-253,[        if ( value == null ) { return 0; },         else { return value.hashCode(); }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/SQLSmallint.java,getObject,161-161,[			return new Integer(value);],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLSmallint.java,hashCode,723-723,[		return (int) value;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLTime.java,hashCode,726-731,[		if (isNull()), 		{, 			return 0;, 		}, 		// add 1 since 0 represents a valid time, 		return encodedTime + encodedTimeFraction + 1;],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/iapi/types/SQLTime.java,compare,272-272,[			return - (other.compare(this));],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/types/SQLTime.java,parseTime,455-469,[                switch( parser.getCurrentSeparator()),                 {,                 case ' ':,                     // IBM USA with minutes,                     if( isJdbcEscape),                     {,                         validSyntax = false;,                         break;,                     },                     amPm = parser.parseChoice( AM_PM);,                     parser.checkEnd();,                     break;, ,                 case JIS_SEPARATOR:,                     second = parser.parseInt( 2, false, END_OF_STRING, false);],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLTimestamp.java,hashCode,805-810,[		if (isNull()), 		{, 			return 0;, 		}, 		, 		return  encodedDate + encodedTime + nanos; //since 0 is null],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/iapi/types/SQLTimestamp.java,compare,284-284,[			return - (other.compare(this));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/iapi/types/SQLTinyint.java,getObject,201-201,[		return (isNull()) ?],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/SQLTinyint.java,hashCode,732-732,[		return (int) value;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/iapi/types/SqlXmlUtil.java,evalXQExpression,648-648,[        if ((itemRefs.size() == 1) && (itemRefs.get(0) instanceof Document))],,evalXQExpression,639-639,[                itemRefs = null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/derby/iapi/types/SqlXmlUtil.java,,743-760,[    private class XMLErrorHandler implements ErrorHandler,     {,         public void error (SAXParseException exception),             throws SAXException,         {,             throw new SAXException (exception);,         }, ,         public void fatalError (SAXParseException exception),             throws SAXException,         {,             throw new SAXException (exception);,         }, ,         public void warning (SAXParseException exception),             throws SAXException,         {,             throw new SAXException (exception);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/iapi/types/TypeId.java,setUserTypeIdInfo,1027-1027,[                UserDefinedTypeIdImpl baseUserTypeId =],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/iapi/types/TypeId.java,setTypeIdSpecificInstanceVariables,754-954,[                switch (formatId),                 {,                         case StoredFormatIds.BIT_TYPE_ID:,                                 typePrecedence = BIT_PRECEDENCE;,                                 javaTypeName = "byte[]";,                                 maxMaxWidth = TypeId.BIT_MAXWIDTH;,                                 isBitTypeId = true;,                                 isConcatableTypeId = true;,                                 break;, ,                         case StoredFormatIds.BOOLEAN_TYPE_ID:,                                 maxPrecision = TypeId.BOOLEAN_MAXWIDTH;,                                 typePrecedence = BOOLEAN_PRECEDENCE;,                                 javaTypeName = "java.lang.Boolean";,                                 maxMaxWidth = TypeId.BOOLEAN_MAXWIDTH;,                                 isBooleanTypeId = true;,                                 break;, ,                         case StoredFormatIds.CHAR_TYPE_ID:,                                 typePrecedence = CHAR_PRECEDENCE;,                                 javaTypeName = "java.lang.String";,                                 maxMaxWidth = TypeId.CHAR_MAXWIDTH;,                                 isStringTypeId = true;,                                 isConcatableTypeId = true;,                                 break;, ,                         case StoredFormatIds.DATE_TYPE_ID:,                                 typePrecedence = DATE_PRECEDENCE;,                                 javaTypeName = "java.sql.Date";,                                 maxMaxWidth = TypeId.DATE_MAXWIDTH;,                                 maxPrecision = TypeId.DATE_MAXWIDTH;,                                 isDateTimeTimeStampTypeId = true;,                                 break;, ,                         case StoredFormatIds.DECIMAL_TYPE_ID:,                                 maxPrecision = TypeId.DECIMAL_PRECISION;,                                 maxScale = TypeId.DECIMAL_SCALE;,                                 typePrecedence = DECIMAL_PRECEDENCE;,                                 javaTypeName = "java.math.BigDecimal";,                                 maxMaxWidth = TypeId.DECIMAL_MAXWIDTH;,                                 isDecimalTypeId = true;,                                 isNumericTypeId = true;,                                 break;, ,                         case StoredFormatIds.DOUBLE_TYPE_ID:,                                 maxPrecision = TypeId.DOUBLE_PRECISION;,                                 maxScale = TypeId.DOUBLE_SCALE;,                                 typePrecedence = DOUBLE_PRECEDENCE;,                                 javaTypeName = "java.lang.Double";,                                 maxMaxWidth = TypeId.DOUBLE_MAXWIDTH;,                                 isNumericTypeId = true;, 								isFloatingPointTypeId = true;,                                 break;, ,                         case StoredFormatIds.INT_TYPE_ID:,                                 maxPrecision = TypeId.INT_PRECISION;,                                 maxScale = TypeId.INT_SCALE;,                                 typePrecedence = INT_PRECEDENCE;,                                 javaTypeName = "java.lang.Integer";,                                 maxMaxWidth = TypeId.INT_MAXWIDTH;,                                 isNumericTypeId = true;,                                 break;, ,                         case StoredFormatIds.BIGINT_TYPE_ID:,                                 maxPrecision = TypeId.LONGINT_PRECISION;,                                 maxScale = TypeId.LONGINT_SCALE;,                                 typePrecedence = LONGINT_PRECEDENCE;,                                 javaTypeName = "java.lang.Long";,                                 maxMaxWidth = TypeId.LONGINT_MAXWIDTH;,                                 isNumericTypeId = true;,                                 break;, ,                         case StoredFormatIds.LONGVARBIT_TYPE_ID:,                                 typePrecedence = LONGVARBIT_PRECEDENCE;,                                 javaTypeName = "byte[]";,                                 maxMaxWidth = TypeId.LONGVARBIT_MAXWIDTH;,                                 isBitTypeId = true;,                                 isConcatableTypeId = true;,                                 isLongConcatableTypeId = true;,                                 break;, ,                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:,                                 typePrecedence = LONGVARCHAR_PRECEDENCE;,                                 javaTypeName = "java.lang.String";,                                 maxMaxWidth = TypeId.LONGVARCHAR_MAXWIDTH;,                                 isStringTypeId = true;,                                 isConcatableTypeId = true;,                                 isLongConcatableTypeId = true;,                                 break;, ,                         case StoredFormatIds.REAL_TYPE_ID:,                                 maxPrecision = TypeId.REAL_PRECISION;,                                 maxScale = TypeId.REAL_SCALE;,                                 typePrecedence = REAL_PRECEDENCE;,                                 javaTypeName = "java.lang.Float";,                                 maxMaxWidth = TypeId.REAL_MAXWIDTH;,                                 isNumericTypeId = true;,                                 isRealTypeId = true;,                                 isFloatingPointTypeId = true;,                                 break;, ,                         case StoredFormatIds.REF_TYPE_ID:,                                 typePrecedence = REF_PRECEDENCE;,                                 javaTypeName = "java.sql.Ref";,                                 isRefTypeId = true;,                                 break;, ,                         case StoredFormatIds.SMALLINT_TYPE_ID:,                                 maxPrecision = TypeId.SMALLINT_PRECISION;,                                 maxScale = TypeId.SMALLINT_SCALE;,                                 typePrecedence = SMALLINT_PRECEDENCE;,                                 javaTypeName = "java.lang.Integer";,                                 maxMaxWidth = TypeId.SMALLINT_MAXWIDTH;,                                 isNumericTypeId = true;,                                 break;, ,                         case StoredFormatIds.TIME_TYPE_ID:,                                 typePrecedence = TIME_PRECEDENCE;,                                 javaTypeName = "java.sql.Time";,                                 maxScale = TypeId.TIME_SCALE;,                                 maxMaxWidth = TypeId.TIME_MAXWIDTH;,                                 maxPrecision = TypeId.TIME_MAXWIDTH;,                                 isDateTimeTimeStampTypeId = true;,                                 break;, ,                         case StoredFormatIds.TIMESTAMP_TYPE_ID:,                                 typePrecedence = TIMESTAMP_PRECEDENCE;,                                 javaTypeName = "java.sql.Timestamp";,                                 maxScale = TypeId.TIMESTAMP_SCALE;,                                 maxMaxWidth = TypeId.TIMESTAMP_MAXWIDTH;,                                 maxPrecision = TypeId.TIMESTAMP_MAXWIDTH;,                                 isDateTimeTimeStampTypeId = true;,                                 break;, ,                         case StoredFormatIds.TINYINT_TYPE_ID:,                                 maxPrecision = TypeId.TINYINT_PRECISION;,                                 maxScale = TypeId.TINYINT_SCALE;,                                 typePrecedence = TINYINT_PRECEDENCE;,                                 javaTypeName = "java.lang.Integer";,                                 maxMaxWidth = TypeId.TINYINT_MAXWIDTH;,                                 isNumericTypeId = true;,                                 break;, ,                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:,                                 if (baseTypeId != null),                                 {,                                         setUserTypeIdInfo();,                                 },                                 else,                                 {,                                         typePrecedence = USER_PRECEDENCE;,                                 },                                 maxMaxWidth = -1;,                                 isUserDefinedTypeId = true;,                                 break;, ,                         case StoredFormatIds.VARBIT_TYPE_ID:,                                 typePrecedence = VARBIT_PRECEDENCE;,                                 javaTypeName = "byte[]";,                                 maxMaxWidth = TypeId.VARBIT_MAXWIDTH;,                                 isBitTypeId = true;,                                 isConcatableTypeId = true;,                                 break;, ,                         case StoredFormatIds.BLOB_TYPE_ID:,                                 typePrecedence = BLOB_PRECEDENCE;,                                 javaTypeName = "java.sql.Blob";,                                 maxMaxWidth = TypeId.BLOB_MAXWIDTH;,                                 isBitTypeId = true;,                                 isConcatableTypeId = true;,                                 isLongConcatableTypeId = true; // ??,                                 isLOBTypeId = true;,                                 break;, ,                         case StoredFormatIds.VARCHAR_TYPE_ID:,                                 typePrecedence = VARCHAR_PRECEDENCE;,                                 javaTypeName = "java.lang.String";,                                 maxMaxWidth = TypeId.VARCHAR_MAXWIDTH;,                                 isStringTypeId = true;,                                 isConcatableTypeId = true;,                                 break;, ,                       case StoredFormatIds.CLOB_TYPE_ID:,                               typePrecedence = CLOB_PRECEDENCE;,                               javaTypeName = "java.sql.Clob";,                               maxMaxWidth = TypeId.CLOB_MAXWIDTH;,                               isStringTypeId = true;,                               isConcatableTypeId = true;,                               isLongConcatableTypeId = true; // ??,                               isLOBTypeId = true;,                               break;, ,                       case StoredFormatIds.XML_TYPE_ID:, ,                               typePrecedence = XML_PRECEDENCE;,                               javaTypeName = "org.apache.derby.iapi.types.XML";,                               maxMaxWidth = TypeId.XML_MAXWIDTH;, ,                               // We set this to true in order to disallow use,                               // of the XML datatype for procedure/function args.,                               isLongConcatableTypeId = true;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/derby/iapi/types/UserType.java,hashCode,573-575,[		if (isNull()), 			return 0;, 		return value.hashCode();],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/iapi/types/UserType.java,compare,363-363,[			return - (other.compare(this));],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/iapi/types/XML.java,,78-1079,[    private static final int BASE_MEMORY_USAGE =,         ClassSize.estimateBaseFromCatalog(XML.class);, ,     // Some syntax-related constants used to determine,     // operator behavior.,     public static final short XQ_PASS_BY_REF = 1;,     public static final short XQ_PASS_BY_VALUE = 2;,     public static final short XQ_RETURN_SEQUENCE = 3;,     public static final short XQ_RETURN_CONTENT = 4;,     public static final short XQ_EMPTY_ON_EMPTY = 5;,     public static final short XQ_NULL_ON_EMPTY = 6;, ,     /* Per SQL/XML[2006] 4.2.2, there are several different,      * XML "types" defined through use of primary and secondary,      * "type modifiers".  For Derby we only support two kinds:,      *,      * XML(DOCUMENT(ANY)) : A valid and well-formed XML,      *  document as defined by W3C, meaning that there is,      *  exactly one root element node.  This is the only,      *  type of XML that can be stored into a Derby XML,      *  column.  This is also the type returned by a call,      *  to XMLPARSE since we require the DOCUMENT keyword.,      *,      * XML(SEQUENCE): A sequence of items (could be nodes or,      *  atomic values).  This is the type returned from an,      *  XMLQUERY operation.  Any node that is XML(DOCUMENT(ANY)),      *  is also XML(SEQUENCE).  Note that an XML(SEQUENCE),      *  value is *only* storable into a Derby XML column,      *  if it is also an XML(DOCUMENT(ANY)).  See the,      *  normalize method below for the code that enforces,      *  this.,      */,     public static final int XML_DOC_ANY = 0;,     public static final int XML_SEQUENCE = 1;, ,     // The fully-qualified type for this XML value.,     private int xType;, ,     // The actual XML data in this implementation is just a simple,     // string, so this class really just wraps a SQLChar and,     // defers most calls to the corresponding calls on that,     // SQLChar.  Note that, even though a SQLChar is the,     // underlying implementation, an XML value is nonetheless,     // NOT considered comparable nor compatible with any of,     // Derby string types.,     private SQLChar xmlStringValue;, ,     /*,      * Status variable used to verify that user's classpath contains,      * required classes for accessing/operating on XML data values.,      */,     private static String xmlReqCheck = null;, ,     /*,      * Whether or not this XML value corresponds to a sequence,      * that has one or more top-level ("parentless") attribute,      * nodes.  If so then we have to throw an error if the user,      * attempts to serialize this value, per XML serialization,      * rules.,      */,     private boolean containsTopLevelAttr;, ,     private SqlXmlUtil tmpUtil;, ,     /**,      * Default constructor.,      */,     public XML(),     {,         xmlStringValue = null;,         xType = -1;,         containsTopLevelAttr = false;,     }, ,     /**,      * Private constructor used for the {@code cloneValue} method.,      * Returns a new instance of XML whose fields are clones,      * of the values received.,      *,      * @param val A SQLChar instance to clone and use for,      *  this XML value.,      * @param xmlType Qualified XML type for "val",      * @param seqWithAttr Whether or not "val" corresponds to,      *  sequence with one or more top-level attribute nodes.,      * @param materialize whether or not to force materialization of the,      *      underlying source data,      */,     private XML(SQLChar val, int xmlType, boolean seqWithAttr,,             boolean materialize) {,         xmlStringValue = (val == null ? null,                                       : (SQLChar)val.cloneValue(materialize));,         setXType(xmlType);,         if (seqWithAttr),             markAsHavingTopLevelAttr();,     }, ,     /* ****,      * DataValueDescriptor interface.,      * */, ,     /**,      * @see DataValueDescriptor#cloneValue,      */,     public DataValueDescriptor cloneValue(boolean forceMaterialization) {,         return new XML(xmlStringValue, getXType(), hasTopLevelAttr(),,                 forceMaterialization);,     }, ,     /**,      * @see DataValueDescriptor#getNewNull,      */,     public DataValueDescriptor getNewNull(),     {,         return new XML();,     }, ,     /**,      * @see DataValueDescriptor#getTypeName,      */,     public String getTypeName(),     {,         return TypeId.XML_NAME;,     }, ,     /**,      * @see DataValueDescriptor#typePrecedence,      */,     public int typePrecedence(),     {,         return TypeId.XML_PRECEDENCE;,     }, ,     /**,      * @see DataValueDescriptor#getString,      */,     public String getString() throws StandardException,     {,         return (xmlStringValue == null) ? null : xmlStringValue.getString();,     }, ,     /**,      * @see DataValueDescriptor#getLength,      */,     public int    getLength() throws StandardException,     {,         return ((xmlStringValue == null) ? 0 : xmlStringValue.getLength());,     }, ,     /** ,      * @see DataValueDescriptor#estimateMemoryUsage,      */,     public int estimateMemoryUsage(),     {,         int sz = BASE_MEMORY_USAGE;,         if (xmlStringValue != null),             sz += xmlStringValue.estimateMemoryUsage();,         return sz;,     }, ,     /**,      * @see DataValueDescriptor#readExternalFromArray,      */,     public void readExternalFromArray(ArrayInputStream in),         throws IOException,     {,         if (xmlStringValue == null),             xmlStringValue = new SQLChar();, ,         // Read the XML implementation id.  Right now there's,         // only one implementation (UTF-8 based), so we don't,         // use this value.  But if better implementations come,         // up in the future, we'll have to use this impl id to,         // figure out how to read the data.,         in.readShort();, ,         // Now just read the XML data as UTF-8.,         xmlStringValue.readExternalFromArray(in);, ,         // If we read it from disk then it must have type,         // XML_DOC_ANY because that's all we allow to be,         // written into an XML column.,         setXType(XML_DOC_ANY);,     }, ,     /**,      * @see DataType#setFrom,      */,     protected void setFrom(DataValueDescriptor theValue),         throws StandardException,     {,         String strVal = theValue.getString();,         if (strVal == null),         {,             xmlStringValue = null;, ,             // Null is a valid value for DOCUMENT(ANY),             setXType(XML_DOC_ANY);,             return;,         }, ,         // Here we just store the received value locally.,         if (xmlStringValue == null),             xmlStringValue = new SQLChar();,         xmlStringValue.setValue(strVal);, ,         /*,          * Assumption is that if theValue is not an XML,          * value then the caller is aware of whether or,          * not theValue constitutes a valid XML(DOCUMENT(ANY)),          * and will behave accordingly (see in particular the,          * XMLQuery method of this class, which calls the,          * setValue() method of XMLDataValue which in turn,          * brings us to this method).,          */,         if (theValue instanceof XMLDataValue),         {,             setXType(((XMLDataValue)theValue).getXType());,             if (((XMLDataValue)theValue).hasTopLevelAttr()),                 markAsHavingTopLevelAttr();,         },     }, ,     /** ,      * @see DataValueDescriptor#setValueFromResultSet ,      */,     public final void setValueFromResultSet(,         ResultSet resultSet, int colNumber, boolean isNullable),         throws SQLException,     {,         if (xmlStringValue == null),             xmlStringValue = new SQLChar();, ,         String valAsStr = resultSet.getString(colNumber);, ,         /* As there is no guarantee that the specified column within,          * resultSet is well-formed XML (is there??), we have to try,          * to parse it in order to set the "xType" field correctly.,          * This is required to ensure that we only store well-formed,          * XML on disk (see "normalize()" method of this class).  So,          * create an instance of SqlXmlUtil and use that to see if the,          * text satisifies the requirements of a well-formed DOCUMENT.,          *,          * RESOLVE: If there is anyway to guarantee that the column,          * is in fact well-formed XML then we can skip all of this,          * logic and simply set xType to XML_DOC_ANY.  But do we,          * have such a guarantee...?,          */,         if (tmpUtil == null),         {,             try {, ,                 tmpUtil = new SqlXmlUtil();, ,             } catch (StandardException se) {, ,                 if (SanityManager.DEBUG),                 {,                     SanityManager.THROWASSERT(,                         "Failed to instantiate SqlXmlUtil for XML parsing.");,                 }, ,                 /* If we failed to get a SqlXmlUtil then we can't parse,                  * the string, which means we don't know if it constitutes,                  * a well-formed XML document or not.  In this case we,                  * set the value, but intentionally leave xType as -1,                  * so that the resultant value canNOT be stored on disk.,                  */,                 xmlStringValue.setValue(valAsStr);,                 setXType(-1);,                 return;, ,             },         }, ,         try {, ,             /* The following call parses the string into a DOM and,              * then serializes it, which is exactly what we do for,              * normal insertion of XML values.  If the parse finishes,              * with no error then we know the type is XML_DOC_ANY,,              * so set it.,              */,             valAsStr = tmpUtil.serializeToString(valAsStr);,             xmlStringValue.setValue(valAsStr);,             setXType(XML_DOC_ANY);, ,         } catch (Throwable t) {, ,             /* It's possible that the string value was either 1) an,              * XML SEQUENCE or 2) not XML at all.  We don't know,              * which one it was, so make xType invalid to ensure this,              * field doesn't end up on disk.,              */,             xmlStringValue.setValue(valAsStr);,             setXType(-1);, ,         },     }, ,     /**,      * Compare two XML DataValueDescriptors.  NOTE: This method,      * should only be used by the database store for the purpose of,      * index positioning--comparisons of XML type are not allowed,      * from the language side of things.  That said, all store,      * wants to do is order the NULLs, so we don't actually,      * have to do a full comparison.  Just return an order,      * value based on whether or not this XML value and the,      * other XML value are null.  As mentioned in the "compare",      * method of DataValueDescriptor, nulls are considered,      * equal to other nulls and less than all other values.,      *,      * An example of when this method might be used is if the,      * user executed a query like:,      *,      * select i from x_table where x_col is not null,      *,      * @see DataValueDescriptor#compare,      */,     public int compare(DataValueDescriptor other),         throws StandardException,     {,         if (SanityManager.DEBUG) {,             SanityManager.ASSERT(other instanceof XMLDataValue,,                 "Store should NOT have tried to compare an XML value " +,                 "with a non-XML value.");,         }, ,         if (isNull()) {,             if (other.isNull()),             // both null, so call them 'equal'.,                 return 0;,             // This XML is 'less than' the other.,             return -1;,         }, ,         if (other.isNull()),         // This XML is 'greater than' the other.,             return 1;, ,         // Two non-null values: we shouldn't ever get here,,         // since that would necessitate a comparsion of XML,         // values, which isn't allowed.,         if (SanityManager.DEBUG) {,             SanityManager.THROWASSERT(,                 "Store tried to compare two non-null XML values, " +,                 "which isn't allowed.");,         },         return 0;,     }, ,     /**,      * Normalization method - this method will always be called when,      * storing an XML value into an XML column, for example, when,      * inserting/updating.  We always force normalization in this,      * case because we need to make sure the qualified type of the,      * value we're trying to store is XML_DOC_ANY--we don't allow,      * anything else.,      *,      * @param desiredType   The type to normalize the source column to,      * @param source        The value to normalize,      *,      * @exception StandardException Thrown if source is not,      *  XML_DOC_ANY.,      */,     public void normalize(,                 DataTypeDescriptor desiredType,,                 DataValueDescriptor source),                     throws StandardException,     {,         if (SanityManager.DEBUG) {,             SanityManager.ASSERT(source instanceof XMLDataValue,,                 "Tried to store non-XML value into XML column; " +,                 "should have thrown error at compile time.");,         }, ,         if (((XMLDataValue)source).getXType() != XML_DOC_ANY) {,             throw StandardException.newException(,                 SQLState.LANG_NOT_AN_XML_DOCUMENT);,         }, ,         ((DataValueDescriptor) this).setValue(source);,         return;, ,     }, ,     /* ****,      * Storable interface, implies Externalizable, TypedFormat,      */, ,     /**,      * @see TypedFormat#getTypeFormatId,      *,      * From the engine's perspective, all XML implementations share,      * the same format id.,      */,     public int getTypeFormatId() {,         return StoredFormatIds.XML_ID;,     }, ,     /**,      * @see Storable#isNull,      */,     public boolean isNull(),     {,         return ((xmlStringValue == null) || xmlStringValue.isNull());,     }, ,     /**,      * @see Storable#restoreToNull,      */,     public void restoreToNull(),     {,         if (xmlStringValue != null),             xmlStringValue.restoreToNull();,     }, ,     /**,      * Read an XML value from an input stream.,      * @param in The stream from which we're reading.,      */,     public void readExternal(ObjectInput in) throws IOException,     {,         if (xmlStringValue == null),             xmlStringValue = new SQLChar();, ,         // Read the XML implementation id.  Right now there's,         // only one implementation (UTF-8 based), so we don't,         // use this value.  But if better implementations come,         // up in the future, we'll have to use this impl id to,         // figure out how to read the data.,         in.readShort();, ,         // Now just read the XML data as UTF-8.,         xmlStringValue.readExternal(in);, ,         // If we read it from disk then it must have type,         // XML_DOC_ANY because that's all we allow to be,         // written into an XML column.,         setXType(XML_DOC_ANY);,     }, ,     /**,      * Write an XML value. ,      * @param out The stream to which we're writing.,      */,     public void writeExternal(ObjectOutput out) throws IOException,     {,         // never called when value is null,         if (SanityManager.DEBUG),             SanityManager.ASSERT(!isNull());, ,         // Write out the XML store impl id.,         out.writeShort(UTF8_IMPL_ID);, ,         // Now write out the data.,         xmlStringValue.writeExternal(out);,     }, ,     /* ****,      * StreamStorable interface,      * */, ,     /**,      * @see StreamStorable#returnStream,      */,     public InputStream returnStream(),     {,         return,             (xmlStringValue == null) ? null : xmlStringValue.returnStream();,     }, ,     /**,      * @see StreamStorable#setStream,      */,     public void setStream(InputStream newStream),     {,         if (xmlStringValue == null),             xmlStringValue = new SQLChar();, ,         // The stream that we receive is for an XML data value,,         // which means it has an XML implementation id stored,         // at the front (we put it there when we wrote it out).,         // If we leave that there we'll get a failure when,         // our underlying SQLChar tries to read from the,         // stream, because the extra impl id will throw,         // off the UTF format.  So we need to read in (and,         // ignore) the impl id before using the stream.,         try {,             // 2 bytes equal a short, which is what an impl id is.,             newStream.read();,             newStream.read();,         } catch (Exception e) {,             if (SanityManager.DEBUG),                 SanityManager.THROWASSERT("Failed to read impl id" +,                     "bytes in setStream.");,         }, ,         // Now go ahead and use the stream.,         xmlStringValue.setStream(newStream);, ,         // If we read it from disk then it must have type,         // XML_DOC_ANY because that's all we allow to be,         // written into an XML column.,         setXType(XML_DOC_ANY);,     }, ,     /**,      * @see StreamStorable#loadStream,      */,     public void loadStream() throws StandardException,     {,         getString();,     }, ,     /* ****,      * XMLDataValue interface.,      * */, ,     /**,      * Method to parse an XML string and, if it's valid,,      * store the _serialized_ version locally and then return,      * this XMLDataValue.,      *,      * @param stringValue The string value to check.,      * @param preserveWS Whether or not to preserve,      *  ignorable whitespace.,      * @param sqlxUtil Contains SQL/XML objects and util,      *  methods that facilitate execution of XML-related,      *  operations,      * @return If 'text' constitutes a valid XML document,,      *  it has been stored in this XML value and this XML,      *  value is returned; otherwise, an exception is thrown. ,      * @exception StandardException Thrown on error.,      */,     public XMLDataValue XMLParse(,             StringDataValue stringValue,,             boolean preserveWS,,             SqlXmlUtil sqlxUtil),         throws StandardException,     {,         if (stringValue.isNull()) {,             setToNull();,             return this;,         }, ,         String text = stringValue.getString();,         try {, ,             if (preserveWS) {,             // Currently the only way a user can view the contents of,             // an XML value is by explicitly calling XMLSERIALIZE.,             // So do a serialization now and just store the result,,             // so that we don't have to re-serialize every time a,             // call is made to XMLSERIALIZE.,                 text = sqlxUtil.serializeToString(text);,             },             else {,             // We don't support this yet, so we shouldn't,             // get here.,                 if (SanityManager.DEBUG),                     SanityManager.THROWASSERT("Tried to STRIP whitespace " +,                         "but we shouldn't have made it this far");,             }, ,         } catch (Throwable t) {,         /* Couldn't parse the XML document.  Throw a StandardException,          * with the parse exception (or other error) nested in it.,          * Note: we catch "Throwable" here to catch as many external,          * errors as possible in order to minimize the chance of an,          * uncaught JAXP/Xalan error (such as a NullPointerException),          * causing Derby to fail in a more serious way.  In particular,,          * an uncaught Java exception like NPE can result in Derby,          * throwing "ERROR 40XT0: An internal error was identified by,          * RawStore module" for all statements on the connection after,          * the failure--which we clearly don't want.  If we catch the,          * error and wrap it, though, the statement will fail but Derby,          * will continue to run as normal.,          */ ,             throw StandardException.newException(,                 SQLState.LANG_INVALID_XML_DOCUMENT, t, t.getMessage());, ,         }, ,         // If we get here, the text is valid XML so go ahead,         // and load/store it.,         setXType(XML_DOC_ANY);,         if (xmlStringValue == null),             xmlStringValue = new SQLChar();,         xmlStringValue.setValue(text);,         return this;,     }, ,     /**,      * The SQL/XML XMLSerialize operator.,      * Serializes this XML value into a string with a user-specified,      * character type, and returns that string via the received,      * StringDataValue (if the received StringDataValue is non-null,      * and of the correct type; else, a new StringDataValue is,      * returned).,      *,      * @param result The result of a previous call to this method,,      *    null if not called yet.,      * @param targetType The string type to which we want to serialize.,      * @param targetWidth The width of the target type.,      * @return A serialized (to string) version of this XML object,,      *  in the form of a StringDataValue object.,      * @exception StandardException    Thrown on error,      */,     public StringDataValue XMLSerialize(StringDataValue result,,         int targetType, int targetWidth, int targetCollationType) ,     throws StandardException,     {,         if (result == null) {,             switch (targetType),             {,                 case Types.CHAR:        result = new SQLChar(); break;,                 case Types.VARCHAR:     result = new SQLVarchar(); break;,                 case Types.LONGVARCHAR: result = new SQLLongvarchar(); break;,                 case Types.CLOB:        result = new SQLClob(); break;,                 default:,                 // Shouldn't ever get here, as this check was performed,                 // at bind time., ,                     if (SanityManager.DEBUG) {,                         SanityManager.THROWASSERT(,                             "Should NOT have made it to XMLSerialize " +,                             "with a non-string target type: " + targetType);,                     },                     return null;,             },             // If the collation type is territory based, then we should use,             // CollatorSQLxxx rather than SQLxxx types for StringDataValue. ,             // eg,             // CREATE TABLE T_MAIN1 (ID INT  GENERATED ALWAYS AS IDENTITY ,             //       PRIMARY KEY, V XML);,             // INSERT INTO T_MAIN1(V) VALUES NULL;,             // SELECT ID, XMLSERIALIZE(V AS CLOB), XMLSERIALIZE(V AS CLOB) ,             //       FROM T_MAIN1 ORDER BY 1;,             // Following code is for (V AS CLOB) inside XMLSERIALIZE. The,             // StringDataValue returned for (V AS CLOB) should consider the ,             // passed collation type in determining whether we should,             // generate SQLChar vs CollatorSQLChar for instance. Keep in mind,             // that collation applies only to character string types.,             try {,                 RuleBasedCollator rbs = ConnectionUtil.getCurrentLCC().getDataValueFactory().,                 getCharacterCollator(targetCollationType);,                 result = ((StringDataValue)result).getValue(rbs);,             },             catch( java.sql.SQLException sqle),             {,                 throw StandardException.plainWrapException( sqle);,             },         }, ,         // Else we're reusing a StringDataValue.  We only reuse,         // the result if we're executing the _same_ XMLSERIALIZE,         // call on multiple rows.  That means that all rows,         // must have the same result type (targetType) and thus,         // we know that the StringDataValue already has the,         // correct type.  So we're set., ,         if (this.isNull()) {,         // Attempts to serialize a null XML value lead to a null,         // result (SQL/XML[2003] section 10.13).,             result.setToNull();,             return result;,         }, ,         /* XML serialization rules say that sequence "normalization",          * must occur before serialization, and normalization dictates,          * that a serialization error must be thrown if the XML value,          * is a sequence with a top-level attribute.  We normalized,          * (and serialized) this XML value when it was first created,,          * and at that time we took note of whether or not there is,          * a top-level attribute.  So throw the error here if needed.,          * See SqlXmlUtil.serializeToString() for more on sequence,          * normalization.,          */,         if (this.hasTopLevelAttr()),         {,             throw StandardException.newException(,                 SQLState.LANG_XQUERY_SERIALIZATION_ERROR);,         }, ,         // Get the XML value as a string.  For this UTF-8 impl,,         // we already have it as a UTF-8 string, so just use,         // that.,         result.setValue(getString());, ,         // Seems wrong to trunc an XML document, as it then becomes non-,         // well-formed and thus useless.  So we throw an error (that's,         // what the "true" in the next line says).,         result.setWidth(targetWidth, 0, true);,         return result;,     }, ,     /**,      * The SQL/XML XMLExists operator.,      * Checks to see if evaluation of the query expression contained,      * within the received util object against this XML value returns,      * at least one item. NOTE: For now, the query expression must be,      * XPath only (XQuery not supported) because that's what Xalan,      * supports.,      *,      * @param sqlxUtil Contains SQL/XML objects and util,      *  methods that facilitate execution of XML-related,      *  operations,      * @return True if evaluation of the query expression stored,      *  in sqlxUtil returns at least one node for this XML value;,      *  unknown if the xml value is NULL; false otherwise.,      * @exception StandardException Thrown on error,      */,     public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil),         throws StandardException,     {,         if (this.isNull()) {,         // if the user specified a context node and that context,         // is null, result of evaluating the query is null,         // (per SQL/XML 6.17:General Rules:1.a), which means that we,         // return "unknown" here (per SQL/XML 8.4:General Rules:2.a).,             return SQLBoolean.unknownTruthValue();,         }, ,         // Make sure we have a compiled query (and associated XML,         // objects) to evaluate.,         if (SanityManager.DEBUG) {,             SanityManager.ASSERT(,                 sqlxUtil != null,,                 "Tried to evaluate XML xquery, but no XML objects were loaded.");,         }, ,         try {, ,             return new SQLBoolean(null !=,                 sqlxUtil.evalXQExpression(this, false, new int[1]));, ,         } catch (StandardException se) {, ,             // Just re-throw it.,             throw se;, ,         } catch (Throwable xe) {,         /* Failed somewhere during evaluation of the XML query expression;,          * turn error into a StandardException and throw it.  Note: we,          * catch "Throwable" here to catch as many Xalan-produced errors,          * as possible in order to minimize the chance of an uncaught Xalan,          * error (such as a NullPointerException) causing Derby to fail in,          * a more serious way.  In particular, an uncaught Java exception,          * like NPE can result in Derby throwing "ERROR 40XT0: An internal,          * error was identified by RawStore module" for all statements on,          * the connection after the failure--which we clearly don't want.  ,          * If we catch the error and wrap it, though, the statement will,          * fail but Derby will continue to run as normal. ,          */,             throw StandardException.newException(,                 SQLState.LANG_XML_QUERY_ERROR,,                 "XMLEXISTS", xe.getMessage());,         },     }, ,     /**,      * Evaluate the XML query expression contained within the received,      * util object against this XML value and store the results into,      * the received XMLDataValue "result" param (assuming "result" is,      * non-null; else create a new XMLDataValue).,      *,      * @param sqlxUtil Contains SQL/XML objects and util methods that,      *  facilitate execution of XML-related operations,      * @param result The result of a previous call to this method; null,      *  if not called yet.,      * @return An XMLDataValue whose content corresponds to the serialized,      *  version of the results from evaluation of the query expression.,      *  Note: this XMLDataValue may not be storable into Derby XML,      *  columns.,      * @exception StandardException thrown on error,      */,     public XMLDataValue XMLQuery(SqlXmlUtil sqlxUtil, XMLDataValue result),             throws StandardException,     {,         if (this.isNull()) {,         // if the context is null, we return null,,         // per SQL/XML[2006] 6.17:GR.1.a.ii.1.,             if (result == null),                 result = (XMLDataValue)getNewNull();,             else,                 result.setToNull();,             return result;,         }, ,         try {,  ,             // Return an XML data value whose contents are the,             // serialized version of the query results.,             int [] xType = new int[1];,             List itemRefs = sqlxUtil.evalXQExpression(,                 this, true, xType);, ,             if (result == null),                 result = new XML();,             String strResult = sqlxUtil.serializeToString(itemRefs, result);,             result.setValue(new SQLChar(strResult));, ,             // Now that we've set the result value, make sure,             // to indicate what kind of XML value we have.,             result.setXType(xType[0]);, ,             // And finally we return the query result as an XML value.,             return result;, ,         } catch (StandardException se) {, ,             // Just re-throw it.,             throw se;, ,         } catch (Throwable xe) {,         /* Failed somewhere during evaluation of the XML query expression;,          * turn error into a StandardException and throw it.  Note: we,          * catch "Throwable" here to catch as many Xalan-produced errors,          * as possible in order to minimize the chance of an uncaught Xalan,          * error (such as a NullPointerException) causing Derby to fail in,          * a more serious way.  In particular, an uncaught Java exception,          * like NPE can result in Derby throwing "ERROR 40XT0: An internal,          * error was identified by RawStore module" for all statements on,          * the connection after the failure--which we clearly don't want.  ,          * If we catch the error and wrap it, though, the statement will,          * fail but Derby will continue to run as normal. ,          */,             throw StandardException.newException(,                 SQLState.LANG_XML_QUERY_ERROR,,                 "XMLQUERY", xe.getMessage());,         },     }, ,     /* ****,      * Helper classes and methods.,      * */, ,     /**,      * Set this XML value's qualified type.,      */,     public void setXType(int xtype),     {,         this.xType = xtype;, ,         /* If the target type is XML_DOC_ANY then this XML value,          * holds a single well-formed Document.  So we know that,          * we do NOT have any top-level attribute nodes.  Note: if,          * xtype is SEQUENCE we don't set "containsTopLevelAttr",          * here; assumption is that the caller of this method will,          * then set the field as appropriate.  Ex. see "setFrom()",          * in this class.,          */,         if (xtype == XML_DOC_ANY),             containsTopLevelAttr = false;,     }, ,     /**,      * Retrieve this XML value's qualified type.,      */,     public int getXType(),     {,         return xType;,     }, ,     /**,      * Take note of the fact this XML value represents an XML,      * sequence that has one or more top-level attribute nodes.,      */,     public void markAsHavingTopLevelAttr(),     {,         this.containsTopLevelAttr = true;,     }, ,     /**,      * Return whether or not this XML value represents a sequence,      * that has one or more top-level attribute nodes.,      */,     public boolean hasTopLevelAttr(),     {,         return containsTopLevelAttr;,     }, ,     /**,      * See if the required JAXP and Xalan classes are in the,      * user's classpath.  Assumption is that we will always,      * call this method before instantiating an instance of,      * SqlXmlUtil, and thus we will never get a ClassNotFound,      * exception caused by missing JAXP/Xalan classes.  Instead,,      * if either is missing we should throw an informative,      * error indicating what the problem is.,      *,      * NOTE: This method only does the checks necessary to,      * allow successful instantiation of the SqlXmlUtil,      * class.  Further checks (esp. the presence of a JAXP,      * _implementation_ in addition to the JAXP _interfaces_),      * are performed in the SqlXmlUtil constructor.,      *,      * @exception StandardException thrown if the required,      *  classes cannot be located in the classpath.,      */,     public static void checkXMLRequirements(),         throws StandardException,     {,         // Only check once; after that, just re-use the result.,         if (xmlReqCheck == null),         {,             xmlReqCheck = "";, ,             /* If the w3c Document class exists, then we,              * assume a JAXP implementation is present in,              * the classpath.  If this assumption is incorrect,              * then we at least know that the JAXP *interface*,              * exists and thus we'll be able to instantiate,              * the SqlXmlUtil class.  We can then do a check,              * for an actual JAXP *implementation* from within,              * the SqlXmlUtil class (see the constructor of,              * that class).,              *,              * Note: The JAXP API and implementation are,              * provided as part the JVM if it is jdk 1.4 or,              * greater.,              */,             Object docImpl = checkJAXPRequirement();,             if (docImpl == null),                 xmlReqCheck = "JAXP";, ,             /* If the XPath class exists, then we assume that our XML,              * query processor (in this case, Xalan), is present in the,              * classpath.  Note: if JAXP API classes aren't present,              * then the following check will return false even if the,              * Xalan classes *are* present; this is because the Xalan,              * XPath class relies on JAXP, as well.  Thus there's no,              * point in checking for Xalan unless we've already confirmed,              * that we have the JAXP interfaces.,              */,             else if (!checkXPathRequirement(docImpl)),                 xmlReqCheck = "XPath 3.0";,         }, ,         if (xmlReqCheck.length() != 0),         {,             throw StandardException.newException(,                 SQLState.LANG_MISSING_XML_CLASSES, xmlReqCheck);,         }, ,         return;,     }, ,     /**,      * Check if we have a JAXP implementation installed.,      *,      * @return a {@code DOMImplementation} object retrieved from the,      * JAXP implementation, if one is installed, or {@code null} if an,      * implementation couldn't be found,      */,     private static Object checkJAXPRequirement() {,         try {,             Class<?> factoryClass =,                     Class.forName("javax.xml.parsers.DocumentBuilderFactory");,             Method newFactory = factoryClass.getMethod(,                     "newInstance", new Class[0]);,             Method newBuilder = factoryClass.getMethod(,                     "newDocumentBuilder", new Class[0]);, ,             Class<?> builderClass =,                     Class.forName("javax.xml.parsers.DocumentBuilder");,             Method getImpl = builderClass.getMethod(,                     "getDOMImplementation", new Class[0]);, ,             Object factory = newFactory.invoke(null, new Object[0]);,             Object builder = newBuilder.invoke(factory, new Object[0]);,             Object impl = getImpl.invoke(builder, new Object[0]);, ,             return impl;, ,         } catch (Throwable t) {,             // Oops... Couldn't get a DOMImplementation object for,             // some reason. Assume we don't have JAXP.,             return null;,         },     }, ,     /**,      * Check if the supplied {@code DOMImplementation} object has,      * support for DOM Level 3 XPath.,      *,      * @param domImpl the {@code DOMImplementation} instance to check,      * @return {@code true} if the required XPath level is supported,,      * {@code false} otherwise,      */,     private static boolean checkXPathRequirement(Object domImpl) {,         try {,             Class<?> domImplClass = Class.forName("org.w3c.dom.DOMImplementation");,             Method getFeature = domImplClass.getMethod(,                     "getFeature", new Class[] {String.class, String.class});,             Object impl =,                     getFeature.invoke(domImpl, new Object[] {"+XPath", "3.0"});,             return impl != null;,         } catch (Throwable t) {,             // Oops... Something went wrong when checking for XPath,             // 3.0 support. Assume we don't have it.,             return false;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/iapi/util/ByteArray.java,getArray,113-113,[		return array;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/util/ByteArray.java,<init>,51-51,[		this.array = array;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/util/ByteArray.java,setBytes,66-66,[		this.array = array;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/util/ByteArray.java,setBytes,73-73,[		this.array = array;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/iapi/util/ByteArray.java,setBytes,80-80,[		this.array = array;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/iapi/util/DoubleProperties.java,,45-81,[	public DoubleProperties(Properties read, Properties write) {, 		this.read = read;, 		this.write = write;, 	}, , 	public Object put(Object key, Object value) {, 		return write.put(key, value);, 	}, , 	public String getProperty(String key) {, , 		return read.getProperty(key, write.getProperty(key));, 	}, , 	public String getProperty(String key, String defaultValue) {, 		return read.getProperty(key, write.getProperty(key, defaultValue));, , 	}, , 	public Enumeration<Object> propertyNames() {,         HashSet<Object> names = new HashSet<Object>();,         addAllNames(write, names);,         addAllNames(read, names);,         return Collections.enumeration(names);, 	}, ,     /**,      * Add all property names in the Properties object {@code src} to the,      * HashSet {@code dest}.,      */,     private static void addAllNames(Properties src, HashSet<Object> dest) {,         if (src != null) {,             for (Enumeration e = src.propertyNames(); e.hasMoreElements(); ) {,                 dest.add(e.nextElement());,             },         },     }],,
I18N,DM_CONVERT_CASE,org/apache/derby/iapi/util/IdUtil.java,SQLIdentifier2CanonicalPropertyUsername,264-264,[			result = authid.toLowerCase();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/util/IdUtil.java,parseIdList,516-516,[		if (v.size() == 0) return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/util/IdUtil.java,parseIdList,469-469,[		if (p==null) return null;],,
BAD_PRACTICE,CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE,org/apache/derby/iapi/util/JBitSet.java,clone,216-216,[		return new JBitSet((BitSet) bitSet.clone(), size);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/iapi/util/StringUtil.java,fromHexString,244-244,[			return null;],,fromHexString,258-258,[				return null;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/db/BasicDatabase.java,apply,689-689,[			String newClasspath = (String) value;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/db/BasicDatabase.java,validate,642-642,[		String newClasspath = (String) value;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/db/BasicDatabase.java,pushDbContext,331-331,[		DatabaseContext dc = new DatabaseContextImpl(cm, this);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/db/BasicDatabase.java,boot,171-171,[            Monitor.bootServiceModule(],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/db/SlaveDatabase.java,handleShutdown,437-437,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/db/SlaveDatabase.java,handleShutdown,437-437,[        } catch (Exception e) {],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/db/SlaveDatabase.java,run,324-324,[                    bootThreadCm = null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/db/SlaveDatabase.java,run,321-321,[                if (bootThreadCm != null) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/drda/AppRequester.java,equals,201-201,[        if (!prdid.equals(a.prdid))],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/drda/DRDAConnThread.java,parseACCRDB,3539-3539,[                    if (appRequester.prdid.length() > CodePoint.PRDID_MAX) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/drda/CcsidManager.java,,41-41,[    this.dot = dot;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/drda/CcsidManager.java,,42-42,[    this.numToCharRepresentation = numToCharRepresentation;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/drda/ClientThread.java,acceptClientWithRetry,73-73,[                        clientSocket.setKeepAlive(parent.getKeepAlive());],,acceptClientWithRetry,100-100,[                    if (clientSocket != null)],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/impl/drda/CodePointNameTable.java,,32-168,[  {,     put(CodePoint.ABNUOWRM, "ABNUOWRM");,     put(CodePoint.ACCRDB, "ACCRDB");,     put(CodePoint.ACCRDBRM, "ACCRDBRM");,     put(CodePoint.ACCSEC, "ACCSEC");,     put(CodePoint.ACCSECRD, "ACCSECRD");,     put(CodePoint.AGENT, "AGENT");,     put(CodePoint.AGNPRMRM, "AGNPRMRM");,     put(CodePoint.BGNBND, "BGNBND");,     put(CodePoint.BGNBNDRM, "BGNBNDRM");,     put(CodePoint.BNDSQLSTT, "BNDSQLSTT");,     put(CodePoint.CCSIDSBC, "CCSIDSBC");,     put(CodePoint.CCSIDMBC, "CCSIDMBC");,     put(CodePoint.CCSIDDBC, "CCSIDDBC");,     put(CodePoint.CLSQRY, "CLSQRY");,     put(CodePoint.CMDATHRM, "CMDATHRM");,     put(CodePoint.CMDCHKRM, "CMDCHKRM");,     put(CodePoint.CMDCMPRM, "CMDCMPRM");,     put(CodePoint.CMDNSPRM, "CMDNSPRM");,     put(CodePoint.CMMRQSRM, "CMMRQSRM");,     put(CodePoint.CMDVLTRM, "CMDVLTRM");,     put(CodePoint.CNTQRY, "CNTQRY");,     put(CodePoint.CRRTKN, "CRRTKN");,     put(CodePoint.DRPPKG, "DRPPKG");,     put(CodePoint.DSCRDBTBL, "DSCRDBTBL");,     put(CodePoint.DSCINVRM, "DSCINVRM");,     put(CodePoint.DSCSQLSTT, "DSCSQLSTT");,     put(CodePoint.DTAMCHRM, "DTAMCHRM");,     put(CodePoint.ENDBND, "ENDBND");,     put(CodePoint.ENDQRYRM, "ENDQRYRM");,     put(CodePoint.ENDUOWRM, "ENDUOWRM");,     put(CodePoint.EXCSAT, "EXCSAT");,     put(CodePoint.EXCSATRD, "EXCSATRD");,     put(CodePoint.EXCSQLIMM, "EXCSQLIMM");,     put(CodePoint.EXCSQLSET, "EXCSQLSET");,     put(CodePoint.EXCSQLSTT, "EXCSQLSTT");,     put(CodePoint.EXTNAM, "EXTNAM");,     put(CodePoint.FRCFIXROW, "FRCFIXROW");,     put(CodePoint.MAXBLKEXT, "MAXBLKEXT");,     put(CodePoint.MAXRSLCNT, "MAXRSLCNT");,     put(CodePoint.MGRDEPRM, "MGRDEPRM");,     put(CodePoint.MGRLVLLS, "MGRLVLLS");,     put(CodePoint.MGRLVLRM, "MGRLVLRM");,     put(CodePoint.MONITOR, "MONITOR");,     put(CodePoint.NBRROW, "NBRROW");,     put(CodePoint.OBJNSPRM, "OBJNSPRM");,     put(CodePoint.OPNQFLRM, "OPNQFLRM");,     put(CodePoint.OPNQRY, "OPNQRY");,     put(CodePoint.OPNQRYRM, "OPNQRYRM");,     put(CodePoint.OUTEXP, "OUTEXP");,     put(CodePoint.OUTOVR, "OUTOVR");,     put(CodePoint.OUTOVROPT, "OUTOVROPT");,     put(CodePoint.PASSWORD, "PASSWORD");,     put(CodePoint.PKGID, "PKGID");,     put(CodePoint.PKGBNARM, "PKGBNARM");,     put(CodePoint.PKGBPARM, "PKGBPARM");,     put(CodePoint.PKGNAMCSN, "PKGNAMCSN");,     put(CodePoint.PKGNAMCT, "PKGNAMCT");,     put(CodePoint.PRCCNVRM, "PRCCNVRM");,     put(CodePoint.PRDID, "PRDID");,     put(CodePoint.PRDDTA, "PRDDTA");,     put(CodePoint.PRMNSPRM, "PRMNSPRM");,     put(CodePoint.PRPSQLSTT, "PRPSQLSTT");,     put(CodePoint.QRYBLKCTL, "QRYBLKCTL");,     put(CodePoint.QRYBLKRST, "QRYBLKRST");,     put(CodePoint.QRYBLKSZ, "QRYBLKSZ");,     put(CodePoint.QRYCLSIMP, "QRYCLSIMP");,     put(CodePoint.QRYCLSRLS, "QRYCLSRLS");,     put(CodePoint.QRYDSC, "QRYDSC");,     put(CodePoint.QRYDTA, "QRYDTA");,     put(CodePoint.QRYINSID, "QRYINSID");,     put(CodePoint.QRYNOPRM, "QRYNOPRM");,     put(CodePoint.QRYPOPRM, "QRYPOPRM");,     put(CodePoint.QRYRELSCR, "QRYRELSCR");,     put(CodePoint.QRYRFRTBL, "QRYRFRTBL");,     put(CodePoint.QRYROWNBR, "QRYROWNBR");,     put(CodePoint.QRYROWSNS, "QRYROWSNS");,     put(CodePoint.QRYRTNDTA, "QRYRTNDTA");,     put(CodePoint.QRYSCRORN, "QRYSCRORN");,     put(CodePoint.QRYROWSET, "QRYROWSET");,     put(CodePoint.RDBAFLRM, "RDBAFLRM");,     put(CodePoint.RDBACCCL, "RDBACCCL");,     put(CodePoint.RDBACCRM, "RDBACCRM");,     put(CodePoint.RDBALWUPD, "RDBALWUPD");,     put(CodePoint.RDBATHRM, "RDBATHRM");,     put(CodePoint.RDBCMM, "RDBCMM");,     put(CodePoint.RDBCMTOK, "RDBCMTOK");,     put(CodePoint.RDBNACRM, "RDBNACRM");,     put(CodePoint.RDBNAM, "RDBNAM");,     put(CodePoint.RDBNFNRM, "RDBNFNRM");,     put(CodePoint.RDBRLLBCK, "RDBRLLBCK");,     put(CodePoint.RDBUPDRM, "RDBUPDRM");,     put(CodePoint.REBIND, "REBIND");,     put(CodePoint.RSCLMTRM, "RSCLMTRM");,     put(CodePoint.RSLSETRM, "RSLSETRM");,     put(CodePoint.RTNEXTDTA, "RTNEXTDTA");,     put(CodePoint.RTNSQLDA, "RTNSQLDA");,     put(CodePoint.SECCHK, "SECCHK");,     put(CodePoint.SECCHKCD, "SECCHKCD");,     put(CodePoint.SECCHKRM, "SECCHKRM");,     put(CodePoint.SECMEC, "SECMEC");,     put(CodePoint.SECMGRNM, "SECMGRNM");,     put(CodePoint.SECTKN, "SECTKN");,     put(CodePoint.SPVNAM, "SPVNAM");,     put(CodePoint.SQLAM, "SQLAM");,     put(CodePoint.SQLATTR, "SQLATTR");,     put(CodePoint.SQLCARD, "SQLCARD");,     put(CodePoint.SQLERRRM, "SQLERRRM");,     put(CodePoint.SQLDARD, "SQLDARD");,     put(CodePoint.SQLDTA, "SQLDTA");,     put(CodePoint.SQLDTARD, "SQLDTARD");,     put(CodePoint.SQLSTT, "SQLSTT");,     put(CodePoint.SQLSTTVRB, "SQLSTTVRB");,     put(CodePoint.SRVCLSNM, "SRVCLSNM");,     put(CodePoint.SRVRLSLV, "SRVRLSLV");,     put(CodePoint.SRVNAM, "SRVNAM");,     put(CodePoint.SVRCOD, "SVRCOD");,     put(CodePoint.SYNCCTL, "SYNCCTL");,     put(CodePoint.SYNCLOG, "SYNCLOG");,     put(CodePoint.SYNCRSY, "SYNCRSY");,     put(CodePoint.SYNTAXRM, "SYNTAXRM");,     put(CodePoint.TRGNSPRM, "TRGNSPRM");,     put(CodePoint.TYPDEFNAM, "TYPDEFNAM");,     put(CodePoint.TYPDEFOVR, "TYPDEFOVR");,     put(CodePoint.TYPSQLDA, "TYPSQLDA");,     put(CodePoint.UOWDSP, "UOWDSP");,     put(CodePoint.USRID, "USRID");,     put(CodePoint.VALNSPRM, "VALNSPRM");,     put(CodePoint.PBSD, "PBSD");,     put(CodePoint.PBSD_ISO, "PBSD_ISO");,     put(CodePoint.PBSD_SCHEMA, "PBSD_SCHEMA");,     put(CodePoint.UNICODEMGR, "UNICODEMGR");,   }, ,   String lookup (int codePoint),   {,     return get(codePoint);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/drda/DDMReader.java,getExtData,1136-1136,[        return null;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/drda/DDMReader.java,,204-204,[        svrcod = 0;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/drda/DDMWriter.java,writeBytes,597-597,[            if (length + start - 1 > buf.length)],,writeBytes,595-595,[            if (buf == null && length > 0)],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/drda/DDMWriter.java,writeUDT,1101-1101,[            ObjectOutputStream oos = new ObjectOutputStream( dbaos );],,
STYLE,UC_USELESS_CONDITION_TYPE,org/apache/derby/impl/drda/DDMWriter.java,calculateExtendedLengthByteCount,1565-1565,[            return 0;],,calculateExtendedLengthByteCount,1560-1560,[        else if (ddmSize <= 0x7fffffffffffffffL)],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/drda/DDMWriter.java,,181-181,[        isDRDAProtocol = true;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/drda/DRDAConnThread.java,parseSECCHK,3160-3161,[                    reader.skipBytes();,                     break;],,parseSECCHK,3267-3268,[                    reader.skipBytes();,                     break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/drda/DRDAConnThread.java,processCommands,1015-1017,[                    reader.skipBytes();,                     writeSQLCARDs(null, 0);,                     break;],,processCommands,1028-1030,[                    reader.skipBytes();,                     writeSQLCARDs(null, 0);,                     break;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/drda/DRDAConnThread.java,writeSQLCARD,6175-6175,[                } catch (Exception restart)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/DRDAConnThread.java,parseEXCSQLSTT,4336-4336,[                CallableStatement cs = (CallableStatement) stmt.prepare(prepareString);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/DRDAConnThread.java,parseSQLSTTDss,5822-5822,[        int codePoint = reader.readLengthAndCodePoint( false );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/DRDAConnThread.java,parseCLSQRY,6015-6015,[                    qryinsid = reader.readNetworkLong();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/DRDAConnThread.java,parseEXCSQLSET,5453-5453,[                    Pkgnamcsn pkgnamcsn = parsePKGNAMCSN();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/DRDAConnThread.java,parseEXCSQLSET,5440-5440,[                    String pkgnamct = parsePKGNAMCT();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/DRDAConnThread.java,parseOUTOVR,2761-2761,[            tripId = reader.readUnsignedByte();],,
PERFORMANCE,DM_GC,org/apache/derby/impl/drda/DRDAConnThread.java,showmem,8908-8908,[        rt.gc();],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/derby/impl/drda/DRDAConnThread.java,writeFdocaVal,8329-8329,[                    writer.writeString(((String) val).toString());],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/impl/drda/DRDAConnThread.java,getProductIDBytes,373-373,[        if ( prdIdBytes == null ) { prdIdBytes = NetworkServerControlImpl.prdIdBytes(); }],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/impl/drda/DRDAConnThread.java,parseACCSEC,1989-1990,[                                    if (decryptionManager == null) {,                                         decryptionManager = new DecryptionManager();],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/impl/drda/DRDAConnThread.java,println2Log,566-567,[        if (logStream == null) {,             logStream = Monitor.getStream();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/impl/drda/DRDAConnThread.java,getDbName,449-449,[        return (database == null) ? null : database.getDatabaseName();],,getDBName,2351-2353,[			SanityManager.ASSERT(!isClosed(), "connection is closed");, , 		return getTR().getDBName();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/drda/DRDAConnThread.java,writeSQLCARDs,6083-6083,[            writeSQLCARD(e, updateCount, 0);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/drda/DRDAConnThread.java,parseCLSQRY,6042-6042,[        if (stmt.wasExplicitlyClosed())],,parseCLSQRY,6036-6036,[        if (stmt == null)],,parseCLSQRY,6039-6039,[            invalidValue(CodePoint.PKGNAMCSN);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/drda/DRDAConnThread.java,parseCNTQRY,2675-2675,[        if (stmt.rsIsClosed())],,parseCNTQRY,2669-2669,[        if (stmt == null)],,parseCNTQRY,2672-2672,[            invalidValue(CodePoint.CNTQRY);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/drda/DRDAConnThread.java,parseEXCSQLSTT,4301-4301,[            stmt.setQryprctyp(CodePoint.QRYBLKCTL_DEFAULT);],,parseEXCSQLSTT,4299-4299,[                invalidValue(CodePoint.PKGNAMCSN);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/drda/DRDAConnThread.java,parseOPNQRY,2211-2211,[        stmt.setOPNQRYOptions(blksize,qryblkctl,maxblkext,outovropt,],,parseOPNQRY,2193-2193,[        if (stmt == null)],,parseOPNQRY,2196-2196,[            invalidValue(CodePoint.PKGNAMCSN);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/drda/DRDAConnThread.java,parseEXCSQLSETobjects,5572-5572,[                        if (sqlStmt.startsWith(TIMEOUT_STATEMENT)) {],,parseEXCSQLSETobjects,5567-5567,[                        if (sqlStmt != null) {],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/impl/drda/DRDAConnThread.java,parseCLSQRY,6035-6035,[        DRDAStatement stmt = database.getDRDAStatement(pkgnamcsn);],,parseCLSQRY,6028-6028,[        if (pkgnamcsn == null) {],,parseCLSQRY,6029-6029,[            missingCodePoint(CodePoint.PKGNAMCSN);],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/impl/drda/DRDAConnThread.java,parseCNTQRY,2668-2668,[        DRDAStatement stmt = database.getDRDAStatement(pkgnamcsn);],,parseCNTQRY,2657-2657,[        if (pkgnamcsn == null) {],,parseCNTQRY,2658-2658,[            missingCodePoint(CodePoint.PKGNAMCSN);],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/impl/drda/DRDAConnThread.java,parseEXCSQLSTT,4276-4276,[        stmt  = database.getDRDAStatement(pkgnamcsn);],,parseEXCSQLSTT,4269-4269,[        if (pkgnamcsn == null) {],,parseEXCSQLSTT,4270-4270,[            missingCodePoint(CodePoint.PKGNAMCSN);],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/impl/drda/DRDAConnThread.java,parseOPNQRY,2192-2192,[        DRDAStatement stmt = database.getDRDAStatement(pkgnamcsn);],,parseOPNQRY,2184-2184,[        if (pkgnamcsn == null) {],,parseOPNQRY,2185-2185,[            missingCodePoint(CodePoint.PKGNAMCSN);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/drda/DRDAConnThread.java,buildSqlerrmc,6465-6465,[        int maxlen = (sqlerrmc == null) ? -1 : Math.min(sqlerrmc.length(),],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/drda/DRDAConnThread.java,parseOPNQRY,858-858,[                        if (pkgnamcsn != null)],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/drda/DRDAConnThread.java,traceEXTDTARead,8887-8887,[                    append("/").append(encoding).append("/").],,traceEXTDTARead,8889-8889,[            if (stream == null) {],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/derby/impl/drda/DRDAConnThread.java,parseACCSEC,1959-1959,[                            if (((securityMechanism != CodePoint.SECMEC_EUSRIDPWD) ||],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/drda/DRDAConnThread.java,buildTokenizedSqlerrmc,6522-6522,[                    sqlerrmc += args[i] + SQLERRMC_TOKEN_DELIMITER;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/drda/DRDAConnThread.java,writeSQLDIAGCI,6745-6745,[                        sqlerrmc += args[i].toString() + SQLERRMC_TOKEN_DELIMITER;],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/derby/impl/drda/DRDAConnThread.java,writeRDBfailure,1304-1307,[                writer.endDss();,             case CodePoint.RDBNFNRM:,             case CodePoint.RDBATHRM:,                 writeSQLCARD(databaseAccessException, 0, 0);],,writeRDBfailure,1307-1310,[                writeSQLCARD(databaseAccessException, 0, 0);,             case CodePoint.RDBACCRM:,                 //Ignore anything that was chained to the ACCRDB.,                 skipRemainder(false);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/drda/DRDAConnThread.java,readAndSetExtParam,5296-5307,[            switch (drdaType) {,                 case DRDAConstants.DRDA_TYPE_LOBCSBCS:,                 case DRDAConstants.DRDA_TYPE_NLOBCSBCS:,                     encoding = stmt.ccsidSBCEncoding;,                     break;,                 case DRDAConstants.DRDA_TYPE_LOBCDBCS:,                 case DRDAConstants.DRDA_TYPE_NLOBCDBCS:,                     encoding = stmt.ccsidDBCEncoding;,                     break;,                 case DRDAConstants.DRDA_TYPE_LOBCMIXED:,                 case DRDAConstants.DRDA_TYPE_NLOBCMIXED:,                     encoding = stmt.ccsidMBCEncoding;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/drda/DRDAConnThread.java,writeRDBfailure,1297-1314,[        switch(codePoint){,             case CodePoint.RDBAFLRM:,                 //RDBAFLRM requires TYPDEFNAM and TYPDEFOVR,                 writer.createDssObject();,                 writer.writeScalarString(CodePoint.TYPDEFNAM,,                                          CodePoint.TYPDEFNAM_QTDSQLASC);,                 writeTYPDEFOVR();,                 writer.endDss();,             case CodePoint.RDBNFNRM:,             case CodePoint.RDBATHRM:,                 writeSQLCARD(databaseAccessException, 0, 0);,             case CodePoint.RDBACCRM:,                 //Ignore anything that was chained to the ACCRDB.,                 skipRemainder(false);, ,                 // Finalize chain state for whatever we wrote in,                 // response to ACCRDB.,                 finalizeChain();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/drda/DRDAConnThread.java,writeSQLDAGRP,8014-8022,[        switch (elemType),         {,             case Types.BINARY:,             case Types.VARBINARY:,             case Types.LONGVARBINARY:,             case Types.BLOB:            //for CLI describe to be correct,             case Types.CLOB:,                 outlen[0] = (rtnOutput ? rsmeta.getPrecision(jdbcElemNum) :,                                             pmeta.getPrecision(jdbcElemNum));],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/drda/DRDAConnThread.java,parseCLSQRY,6042-6042,[        if (stmt.wasExplicitlyClosed())],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/drda/DRDAConnThread.java,parseSECCHK,3254-3254,[                        tooMany(CodePoint.SECTKN);],,parseSECCHK,3234-3234,[                    else if (database.securityMechanism ==],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/drda/DRDAConnThread.java,parseACCSEC,2054-2054,[                SanityManager.ASSERT((securityCheckCode == 0),],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/drda/DRDAConnThread.java,parseACCSEC,1959-1959,[                            if (((securityMechanism != CodePoint.SECMEC_EUSRIDPWD) ||],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/drda/DRDAConnThread.java,writeQRYPOPRM,2377-2383,[        writer.createDssReply();,         writer.startDdm(CodePoint.QRYPOPRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, CodePoint.SVRCOD_ERROR);,         writeRDBNAM(database.getDatabaseName());,         writePKGNAMCSN();,         writer.endDdmAndDss();,     }],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/derby/impl/drda/DRDAConnThread.java,,111-9501,[    private static int [] ACCRDB_REQUIRED = {CodePoint.RDBACCCL, ,                                              CodePoint.CRRTKN,,                                              CodePoint.PRDID,,                                              CodePoint.TYPDEFNAM,,                                              CodePoint.TYPDEFOVR};, ,     private static int MAX_REQUIRED_LEN = 5;, ,     private int currentRequiredLength = 0;,     private int [] required = new int[MAX_REQUIRED_LEN];, , ,     private NetworkServerControlImpl server;            // server who created me,     private Session session;    // information about the session,     /** Time slice for this thread. */,     private volatile long timeSlice;,     /** Whether or not to log connections. */,     private volatile boolean logConnections;, ,     private boolean sendWarningsOnCNTQRY = false;   // Send Warnings for SELECT if true,     /** End this thread. */,     private volatile boolean close;,     private static HeaderPrintWriter logStream;,     private AppRequester appRequester;  // pointer to the application requester,                                         // for the session being serviced,     private Database database;  // pointer to the current database,     private int sqlamLevel;     // SQLAM Level - determines protocol, ,     // DRDA diagnostic level, DIAGLVL0 by default ,     private byte diagnosticLevel = (byte)0xF0; , ,     // manager processing,     private List<Integer> unknownManagers;,     private List<Integer> knownManagers;, ,     // database accessed failed,     private SQLException databaseAccessException;, ,     // these fields are needed to feed back to jcc about a statement/procedure's PKGNAMCSN,     /** The value returned by the previous call to,      * <code>parsePKGNAMCSN()</code>. */,     private Pkgnamcsn prevPkgnamcsn = null;,     /** Current RDB Package Name. */,     private DRDAString rdbnam = null;,     /** Current RDB Collection Identifier. */,     private DRDAString rdbcolid = null;,     /** Current RDB Package Identifier. */,     private DRDAString pkgid = null;,     /** Current RDB Package Consistency Token. */,     private DRDAString pkgcnstkn = null;,     /** Current RDB Package Section Number. */,     private int pkgsn;, ,     private final static String TIMEOUT_STATEMENT = "SET STATEMENT_TIMEOUT ";, ,     private int pendingStatementTimeout; // < 0 means no pending timeout to set, ,     // this flag is for an execute statement/procedure which actually returns a result set;,     // do not commit the statement, otherwise result set is closed, ,     // for decryption,     private static DecryptionManager decryptionManager;, ,     // public key generated by Deffie-Hellman algorithm, to be passed to the encrypter,,     // as well as used to initialize the cipher,     private byte[] myPublicKey;, ,     // generated target seed to be used to generate the password substitute,     // as part of SECMEC_USRSSBPWD security mechanism,     private byte[] myTargetSeed;, ,     // product id as bytes,     private static  byte[]  prdIdBytes;, ,     // Some byte[] constants that are frequently written into messages. It is more efficient to ,     // use these constants than to convert from a String each time ,     // (This replaces the qryscraft_ and notQryscraft_ static exception objects.),     private static final byte[] eod00000 = { '0', '0', '0', '0', '0' };,     private static final byte[] eod02000 = { '0', '2', '0', '0', '0' };,     private static final byte[] nullSQLState = { ' ', ' ', ' ', ' ', ' ' };,     private static final byte[] errD5_D6 = { 0, 0, 0, 0, 0, 0, 0, 0 }; // 8x0 ,     private static final byte[] warn0_warnA = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };  // 11x ' ', ,     private final static String AUTHENTICATION_PROVIDER_BUILTIN_CLASS =,     "org.apache.derby.impl.jdbc.authentication.BasicAuthenticationServiceImpl";, ,     private final static String AUTHENTICATION_PROVIDER_NONE_CLASS =,     "org.apache.derby.impl.jdbc.authentication.NoneAuthenticationServiceImpl";, ,     // Work around a classloader bug involving interrupt handling during,     // class loading. If the first request to load the,     // DRDAProtocolExceptionInfo class occurs during shutdown, the,     // loading of the class may be aborted when the Network Server calls,     // Thread.interrupt() on the DRDAConnThread. By including a static,     // reference to the DRDAProtocolExceptionInfo class here, we ensure,     // that it is loaded as soon as the DRDAConnThread class is loaded,,     // and therefore we know we won't be trying to load the class during,     // shutdown. See DERBY-1338 for more background, including pointers,     // to the apparent classloader bug in the JVM.,     private static final DRDAProtocolExceptionInfo dummy =,         new DRDAProtocolExceptionInfo(0,0,0,false);,     /**,      * Tells if the reset / connect request is a deferred request.,      * This information is used to work around a bug (DERBY-3596) in a,      * compatible manner, which also avoids any changes in the client driver.,      * <p>,      * The bug manifests itself when a connection pool data source is used and,      * logical connections are obtained from the physical connection associated,      * with the data source. Each new logical connection causes a new physical,      * connection on the server, including a new transaction. These connections,      * and transactions are not closed / cleaned up.,      */,     private boolean deferredReset = false;, ,     // constructor,     /**,      * Create a new Thread for processing session requests,      *,      * @param session Session requesting processing,      * @param server  Server starting thread,      * @param timeSlice timeSlice for thread,      * @param logConnections,      **/, ,     DRDAConnThread(Session session, NetworkServerControlImpl server, ,                           long timeSlice,,                           boolean logConnections) {,         // Use a more meaningful name for this thread.,         super(NetworkServerControlImpl.getUniqueThreadName("DRDAConnThread"));, ,         this.session = session;,         this.server = server;,         this.timeSlice = timeSlice;,         this.logConnections = logConnections;,         this.pendingStatementTimeout = -1;,         initialize();,     }, ,     /**,      * Main routine for thread, loops until the thread is closed,      * Gets a session, does work for the session,      */,     @Override,     public void run() {,         if (SanityManager.DEBUG) {,             trace("Starting new connection thread");,         }, ,         Session prevSession;,         while(!closed()),         {, ,             // get a new session,             prevSession = session;,             session = server.getNextSession(session);,             if (session == null) {,                 close();,             }, ,             if (closed()) {,                 break;,             }, ,             if (session != prevSession),             {,                 initializeForSession();,             },             try {,                 long timeStart = System.currentTimeMillis();, ,                 switch (session.state),                 {,                     case Session.INIT:,                         sessionInitialState();,                         if (session == null) {,                             break;,                         },                         // else fallthrough,                     case Session.ATTEXC:,                     case Session.SECACC:,                     case Session.CHKSEC:,                         long currentTimeSlice;, ,                         do {,                             try {,                                 processCommands();,                             } catch (DRDASocketTimeoutException ste) {,                                 // Just ignore the exception. This was,                                 // a timeout on the read call in,                                 // DDMReader.fill(), which will happen,                                 // only when timeSlice is set.,                             },                             currentTimeSlice = getTimeSlice();,                         } while ((currentTimeSlice <= 0)  || ,                             (System.currentTimeMillis() - timeStart < currentTimeSlice));, ,                         break;,                     default:,                         // this is an error,                         agentError("Session in invalid state:" + session.state);,                 },             } catch (Exception e) {,                 if (e instanceof DRDAProtocolException && ,                         ((DRDAProtocolException)e).isDisconnectException()),                 {,                     // client went away - this is O.K. here,                     closeSession();,                 },                 else,                 {,                     handleException(e);,                 },             } catch (Error error) {,                 // Do as little as possible, but try to cut loose the client,                 // to avoid that it hangs in a socket read-call.,                 // TODO: Could make use of Throwable.addSuppressed here when,                 //       compiled as Java 7 (or newer).,                 try {,                     closeSession();,                 } catch (Throwable t) {,                     // One last attempt...,                     try {,                         session.clientSocket.close();,                     } catch (IOException ioe) {,                         // Ignore, we're in deeper trouble already.,                     } ,                 } finally {,                     // Rethrow the original error, ignore errors that happened,                     // when trying to close the socket to the client.,                     throw error;,                 },             },         },         if (SanityManager.DEBUG) {,             trace("Ending connection thread");,         },         server.removeThread(this);, ,     },     /**,      * Get input stream,      *,      * @return input stream,      */,     protected InputStream getInputStream(),     {,         return sockis;,     }, ,     /**,      * Get output stream,      *,      * @return output stream,      */,     protected OutputStream getOutputStream(),     {,         return sockos;,     }, ,     /** Get product id as bytes */,     private static  byte[]  getProductIDBytes(),     {,         if ( prdIdBytes == null ) { prdIdBytes = NetworkServerControlImpl.prdIdBytes(); },         return prdIdBytes;,     }, ,     /**,      *  get DDMReader,      * @return DDMReader for this thread,      */,     protected DDMReader getReader(),     {,         return reader;,     },     ,     /** ,      * get  DDMWriter ,      * @return DDMWriter for this thread,      */,     protected DDMWriter getWriter(),     {,         return writer;,     }, ,     /**,      * Get correlation id,      *,      * @return correlation id,      */,     protected int getCorrelationID (),     {,         return correlationID;,     }, ,     /**,      * Get session we are working on,      *,      * @return session,      */,     protected Session getSession(),     {,         return session;,     }, ,     /**,      * Get Database we are working on,      *,      * @return database,      */,     protected Database getDatabase(),     {,         return database;,     },     /**,      * Get server,      *,      * @return server,      */,     protected NetworkServerControlImpl getServer(),     {,         return server;,     },     /**,      * Get correlation token,      *,      * @return crrtkn,      */,     protected byte[] getCrrtkn(),     {,         return (database == null) ? null : database.crrtkn;,     },     /**,      * Get database name,      *,      * @return database name,      */,     protected String getDbName(),     {,         return (database == null) ? null : database.getDatabaseName();,     },     /**,      * Close DRDA  connection thread,      */,     protected void close(),     {,         close = true;,     }, ,     /**,      * Set logging of connections,      * ,      * @param value value to set for logging connections,      */,     protected void setLogConnections(boolean value),     {,         logConnections = value;,     },     /**,      * Set time slice value,      *,      * @param value new value for time slice,      */,     protected void setTimeSlice(long value),     {,         timeSlice = value;,     },     /**,      * Indicate a communications failure,      * ,      * @param arg1 - info about the communications failure,      * @param arg2 - info about the communications failure,      * @param arg3 - info about the communications failure,      * @param arg4 - info about the communications failure,      *,      * @exception DRDAProtocolException  disconnect exception always thrown,      */,     protected void markCommunicationsFailure(String arg1, String arg2, String arg3,,         String arg4) throws DRDAProtocolException,     {,         markCommunicationsFailure(null,arg1,arg2,arg3, arg4);, ,     },         ,         ,         /**,          * Indicate a communications failure. Log to derby.log,          * ,          * @param e  - Source exception that was thrown,          * @param arg1 - info about the communications failure,          * @param arg2 - info about the communications failure,          * @param arg3 - info about the communications failure,          * @param arg4 - info about the communications failure,          *,          * @exception DRDAProtocolException  disconnect exception always thrown,          */,         protected void markCommunicationsFailure(Exception e, String arg1, String arg2, String arg3,,                 String arg4) throws DRDAProtocolException,         {,             if (e != null) {,                 println2Log(getDbName(), session.drdaID, e.getMessage());,                 server.consoleExceptionPrintTrace(e);,             },         ,             Object[] oa = {arg1,arg2,arg3,arg4};,             throw DRDAProtocolException.newDisconnectException(this,oa);,         }, ,     /**,      * Syntax error,      *,      * @param errcd     Error code,      * @param cpArg  code point value,      * @exception DRDAProtocolException,      */, ,     protected  void throwSyntaxrm(int errcd, int cpArg),         throws DRDAProtocolException,     {,         throw new,             DRDAProtocolException(DRDAProtocolException.DRDA_Proto_SYNTAXRM,,                                   this,,                                   cpArg,,                                   errcd);,     },     /**,      * Agent error - something very bad happened,      *,      * @param msg   Message describing error,      *,      * @exception DRDAProtocolException  newAgentError always thrown,      */,     protected void agentError(String msg) throws DRDAProtocolException,     {,         throw DRDAProtocolException.newAgentError(this, CodePoint.SVRCOD_PRMDMG, ,             getDbName(), msg);,     },     /**,      * Missing code point,      *,      * @param codePoint  code point value,      * @exception DRDAProtocolException,      */,     protected void missingCodePoint(int codePoint) throws DRDAProtocolException,     {,         throwSyntaxrm(CodePoint.SYNERRCD_REQ_OBJ_NOT_FOUND, codePoint);,     },     /**,      * Print a line to the DB2j log,      *,      * @param dbname  database name,      * @param drdaID    DRDA identifier,      * @param msg   message,      */,     protected static void println2Log(String dbname, String drdaID, String msg),     {,         if (logStream == null) {,             logStream = Monitor.getStream();,         }, ,         if (dbname != null),         {,             int endOfName = dbname.indexOf(';');,             if (endOfName != -1) {,                 dbname = dbname.substring(0, endOfName);,             },         },         logStream.printlnWithHeader("(DATABASE = " + dbname + "), (DRDAID = " + drdaID + "), " + msg);,     },     /**,      * Write RDBNAM,      *,      * @param rdbnam    database name,      * @exception DRDAProtocolException,      */,     protected void writeRDBNAM(String rdbnam),         throws DRDAProtocolException,     {,         CcsidManager currentManager = writer.getCurrentCcsidManager();, ,         int len = Math.max(,                 CodePoint.RDBNAM_LEN,,                 currentManager.getByteLength(rdbnam));, ,         /* Write the string padded */,         writer.writeScalarPaddedString(CodePoint.RDBNAM, rdbnam, len);,     },     /***************************************************************************,      *                   Private methods,      ***************************************************************************/, ,     /**,      * Initialize class,      */,     private void initialize(),     {,         // set input and output sockets,         // this needs to be done before creating reader,         sockis = session.sessionInput;,         sockos = session.sessionOutput;, ,         reader = new DDMReader(this, session.dssTrace);,         writer = new DDMWriter(this, session.dssTrace);,         ,         /* At this stage we can initialize the strings as we have,          * the CcsidManager for the DDMWriter. */,         rdbnam = new DRDAString(writer);,         rdbcolid = new DRDAString(writer);,         pkgid = new DRDAString(writer);,         pkgcnstkn = new DRDAString(writer);,     }, ,     /**,      * Initialize for a new session,      */,     private void initializeForSession(),     {,         // set input and output sockets,         sockis = session.sessionInput;,         sockos = session.sessionOutput;, ,         // intialize reader and writer,         reader.initialize(this, session.dssTrace);,         writer.reset(session.dssTrace);, ,         // initialize local pointers to session info,         database = session.database;,         appRequester = session.appRequester;, ,         // set sqlamLevel,         if (session.state == Session.ATTEXC) {,             sqlamLevel = appRequester.getManagerLevel(CodePoint.SQLAM);,         }, ,         /* All sessions MUST start as EBCDIC */,         reader.setEbcdicCcsid();,         writer.setEbcdicCcsid();,     },     /**      ,      * In initial state for a session, ,      * determine whether this is a command,      * session or a DRDA protocol session.  A command session is for changing,      * the configuration of the Net server, e.g., turning tracing on,      * If it is a command session, process the command and close the session.,      * If it is a DRDA session, exchange server attributes and change session,      * state.,      */,     private void sessionInitialState(),         throws Exception,     {,         // process NetworkServerControl commands - if it is not either valid protocol  let the ,         // DRDA error handling handle it,         if (reader.isCmd()),         {,             try {,                 server.processCommands(reader, writer, session);,                 // reset reader and writer,                 reader.initialize(this, null);,                 writer.reset(null);,                 closeSession();,             } catch (InterruptedException ie) {,                 throw ie;,             } catch (Throwable t) {,                 server.consoleExceptionPrintTrace(t);,             }, ,         },         else,         {,             // exchange attributes with application requester,             exchangeServerAttributes();,         },     }, ,     /**,      * Cleans up and closes a result set if an exception is thrown,      * when collecting QRYDTA in response to OPNQRY or CNTQRY.,      *,      * @param stmt the DRDA statement to clean up,      * @param sqle the exception that was thrown,      * @param writerMark start index for the first DSS to clear from,      * the output buffer,      * @exception DRDAProtocolException if a DRDA protocol error is,      * detected,      */,     private void cleanUpAndCloseResultSet(DRDAStatement stmt,,                                           SQLException sqle,,                                           int writerMark),         throws DRDAProtocolException,     {,         if (stmt != null) {,             writer.clearDSSesBackToMark(writerMark);,             if (!stmt.rsIsClosed()) {,                 try {,                     stmt.rsClose();,                 } catch (SQLException ec) {,                     if (SanityManager.DEBUG) {,                         trace("Warning: Error closing result set");,                     },                 },                 writeABNUOWRM();,                 writeSQLCARD(sqle, 0, 0);,             },         } else {,             writeSQLCARDs(sqle, 0);,         },         errorInChain(sqle);,     }, ,     /**,      * Process DRDA commands we can receive once server attributes have been,      * exchanged.,      *,      * @exception DRDAProtocolException,      */,     private void processCommands() throws DRDAProtocolException,     {,         DRDAStatement stmt = null;,         boolean PRPSQLSTTfailed = false;,         boolean checkSecurityCodepoint = session.requiresSecurityCodepoint();,         do,         {,             correlationID = reader.readDssHeader();,             int codePoint = reader.readLengthAndCodePoint( false );,             int writerMark = writer.markDSSClearPoint();,             ,             if (checkSecurityCodepoint) {,                 verifyInOrderACCSEC_SECCHK(codePoint,session.getRequiredSecurityCodepoint());,             }, ,             switch(codePoint),             {,                 case CodePoint.CNTQRY:,                     try{,                         stmt = parseCNTQRY();,                         if (stmt != null),                         {,                             writeQRYDTA(stmt);,                             if (stmt.rsIsClosed()),                             {,                                 writeENDQRYRM(CodePoint.SVRCOD_WARNING);,                                 writeNullSQLCARDobject();,                             },                             // Send any warnings if JCC can handle them,                             checkWarning(null, null, stmt.getResultSet(), 0, false, sendWarningsOnCNTQRY);,                             writePBSD();,                         },                     },                     catch(SQLException e),                     {,                         // if we got a SQLException we need to clean up and,                         // close the result set Beetle 4758,                         cleanUpAndCloseResultSet(stmt, e, writerMark);,                     },                     break;,                 case CodePoint.EXCSQLIMM:,                     try {,                         long updateCount = parseEXCSQLIMM();,                         // RESOLVE: checking updateCount is not sufficient,                         // since it will be 0 for creates, we need to know when,                         // any logged changes are made to the database,                         // Not getting this right for JCC is probably O.K., this,                         // will probably be a problem for ODBC and XA,                         // The problem is that JDBC doesn't provide this information,                         // so we would have to expand the JDBC API or call a,                         // builtin method to check(expensive),                         // For now we will assume that every execute immediate,                         // does an update (that is the most conservative thing),                         if (database.RDBUPDRM_sent == false),                         {,                             writeRDBUPDRM();,                         }, ,                         // we need to set update count in SQLCARD,                         checkWarning(null, database.getDefaultStatement().getStatement(),,                             null, updateCount, true, true);,                         writePBSD();,                     } catch (SQLException e),                     {,                         writer.clearDSSesBackToMark(writerMark);,                         writeSQLCARDs(e, 0);,                         errorInChain(e);,                     },                     break;, ,                 case CodePoint.EXCSQLSET:,                     try {,                         if (parseEXCSQLSET()) {,                             // all went well.,                             writeSQLCARDs(null, 0);,                         },                     },                     catch (SQLWarning w),                     {,                         writeSQLCARD(w, 0, 0);,                     },                     catch (SQLException e),                     {,                         writer.clearDSSesBackToMark(writerMark);,                         writeSQLCARDs(e, 0);,                         errorInChain(e);,                     },                     break;,                     ,                 case CodePoint.PRPSQLSTT:,                     int sqldaType;,                     PRPSQLSTTfailed = false;,                     try {,                         database.getConnection().clearWarnings();,                         sqldaType = parsePRPSQLSTT();,                         database.getCurrentStatement().sqldaType = sqldaType;,                         if (sqldaType > 0) {    // do write SQLDARD,                             writeSQLDARD(database.getCurrentStatement(),,                                          (sqldaType ==  CodePoint.TYPSQLDA_LIGHT_OUTPUT),,                                          database.getConnection().getWarnings());,                         } else {,                             checkWarning(database.getConnection(), null, null, 0, true, true);,                         }, ,                     } catch (SQLException e),                     {,                         writer.clearDSSesBackToMark(writerMark);,                         writeSQLCARDs(e, 0, true);,                         PRPSQLSTTfailed = true;,                         errorInChain(e);,                     },                     break;,                 case CodePoint.OPNQRY:,                     try {,                         // activate the following to run the isValid(timeout) test in jdbc4.ConnectionTest,                         /*try { ,                             Thread.sleep(2000);,                         } catch (InterruptedException ie) {,                             System.out.println("interrupted exception: " + ie.getMessage());,                             ie.printStackTrace();,                         }*/,                         if (PRPSQLSTTfailed) {,                             // read the command objects,                             // for ps with parameter,                             // Skip objects/parameters,                             skipRemainder(true);, ,                             // If we failed to prepare, then we fail,                             // to open, which  means OPNQFLRM.,                             writeOPNQFLRM(null);,                             break;,                         },                         Pkgnamcsn pkgnamcsn = parseOPNQRY();,                         if (pkgnamcsn != null),                         {,                             stmt = database.getDRDAStatement(pkgnamcsn);,                             PreparedStatement ps = stmt.getPreparedStatement();,                             ps.clearWarnings();,                             if (pendingStatementTimeout >= 0) {,                                 ps.setQueryTimeout(pendingStatementTimeout);,                                 pendingStatementTimeout = -1;,                             },                             stmt.execute();,                             writeOPNQRYRM(false, stmt);,                             checkWarning(null, ps, null, 0, false, true);, ,                             long sentVersion = stmt.versionCounter;,                             long currentVersion =,                                     ((EnginePreparedStatement)stmt.ps).,                                     getVersionCounter();, ,                             if (stmt.sqldaType ==,                                     CodePoint.TYPSQLDA_LIGHT_OUTPUT &&,                                     currentVersion != sentVersion) {,                                 // DERBY-5459. The prepared statement has a,                                 // result set and has changed on the server,                                 // since we last informed the client about its,                                 // shape, so re-send metadata.,                                 //,                                 // NOTE: This is an extension of the standard,                                 // DRDA protocol since we send the SQLDARD,                                 // even if it isn't requested in this case.,                                 // This is OK because there is already code on the,                                 // client to handle an unrequested SQLDARD at,                                 // this point in the protocol.,                                 writeSQLDARD(stmt, true, null);,                             },                             writeQRYDSC(stmt, false);, ,                             stmt.rsSuspend();, ,                             if (stmt.getQryprctyp() == CodePoint.LMTBLKPRC &&,                                     stmt.getQryrowset() != 0) {,                                 // The DRDA spec allows us to send,                                 // QRYDTA here if there are no LOB,                                 // columns.,                                 DRDAResultSet drdars =,                                     stmt.getCurrentDrdaResultSet();,                                 try {,                                     if (drdars != null &&,                                         !drdars.hasLobColumns()) {,                                         writeQRYDTA(stmt);,                                     },                                 } catch (SQLException sqle) {,                                     cleanUpAndCloseResultSet(stmt, sqle,,                                                              writerMark);,                                 },                             },                         },                         writePBSD();,                     },                     catch (SQLException e),                     {,                         writer.clearDSSesBackToMark(writerMark);,                         // The fix for DERBY-1196 removed code ,                         // here to close the prepared statement ,                         // if OPNQRY failed.,                             writeOPNQFLRM(e);,                     },                     break;,                 case CodePoint.RDBCMM:,                     try,                     {,                         if (SanityManager.DEBUG) {,                             trace("Received commit");,                         },                         if (!database.getConnection().getAutoCommit()),                         {,                             database.getConnection().clearWarnings();,                             database.commit();,                             writeENDUOWRM(COMMIT);,                             checkWarning(database.getConnection(), null, null, 0, true, true);,                         },                         // we only want to write one of these per transaction,                         // so set to false in preparation for next command,                         database.RDBUPDRM_sent = false;,                     },                     catch (SQLException e),                     {,                         writer.clearDSSesBackToMark(writerMark);,                         // Even in case of error, we have to write the ENDUOWRM.,                         writeENDUOWRM(COMMIT);,                         writeSQLCARDs(e, 0);,                         errorInChain(e);,                     },                     break;,                 case CodePoint.RDBRLLBCK:,                     try,                     {,                         if (SanityManager.DEBUG) {,                             trace("Received rollback");,                         },                         database.getConnection().clearWarnings();,                         database.rollback();,                         writeENDUOWRM(ROLLBACK);,                         checkWarning(database.getConnection(), null, null, 0, true, true);,                         // we only want to write one of these per transaction,                         // so set to false in preparation for next command,                         database.RDBUPDRM_sent = false;,                     },                     catch (SQLException e),                     {,                         writer.clearDSSesBackToMark(writerMark);,                         // Even in case of error, we have to write the ENDUOWRM.,                         writeENDUOWRM(ROLLBACK);,                         writeSQLCARDs(e, 0);,                         errorInChain(e);,                     },                     break;,                 case CodePoint.CLSQRY:,                     try{,                         stmt = parseCLSQRY();,                         stmt.rsClose();,                         writeSQLCARDs(null, 0);,                     },                     catch (SQLException e),                     {,                         writer.clearDSSesBackToMark(writerMark);,                         writeSQLCARDs(e, 0);,                         errorInChain(e);,                     },                     break;,                 case CodePoint.EXCSAT:,                     parseEXCSAT();,                     writeEXCSATRD();,                     break;,                 case CodePoint.ACCSEC:,                     int securityCheckCode = parseACCSEC();,                     writeACCSECRD(securityCheckCode); ,                     ,                     /* ACCSECRD is the last reply that is mandatorily in EBCDIC */,                     if (appRequester.supportsUtf8Ccsid()) {,                         switchToUtf8();,                     } else {,                         /* This thread might serve several requests.,                          * Revert if not supported by current client. */,                         switchToEbcdic();,                     },                     checkSecurityCodepoint = true;,                     break;,                 case CodePoint.SECCHK:,                     if (parseDRDAConnection()) {,                         // security all checked and connection ok,                         checkSecurityCodepoint = false;,                     },                     break;,                 /* since we don't support sqlj, we won't get bind commands from jcc, we,                  * might get it from ccc; just skip them.,                  */,                 case CodePoint.BGNBND:,                     reader.skipBytes();,                     writeSQLCARDs(null, 0);,                     break;,                 case CodePoint.BNDSQLSTT:,                     reader.skipBytes();,                     parseSQLSTTDss();,                     writeSQLCARDs(null, 0);,                     break;,                 case CodePoint.SQLSTTVRB:,                     // optional,                     reader.skipBytes();,                     break;,                 case CodePoint.ENDBND:,                     reader.skipBytes();,                     writeSQLCARDs(null, 0);,                     break;,                 case CodePoint.DSCSQLSTT:,                     if (PRPSQLSTTfailed) {,                         reader.skipBytes();,                         writeSQLCARDs(null, 0);,                         break;,                     },                     try {,                         boolean rtnOutput = parseDSCSQLSTT();,                         writeSQLDARD(database.getCurrentStatement(), rtnOutput,,                                      null);,                         ,                     } catch (SQLException e),                     {,                         writer.clearDSSesBackToMark(writerMark);,                         server.consoleExceptionPrint(e);,                         try {,                             writeSQLDARD(database.getCurrentStatement(), true, e);,                         } catch (SQLException e2) { // should not get here since doing nothing with ps,                             agentError("Why am I getting another SQLException?");,                         },                         errorInChain(e);,                     },                     break;,                 case CodePoint.EXCSQLSTT:,                     if (PRPSQLSTTfailed) {,                         // Skip parameters too if they are chained Beetle 4867,                         skipRemainder(true);,                         writeSQLCARDs(null, 0);,                         break;,                     },                     try {,                         parseEXCSQLSTT();, ,                         DRDAStatement curStmt = database.getCurrentStatement();,                         if (curStmt != null) {,                             curStmt.rsSuspend();,                         },                         writePBSD();,                     } catch (SQLException e),                     {,                         skipRemainder(true);,                         writer.clearDSSesBackToMark(writerMark);,                         if (SanityManager.DEBUG) ,                         {,                             server.consoleExceptionPrint(e);,                         },                         writeSQLCARDs(e, 0);,                         errorInChain(e);,                     },                     break;,                 case CodePoint.SYNCCTL:,                     if (xaProto == null) {,                         xaProto = new DRDAXAProtocol(this);,                     },                     xaProto.parseSYNCCTL();,                     try {,                         writePBSD();,                     } catch (SQLException se) {,                         server.consoleExceptionPrint(se);,                         errorInChain(se);,                     },                     break;,                 default:,                     codePointNotSupported(codePoint);,             }, ,             if (SanityManager.DEBUG) {,                 String cpStr = new CodePointNameTable().lookup(codePoint);,                 try {,                     PiggyBackedSessionData pbsd =,                             database.getPiggyBackedSessionData(false);,                     // DERBY-3596,                     // Don't perform this assert if a deferred reset is,                     // happening or has recently taken place, because the,                     // connection state has been changed under the feet of the,                     // piggy-backing mechanism.,                     if (!this.deferredReset && pbsd != null) {,                         // Session data has already been piggy-backed. Refresh,                         // the data from the connection, to make sure it has,                         // not changed behind our back.,                         pbsd.refresh();,                         SanityManager.ASSERT(!pbsd.isModified(),,                               "Unexpected PBSD modification: " + pbsd +,                               " after codePoint " + cpStr);,                     },                     // Not having a pbsd here is ok. No data has been,                     // piggy-backed and the client has no cached values.,                     // If needed it will send an explicit request to get,                     // session data,                 } catch (SQLException sqle) {,                     server.consoleExceptionPrint(sqle);,                     SanityManager.THROWASSERT("Unexpected exception after " +,                             "codePoint "+cpStr, sqle);,                 },             }, ,             // Set the correct chaining bits for whatever,             // reply DSS(es) we just wrote.  If we've reached,             // the end of the chain, this method will send,             // the DSS(es) across.,             finalizeChain();, ,         },         while (reader.isChainedWithSameID() || reader.isChainedWithDiffID());,     }, ,     /**,      * If there's a severe error in the DDM chain, and if the header indicates,      * "terminate chain on error", we stop processing further commands in the chain,      * nor do we send any reply for them.  In accordance to this, a SQLERRRM message ,      * indicating the severe error must have been sent! (otherwise application requestor,,      * such as JCC, would not terminate the receiving of chain replies.),      *,      * Each DRDA command is processed independently. DRDA defines no interdependencies,      * across chained commands. A command is processed the same when received within,      * a set of chained commands or received separately.  The chaining was originally,      * defined as a way to save network costs.,      *,      * @param e     the SQLException raised,      * @exception   DRDAProtocolException,      */,     private void errorInChain(SQLException e) throws DRDAProtocolException,     {,         if (reader.terminateChainOnErr() && (getExceptionSeverity(e) > CodePoint.SVRCOD_ERROR)),         {,             if (SanityManager.DEBUG) {,                 trace("terminating the chain on error...");,             },             skipRemainder(false);,         },     }, ,     /**,      * Exchange server attributes with application requester,      *,      * @exception DRDAProtocolException,      */,     private void exchangeServerAttributes(),         throws  DRDAProtocolException,     {,         int codePoint;,         correlationID = reader.readDssHeader();,         if (SanityManager.DEBUG) {,           if (correlationID == 0),           {,             SanityManager.THROWASSERT(,                           "Unexpected value for correlationId = " + correlationID);,           },         }, ,         codePoint = reader.readLengthAndCodePoint( false );, ,         // The first code point in the exchange of attributes must be EXCSAT,         if (codePoint != CodePoint.EXCSAT),         {,             //Throw PRCCNVRM ,             throw,                 new DRDAProtocolException(DRDAProtocolException.DRDA_Proto_PRCCNVRM,,                                           this, codePoint,,                                           CodePoint.PRCCNVCD_EXCSAT_FIRST_AFTER_CONN);,         }, ,         parseEXCSAT();,         writeEXCSATRD();,         finalizeChain();,         session.setState(Session.ATTEXC);,     },     , ,     private boolean parseDRDAConnection() throws DRDAProtocolException,     {,         int codePoint;,         boolean sessionOK = true;, , ,         int securityCheckCode = parseSECCHK();,         if (SanityManager.DEBUG) {,             trace("*** SECCHKRM securityCheckCode is: " + securityCheckCode);,         },         writeSECCHKRM(securityCheckCode);,         //at this point if the security check failed, we're done, the session failed,         if (securityCheckCode != 0),         {,             return false;,         }, ,         correlationID = reader.readDssHeader();,         codePoint = reader.readLengthAndCodePoint( false );,         verifyRequiredObject(codePoint,CodePoint.ACCRDB);,         int svrcod = parseACCRDB();, ,         //If network server gets a null connection form InternalDriver, reply with,         //RDBAFLRM and SQLCARD with null SQLException ,         if(database.getConnection() == null && databaseAccessException == null){,             writeRDBfailure(CodePoint.RDBAFLRM);,             return false;,         },         ,         //if earlier we couldn't access the database,         if (databaseAccessException != null),         {, ,             //if the Database was not found we will try DS,             int failureType = getRdbAccessErrorCodePoint();,             if (failureType == CodePoint.RDBNFNRM ,                 || failureType == CodePoint.RDBATHRM),             {,                 writeRDBfailure(failureType);,             },             else,             {,                 writeRDBfailure(CodePoint.RDBAFLRM);,             },             return false;,         },         else if (database.accessCount > 1 ) // already in conversation with database,         {,             writeRDBfailure(CodePoint.RDBACCRM);,             return false;,         },         else,         {,             writeACCRDBRM(svrcod);,         }, ,         // compare this application requester with previously stored,         // application requesters and if we have already seen this one,         // use stored application requester ,         session.appRequester = server.getAppRequester(appRequester);,         return sessionOK;,     }, ,     /**,      * Switch the DDMWriter and DDMReader to UTF8 IF supported,      */,     private void switchToUtf8() {,         writer.setUtf8Ccsid();,         reader.setUtf8Ccsid();,     },     ,     /**,      * Switch the DDMWriter and DDMReader to EBCDIC,      */,     private void switchToEbcdic() {,         writer.setEbcdicCcsid();,         reader.setEbcdicCcsid();,     },     ,     /**,      * Write RDB Failure,      *,      * Instance Variables,      *  SVRCOD - Severity Code - required,      *  RDBNAM - Relational Database name - required,      *  SRVDGN - Server Diagnostics - optional (not sent for now),      *,      * @param   codePoint   codepoint of failure,      */,     private void writeRDBfailure(int codePoint) throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(codePoint);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, CodePoint.SVRCOD_ERROR);,         writeRDBNAM(database.getDatabaseName());,         writer.endDdmAndDss();,         ,         switch(codePoint){,             case CodePoint.RDBAFLRM:,                 //RDBAFLRM requires TYPDEFNAM and TYPDEFOVR,                 writer.createDssObject();,                 writer.writeScalarString(CodePoint.TYPDEFNAM,,                                          CodePoint.TYPDEFNAM_QTDSQLASC);,                 writeTYPDEFOVR();,                 writer.endDss();,             case CodePoint.RDBNFNRM:,             case CodePoint.RDBATHRM:,                 writeSQLCARD(databaseAccessException, 0, 0);,             case CodePoint.RDBACCRM:,                 //Ignore anything that was chained to the ACCRDB.,                 skipRemainder(false);, ,                 // Finalize chain state for whatever we wrote in,                 // response to ACCRDB.,                 finalizeChain();,                 break;,         },         ,     }, ,     /* Check the database access exception and return the appropriate,        error codepoint.,        RDBNFNRM - Database not found,        RDBATHRM - Not Authorized,        RDBAFLRM - Access failure,        @return RDB Access codepoint ,                ,     */, ,     private int getRdbAccessErrorCodePoint(),     {,         String sqlState = databaseAccessException.getSQLState();,         // These tests are ok since DATABASE_NOT_FOUND and ,         // AUTH_INVALID_USER_NAME are not ambigious error codes (on the first,         // five characters) in SQLState. If they were, we would have to,         // perform a similar check as done in method isAuthenticationException,         if (sqlState.regionMatches(0,SQLState.DATABASE_NOT_FOUND,0,5)) {,             // RDB not found codepoint,             return CodePoint.RDBNFNRM;,         } else {,             if (isAuthenticationException(databaseAccessException) ||,                 sqlState.regionMatches(0,SQLState.AUTH_INVALID_USER_NAME,0,5)) {,                 // Not Authorized To RDB reply message codepoint,                 return CodePoint.RDBATHRM;,             } else {,                 // RDB Access Failed Reply Message codepoint,                 return CodePoint.RDBAFLRM;,             },         },     }, ,     /**,      * There are multiple reasons for not getting a connection, and,      * all these should throw SQLExceptions with SQL state 08004,      * according to the SQL standard. Since only one of these SQL,      * states indicate that an authentication error has occurred, it,      * is not enough to check that the SQL state is 08004 and conclude,      * that authentication caused the exception to be thrown.,      *,      * This method tries to get a StandardException from the SQLException,      * and use getMessageId on that object to check for authentication,      * error instead of the SQL state we get from,      * SQLExceptions#getSQLState. getMessageId returns the entire id,      * as defined in SQLState (e.g. 08004.C.1), while getSQLState only,      * return the 5 first characters (i.e. 08004 instead of 08004.C.1),      *,      * If the SQLException isn't linked to a StandardException, the,      * assumption that SQL State 08004 is caused by an authentication,      * failure is followed even though this is not correct. This was,      * the pre DERBY-3060 way of solving the issue.,      *,      * @param sqlException The exception that is checked to see if,      * this is really caused by an authentication failure,      * @return true if sqlException is (or has to be assumed to be),      * caused by an authentication failure, false otherwise.,      * @see SQLState,      */,     private boolean isAuthenticationException (SQLException sqlException) {,         boolean authFail = false;, ,         // get exception which carries Derby messageID and args,         StandardException se = StandardException.getArgumentFerry(sqlException);, ,         if (se != null) {,             // DERBY-3060: if this is a Derby exception, we can,             // check the messageId to find out what caused the,             // exception., ,             String msgId = se.getMessageId();, ,             // Of the 08004.C.x messages, only,             // SQLState.NET_CONNECT_AUTH_FAILED is an authentication,             // exception,             if (msgId.equals(SQLState.NET_CONNECT_AUTH_FAILED)) {,                 authFail = true;,             },         } else {,             String sqlState = sqlException.getSQLState();,             if (sqlState.regionMatches(0,SQLState.LOGIN_FAILED,0,5)) {,                 // Unchanged by DERBY-3060: This is not an,                 // Derby exception, so we cannot check the,                 // messageId. As before DERBY-3060, we assume that all,                 // 08004 error codes are due to an authentication,                 // failure, even though this ambigious,                 authFail = true;,             },         },         return authFail;,     }, ,     /**,      * Verify userId and password,      *,      * Username and password is verified by making a connection to the,      * database,      *,      * @return security check code, 0 is O.K.,      * @exception DRDAProtocolException,      */,     private int verifyUserIdPassword() throws DRDAProtocolException,     {,         databaseAccessException = null;,         return getConnFromDatabaseName();,     }, ,     /**,      * Get connection from a database name,      *,      * Username and password is verified by making a connection to the,      * database,      *,      * @return security check code, 0 is O.K.,      * @exception DRDAProtocolException,      */,     private int getConnFromDatabaseName() throws DRDAProtocolException,     {,         Properties p = new Properties();,         databaseAccessException = null;,         //if we haven't got the correlation token yet, use session number for drdaID,         if (session.drdaID == null) {,             session.drdaID = leftBrace + session.connNum + rightBrace;,         },         p.put(Attribute.DRDAID_ATTR, session.drdaID);, ,         // We pass extra property information for the authentication provider,         // to successfully re-compute the substitute (hashed) password and,         // compare it with what we've got from the requester (source).,         //,         // If a password attribute appears as part of the connection URL,         // attributes, we then don't use the substitute hashed password,         // to authenticate with the engine _as_ the one (if any) as part,         // of the connection URL attributes, will be used to authenticate,         // against Derby's BUILT-IN authentication provider - As a reminder,,         // Derby allows password to be mentioned as part of the connection,         // URL attributes, as this extra capability could be useful to pass,         // passwords to external authentication providers for Derby; hence,         // a password defined as part of the connection URL attributes cannot,         // be substituted (single-hashed) as it is not recoverable.,         if ((database.securityMechanism == CodePoint.SECMEC_USRSSBPWD) &&,             (database.getDatabaseName().indexOf(Attribute.PASSWORD_ATTR) == -1)),         {,             p.put(Attribute.DRDA_SECMEC,,                   String.valueOf(database.securityMechanism));,             p.put(Attribute.DRDA_SECTKN_IN,,                   DecryptionManager.toHexString(database.secTokenIn, 0,,                                                 database.secTokenIn.length));,             p.put(Attribute.DRDA_SECTKN_OUT,,                   DecryptionManager.toHexString(database.secTokenOut, 0,,                                                 database.secTokenOut.length));,         },             ,         try {,             database.makeConnection(p);,         } catch (SQLException se) {,             databaseAccessException = se;,             for (; se != null; se = se.getNextException()),             {,                 if (SanityManager.DEBUG) {,                     trace(se.getMessage());,                 },                 println2Log(database.getDatabaseName(), session.drdaID, se.getMessage());,             }, ,             if (isAuthenticationException(databaseAccessException)) {,                 // need to set the security check code based on the,                 // reason the connection was denied, Derby doesn't say,                 // whether the userid or password caused the problem,,                 // so we will just return userid invalid,                 return CodePoint.SECCHKCD_USERIDINVALID;,             } else {,                 return 0;,             },         },         catch (Exception e),         {,             // If Derby has shut down for some reason,,             // we will send  an agent error and then try to ,             // get the driver loaded again.  We have to get,             // rid of the client first in case they are holding,             // the DriverManager lock.,             println2Log(database.getDatabaseName(), session.drdaID, ,                         "Driver not loaded",                         + e.getMessage());,                 try {,                     agentError("Driver not loaded");,                 },                 catch (DRDAProtocolException dpe),                 {,                     // Retry starting the server before rethrowing ,                     // the protocol exception.  Then hopfully all,                     // will be well when they try again.,                     try {,                         server.startNetworkServer();,                     } catch (Exception re) {,                         println2Log(database.getDatabaseName(), session.drdaID, "Failed attempt to reload driver " +re.getMessage()  );,                     },                     throw dpe;,                 },         },         ,     ,         // Everything worked so log connection to the database.,         if (getLogConnections()) {,             println2Log(database.getDatabaseName(), session.drdaID,,                 "Apache Derby Network Server connected to database " +,                         database.getDatabaseName());,         },         return 0;,     }, , ,     /**,      * Parses EXCSAT (Exchange Server Attributes),      * Instance variables,      *  EXTNAM(External Name)   - optional,      *  MGRLVLLS(Manager Levels) - optional,      *  SPVNAM(Supervisor Name) - optional,      *  SRVCLSNM(Server Class Name) - optional,      *  SRVNAM(Server Name) - optional, ignorable,      *  SRVRLSLV(Server Product Release Level) - optional, ignorable,      *,      * @exception DRDAProtocolException,      */,     private void parseEXCSAT() throws DRDAProtocolException,     {,         int codePoint;,         String strVal;, ,         // There are three kinds of EXCSAT's we might get.,         // 1) Initial Exchange attributes.,         //    For this we need to initialize the apprequester.,         //    Session state is set to ATTEXC and then the AR must ,         //    follow up with ACCSEC and SECCHK to get the connection.,         //  2) Send of EXCSAT as ping or mangager level adjustment. ,         //     (see parseEXCSAT2()),         //     For this we just ignore the EXCSAT objects that,         //     are already set.,         //  3) Send of EXCSAT for connection reset. (see parseEXCSAT2()),         //     This is treated just like ping and will be followed up ,         //     by an ACCSEC request if in fact it is a connection reset., ,         // If we have already exchanged attributes once just ,         // process any new manager levels and return (case 2 and 3 above),         this.deferredReset = false; // Always reset, only set to true below.,         if (appRequester != null),         {,             // DERBY-3596,             // Don't mess with XA requests, as the logic for these are handled,             // by the server side (embedded) objects. Note that XA requests,             // results in a different database object implementation, and it,             // does not have the bug we are working around.,             if (!appRequester.isXARequester()) {,                 this.deferredReset = true; // Non-XA deferred reset detected.,             },             parseEXCSAT2();,             return;,         }, ,         // set up a new Application Requester to store information about the,         // application requester for this session, ,         appRequester = new AppRequester();, ,         reader.markCollection();, ,         codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch (codePoint),             {,                 // optional,                 case CodePoint.EXTNAM:,                     appRequester.extnam = reader.readString();,                     if (SanityManager.DEBUG) {,                         trace("extName = " + appRequester.extnam);,                     },                     if (appRequester.extnam.length() > CodePoint.MAX_NAME) {,                         tooBig(CodePoint.EXTNAM);,                     },                     break;,                 // optional,                 case CodePoint.MGRLVLLS:,                     parseMGRLVLLS(1);,                     break;,                 // optional ,                 case CodePoint.SPVNAM:,                     appRequester.spvnam = reader.readString();,                     // This is specified as a null parameter so length should,                     // be zero,                     if (appRequester.spvnam != null) {,                         badObjectLength(CodePoint.SPVNAM);,                     },                     break;,                 // optional,                 case CodePoint.SRVNAM:,                     appRequester.srvnam = reader.readString();,                     if (SanityManager.DEBUG) {,                         trace("serverName = " +  appRequester.srvnam);,                     },                     if (appRequester.srvnam.length() > CodePoint.MAX_NAME) {,                         tooBig(CodePoint.SRVNAM);,                     },                     break;,                 // optional,                 case CodePoint.SRVRLSLV:,                     appRequester.srvrlslv = reader.readString();,                     if (SanityManager.DEBUG) {,                         trace("serverlslv = " + appRequester.srvrlslv);,                     },                     if (appRequester.srvrlslv.length() > CodePoint.MAX_NAME) {,                         tooBig(CodePoint.SRVRLSLV);,                     },                     break;,                 // optional,                 case CodePoint.SRVCLSNM:,                     appRequester.srvclsnm = reader.readString();,                     if (SanityManager.DEBUG) {,                         trace("serverClassName = " + appRequester.srvclsnm);,                     },                     if (appRequester.srvclsnm.length() > CodePoint.MAX_NAME) {,                         tooBig(CodePoint.SRVCLSNM);,                     },                     break;,                 default:,                     invalidCodePoint(codePoint);,             },             codePoint = reader.getCodePoint();,         },     }, ,     /**,      * Parses EXCSAT2 (Exchange Server Attributes),      * Instance variables,      *  EXTNAM(External Name)   - optional,      *  MGRLVLLS(Manager Levels) - optional,      *  SPVNAM(Supervisor Name) - optional,      *  SRVCLSNM(Server Class Name) - optional,      *  SRVNAM(Server Name) - optional, ignorable,      *  SRVRLSLV(Server Product Release Level) - optional, ignorable,      *,      * @exception DRDAProtocolException,      * ,      * This parses a second occurrence of an EXCSAT command,      * The target must ignore the values for extnam, srvclsnm, srvnam and srvrlslv.,      * I am also going to ignore spvnam since it should be null anyway.,      * Only new managers can be added.,      */,     private void parseEXCSAT2() throws DRDAProtocolException,     {,         int codePoint;,         reader.markCollection();, ,         codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch (codePoint),             {,                 // optional,                 case CodePoint.EXTNAM:,                 case CodePoint.SRVNAM:,                 case CodePoint.SRVRLSLV:,                 case CodePoint.SRVCLSNM:,                 case CodePoint.SPVNAM:,                     reader.skipBytes();,                     break;,                 // optional,                 case CodePoint.MGRLVLLS:,                     parseMGRLVLLS(2);,                     break;,                 default:,                     invalidCodePoint(codePoint);,             },             codePoint = reader.getCodePoint();,         },     }, ,     /**,      *  Parse manager levels,      *  Instance variables,      *      MGRLVL - repeatable, required,      *        CODEPOINT,      *          CCSIDMGR - CCSID Manager,      *          CMNAPPC - LU 6.2 Conversational Communications Manager,      *          CMNSYNCPT - SNA LU 6.2 SyncPoint Conversational Communications Manager,      *          CMNTCPIP - TCP/IP Communication Manager,      *          DICTIONARY - Dictionary,      *          RDB - Relational Database,      *          RSYNCMGR - Resynchronization Manager,      *          SECMGR - Security Manager,      *          SQLAM - SQL Application Manager,      *          SUPERVISOR - Supervisor,      *          SYNCPTMGR - Sync Point Manager,      *        VALUE,      *,      *  On the second appearance of this codepoint, it can only add managers,      *,      * @param time  1 for first time this is seen, 2 for subsequent ones,      * @exception DRDAProtocolException,      * ,      */,     private void parseMGRLVLLS(int time) throws DRDAProtocolException,     {,         int manager, managerLevel;,         int currentLevel;,         // set up vectors to keep track of manager information,         unknownManagers = new ArrayList<Integer>();,         knownManagers = new ArrayList<Integer>();,         ArrayList<Integer> errorManagers = new ArrayList<Integer>();,         ArrayList<Integer> errorManagersLevel = new ArrayList<Integer>();,         if (SanityManager.DEBUG) {,             trace("Manager Levels");,         }, ,         while (reader.moreDdmData()),         {,             manager = reader.readNetworkShort();,             managerLevel = reader.readNetworkShort();,             if (CodePoint.isKnownManager(manager)),             {,                 knownManagers.add(manager);,                 //if the manager level hasn't been set, set it,                 currentLevel = appRequester.getManagerLevel(manager);,                 if (currentLevel == AppRequester.MGR_LEVEL_UNKNOWN),                 {,                     appRequester.setManagerLevel(manager, managerLevel);,                 },                 else,                 {,                     //if the level is still the same we'll ignore it,                     if (currentLevel != managerLevel),                     {,                         //keep a list of conflicting managers,                         errorManagers.add(manager);,                         errorManagersLevel.add(managerLevel);,                     },                 }, ,             },             else,             {,                 unknownManagers.add(manager);,             }, ,             if (SanityManager.DEBUG) {,                trace("Manager = " + java.lang.Integer.toHexString(manager) + ,                       " ManagerLevel " + managerLevel);,             },         },         sqlamLevel = appRequester.getManagerLevel(CodePoint.SQLAM);,         // did we have any errors,         if (errorManagers.size() > 0),         {,             Object [] oa = new Object[errorManagers.size()*2];,             int j = 0;,             for (int i = 0; i < errorManagers.size(); i++),             {,                 oa[j++] = errorManagers.get(i);,                 oa[j++] = errorManagersLevel.get(i);,             },             throw new DRDAProtocolException(DRDAProtocolException.DRDA_Proto_MGRLVLRM,,                                           this, 0,,                                           0, oa);,         },     },     /**,      * Write reply to EXCSAT command,      * Instance Variables,      *  EXTNAM - External Name (optional),      *  MGRLVLLS - Manager Level List (optional),      *  SRVCLSNM - Server Class Name (optional) - used by JCC,      *  SRVNAM - Server Name (optional),      *  SRVRLSLV - Server Product Release Level (optional),      *,      * @exception DRDAProtocolException,      */,     private void writeEXCSATRD() throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.EXCSATRD);,         writer.writeScalarString(CodePoint.EXTNAM,,                                  NetworkServerControlImpl.att_extnam());,         //only reply with manager levels if we got sent some,         if (knownManagers != null && knownManagers.size() > 0) {,             writeMGRLEVELS();,         },         writer.writeScalarString(CodePoint.SRVCLSNM,,                                  NetworkServerControlImpl.att_srvclsnm());,         writer.writeScalarString(CodePoint.SRVNAM,,                                  NetworkServerControlImpl.ATT_SRVNAM);,         writer.writeScalarString(CodePoint.SRVRLSLV,,                                  NetworkServerControlImpl.att_srvrlslv());,         writer.endDdmAndDss();,     },     /**,      * Write manager levels,      * The target server must not provide information for any target,      * managers unless the source explicitly requests it.,      * For each manager class, if the target server's support level,      * is greater than or equal to the source server's level, then the source,      * server's level is returned for that class if the target server can operate,      * at the source's level; otherwise a level 0 is returned.  If the target,      * server's support level is less than the source server's level, the,      * target server's level is returned for that class.  If the target server,      * does not recognize the code point of a manager class or does not support,      * that class, it returns a level of 0.  The target server then waits,      * for the next command or for the source server to terminate communications.,      * When the source server receives EXCSATRD, it must compare each of the entries,      * in the mgrlvlls parameter it received to the corresponding entries in the mgrlvlls,      * parameter it sent.  If any level mismatches, the source server must decide,      * whether it can use or adjust to the lower level of target support for that manager,      * class.  There are no architectural criteria for making this decision.,      * The source server can terminate communications or continue at the target,      * servers level of support.  It can also attempt to use whatever,      * commands its user requests while receiving error reply messages for real,      * functional mismatches.,      * The manager levels the source server specifies or the target server,      * returns must be compatible with the manager-level dependencies of the specified,      * manangers.  Incompatible manager levels cannot be specified.,      *  Instance variables,      *      MGRLVL - repeatable, required,      *        CODEPOINT,      *          CCSIDMGR - CCSID Manager,      *          CMNAPPC - LU 6.2 Conversational Communications Manager,      *          CMNSYNCPT - SNA LU 6.2 SyncPoint Conversational Communications Manager,      *          CMNTCPIP - TCP/IP Communication Manager,      *          DICTIONARY - Dictionary,      *          RDB - Relational Database,      *          RSYNCMGR - Resynchronization Manager,      *          SECMGR - Security Manager,      *          SQLAM - SQL Application Manager,      *          SUPERVISOR - Supervisor,      *          SYNCPTMGR - Sync Point Manager,      *          XAMGR - XA manager,      *        VALUE,      */,     private void writeMGRLEVELS() throws DRDAProtocolException,     {,         writer.startDdm(CodePoint.MGRLVLLS);,         for (int manager : knownManagers),         {,             int appLevel = appRequester.getManagerLevel(manager);,             int serverLevel = server.getManagerLevel(manager);,             if (serverLevel >= appLevel),             {,                 //Note appLevel has already been set to 0 if we can't support,                 //the original app Level,                 writer.writeCodePoint4Bytes(manager, appLevel);,             },             else,             {,                 writer.writeCodePoint4Bytes(manager, serverLevel);,                 // reset application manager level to server level,                 appRequester.setManagerLevel(manager, serverLevel);,             },         },         // write 0 for all unknown managers,         for (int manager : unknownManagers),         {,             writer.writeCodePoint4Bytes(manager, 0);,         },         writer.endDdm();,     },     /**,      *  Parse Access Security,      *,      *  If the target server supports the SECMEC requested by the application requester,      *  then a single value is returned and it is identical to the SECMEC value,      *  in the ACCSEC command. If the target server does not support the SECMEC,      *  requested, then one or more values are returned and the application requester,      *  must choose one of these values for the security mechanism.,      *  We currently support,      *      - user id and password (default for JCC),      *      - encrypted user id and password,      *      - strong password substitute (USRSSBPWD w/,      *                                    Derby network client only),      *,      *  Instance variables,      *    SECMGRNM  - security manager name - optional,      *    SECMEC    - security mechanism - required,      *    RDBNAM    - relational database name - optional,      *    SECTKN    - security token - optional, (required if sec mech. needs it),      *,      *  @return security check code - 0 if everything O.K.,      */,     private int parseACCSEC() throws  DRDAProtocolException,     {,         int securityCheckCode = 0;,         int securityMechanism = 0;,         byte [] secTokenIn = null;, ,         reader.markCollection();,         int codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch(codePoint),             {,                 //optional,                 case CodePoint.SECMGRNM:,                     // this is defined to be 0 length,                     if (reader.getDdmLength() != 0) {,                         badObjectLength(CodePoint.SECMGRNM);,                     },                     break;,                 //required,                 case CodePoint.SECMEC:,                     checkLength(CodePoint.SECMEC, 2);,                     securityMechanism = reader.readNetworkShort();,                     if (SanityManager.DEBUG) {,                         trace("parseACCSEC - Security mechanism = " + securityMechanism);,                     },                     ,                     // if Property.DRDA_PROP_SECURITYMECHANISM has been set, then,                     // network server only accepts connections which use that,                     // security mechanism. No other types of connections ,                     // are accepted.,                     // Make check to see if this property has been set.,                     // if set, and if the client requested security mechanism ,                     // is not the same, then return a security check code ,                     // that the server does not support/allow this security ,                     // mechanism,                     if ( (server.getSecurityMechanism() != ,                         NetworkServerControlImpl.INVALID_OR_NOTSET_SECURITYMECHANISM),                             && securityMechanism != server.getSecurityMechanism()),                     {,                         securityCheckCode = CodePoint.SECCHKCD_NOTSUPPORTED;,                         if (SanityManager.DEBUG) {,                             trace("parseACCSEC - SECCHKCD_NOTSUPPORTED [1] - " +,                                   securityMechanism + " <> " +,                                   server.getSecurityMechanism() + "\n");,                         },                     },                     else,                     {,                         // for plain text userid,password USRIDPWD, and USRIDONL,                         // no need of decryptionManager,                         if (securityMechanism != CodePoint.SECMEC_USRIDPWD &&,                                 securityMechanism != CodePoint.SECMEC_USRIDONL),                         {,                             // These are the only other mechanisms we understand,                             if (((securityMechanism != CodePoint.SECMEC_EUSRIDPWD) ||,                                  (securityMechanism == CodePoint.SECMEC_EUSRIDPWD && ,                                    !server.supportsEUSRIDPWD()),                                  ) &&,                                 (securityMechanism !=,                                         CodePoint.SECMEC_USRSSBPWD)),                                 //securityCheckCode = CodePoint.SECCHKCD_NOTSUPPORTED;,                     {,                         securityCheckCode = CodePoint.SECCHKCD_NOTSUPPORTED;,                         if (SanityManager.DEBUG) {,                             trace("parseACCSEC - SECCHKCD_NOTSUPPORTED [2]\n");,                         },                     },                             else,                             {,                                 // We delay the initialization and required,                                 // processing for SECMEC_USRSSBPWD as we need,                                 // to ensure the database is booted so that,                                 // we can verify that the current auth scheme,                                 // is set to BUILT-IN or NONE. For this we need,                                 // to have the RDBNAM codepoint available.,                                 //,                                 // See validateSecMecUSRSSBPWD() call below,                                 if (securityMechanism ==,                                         CodePoint.SECMEC_USRSSBPWD) {,                                     break;,                                 }, ,                                 // SECMEC_EUSRIDPWD initialization,                                 try {,                                     if (decryptionManager == null) {,                                         decryptionManager = new DecryptionManager();,                                     },                                     myPublicKey = decryptionManager.obtainPublicKey();,                                 } catch (SQLException e) {,                                     println2Log(null, session.drdaID, e.getMessage());,                                     // Local security service non-retryable error.,                                     securityCheckCode = CodePoint.SECCHKCD_0A;,                                 },                             },                         },                     },                     break;,                 //optional (currently required for Derby - needed for,                 //          DERBY-528 as well),                 case CodePoint.RDBNAM:,                     String dbname = parseRDBNAM();,                     Database d = session.getDatabase(dbname);,                     if (d == null),                     {,                         initializeDatabase(dbname);,                     },                     else,                     {,                         // reset database for connection re-use ,                         // DERBY-3596,                         // If we are reusing resources for a new physical,                         // connection, reset the database object. If the client,                         // is in the process of creating a new logical,                         // connection only, don't reset the database object.,                         if (!deferredReset) {,                             d.reset();,                         },                         database = d;,                     },                     break;,                 //optional - depending on security Mechanism ,                 case CodePoint.SECTKN:,                     secTokenIn = reader.readBytes();,                     break;,                 default:,                     invalidCodePoint(codePoint);,             },             codePoint = reader.getCodePoint();,         }, ,         // check for required CodePoint's,         if (securityMechanism == 0) {,             missingCodePoint(CodePoint.SECMEC);,         }, , ,         if (database == null) {,             initializeDatabase(null);,         },         database.securityMechanism = securityMechanism;,         database.secTokenIn = secTokenIn;, ,         // If security mechanism is SECMEC_USRSSBPWD, then ensure it can be,         // used for the database or system based on the client's connection,         // URL and its identity.,         if (securityCheckCode == 0  &&,             (database.securityMechanism == CodePoint.SECMEC_USRSSBPWD)),         {,             if (SanityManager.DEBUG) {,                 SanityManager.ASSERT((securityCheckCode == 0),,                         "SECMEC_USRSSBPWD: securityCheckCode should not " +,                         "already be set, found it initialized with " +,                         "a value of '" + securityCheckCode + "'.");,             },             securityCheckCode = validateSecMecUSRSSBPWD();,         }, ,         // need security token,         if (securityCheckCode == 0  && ,             (database.securityMechanism == CodePoint.SECMEC_EUSRIDPWD ||,             database.securityMechanism == CodePoint.SECMEC_USRSSBPWD) &&,             database.secTokenIn == null),         {,             securityCheckCode = CodePoint.SECCHKCD_SECTKNMISSING_OR_INVALID;,         }, ,         // shouldn't have security token,         if (securityCheckCode == 0 &&,             (database.securityMechanism == CodePoint.SECMEC_USRIDPWD ||,             database.securityMechanism == CodePoint.SECMEC_USRIDONL)  &&,             database.secTokenIn != null),         {,             securityCheckCode = CodePoint.SECCHKCD_SECTKNMISSING_OR_INVALID;,         }, ,         if (SanityManager.DEBUG) {,             trace("** ACCSECRD securityCheckCode is: " + securityCheckCode);,         },         ,         // If the security check was successful set the session state to,         // security accesseed.  Otherwise go back to attributes exchanged so we,         // require another ACCSEC,         session.setState(,             (securityCheckCode == 0) ? Session.SECACC : Session.ATTEXC);, ,         return securityCheckCode;,     }, ,     /**,      * Parse OPNQRY,      * Instance Variables,      *  RDBNAM - relational database name - optional,      *  PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required,      *  QRYBLKSZ - Query Block Size - required,      *  QRYBLKCTL - Query Block Protocol Control - optional ,      *  MAXBLKEXT - Maximum Number of Extra Blocks - optional - default value 0,      *  OUTOVROPT - Output Override Option,      *  QRYROWSET - Query Rowset Size - optional - level 7,      *  MONITOR - Monitor events - optional.,      *,      * @return RDB Package Name, Consistency Token, and Section Number,      * @exception DRDAProtocolException,      */,     private Pkgnamcsn parseOPNQRY() throws DRDAProtocolException, SQLException,     {,         Pkgnamcsn pkgnamcsn = null;,         boolean gotQryblksz = false;,         int blksize = 0;,         int qryblkctl = CodePoint.QRYBLKCTL_DEFAULT;,         int maxblkext = CodePoint.MAXBLKEXT_DEFAULT;,         int qryrowset = CodePoint.QRYROWSET_DEFAULT;,         int qryclsimp = DRDAResultSet.QRYCLSIMP_DEFAULT;,         int outovropt = CodePoint.OUTOVRFRS;,         reader.markCollection();,         int codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch(codePoint),             {,                 //optional,                 case CodePoint.RDBNAM:,                     setDatabase(CodePoint.OPNQRY);,                     break;,                 //required,                 case CodePoint.PKGNAMCSN:,                     pkgnamcsn = parsePKGNAMCSN();,                     break;,                 //required,                 case CodePoint.QRYBLKSZ:,                     blksize = parseQRYBLKSZ();,                     gotQryblksz = true;,                     break;,                 //optional,                 case CodePoint.QRYBLKCTL:,                     qryblkctl = reader.readNetworkShort();,                     //The only type of query block control we can specify here,                     //is forced fixed row,                     if (qryblkctl != CodePoint.FRCFIXROW) {,                         invalidCodePoint(qryblkctl);,                     },                     if (SanityManager.DEBUG) {,                         trace("!!qryblkctl = "+Integer.toHexString(qryblkctl));,                     },                     gotQryblksz = true;,                     break;,                 //optional,                 case CodePoint.MAXBLKEXT:,                     maxblkext = reader.readSignedNetworkShort();,                     if (SanityManager.DEBUG) {,                         trace("maxblkext = "+maxblkext);,                     },                     break;,                 // optional,                 case CodePoint.OUTOVROPT:,                     outovropt = parseOUTOVROPT();,                     break;,                 //optional,                 case CodePoint.QRYROWSET:,                     //Note minimum for OPNQRY is 0,                     qryrowset = parseQRYROWSET(0);,                     break;,                 case CodePoint.QRYCLSIMP:,                     // Implicitly close non-scrollable cursor,                     qryclsimp = parseQRYCLSIMP();,                     break;,                 case CodePoint.QRYCLSRLS:,                     // Ignore release of read locks.  Nothing we can do here,                     parseQRYCLSRLS();,                     break;,                 // optional,                 case CodePoint.MONITOR:,                     parseMONITOR();,                     break;,                 default:,                     invalidCodePoint(codePoint);,             },             codePoint = reader.getCodePoint();,         },         // check for required variables,         if (pkgnamcsn == null) {,             missingCodePoint(CodePoint.PKGNAMCSN);,         },         if (!gotQryblksz) {,             missingCodePoint(CodePoint.QRYBLKSZ);,         }, ,         // get the statement we are opening,         DRDAStatement stmt = database.getDRDAStatement(pkgnamcsn);,         if (stmt == null),         {,             //XXX should really throw a SQL Exception here,             invalidValue(CodePoint.PKGNAMCSN);,         }, ,         // check that this statement is not already open,         // commenting this check out for now,         // it turns out that JCC doesn't send a close if executeQuery is,         // done again without closing the previous result set,         // this check can't be done since the second executeQuery should work,         //if (stmt.state != DRDAStatement.NOT_OPENED),         //{,         //  writeQRYPOPRM();,         //  pkgnamcsn = null;,         //},         //else,         //{,         stmt.setOPNQRYOptions(blksize,qryblkctl,maxblkext,outovropt,,                               qryrowset, qryclsimp);,         //},         ,         // read the command objects,         // for ps with parameter,         if (reader.isChainedWithSameID()),         {,             if (SanityManager.DEBUG) {,                 trace("&&&&&& parsing SQLDTA");,             },             parseOPNQRYobjects(stmt);,         },         return pkgnamcsn;,     },     /**,      * Parse OPNQRY objects,      * Objects,      *  TYPDEFNAM - Data type definition name - optional,      *  TYPDEFOVR - Type defintion overrides - optional,      *  SQLDTA- SQL Program Variable Data - optional,      *,      * If TYPDEFNAM and TYPDEFOVR are supplied, they apply to the objects,      * sent with the statement.  Once the statement is over, the default values,      * sent in the ACCRDB are once again in effect.  If no values are supplied,,      * the values sent in the ACCRDB are used.,      * Objects may follow in one DSS or in several DSS chained together.,      * ,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void parseOPNQRYobjects(DRDAStatement stmt) ,         throws DRDAProtocolException, SQLException,     {,         int codePoint;,         do,         {,             correlationID = reader.readDssHeader();,             while (reader.moreDssData()),             {,                 codePoint = reader.readLengthAndCodePoint( false );,                 switch(codePoint),                 {,                     // optional,                     case CodePoint.TYPDEFNAM:,                         setStmtOrDbByteOrder(false, stmt, parseTYPDEFNAM());,                         break;,                     // optional,                     case CodePoint.TYPDEFOVR:,                         parseTYPDEFOVR(stmt);,                         break;,                     // optional ,                     case CodePoint.SQLDTA:,                         parseSQLDTA(stmt);,                         break;,                     // optional,                     case CodePoint.EXTDTA:,                         readAndSetAllExtParams(stmt, false);,                         break;,                     default:,                         invalidCodePoint(codePoint);,                 },             },         } while (reader.isChainedWithSameID());, ,     },     /**,      * Parse OUTOVROPT - this indicates whether output description can be,      * overridden on just the first CNTQRY or on any CNTQRY,      *,      * @return output override option,      * @exception DRDAProtocolException,      */,     private int parseOUTOVROPT() throws DRDAProtocolException,     {,         checkLength(CodePoint.OUTOVROPT, 1);,         int outovropt = reader.readUnsignedByte();,         if (SanityManager.DEBUG) {,             trace("output override option: "+outovropt);,         },         if (outovropt != CodePoint.OUTOVRFRS &&,                 outovropt != CodePoint.OUTOVRANY) {,             invalidValue(CodePoint.OUTOVROPT);,         },         return outovropt;,     }, ,     /**,      * Parse QRYBLSZ - this gives the maximum size of the query blocks that,      * can be returned to the requester,      *,      * @return query block size,      * @exception DRDAProtocolException,      */,     private int parseQRYBLKSZ() throws DRDAProtocolException,     {,         checkLength(CodePoint.QRYBLKSZ, 4);,         int blksize = reader.readNetworkInt();,         if (SanityManager.DEBUG) {,             trace("qryblksz = "+blksize);,         },         if (blksize < CodePoint.QRYBLKSZ_MIN ||,                 blksize > CodePoint.QRYBLKSZ_MAX) {,             invalidValue(CodePoint.QRYBLKSZ);,         },         return blksize;,     },     /**,      * Parse QRYROWSET - this is the number of rows to return,      *,      * @param minVal - minimum value,      * @return query row set size,      * @exception DRDAProtocolException,      */,     private int parseQRYROWSET(int minVal) throws DRDAProtocolException,     {,         checkLength(CodePoint.QRYROWSET, 4);,         int qryrowset = reader.readNetworkInt();,         if (SanityManager.DEBUG) {,             trace("qryrowset = " + qryrowset);,         },         if (qryrowset < minVal || qryrowset > CodePoint.QRYROWSET_MAX) {,             invalidValue(CodePoint.QRYROWSET);,         },         return qryrowset;,     }, ,     /** Parse a QRYCLSIMP - Implicitly close non-scrollable cursor ,      * after end of data.,      * @return  true to close on end of data ,      */,     private int  parseQRYCLSIMP() throws DRDAProtocolException,     {,        ,         checkLength(CodePoint.QRYCLSIMP, 1);,         int qryclsimp = reader.readUnsignedByte();,         if (SanityManager.DEBUG) {,             trace ("qryclsimp = " + qryclsimp);,         },         if (qryclsimp != CodePoint.QRYCLSIMP_SERVER_CHOICE &&,             qryclsimp != CodePoint.QRYCLSIMP_YES &&,             qryclsimp != CodePoint.QRYCLSIMP_NO ),         {,             invalidValue(CodePoint.QRYCLSIMP);,         },         return qryclsimp;,     }, , ,     private int parseQRYCLSRLS() throws DRDAProtocolException,     {,         reader.skipBytes();,         return 0;,     }, ,     /**,      * Write a QRYPOPRM - Query Previously opened,      * Instance Variables,      *  SVRCOD - Severity Code - required - 8 ERROR,      *  RDBNAM - Relational Database Name - required,      *  PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number - required,      * ,      * @exception DRDAProtocolException,      */,     private void writeQRYPOPRM() throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.QRYPOPRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, CodePoint.SVRCOD_ERROR);,         writeRDBNAM(database.getDatabaseName());,         writePKGNAMCSN();,         writer.endDdmAndDss();,     },     /**,      * Write a QRYNOPRM - Query Not Opened,      * Instance Variables,      *  SVRCOD - Severity Code - required -  4 Warning 8 ERROR,      *  RDBNAM - Relational Database Name - required,      *  PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number - required,      * ,      * @param svrCod    Severity Code,      * @exception DRDAProtocolException,      */,     private void writeQRYNOPRM(int svrCod) throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.QRYNOPRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, svrCod);,         writeRDBNAM(database.getDatabaseName());,         writePKGNAMCSN();,         writer.endDdmAndDss();,     },     /**,      * Write a OPNQFLRM - Open Query Failure,      * Instance Variables,      *  SVRCOD - Severity Code - required - 8 ERROR,      *  RDBNAM - Relational Database Name - required,      *,      * @param   e   Exception describing failure,      *,      * @exception DRDAProtocolException,      */,     private void writeOPNQFLRM(SQLException e) throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.OPNQFLRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, CodePoint.SVRCOD_ERROR);,         writeRDBNAM(database.getDatabaseName());,         writer.endDdm();,         writer.startDdm(CodePoint.SQLCARD);,         writeSQLCAGRP(e, 0, 0);,         writer.endDdmAndDss();,     },     /**,      * Write PKGNAMCSN,      * Instance Variables,      *   NAMESYMDR - database name - not validated,      *   RDBCOLID - RDB Collection Identifier,      *   PKGID - RDB Package Identifier,      *   PKGCNSTKN - RDB Package Consistency Token,      *   PKGSN - RDB Package Section Number,      *,      * There are two possible formats, fixed and extended which includes length,      * information for the strings,      *,      * @throws DRDAProtocolException,      */,     private void writePKGNAMCSN(byte[] pkgcnstkn) throws DRDAProtocolException,     {,         writer.startDdm(CodePoint.PKGNAMCSN);,         if (rdbnam.length() <= CodePoint.RDBNAM_LEN &&,             rdbcolid.length() <= CodePoint.RDBCOLID_LEN &&,             pkgid.length() <= CodePoint.PKGID_LEN),         {   // if none of RDBNAM, RDBCOLID and PKGID have a length of,             // more than 18, use fixed format,             writer.writeScalarPaddedString(rdbnam, CodePoint.RDBNAM_LEN);,             writer.writeScalarPaddedString(rdbcolid, CodePoint.RDBCOLID_LEN);,             writer.writeScalarPaddedString(pkgid, CodePoint.PKGID_LEN);,             writer.writeScalarPaddedBytes(pkgcnstkn,,                                           CodePoint.PKGCNSTKN_LEN, (byte) 0);,             writer.writeShort(pkgsn);,         },         else    // extended format,         {,             int len = Math.max(CodePoint.RDBNAM_LEN, rdbnam.length());,             writer.writeShort(len);,             writer.writeScalarPaddedString(rdbnam, len);,             len = Math.max(CodePoint.RDBCOLID_LEN, rdbcolid.length());,             writer.writeShort(len);,             writer.writeScalarPaddedString(rdbcolid, len);,             len = Math.max(CodePoint.PKGID_LEN, pkgid.length());,             writer.writeShort(len);,             writer.writeScalarPaddedString(pkgid, len);,             writer.writeScalarPaddedBytes(pkgcnstkn,,                                           CodePoint.PKGCNSTKN_LEN, (byte) 0);,             writer.writeShort(pkgsn);,         },         writer.endDdm();,     }, ,     private void writePKGNAMCSN() throws DRDAProtocolException,     {,         writePKGNAMCSN(pkgcnstkn.getBytes());,     }, ,     /**,      * Parse CNTQRY - Continue Query,      * Instance Variables,      *   RDBNAM - Relational Database Name - optional,      *   PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number - required,      *   QRYBLKSZ - Query Block Size - required,      *   QRYRELSCR - Query Relative Scrolling Action - optional,      *   QRYSCRORN - Query Scroll Orientation - optional - level 7,      *   QRYROWNBR - Query Row Number - optional,      *   QRYROWSNS - Query Row Sensitivity - optional - level 7,      *   QRYBLKRST - Query Block Reset - optional - level 7,      *   QRYRTNDTA - Query Returns Data - optional - level 7,      *   QRYROWSET - Query Rowset Size - optional - level 7,      *   QRYRFRTBL - Query Refresh Answer Set Table - optional,      *   NBRROW - Number of Fetch or Insert Rows - optional,      *   MAXBLKEXT - Maximum number of extra blocks - optional,      *   RTNEXTDTA - Return of EXTDTA Option - optional,      *   MONITOR - Monitor events - optional.,      *,      * @return DRDAStatement we are continuing,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private DRDAStatement parseCNTQRY() throws DRDAProtocolException, SQLException,     {,         byte val;,         Pkgnamcsn pkgnamcsn = null;,         boolean gotQryblksz = false;,         boolean qryrelscr = true;,         long qryrownbr = 1;,         boolean qryrfrtbl = false;,         int nbrrow = 1;,         int blksize = 0;,         int maxblkext = -1;,         long qryinsid;,         boolean gotQryinsid = false;,         int qryscrorn = CodePoint.QRYSCRREL;,         boolean qryrowsns = false;,         boolean gotQryrowsns = false;,         boolean qryblkrst = false;,         boolean qryrtndta = true;,         int qryrowset = CodePoint.QRYROWSET_DEFAULT;,         int rtnextdta = CodePoint.RTNEXTROW;,         reader.markCollection();,         int codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch(codePoint),             {,                 //optional,                 case CodePoint.RDBNAM:,                     setDatabase(CodePoint.CNTQRY);,                     break;,                 //required,                 case CodePoint.PKGNAMCSN:,                     pkgnamcsn = parsePKGNAMCSN();,                     break;,                 //required,                 case CodePoint.QRYBLKSZ:,                     blksize = parseQRYBLKSZ();,                     gotQryblksz = true;,                     break;,                 //optional,                 case CodePoint.QRYRELSCR:,                     qryrelscr = readBoolean(CodePoint.QRYRELSCR);,                     if (SanityManager.DEBUG) {,                         trace("qryrelscr = "+qryrelscr);,                     },                     break;,                 //optional,                 case CodePoint.QRYSCRORN:,                     checkLength(CodePoint.QRYSCRORN, 1);,                     qryscrorn = reader.readUnsignedByte();,                     if (SanityManager.DEBUG) {,                         trace("qryscrorn = "+qryscrorn);,                     },                     switch (qryscrorn),                     {,                         case CodePoint.QRYSCRREL:,                         case CodePoint.QRYSCRABS:,                         case CodePoint.QRYSCRAFT:,                         case CodePoint.QRYSCRBEF:,                             break;,                         default:,                             invalidValue(CodePoint.QRYSCRORN);,                     },                     break;,                 //optional,                 case CodePoint.QRYROWNBR:,                     checkLength(CodePoint.QRYROWNBR, 8);,                     qryrownbr = reader.readNetworkLong();,                     if (SanityManager.DEBUG) {,                         trace("qryrownbr = "+qryrownbr);,                     },                     break;,                 //optional,                 case CodePoint.QRYROWSNS:,                     checkLength(CodePoint.QRYROWSNS, 1);,                     qryrowsns = readBoolean(CodePoint.QRYROWSNS);,                     if (SanityManager.DEBUG) {,                         trace("qryrowsns = "+qryrowsns);,                     },                     gotQryrowsns = true;,                     break;,                 //optional,                 case CodePoint.QRYBLKRST:,                     checkLength(CodePoint.QRYBLKRST, 1);,                     qryblkrst = readBoolean(CodePoint.QRYBLKRST);,                     if (SanityManager.DEBUG) {,                         trace("qryblkrst = "+qryblkrst);,                     },                     break;,                 //optional,                 case CodePoint.QRYRTNDTA:,                     qryrtndta = readBoolean(CodePoint.QRYRTNDTA);,                     if (SanityManager.DEBUG) {,                         trace("qryrtndta = "+qryrtndta);,                     },                     break;,                 //optional,                 case CodePoint.QRYROWSET:,                     //Note minimum for CNTQRY is 1,                     qryrowset = parseQRYROWSET(1);,                     if (SanityManager.DEBUG) {,                         trace("qryrowset = "+qryrowset);,                     },                     break;,                 //optional,                 case CodePoint.QRYRFRTBL:,                     qryrfrtbl = readBoolean(CodePoint.QRYRFRTBL);,                     if (SanityManager.DEBUG) {,                         trace("qryrfrtbl = "+qryrfrtbl);,                     },                     break;,                 //optional,                 case CodePoint.NBRROW:,                     checkLength(CodePoint.NBRROW, 4);,                     nbrrow = reader.readNetworkInt();,                     if (SanityManager.DEBUG) {,                         trace("nbrrow = "+nbrrow);,                     },                     break;,                 //optional,                 case CodePoint.MAXBLKEXT:,                     checkLength(CodePoint.MAXBLKEXT, 2);,                     maxblkext = reader.readSignedNetworkShort();,                     if (SanityManager.DEBUG) {,                         trace("maxblkext = "+maxblkext);,                     },                     break;,                 //optional,                 case CodePoint.RTNEXTDTA:,                     checkLength(CodePoint.RTNEXTDTA, 1);,                     rtnextdta = reader.readUnsignedByte();,                     if (rtnextdta != CodePoint.RTNEXTROW && ,                             rtnextdta != CodePoint.RTNEXTALL) {,                         invalidValue(CodePoint.RTNEXTDTA);,                     },                     if (SanityManager.DEBUG) {,                         trace("rtnextdta = "+rtnextdta);,                     },                     break;,                 // required for SQLAM >= 7,                 case CodePoint.QRYINSID:,                     checkLength(CodePoint.QRYINSID, 8);,                     qryinsid = reader.readNetworkLong();,                     gotQryinsid = true;,                     if (SanityManager.DEBUG) {,                         trace("qryinsid = "+qryinsid);,                     },                     break;,                 // optional,                 case CodePoint.MONITOR:,                     parseMONITOR();,                     break;,                 default:,                     invalidCodePoint(codePoint);,             },             codePoint = reader.getCodePoint();,         },         // check for required variables,         if (pkgnamcsn == null) {,             missingCodePoint(CodePoint.PKGNAMCSN);,         },         if (!gotQryblksz) {,             missingCodePoint(CodePoint.QRYBLKSZ);,         },         if (sqlamLevel >= MGRLVL_7 && !gotQryinsid) {,             missingCodePoint(CodePoint.QRYINSID);,         }, ,         // get the statement we are continuing,         DRDAStatement stmt = database.getDRDAStatement(pkgnamcsn);,         if (stmt == null),         {,             //XXX should really throw a SQL Exception here,             invalidValue(CodePoint.CNTQRY);,         }, ,         if (stmt.rsIsClosed()),         {,             writeQRYNOPRM(CodePoint.SVRCOD_ERROR);,             skipRemainder(true);,             return null;,         },         stmt.setQueryOptions(blksize,qryrelscr,qryrownbr,qryrfrtbl,nbrrow,maxblkext,,                          qryscrorn,qryrowsns,qryblkrst,qryrtndta,qryrowset,,                          rtnextdta);, ,         if (reader.isChainedWithSameID()) {,             parseCNTQRYobjects(stmt);,         }, ,         return stmt;,     },     /**,      * Skip remainder of current DSS and all chained DSS'es,      *,      * @param onlySkipSameIds True if we _only_ want to skip DSS'es,      *   that are chained with the SAME id as the current DSS.,      *   False means skip ALL chained DSSes, whether they're,      *   chained with same or different ids.,      * @exception DRDAProtocolException,      */,     private void skipRemainder(boolean onlySkipSameIds) throws DRDAProtocolException,     {,         reader.skipDss();,         while (reader.isChainedWithSameID() ||,             (!onlySkipSameIds && reader.isChainedWithDiffID())),         {,             reader.readDssHeader();,             reader.skipDss();,         },     },     /**,      * Parse CNTQRY objects,      * Instance Variables,      *   OUTOVR - Output Override Descriptor - optional,      *,      * @param stmt DRDA statement we are working on,      * @exception DRDAProtocolException,      */,     private void parseCNTQRYobjects(DRDAStatement stmt) throws DRDAProtocolException, SQLException,     {,         int codePoint;,         do,         {,             correlationID = reader.readDssHeader();,             while (reader.moreDssData()),             {,                 codePoint = reader.readLengthAndCodePoint( false );,                 switch(codePoint),                 {,                     // optional,                     case CodePoint.OUTOVR:,                         parseOUTOVR(stmt);,                         break;,                     default:,                         invalidCodePoint(codePoint);,                 },             },         } while (reader.isChainedWithSameID());, ,     },     /**,      * Parse OUTOVR - Output Override Descriptor,      * This specifies the output format for data to be returned as output to a SQL,      * statement or as output from a query.,      *,      * @param stmt  DRDA statement this applies to,      * @exception DRDAProtocolException,      */,     private void parseOUTOVR(DRDAStatement stmt) throws DRDAProtocolException, SQLException,     {,         boolean first = true;,         int numVars;,         int dtaGrpLen;,         int tripType;,         int tripId;,         int precision;,         int start = 0;,         while (true),         {,             dtaGrpLen = reader.readUnsignedByte();,             tripType = reader.readUnsignedByte();,             tripId = reader.readUnsignedByte();,             // check if we have reached the end of the data,             if (tripType == FdocaConstants.RLO_TRIPLET_TYPE),             {,                 //read last part of footer,                 reader.skipBytes();,                 break;,             },             numVars = (dtaGrpLen - 3) / 3;,             if (SanityManager.DEBUG) {,                 trace("num of vars is: "+numVars);,             },             int[] outovr_drdaType;,             if (first),             {,                 outovr_drdaType = new int[numVars];,                 first = false;,             },             else,             {,                 int[] oldoutovr_drdaType = stmt.getOutovr_drdaType();,                 int oldlen = oldoutovr_drdaType.length;,                 // create new array and copy over already read stuff,                 outovr_drdaType = new int[oldlen + numVars];,                 System.arraycopy(oldoutovr_drdaType, 0,,                                  outovr_drdaType,0,,                                  oldlen);,                 start = oldlen;,             },             for (int i = start; i < numVars + start; i++),             {,                 int drdaType = reader.readUnsignedByte();,                 if (!database.supportsLocator()) { ,                     // ignore requests for locator when it is not supported,                     if ((drdaType >= DRDAConstants.DRDA_TYPE_LOBLOC),                         && (drdaType <= DRDAConstants.DRDA_TYPE_NCLOBLOC)) {,                         if (SanityManager.DEBUG) {,                             trace("ignoring drdaType: " + drdaType);,                         },                         reader.readNetworkShort(); // Skip rest,                         continue;,                     },                 },                 outovr_drdaType[i] = drdaType;,                 if (SanityManager.DEBUG) {,                     trace("drdaType is: "+ outovr_drdaType[i]);,                 },                 precision = reader.readNetworkShort();,                 if (SanityManager.DEBUG) {,                     trace("drdaLength is: "+precision);,                 },                 outovr_drdaType[i] |= (precision << 8);,             },             stmt.setOutovr_drdaType(outovr_drdaType);,         },     }, ,     /**,      * Piggy-back any modified session attributes on the current message. Writes,      * a PBSD conataining one or both of PBSD_ISO and PBSD_SCHEMA. PBSD_ISO is,      * followed by the jdbc isolation level as an unsigned byte. PBSD_SCHEMA is,      * followed by the name of the current schema as an UTF-8 String.,      * @throws java.sql.SQLException,      * @throws org.apache.derby.impl.drda.DRDAProtocolException,      */,     private void writePBSD() throws SQLException, DRDAProtocolException,     {,         if (!appRequester.supportsSessionDataCaching()) {,             return;,         },         PiggyBackedSessionData pbsd = database.getPiggyBackedSessionData(true);,         if (SanityManager.DEBUG) {,             SanityManager.ASSERT(pbsd != null, "pbsd is not expected to be null");,         },         // DERBY-3596,         // Reset the flag. In sane builds it is used to avoid an assert, but,         // we want to reset it as soon as possible to avoid masking real bugs.,         // We have to do this because we are changing the connection state,         // at an unexpected time (deferred reset, see parseSECCHK). This was,         // done to avoid having to change the client code.,         this.deferredReset = false;,         pbsd.refresh();,         if (pbsd.isModified()) {,             writer.createDssReply();,             writer.startDdm(CodePoint.PBSD);, ,             if (pbsd.isIsoModified()) {,                 writer.writeScalar1Byte(CodePoint.PBSD_ISO, pbsd.getIso());,             }, ,             if (pbsd.isSchemaModified()) {,                 writer.startDdm(CodePoint.PBSD_SCHEMA);,                 writer.writeString(pbsd.getSchema());,                 writer.endDdm();,             },             writer.endDdmAndDss();,         },         pbsd.setUnmodified();,         if (SanityManager.DEBUG) {,             PiggyBackedSessionData pbsdNew =,                 database.getPiggyBackedSessionData(true);,             SanityManager.ASSERT(pbsdNew == pbsd,,                                  "pbsdNew and pbsd are expected to reference " +,                                  "the same object");,             pbsd.refresh();,             SanityManager.ASSERT,                 (!pbsd.isModified(),,                  "pbsd=("+pbsd+") is not expected to be modified");,         },     }, ,     /**,      * Write OPNQRYRM - Open Query Complete,      * Instance Variables,      *   SVRCOD - Severity Code - required,      *   QRYPRCTYP - Query Protocol Type - required,      *   SQLCSRHLD - Hold Cursor Position - optional,      *   QRYATTSCR - Query Attribute for Scrollability - optional - level 7,      *   QRYATTSNS - Query Attribute for Sensitivity - optional - level 7,      *   QRYATTUPD - Query Attribute for Updatability -optional - level 7,      *   QRYINSID - Query Instance Identifier - required - level 7,      *   SRVDGN - Server Diagnostic Information - optional,      *,      * @param isDssObject - return as a DSS object (part of a reply) ,      * @param stmt - DRDA statement we are processing,      *,      * @exception DRDAProtocolException,      */,     private void writeOPNQRYRM(boolean isDssObject, DRDAStatement stmt) ,         throws DRDAProtocolException, SQLException,     {,         if (SanityManager.DEBUG) {,             trace("WriteOPNQRYRM");,         }, ,         if (isDssObject) {,             writer.createDssObject();,         } else {,             writer.createDssReply();,         },         writer.startDdm(CodePoint.OPNQRYRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD,CodePoint.SVRCOD_INFO);, ,         // There is currently a problem specifying LMTBLKPRC for LOBs with JCC,         // JCC will throw an ArrayOutOfBounds exception.  Once this is fixed, we,         // don't need to pass the two arguments for getQryprctyp.,         int prcType = stmt.getQryprctyp();,         if (SanityManager.DEBUG) {,             trace("sending QRYPRCTYP: " + prcType);,         },         writer.writeScalar2Bytes(CodePoint.QRYPRCTYP, prcType);, ,         //pass the SQLCSRHLD codepoint only if statement producing the ResultSet has ,         //hold cursors over commit set. In case of stored procedures which use server-side,         //JDBC, the holdability of the ResultSet will be the holdability of the statement ,         //in the stored procedure, not the holdability of the calling statement.,         if (stmt.getCurrentDrdaResultSet().withHoldCursor == ResultSet.HOLD_CURSORS_OVER_COMMIT),         {,             writer.writeScalar1Byte(CodePoint.SQLCSRHLD, CodePoint.TRUE);,         },         if (sqlamLevel >= MGRLVL_7),         {,             writer.writeScalarHeader(CodePoint.QRYINSID, 8);,             //This is implementer defined.  DB2 uses this for the nesting level,             //of the query.  A query from an application would be nesting level 0,,             //from a stored procedure, nesting level 1, from a recursive call of,             //a stored procedure, nesting level 2, etc.,             writer.writeInt(0);     ,             //This is a unique sequence number per session,             writer.writeInt(session.qryinsid++);,             //Write the scroll attributes if they are set,             if (stmt.isScrollable()),             {,                 writer.writeScalar1Byte(CodePoint.QRYATTSCR, CodePoint.TRUE);,                 if ((stmt.getConcurType() == ResultSet.CONCUR_UPDATABLE) &&,                         (stmt.getResultSet().getType() == ,                          ResultSet.TYPE_SCROLL_INSENSITIVE)) {,                     writer.writeScalar1Byte(CodePoint.QRYATTSNS, ,                                             CodePoint.QRYSNSSTC);,                 } else {,                     writer.writeScalar1Byte(CodePoint.QRYATTSNS, ,                                             CodePoint.QRYINS);,                 },             },             if (stmt.getConcurType() == ResultSet.CONCUR_UPDATABLE) {,                 if (stmt.getResultSet() != null) { ,                     // Resultset concurrency can be less than statement,                     // concurreny if the underlying language resultset,                     // is not updatable.,                     if (stmt.getResultSet().getConcurrency() == ,                         ResultSet.CONCUR_UPDATABLE) {,                         writer.writeScalar1Byte(CodePoint.QRYATTUPD, ,                                                 CodePoint.QRYUPD);,                     } else {,                         writer.writeScalar1Byte(CodePoint.QRYATTUPD, ,                                                 CodePoint.QRYRDO);,                     },                 } else {,                     writer.writeScalar1Byte(CodePoint.QRYATTUPD, ,                                             CodePoint.QRYUPD);,                 },             } else {,                 writer.writeScalar1Byte(CodePoint.QRYATTUPD, CodePoint.QRYRDO);,             },         },         writer.endDdmAndDss ();,     },     /**,      * Write ENDQRYRM - query process has terminated in such a manner that the,      *  query or result set is now closed.  It cannot be resumed with the CNTQRY,      *  command or closed with the CLSQRY command,      * @param svrCod  Severity code - WARNING or ERROR,      * @exception DRDAProtocolException,      */,     private void writeENDQRYRM(int svrCod) throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.ENDQRYRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD,svrCod);,         writer.endDdmAndDss();,     }, /**,      * Write ABNUOWRM - query process has terminated in an error condition,      * such as deadlock or lock timeout.,      * Severity code is always error,      *   * @exception DRDAProtocolException,      */,     private void writeABNUOWRM() throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.ABNUOWRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD,CodePoint.SVRCOD_ERROR);,         writeRDBNAM(database.getDatabaseName());,         writer.endDdmAndDss();,     },     /**,      * Parse database name,      *,      * @return database name,      *,      * @exception DRDAProtocolException,      */,     private String parseRDBNAM() throws DRDAProtocolException,     {,         String name;,         byte [] rdbName = reader.readBytes();,         if (rdbName.length == 0),         {,             // throw RDBNFNRM,             rdbNotFound(null);,         },         //SQLAM level 7 allows db name up to 255, level 6 fixed len 18,         // but Derby 10.11 allows 1024,         if (rdbName.length < CodePoint.RDBNAM_LEN ||,                 rdbName.length > CodePoint.RDBNAM_MAX_NAME) {,             badObjectLength(CodePoint.RDBNAM);,         },         name = reader.convertBytes(rdbName);,         // trim trailing blanks from the database name,         name = name.trim();,         if (SanityManager.DEBUG) {,             trace("RdbName " + name);,         },         return name;,     }, ,     /**,      * Write ACCSECRD,      * If the security mechanism is known, we just send it back along with,      * the security token if encryption is going to be used.,      * If the security mechanism is not known, we send a list of the ones,      * we know.,      * Instance Variables,      *  SECMEC - security mechanism - required,      *  SECTKN - security token - optional (required if security mechanism,      *                      uses encryption),      *  SECCHKCD - security check code - error occurred in processing ACCSEC,      *,      * @param securityCheckCode,      * ,      * @exception DRDAProtocolException,      */,     private void writeACCSECRD(int securityCheckCode),         throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.ACCSECRD);, ,         if (securityCheckCode != CodePoint.SECCHKCD_NOTSUPPORTED),         {,             writer.writeScalar2Bytes(CodePoint.SECMEC, database.securityMechanism);,         },         else,         { ,             // if server doesnt recognize or allow the client requested security mechanism,,             // then need to return the list of security mechanisms supported/allowed by the server,             ,             // check if server is set to accept connections from client at a certain ,             // security mechanism, if so send only the security mechanism  that the ,             // server will accept, to the client,             if ( server.getSecurityMechanism() != NetworkServerControlImpl.INVALID_OR_NOTSET_SECURITYMECHANISM ),             {,                 writer.writeScalar2Bytes(CodePoint.SECMEC, server.getSecurityMechanism());,             },             else,             {,                 // note: per the DDM manual , ACCSECRD response is of ,                 // form SECMEC (value{value..})  ,                 // Need to fix the below to send a list of supported security ,                 // mechanisms for value of one SECMEC codepoint (JIRA 926),                 // these are the ones we know about,                 writer.writeScalar2Bytes(CodePoint.SECMEC, CodePoint.SECMEC_USRIDPWD);,                 // include EUSRIDPWD in the list of supported secmec only if ,                 // server can truely support it in the jvm that is running in,                 if ( server.supportsEUSRIDPWD()) {,                     writer.writeScalar2Bytes(CodePoint.SECMEC, CodePoint.SECMEC_EUSRIDPWD);,                 },                 writer.writeScalar2Bytes(CodePoint.SECMEC, CodePoint.SECMEC_USRIDONL);,                 writer.writeScalar2Bytes(CodePoint.SECMEC, CodePoint.SECMEC_USRSSBPWD);,             },         }, ,         if (securityCheckCode != 0),         {,             writer.writeScalar1Byte(CodePoint.SECCHKCD, securityCheckCode);,         },         else,         {,             // we need to send back the key if encryption is being used,             if (database.securityMechanism == CodePoint.SECMEC_EUSRIDPWD),             {,                 writer.writeScalarBytes(CodePoint.SECTKN, myPublicKey);,             },             else if (database.securityMechanism == CodePoint.SECMEC_USRSSBPWD),             {,                 writer.writeScalarBytes(CodePoint.SECTKN, myTargetSeed);,             },         },         writer.endDdmAndDss ();, ,         if (securityCheckCode != 0) {,         // then we have an error and so can ignore the rest of the,         // DSS request chain.,             skipRemainder(false);,         }, ,         finalizeChain();,     }, ,     /**,      * Parse security check,      * Instance Variables,      *  SECMGRNM - security manager name - optional, ignorable,      *  SECMEC  - security mechanism - required,      *  SECTKN  - security token - optional, (required if encryption used),      *  PASSWORD - password - optional, (required if security mechanism uses it),      *  NEWPASSWORD - new password - optional, (required if sec mech. uses it),      *  USRID   - user id - optional, (required if sec mec. uses it),      *  RDBNAM  - database name - optional (required if databases can have own sec.),      *,      * ,      * @return security check code,      * @exception DRDAProtocolException,      */,     private int parseSECCHK() throws DRDAProtocolException,     {,         int codePoint, securityCheckCode = 0;,         int securityMechanism = 0;,         databaseAccessException = null;,         reader.markCollection();,         codePoint = reader.getCodePoint();,         if (this.deferredReset) {,             // Skip the SECCHK, but assure a minimal degree of correctness.,             while (codePoint != -1) {,                 switch (codePoint) {,                     // Note the fall-through.,                     // Minimal level of checking to detect protocol errors.,                     // NOTE: SECMGR level 8 code points are not handled.,                     case CodePoint.SECMGRNM:,                     case CodePoint.SECMEC:,                     case CodePoint.SECTKN:,                     case CodePoint.PASSWORD:,                     case CodePoint.NEWPASSWORD:,                     case CodePoint.USRID:,                     case CodePoint.RDBNAM:,                         reader.skipBytes();,                         break;,                     default:,                         invalidCodePoint(codePoint);,                 },                 codePoint = reader.getCodePoint();,             },         } else {,         while (codePoint != -1),         {,             switch (codePoint),             {,                 //optional, ignorable,                 case CodePoint.SECMGRNM:,                     reader.skipBytes();,                     break;,                 //required,                 case CodePoint.SECMEC:,                     checkLength(CodePoint.SECMEC, 2);,                     securityMechanism = reader.readNetworkShort();,                     if (SanityManager.DEBUG) {,                         trace("parseSECCHK - Security mechanism = " + securityMechanism);,                     },                     //RESOLVE - spec is not clear on what should happen,                     //in this case,                     if (securityMechanism != database.securityMechanism) {,                         invalidValue(CodePoint.SECMEC);,                     },                     break;,                 //optional - depending on security Mechanism ,                 case CodePoint.SECTKN:,                     if ((database.securityMechanism !=,                                         CodePoint.SECMEC_EUSRIDPWD) &&,                         (database.securityMechanism !=,                                         CodePoint.SECMEC_USRSSBPWD)),                     {,                         securityCheckCode = CodePoint.SECCHKCD_SECTKNMISSING_OR_INVALID;,                         reader.skipBytes();,                     },                     else if (database.securityMechanism ==,                                                 CodePoint.SECMEC_EUSRIDPWD),                     {,                         if (database.decryptedUserId == null),                         {,                             try {,                                 database.decryptedUserId =,                                     reader.readEncryptedString(,                                                 decryptionManager,,                                                 database.securityMechanism,,                                                 myPublicKey,,                                                 database.secTokenIn);,                             } catch (SQLException se) {,                                 println2Log(database.getDatabaseName(), session.drdaID,,                                             se.getMessage());,                                 if (securityCheckCode == 0) {,                                     //userid invalid,                                     securityCheckCode = CodePoint.SECCHKCD_13;,                                 },                             },                             database.userId = database.decryptedUserId;,                             if (SanityManager.DEBUG) {,                                 trace("**decrypted userid is: "+database.userId);,                             },                         },                         else if (database.decryptedPassword == null),                         {,                             try {,                                 database.decryptedPassword =,                                     reader.readEncryptedString(,                                             decryptionManager,,                                             database.securityMechanism,,                                             myPublicKey,,                                             database.secTokenIn);,                             } catch (SQLException se) {,                                 println2Log(database.getDatabaseName(), session.drdaID,,                                             se.getMessage());,                                 if (securityCheckCode == 0) {,                                     //password invalid,                                     securityCheckCode = CodePoint.SECCHKCD_0F;,                                 },                             },                             database.password = database.decryptedPassword;,                             if (SanityManager.DEBUG) {,                                 trace("**decrypted password is: " +,                                       database.password);,                             },                         },                     },                     else if (database.securityMechanism ==,                                                 CodePoint.SECMEC_USRSSBPWD),                     {,                         if (database.passwordSubstitute == null),                         {,                             database.passwordSubstitute = reader.readBytes();,                             if (SanityManager.DEBUG) {,                                 trace("** Substitute Password is:" +,                                       DecryptionManager.toHexString(,                                         database.passwordSubstitute, 0,,                                         database.passwordSubstitute.length));,                             },                             database.password =,                                 DecryptionManager.toHexString(,                                     database.passwordSubstitute, 0,,                                     database.passwordSubstitute.length);,                         },                     },                     else,                     {,                         tooMany(CodePoint.SECTKN);,                     },                     break;,                 //optional - depending on security Mechanism,                 case CodePoint.PASSWORD:,                     database.password = reader.readString();,                     if (SanityManager.DEBUG) {,                         trace("PASSWORD " + database.password);,                     },                     break;,                 //optional - depending on security Mechanism,                 //we are not supporting this method so we'll skip bytes,                 case CodePoint.NEWPASSWORD:,                     reader.skipBytes();,                     break;,                 //optional - depending on security Mechanism,                 case CodePoint.USRID:,                     database.userId = reader.readString();,                     if (SanityManager.DEBUG) {,                         trace("USERID " + database.userId);,                     },                     break;,                 //optional - depending on security Mechanism,                 case CodePoint.RDBNAM:,                     String dbname = parseRDBNAM();,                     if (database != null) ,                     {,                         if (database.getDatabaseName() == null) {,                             // we didn't get the RDBNAM on ACCSEC. Set it here,                             database.setDatabaseName(dbname);,                             session.addDatabase(database);,                             session.database = database;,                         },                         else if (!database.getDatabaseName().equals(dbname)) {,                             rdbnamMismatch(CodePoint.SECCHK);,                         },                     },                     else,                     {,                         // we should already have added the database in ACCSEC,                         // added code here in case we make the SECMEC session rather,                         // than database wide,                         initializeDatabase(dbname);,                     },                     break;,                 default:,                     invalidCodePoint(codePoint);, ,             },             codePoint = reader.getCodePoint();,         },         // check for SECMEC which is required,         if (securityMechanism == 0) {,             missingCodePoint(CodePoint.SECMEC);,         }, ,         // Check that we have a database name.,         if (getDbName() == null) {,             missingCodePoint(CodePoint.RDBNAM);,         }, ,         //check if we have a userid and password when we need it,         if (securityCheckCode == 0 && ,            (database.securityMechanism == CodePoint.SECMEC_USRIDPWD||,             database.securityMechanism == CodePoint.SECMEC_USRIDONL )),         {,             if (database.userId == null),             {,                 securityCheckCode = CodePoint.SECCHKCD_USERIDMISSING;,             },             else if (database.securityMechanism == CodePoint.SECMEC_USRIDPWD),             {,                 if (database.password == null) {,                     securityCheckCode = CodePoint.SECCHKCD_PASSWORDMISSING;,                 },             },             //Note, we'll ignore encryptedUserId and encryptedPassword if they,             //are also set,         }, ,         if (securityCheckCode == 0 && ,                 database.securityMechanism == CodePoint.SECMEC_USRSSBPWD),         {,             if (database.userId == null) {,                 securityCheckCode = CodePoint.SECCHKCD_USERIDMISSING;,             } else if (database.passwordSubstitute == null) {,                 securityCheckCode = CodePoint.SECCHKCD_PASSWORDMISSING;,             },         }, ,         if (securityCheckCode == 0 && ,                 database.securityMechanism == CodePoint.SECMEC_EUSRIDPWD),         {,             if (database.decryptedUserId == null) {,                 securityCheckCode = CodePoint.SECCHKCD_USERIDMISSING;,             } else if (database.decryptedPassword == null) {,                 securityCheckCode = CodePoint.SECCHKCD_PASSWORDMISSING;,             },         },         // RESOLVE - when we do security we need to decrypt encrypted userid & password,         // before proceeding,         } // End "if (deferredReset) ... else ..." block, ,         // verify userid and password, if we haven't had any errors thus far.,         if ((securityCheckCode == 0) && (databaseAccessException == null)),         {,             // DERBY-3596: Reset server side (embedded) physical connection for,             //     use with a new logical connection on the client.,             if (this.deferredReset) {,                 // Reset the existing connection here.,                 try {,                     database.getConnection().resetFromPool();,                     database.getConnection().setHoldability(,                             ResultSet.HOLD_CURSORS_OVER_COMMIT);,                     // Reset isolation level to default, as the client is in,                     // the process of creating a new logical connection.,                     database.getConnection().setTransactionIsolation(,                             Connection.TRANSACTION_READ_COMMITTED);,                 } catch (SQLException sqle) {,                     handleException(sqle);,                 },             } else {,                 securityCheckCode = verifyUserIdPassword();,             },         }, ,         // Security all checked ,         if (securityCheckCode == 0) {,             session.setState(Session.CHKSEC);,         },         ,         return securityCheckCode;, ,     }, ,     /**,      * Write security check reply,      * Instance variables,      *  SVRCOD - serverity code - required,      *  SECCHKCD    - security check code  - required,      *  SECTKN - security token - optional, ignorable,      *  SVCERRNO    - security service error number,      *  SRVDGN  - Server Diagnostic Information,      *,      * @exception DRDAProtocolException,      */,     private void writeSECCHKRM(int securityCheckCode) throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.SECCHKRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, svrcodFromSecchkcd(securityCheckCode));,         writer.writeScalar1Byte(CodePoint.SECCHKCD, securityCheckCode);,         writer.endDdmAndDss ();, ,         if (securityCheckCode != 0) {,         // then we have an error and are going to end up ignoring the rest,         // of the DSS request chain.,             skipRemainder(false);,         }, ,         finalizeChain();, ,     },     /**,      * Calculate SVRCOD value from SECCHKCD,      *,      * @param securityCheckCode,      * @return SVRCOD value,      */,     private int svrcodFromSecchkcd(int securityCheckCode),     {,         if (securityCheckCode == 0 || securityCheckCode == 2 ||,             securityCheckCode == 5 || securityCheckCode == 8) {,             return CodePoint.SVRCOD_INFO;,         } else {,             return CodePoint.SVRCOD_ERROR;,         },     },     /**,      * Parse access RDB,      * Instance variables,      *  RDBACCCL - RDB Access Manager Class - required must be SQLAM,      *  CRRTKN - Correlation Token - required,      *  RDBNAM - Relational database name -required,      *  PRDID - Product specific identifier - required,      *  TYPDEFNAM   - Data Type Definition Name -required,      *  TYPDEFOVR   - Type definition overrides -required,      *  RDBALWUPD -  RDB Allow Updates optional,      *  PRDDTA - Product Specific Data - optional - ignorable,      *  STTDECDEL - Statement Decimal Delimiter - optional,      *  STTSTRDEL - Statement String Delimiter - optional,      *  TRGDFTRT - Target Default Value Return - optional,      *,      * @return severity code,      *,      * @exception DRDAProtocolException,      */,     private int parseACCRDB() throws  DRDAProtocolException,     {,         int codePoint;,         int svrcod = 0;,         copyToRequired(ACCRDB_REQUIRED);,         reader.markCollection();,         codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch (codePoint),             {,                 //required,                 case CodePoint.RDBACCCL:,                     checkLength(CodePoint.RDBACCCL, 2);,                     int sqlam = reader.readNetworkShort();,                     if (SanityManager.DEBUG) {,                         trace("RDBACCCL = " + sqlam);,                     },                     // required to be SQLAM , ,                     if (sqlam != CodePoint.SQLAM) {,                         invalidValue(CodePoint.RDBACCCL);,                     },                     removeFromRequired(CodePoint.RDBACCCL);,                     break;,                 //required,                 case CodePoint.CRRTKN:,                     database.crrtkn = reader.readBytes();,                     if (SanityManager.DEBUG) {,                         trace("crrtkn " + convertToHexString(database.crrtkn));,                     },                     removeFromRequired(CodePoint.CRRTKN);,                     int l = database.crrtkn.length;,                     if (l > CodePoint.MAX_NAME) {,                         tooBig(CodePoint.CRRTKN);,                     },                     // the format of the CRRTKN is defined in the DRDA reference,                     // x.yz where x is 1 to 8 bytes (variable),                     //      y is 1 to 8 bytes (variable),                     //      x is 6 bytes fixed,                     //      size is variable between 9 and 23,                     if (l < 9 || l > 23) {,                         invalidValue(CodePoint.CRRTKN);,                     },                     byte[] part1 = new byte[l - 6];,                     System.arraycopy(database.crrtkn, 0,,                                      part1, 0, part1.length);,                     long time = SignedBinary.getLong(database.crrtkn, ,                             l-8, SignedBinary.BIG_ENDIAN); // as "long" as unique,                     session.drdaID = reader.convertBytes(part1) + ,                                     time + leftBrace + session.connNum + rightBrace;,                     if (SanityManager.DEBUG) {,                         trace("******************************************drdaID is: " + session.drdaID);,                     },                     database.setDrdaID(session.drdaID);,     ,                     break;,                 //required,                 case CodePoint.RDBNAM:,                     String dbname = parseRDBNAM();,                     if (database != null),                     { ,                         if (!database.getDatabaseName().equals(dbname)) {,                             rdbnamMismatch(CodePoint.ACCRDB);,                         },                     },                     else,                     {,                         //first time we have seen a database name,                         Database d = session.getDatabase(dbname);,                         if (d == null),                         {,                             initializeDatabase(dbname);,                         },                         else,                         {,                             database = d;,                             database.accessCount++;,                         },                     },                     removeFromRequired(CodePoint.RDBNAM);,                     break;,                 //required,                 case CodePoint.PRDID:,                     appRequester.setClientVersion(reader.readString());,                     if (SanityManager.DEBUG) {,                         trace("prdId " + appRequester.prdid);,                     },                     if (appRequester.prdid.length() > CodePoint.PRDID_MAX) {,                         tooBig(CodePoint.PRDID);,                     },                     if (appRequester.getClientType() != AppRequester.DNC_CLIENT) {,                         invalidClient(appRequester.prdid);,                     },                     // All versions of DNC,the only client supported, handle,                     // warnings on CNTQRY,                     sendWarningsOnCNTQRY = true;,                     // The client can not request DIAGLVL because when run with,                     // an older server it will cause an exception. Older version,                     // of the server do not recognize requests for DIAGLVL.,                     if ((appRequester.getClientType() == AppRequester.DNC_CLIENT) &&,                             appRequester.greaterThanOrEqualTo(10, 2, 0)) {,                         diagnosticLevel = CodePoint.DIAGLVL1;,                     }, ,                     removeFromRequired(CodePoint.PRDID);,                     break;,                 //required,                 case CodePoint.TYPDEFNAM:,                     setStmtOrDbByteOrder(true, null, parseTYPDEFNAM());,                     removeFromRequired(CodePoint.TYPDEFNAM);,                     break;,                 //required,                 case CodePoint.TYPDEFOVR:,                     parseTYPDEFOVR(null);,                     removeFromRequired(CodePoint.TYPDEFOVR);,                     break;,                 //optional ,                 case CodePoint.RDBALWUPD:,                     checkLength(CodePoint.RDBALWUPD, 1);,                     database.rdbAllowUpdates = readBoolean(CodePoint.RDBALWUPD);,                     if (SanityManager.DEBUG) {,                         trace("rdbAllowUpdates = "+database.rdbAllowUpdates);,                     },                     break;,                 //optional, ignorable,                 case CodePoint.PRDDTA:,                     // check that it fits in maximum but otherwise ignore for now,                     if (reader.getDdmLength() > CodePoint.MAX_NAME) {,                         tooBig(CodePoint.PRDDTA);,                     },                     reader.skipBytes();,                     break;,                 case CodePoint.TRGDFTRT:,                     if (reader.readByte() == (byte) 0xF1) {,                         database.sendTRGDFTRT = true;,                     },                     break;,                 //optional - not used in JCC so skip for now,                 case CodePoint.STTDECDEL:,                 case CodePoint.STTSTRDEL:,                     codePointNotSupported(codePoint);,                     break;,                 default:,                     invalidCodePoint(codePoint);,             },             codePoint = reader.getCodePoint();,         },         checkRequired(CodePoint.ACCRDB);,         // check that we can support the double-byte and mixed-byte CCSIDS,         // set svrcod to warning if they are not supported,         if ((database.ccsidDBC != 0 && !server.supportsCCSID(database.ccsidDBC)) ||,                 (database.ccsidMBC != 0 && !server.supportsCCSID(database.ccsidMBC))) ,         {,             svrcod = CodePoint.SVRCOD_WARNING;,         },         return svrcod;,     },     /**,      * Parse TYPDEFNAM,      *,      * @return typdefnam,      * @exception DRDAProtocolException,      */,     private String parseTYPDEFNAM() throws DRDAProtocolException,     {,         String typDefNam = reader.readString();,         if (SanityManager.DEBUG) {,             trace("typeDefName " + typDefNam);,         },         if (typDefNam.length() > CodePoint.MAX_NAME) {,             tooBig(CodePoint.TYPDEFNAM);,         },         checkValidTypDefNam(typDefNam);,         // check if the typedef is one we support,         if (!typDefNam.equals(CodePoint.TYPDEFNAM_QTDSQLASC)  &&,             !typDefNam.equals(CodePoint.TYPDEFNAM_QTDSQLJVM) &&,             !typDefNam.equals(CodePoint.TYPDEFNAM_QTDSQLX86)),         {,             valueNotSupported(CodePoint.TYPDEFNAM);,         },         return typDefNam;,     }, ,     /**,      * Set a statement or the database' byte order, depending on the arguments,      *,      * @param setDatabase   if true, set database' byte order, otherwise set statement's,      * @param stmt          DRDAStatement, used when setDatabase is false,      * @param typDefNam     TYPDEFNAM value,      */,     private void setStmtOrDbByteOrder(boolean setDatabase, DRDAStatement stmt, String typDefNam),     {,         int byteOrder = (typDefNam.equals(CodePoint.TYPDEFNAM_QTDSQLX86) ?,                             SignedBinary.LITTLE_ENDIAN : SignedBinary.BIG_ENDIAN);,         if (setDatabase),         {,             database.typDefNam = typDefNam;,             database.byteOrder = byteOrder;,         },         else,         {,             stmt.typDefNam = typDefNam;,             stmt.byteOrder = byteOrder;,         },     }, ,     /**,      * Write Access to RDB Completed,      * Instance Variables,      *  SVRCOD - severity code - 0 info, 4 warning -required,      *  PRDID - product specific identifier -required,      *  TYPDEFNAM - type definition name -required,      *  TYPDEFOVR - type definition overrides - required,      *  RDBINTTKN - token which can be used to interrupt DDM commands - optional,      *  CRRTKN  - correlation token - only returned if we didn't get one from requester,      *  SRVDGN - server diagnostic information - optional,      *  PKGDFTCST - package default character subtype - optional,      *  USRID - User ID at the target system - optional,      *  SRVLST - Server List,      * ,      * @exception DRDAProtocolException,      */,     private void writeACCRDBRM(int svrcod) throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.ACCRDBRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, svrcod);,         writer.writeScalarString(CodePoint.PRDID,,                                  NetworkServerControlImpl.prdId());,         //TYPDEFNAM -required - JCC doesn't support QTDSQLJVM so for now we,         // just use ASCII, though we should eventually be able to use QTDSQLJVM,         // at level 7,         writer.writeScalarString(CodePoint.TYPDEFNAM,,                                  CodePoint.TYPDEFNAM_QTDSQLASC);,         writeTYPDEFOVR();,         writer.endDdmAndDss ();, ,          // Write the initial piggy-backed data, currently the isolation level,          // and the schema name. Only write it if the client supports session,          // data caching.,          // Sending the session data on connection initialization was introduced,          // in Derby 10.7.,          if ((appRequester.getClientType() == AppRequester.DNC_CLIENT) &&,                  appRequester.greaterThanOrEqualTo(10, 7, 0)) {,              try {,                  writePBSD();,              } catch (SQLException se) {,                  server.consoleExceptionPrint(se);,                  errorInChain(se);,              },          },         finalizeChain();,     },     ,     private void writeTYPDEFOVR() throws DRDAProtocolException,     {,         //TYPDEFOVR - required - only single byte and mixed byte are specified,         writer.startDdm(CodePoint.TYPDEFOVR);,         writer.writeScalar2Bytes(CodePoint.CCSIDSBC,,                                  NetworkServerControlImpl.CCSIDSBC);,         writer.writeScalar2Bytes(CodePoint.CCSIDMBC,,                                  NetworkServerControlImpl.CCSIDMBC);,         // PKGDFTCST - Send character subtype and userid if requested,         if (database.sendTRGDFTRT),         {,             // default to multibyte character,             writer.startDdm(CodePoint.PKGDFTCST);,             writer.writeShort(CodePoint.CSTMBCS);,             writer.endDdm();,             // userid,             writer.startDdm(CodePoint.USRID);,             writer.writeString(database.userId);,             writer.endDdm();,         },         writer.endDdm();, ,     },     ,     /**,      * Parse Type Defintion Overrides,      *  TYPDEF Overrides specifies the Coded Character SET Identifiers (CCSIDs),      *  that are in a named TYPDEF.,      * Instance Variables,      *  CCSIDSBC - CCSID for Single-Byte - optional,      *  CCSIDDBC - CCSID for Double-Byte - optional,      *  CCSIDMBC - CCSID for Mixed-byte characters -optional,      *,      * @param st    Statement this TYPDEFOVR applies to,      *,      * @exception DRDAProtocolException,      */,     private void parseTYPDEFOVR(DRDAStatement st) throws  DRDAProtocolException,     {,         int codePoint;,         int ccsidSBC = 0;,         int ccsidDBC = 0;,         int ccsidMBC = 0;,         String ccsidSBCEncoding = null;,         String ccsidDBCEncoding = null;,         String ccsidMBCEncoding = null;, ,         reader.markCollection();, ,         codePoint = reader.getCodePoint();,         // at least one of the following instance variable is required,         // if the TYPDEFOVR is specified in a command object,         if (codePoint == -1 && st != null) {,             missingCodePoint(CodePoint.CCSIDSBC);,         }, ,         while (codePoint != -1),         {,             switch (codePoint),             {,                 case CodePoint.CCSIDSBC:,                     checkLength(CodePoint.CCSIDSBC, 2);,                     ccsidSBC = reader.readNetworkShort();,                     try {,                         ccsidSBCEncoding = ,                             CharacterEncodings.getJavaEncoding(ccsidSBC);,                     } catch (Exception e) {,                         valueNotSupported(CodePoint.CCSIDSBC);,                     },                     if (SanityManager.DEBUG) {,                         trace("ccsidsbc = " + ccsidSBC + " encoding = " + ccsidSBCEncoding);,                     },                     break;,                 case CodePoint.CCSIDDBC:,                     checkLength(CodePoint.CCSIDDBC, 2);,                     ccsidDBC = reader.readNetworkShort();,                     try {,                         ccsidDBCEncoding = ,                             CharacterEncodings.getJavaEncoding(ccsidDBC);,                     } catch (Exception e) {,                         // we write a warning later for this so no error,                         // unless for a statement,                         ccsidDBCEncoding = null;,                         if (st != null) {,                             valueNotSupported(CodePoint.CCSIDSBC);,                         },                     },                     if (SanityManager.DEBUG) {,                         trace("ccsiddbc = " + ccsidDBC + " encoding = " + ccsidDBCEncoding);,                     },                     break;,                 case CodePoint.CCSIDMBC:,                     checkLength(CodePoint.CCSIDMBC, 2);,                     ccsidMBC = reader.readNetworkShort();,                     try {,                         ccsidMBCEncoding = ,                             CharacterEncodings.getJavaEncoding(ccsidMBC);,                     } catch (Exception e) {,                         // we write a warning later for this so no error,                         ccsidMBCEncoding = null;,                         if (st != null) {,                             valueNotSupported(CodePoint.CCSIDMBC);,                         },                     },                     if (SanityManager.DEBUG) {,                         trace("ccsidmbc = " + ccsidMBC + " encoding = " + ccsidMBCEncoding);,                     },                     break;,                 default:,                     invalidCodePoint(codePoint);, ,             },             codePoint = reader.getCodePoint();,         },         if (st == null),         {,             if (ccsidSBC != 0),             {,                 database.ccsidSBC = ccsidSBC;,                 database.ccsidSBCEncoding = ccsidSBCEncoding;,             },             if (ccsidDBC != 0),             {,                 database.ccsidDBC = ccsidDBC;,                 database.ccsidDBCEncoding = ccsidDBCEncoding;,             },             if (ccsidMBC != 0),             {,                 database.ccsidMBC = ccsidMBC;,                 database.ccsidMBCEncoding = ccsidMBCEncoding;,             },         },         else,         {,             if (ccsidSBC != 0),             {,                 st.ccsidSBC = ccsidSBC;,                 st.ccsidSBCEncoding = ccsidSBCEncoding;,             },             if (ccsidDBC != 0),             {,                 st.ccsidDBC = ccsidDBC;,                 st.ccsidDBCEncoding = ccsidDBCEncoding;,             },             if (ccsidMBC != 0),             {,                 st.ccsidMBC = ccsidMBC;,                 st.ccsidMBCEncoding = ccsidMBCEncoding;,             },         },     },     /**,      * Parse PRPSQLSTT - Prepare SQL Statement,      * Instance Variables,      *   RDBNAM - Relational Database Name - optional,      *   PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number - required,      *   RTNSQLDA - Return SQL Descriptor Area - optional,      *   MONITOR - Monitor events - optional.,      *   ,      * @return return 0 - don't return sqlda, 1 - return input sqlda, ,      *      2 - return output sqlda,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private int parsePRPSQLSTT() throws DRDAProtocolException,SQLException,     {,         int codePoint;,         boolean rtnsqlda = false;,         boolean rtnOutput = true;   // Return output SQLDA is default,         Pkgnamcsn pkgnamcsn = null;, ,         Database databaseToSet = null;, ,         reader.markCollection();, ,         codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch (codePoint),             {,                 // optional,                 case CodePoint.RDBNAM:,                     setDatabase(CodePoint.PRPSQLSTT);,                     databaseToSet = database;,                     break;,                 // required,                 case CodePoint.PKGNAMCSN:,                     pkgnamcsn = parsePKGNAMCSN(); ,                     break;,                 //optional,                 case CodePoint.RTNSQLDA:,                 // Return SQLDA with description of statement,                     rtnsqlda = readBoolean(CodePoint.RTNSQLDA);,                     break;,                 //optional,                 case CodePoint.TYPSQLDA:,                     rtnOutput = parseTYPSQLDA();,                     break;,                 //optional,                 case CodePoint.MONITOR:,                     parseMONITOR();,                     break;,                 default:,                     invalidCodePoint(codePoint);, ,             },             codePoint = reader.getCodePoint();,         }, ,         DRDAStatement stmt = database.newDRDAStatement(pkgnamcsn);,         String sqlStmt = parsePRPSQLSTTobjects(stmt);,         if (databaseToSet != null) {,             stmt.setDatabase(database);,         },         stmt.explicitPrepare(sqlStmt);,         // set the statement as the current statement,         database.setCurrentStatement(stmt);, ,         if (!rtnsqlda) {,             return 0;,         } else if (rtnOutput) {,             return 2;,         } else {,             return 1;,         },     },     /**,      * Parse PRPSQLSTT objects,      * Objects,      *  TYPDEFNAM - Data type definition name - optional,      *  TYPDEFOVR - Type defintion overrides - optional,      *  SQLSTT - SQL Statement required,      *  SQLATTR - Cursor attributes on prepare - optional - level 7,      *,      * If TYPDEFNAM and TYPDEFOVR are supplied, they apply to the objects,      * sent with the statement.  Once the statement is over, the default values,      * sent in the ACCRDB are once again in effect.  If no values are supplied,,      * the values sent in the ACCRDB are used.,      * Objects may follow in one DSS or in several DSS chained together.,      * ,      * @return SQL statement,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private String parsePRPSQLSTTobjects(DRDAStatement stmt) ,         throws DRDAProtocolException, SQLException,     {,         String sqlStmt = null;,         int codePoint;,         do,         {,             correlationID = reader.readDssHeader();,             while (reader.moreDssData()),             {,                 codePoint = reader.readLengthAndCodePoint( false );,                 switch(codePoint),                 {,                     // required,                     case CodePoint.SQLSTT:,                         sqlStmt = parseEncodedString();,                         if (SanityManager.DEBUG) {,                             trace("sqlStmt = " + sqlStmt);,                         },                         break;,                     // optional,                     case CodePoint.TYPDEFNAM:,                         setStmtOrDbByteOrder(false, stmt, parseTYPDEFNAM());,                         break;,                     // optional,                     case CodePoint.TYPDEFOVR:,                         parseTYPDEFOVR(stmt);,                         break;,                     // optional,                     case CodePoint.SQLATTR:,                         parseSQLATTR(stmt);,                         break;,                     default:,                         invalidCodePoint(codePoint);,                 },             },         } while (reader.isChainedWithSameID());,         if (sqlStmt == null) {,             missingCodePoint(CodePoint.SQLSTT);,         }, ,         return sqlStmt;,     }, ,     /**,      * Parse TYPSQLDA - Type of the SQL Descriptor Area,      *,      * @return true if for output; false otherwise,      * @exception DRDAProtocolException,      */,     private boolean parseTYPSQLDA() throws DRDAProtocolException,     {,         checkLength(CodePoint.TYPSQLDA, 1);,         byte sqldaType = reader.readByte();,         if (SanityManager.DEBUG) {,             trace("typSQLDa " + sqldaType);,         },         if (sqldaType == CodePoint.TYPSQLDA_STD_OUTPUT ||,                 sqldaType == CodePoint.TYPSQLDA_LIGHT_OUTPUT ||,                 sqldaType == CodePoint.TYPSQLDA_X_OUTPUT),         {,             return true;,         },         else if (sqldaType == CodePoint.TYPSQLDA_STD_INPUT ||,                      sqldaType == CodePoint.TYPSQLDA_LIGHT_INPUT ||,                      sqldaType == CodePoint.TYPSQLDA_X_INPUT),         {,                 return false;,         },         else,         {,             invalidValue(CodePoint.TYPSQLDA);,         }, ,         // shouldn't get here but have to shut up compiler,         return false;,     },     /**,      * Parse SQLATTR - Cursor attributes on prepare,      *   This is an encoded string. Can have combination of following, eg INSENSITIVE SCROLL WITH HOLD,      * Possible strings are,      *  SENSITIVE DYNAMIC SCROLL [FOR UPDATE],      *  SENSITIVE STATIC SCROLL [FOR UPDATE],      *  INSENSITIVE SCROLL,      *  FOR UPDATE,      *  WITH HOLD,      *,      * @param stmt DRDAStatement,      * @exception DRDAProtocolException,      */,     protected void parseSQLATTR(DRDAStatement stmt) throws DRDAProtocolException,     {,         String attrs = parseEncodedString();,         if (SanityManager.DEBUG) {,             trace("sqlattr = '" + attrs+"'");,         },         //let Derby handle any errors in the types it doesn't support,         //just set the attributes, ,         boolean validAttribute = false;,         if (attrs.indexOf("INSENSITIVE SCROLL") != -1 || attrs.indexOf("SCROLL INSENSITIVE") != -1) //CLI,         {,             stmt.scrollType = ResultSet.TYPE_SCROLL_INSENSITIVE;,             stmt.concurType = ResultSet.CONCUR_READ_ONLY;,             validAttribute = true;,         },         if ((attrs.indexOf("SENSITIVE DYNAMIC SCROLL") != -1) || (attrs.indexOf("SENSITIVE STATIC SCROLL") != -1)),         {,             stmt.scrollType = ResultSet.TYPE_SCROLL_SENSITIVE;,             validAttribute = true;,         }, ,         if ((attrs.indexOf("FOR UPDATE") != -1)),         {,             validAttribute = true;,             stmt.concurType = ResultSet.CONCUR_UPDATABLE;,         }, ,         if (attrs.indexOf("WITH HOLD") != -1),         {,             stmt.withHoldCursor = ResultSet.HOLD_CURSORS_OVER_COMMIT;,             validAttribute = true;,         }, ,         if (!validAttribute),         {,             invalidValue(CodePoint.SQLATTR);,         },     }, ,     /**,      * Parse DSCSQLSTT - Describe SQL Statement previously prepared,      * Instance Variables,      *  TYPSQLDA - sqlda type expected (output or input),      *  RDBNAM - relational database name - optional,      *  PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required,      *  MONITOR - Monitor events - optional.,      *,      * @return expect "output sqlda" or not,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private boolean parseDSCSQLSTT() throws DRDAProtocolException,SQLException,     {,         int codePoint;,         boolean rtnOutput = true;   // default,         Pkgnamcsn pkgnamcsn = null;,         reader.markCollection();, ,         codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch (codePoint),             {,                 // optional,                 case CodePoint.TYPSQLDA:,                     rtnOutput = parseTYPSQLDA();,                     break;,                 // optional,                 case CodePoint.RDBNAM:,                     setDatabase(CodePoint.DSCSQLSTT);,                     break;,                 // required,                 case CodePoint.PKGNAMCSN:,                     pkgnamcsn = parsePKGNAMCSN();,                     DRDAStatement stmt = database.getDRDAStatement(pkgnamcsn);     ,                     if (stmt == null),                     {,                         invalidValue(CodePoint.PKGNAMCSN);,                     },                     break;,                 //optional,                 case CodePoint.MONITOR:,                     parseMONITOR();,                     break;,                 default:,                     invalidCodePoint(codePoint);,             },             codePoint = reader.getCodePoint();,         },         if (pkgnamcsn == null) {,             missingCodePoint(CodePoint.PKGNAMCSN);,         },         return rtnOutput;,     }, ,     /**,      * Parse EXCSQLSTT - Execute non-cursor SQL Statement previously prepared,      * Instance Variables,      *  RDBNAM - relational database name - optional,      *  PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required,      *  OUTEXP - Output expected,      *  NBRROW - Number of rows to be inserted if it's an insert,      *  PRCNAM - procedure name if specified by host variable, not needed for Derby,      *  QRYBLKSZ - query block size,      *  MAXRSLCNT - max resultset count,      *  MAXBLKEXT - Max number of extra blocks,      *  RSLSETFLG - resultset flag,      *  RDBCMTOK - RDB Commit Allowed - optional,      *  OUTOVROPT - output override option,      *  QRYROWSET - Query Rowset Size - Level 7,      *  MONITOR - Monitor events - optional.,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void parseEXCSQLSTT() throws DRDAProtocolException,SQLException,     {,         int codePoint;,         String strVal;,         reader.markCollection();, ,         codePoint = reader.getCodePoint();,         boolean outputExpected = false;,         Pkgnamcsn pkgnamcsn = null;,         int numRows = 1;    // default value,         int blkSize =  0;,         int maxrslcnt = 0;  // default value,         int maxblkext = CodePoint.MAXBLKEXT_DEFAULT;,         int qryrowset = CodePoint.QRYROWSET_DEFAULT;,         int outovropt = CodePoint.OUTOVRFRS;,         byte [] rslsetflg = null;,         String procName = null;, ,         while (codePoint != -1),         {,             switch (codePoint),             {,                 // optional,                 case CodePoint.RDBNAM:,                     setDatabase(CodePoint.EXCSQLSTT);,                     break;,                 // required,                 case CodePoint.PKGNAMCSN:,                     pkgnamcsn = parsePKGNAMCSN();,                     break;,                 // optional,                 case CodePoint.OUTEXP:,                     outputExpected = readBoolean(CodePoint.OUTEXP);,                     if (SanityManager.DEBUG) {,                         trace("outexp = "+ outputExpected);,                     },                     break;,                 // optional,                 case CodePoint.NBRROW:,                     checkLength(CodePoint.NBRROW, 4);,                     numRows = reader.readNetworkInt();,                     if (SanityManager.DEBUG) {,                         trace("# of rows: "+numRows);,                     },                     break;,                 // optional,                 case CodePoint.PRCNAM:,                     procName = reader.readString();,                     if (SanityManager.DEBUG) {,                         trace("Procedure Name = " + procName);,                     },                     break;,                 // optional,                 case CodePoint.QRYBLKSZ:,                     blkSize = parseQRYBLKSZ();,                     break;,                 // optional,                 case CodePoint.MAXRSLCNT:,                     // this is the maximum result set count,                     // values are 0 - requester is not capabable of receiving result,                     // sets as reply data in the response to EXCSQLSTT,                     // -1 - requester is able to receive all result sets,                     checkLength(CodePoint.MAXRSLCNT, 2);,                     maxrslcnt = reader.readNetworkShort();,                     if (SanityManager.DEBUG) {,                         trace("max rs count: "+maxrslcnt);,                     },                     break;,                 // optional,                 case CodePoint.MAXBLKEXT:,                     // number of extra qury blocks of answer set data per result set,                     // 0 - no extra query blocks,                     // -1 - can receive entire result set,                     checkLength(CodePoint.MAXBLKEXT, 2);,                     maxblkext = reader.readNetworkShort();,                     if (SanityManager.DEBUG) {,                         trace("max extra blocks: "+maxblkext);,                     },                     break;,                 // optional,                 case CodePoint.RSLSETFLG:,                     //Result set flags,                     rslsetflg = reader.readBytes();,                     if (SanityManager.DEBUG) {,                         for (byte b : rslsetflg) {,                             trace("rslsetflg: " + b);,                         },                     },                     break;,                 // optional,                 case CodePoint.RDBCMTOK:,                     parseRDBCMTOK();,                     break;,                 // optional,                 case CodePoint.OUTOVROPT:,                     outovropt = parseOUTOVROPT();,                     break;,                 // optional,                 case CodePoint.QRYROWSET:,                     //Note minimum for OPNQRY is 0, we'll assume it is the same,                     //for EXCSQLSTT though the standard doesn't say,                     qryrowset = parseQRYROWSET(0);,                     break;,                 //optional,                 case CodePoint.MONITOR:,                     parseMONITOR();,                     break;,                 default:,                     invalidCodePoint(codePoint);,             },             codePoint = reader.getCodePoint();,         }, ,         if (pkgnamcsn == null) {,             missingCodePoint(CodePoint.PKGNAMCSN);,         }, ,         DRDAStatement stmt;,         boolean needPrepareCall = false;, ,         stmt  = database.getDRDAStatement(pkgnamcsn);,         boolean isProcedure = (procName !=null || ,                                (stmt != null && ,                                 stmt.wasExplicitlyPrepared() &&,                                 stmt.isCall));, ,         if (isProcedure)        // stored procedure call,         {,             if ( stmt == null  || !(stmt.wasExplicitlyPrepared())),             {,                 stmt  = database.newDRDAStatement(pkgnamcsn);,                 stmt.setQryprctyp(CodePoint.QRYBLKCTL_DEFAULT);,                 needPrepareCall = true;,             },                 ,             stmt.procName = procName;,             stmt.outputExpected = outputExpected;,         },         else,         {,             // we can't find the statement,             if (stmt == null),             {,                 invalidValue(CodePoint.PKGNAMCSN);,             },             stmt.setQryprctyp(CodePoint.QRYBLKCTL_DEFAULT);,         }, ,         stmt.nbrrow = numRows;,         stmt.qryrowset = qryrowset;,         stmt.blksize = blkSize;,         stmt.maxblkext = maxblkext;,         stmt.maxrslcnt = maxrslcnt;,         stmt.outovropt = outovropt;,         stmt.rslsetflg = rslsetflg;,         if (pendingStatementTimeout >= 0) {,             stmt.getPreparedStatement().setQueryTimeout(pendingStatementTimeout);,             pendingStatementTimeout = -1;,         },  ,     ,         // set the statement as the current statement,         database.setCurrentStatement(stmt);,         ,         boolean hasResultSet;,         if (reader.isChainedWithSameID()) ,         {,             hasResultSet = parseEXCSQLSTTobjects(stmt);,         } else ,         {,             if (isProcedure  && (needPrepareCall)),             {,                 // if we had parameters the callable statement would,                 // be prepared with parseEXCQLSTTobjects, otherwise we,                 // have to do it here,                 String prepareString = "call " + stmt.procName +"()";,                 if (SanityManager.DEBUG) {,                     trace ("$$$prepareCall is: "+prepareString);,                 },                 database.getConnection().clearWarnings();,                 CallableStatement cs = (CallableStatement) stmt.prepare(prepareString);,             },             stmt.ps.clearWarnings();,             hasResultSet = stmt.execute();,         },         ,         ,         ResultSet rs = null;,         if (hasResultSet),         {,             rs = stmt.getResultSet();,         },         // temp until ps.execute() return value fixed,         hasResultSet = (rs != null);,         int numResults = 0;,         if (hasResultSet),         {,             numResults = stmt.getNumResultSets();,             writeRSLSETRM(stmt);,         }, ,         // First of all, we send if there really are output params. Otherwise,         // CLI (.Net driver) fails. DRDA spec (page 151,152) says send SQLDTARD,         // if server has output param data to send.,         boolean sendSQLDTARD = stmt.hasOutputParams() && outputExpected;,         if (isProcedure),         {,             if (sendSQLDTARD) {,                 writer.createDssObject();,                 writer.startDdm(CodePoint.SQLDTARD);,                 writer.startDdm(CodePoint.FDODSC);,                 writeQRYDSC(stmt, true);,                 writer.endDdm();,                 writer.startDdm(CodePoint.FDODTA);,                 writeFDODTA(stmt);,                 writer.endDdm();,                 writer.endDdmAndDss();, ,                 if (stmt.getExtDtaObjects() != null),                 {,                     // writeScalarStream() ends the dss,                     writeEXTDTA(stmt);,                 },             },             else if (hasResultSet) {,             // DRDA spec says that we MUST return either an,             // SQLDTARD or an SQLCARD--the former when we have,             // output parameters, the latter when we don't.,             // If we have a result set, then we have to write,             // the SQLCARD _now_, since it is expected before,             // we send the result set info below; if we don't,             // have a result set and we don't send SQLDTARD,,             // then we can wait until we reach the call to,             // checkWarning() below, which will write an,             // SQLCARD for us.,                 writeNullSQLCARDobject();,             },         }, ,         //We need to marke that params are finished so that we know we ,         // are ready to send resultset info.,         stmt.finishParams();,             ,         EnginePreparedStatement ps = stmt.getPreparedStatement();,         int rsNum = 0;,         do {,         if (hasResultSet),         {,             stmt.setCurrentDrdaResultSet(rsNum);,             //indicate that we are going to return data,             stmt.setQryrtndta(true);,             if (!isProcedure) {,                 checkWarning(null, ps, null, -1, true, true);,             },             if (rsNum == 0) {,                 writeSQLRSLRD(stmt);,             },             writeOPNQRYRM(true, stmt);,             writeSQLCINRD(stmt);,             writeQRYDSC(stmt, false);,             stmt.rsSuspend();, ,             /* Currently, if LMTBLKPRC is used, a pre-condition is that no lob columns.,              * But in the future, when we do support LOB in LMTBLKPRC, the drda spec still,              * does not allow LOB to be sent with OPNQRYRM.  So this "if" here will have,              * to add "no lob columns".,              */,             if (stmt.getQryprctyp() == CodePoint.LMTBLKPRC) {,                 writeQRYDTA(stmt);,             },         },         else  if (! sendSQLDTARD),         {,             long updateCount = ps.getLargeUpdateCount();, ,             // The protocol wants us to send RDBUPDRM here, but we don't do,             // that because it used to cause protocol errors. DERBY-5847 has,             // some discussion about this issue., ,             checkWarning(database.getConnection(), stmt.ps, null, updateCount, true, true);,         }, ,         } while(hasResultSet && (++rsNum < numResults));,     }, , ,     /**,      * Parse RDBCMTOK - tells the database whether to allow commits or rollbacks,      * to be executed as part of the command,      * Since we don't have a SQL commit or rollback command, we will just ignore,      * this for now,      *,      * @exception DRDAProtocolException,      */,     private void parseRDBCMTOK() throws DRDAProtocolException,     {,         boolean rdbcmtok = readBoolean(CodePoint.RDBCMTOK);,         if (SanityManager.DEBUG) {,             trace("rdbcmtok = " + rdbcmtok);,         },     }, ,     /**,      * Parse EXCSQLSTT command objects,      * Command Objects,      *  TYPDEFNAM - Data Type Definition Name - optional,      *  TYPDEFOVR - TYPDEF Overrides -optional,      *  SQLDTA - optional, variable data, specified if prpared statement has input parameters,      *  EXTDTA - optional, externalized FD:OCA data,      *  OUTOVR - output override descriptor, not allowed for stored procedure calls,      *,      * If TYPDEFNAM and TYPDEFOVR are supplied, they apply to the objects,      * sent with the statement.  Once the statement is over, the default values,      * sent in the ACCRDB are once again in effect.  If no values are supplied,,      * the values sent in the ACCRDB are used.,      * Objects may follow in one DSS or in several DSS chained together.,      * ,      * @param stmt  the DRDAStatement to execute,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private boolean parseEXCSQLSTTobjects(DRDAStatement stmt) throws DRDAProtocolException, SQLException,     {,         int codePoint;,         boolean gotSQLDTA = false, gotEXTDTA = false;,         boolean result = false;,         do,         {,             correlationID = reader.readDssHeader();,             while (reader.moreDssData()),             {,                 codePoint = reader.readLengthAndCodePoint( true );,                 switch(codePoint),                 {,                     // optional,                     case CodePoint.TYPDEFNAM:,                         setStmtOrDbByteOrder(false, stmt, parseTYPDEFNAM());,                         stmt.setTypDefValues();,                         break;,                     // optional,                     case CodePoint.TYPDEFOVR:,                         parseTYPDEFOVR(stmt);,                         stmt.setTypDefValues();,                         break;,                     // required,                     case CodePoint.SQLDTA:,                         parseSQLDTA(stmt);,                         gotSQLDTA = true;,                         break;,                     // optional,                     case CodePoint.EXTDTA:,                         readAndSetAllExtParams(stmt, true);,                         stmt.ps.clearWarnings();,                         result = stmt.execute();,                         gotEXTDTA = true;,                         break;,                     // optional,                     case CodePoint.OUTOVR:,                         parseOUTOVR(stmt);,                         break;,                     default:,                         invalidCodePoint(codePoint);,                 },             },         } while (reader.isChainedWithSameID());, ,         // SQLDTA is required,         if (!gotSQLDTA) {,             missingCodePoint(CodePoint.SQLDTA);,         },         ,         if (! gotEXTDTA) {,             stmt.ps.clearWarnings();,             result = stmt.execute();,         },         ,         return result;,     }, ,     /**,      * Write SQLCINRD - result set column information,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeSQLCINRD(DRDAStatement stmt) throws DRDAProtocolException,SQLException,     {,         ResultSet rs = stmt.getResultSet();, ,         writer.createDssObject();,         writer.startDdm(CodePoint.SQLCINRD);,         if (sqlamLevel >= MGRLVL_7) {,             writeSQLDHROW(rs.getHoldability());,         }, ,         ResultSetMetaData rsmeta = rs.getMetaData();,         int ncols = rsmeta.getColumnCount();,         writer.writeShort(ncols);   // num of columns,         if (sqlamLevel >= MGRLVL_7),         {,             for (int i = 0; i < ncols; i++) {,                 writeSQLDAGRP (rsmeta, null, i, true);,             },         },         else,         {,             for (int i = 0; i < ncols; i++),             {,                 writeVCMorVCS(rsmeta.getColumnName(i+1));,                 writeVCMorVCS(rsmeta.getColumnLabel(i+1));,                 writeVCMorVCS(null);,             },         },         writer.endDdmAndDss();,     }, ,     /**,      * Write SQLRSLRD - result set reply data,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeSQLRSLRD(DRDAStatement stmt) throws DRDAProtocolException,SQLException,     {,         int numResults = stmt.getNumResultSets();, ,         writer.createDssObject();,         writer.startDdm(CodePoint.SQLRSLRD);,         writer.writeShort(numResults); // num of result sets, ,         for (int i = 0; i < numResults; i ++),             {,                 writer.writeInt(i); // rsLocator,                 writeVCMorVCS(stmt.getResultSetCursorName(i));,                 writer.writeInt(1); // num of rows XXX resolve, it doesn't matter for now, ,             },         writer.endDdmAndDss();,     }, ,     /**,      * Write RSLSETRM,      * Instance variables,      *  SVRCOD - Severity code - Information only - required,      *  PKGSNLST - list of PKGNAMCSN -required,      *  SRVDGN - Server Diagnostic Information -optional,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeRSLSETRM(DRDAStatement stmt) throws DRDAProtocolException,SQLException,     {,         int numResults = stmt.getNumResultSets();,         writer.createDssReply();,         writer.startDdm(CodePoint.RSLSETRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, 0);,         writer.startDdm(CodePoint.PKGSNLST);,         ,         for (int i = 0; i < numResults; i++) {,             writePKGNAMCSN(stmt.getResultSetPkgcnstkn(i).getBytes());,         },         writer.endDdm();,         writer.endDdmAndDss();,     }, ,     ,     /**,      * Parse SQLDTA - SQL program variable data ,      * and handle exception.,      * @see #parseSQLDTA_work,      */, ,     private void parseSQLDTA(DRDAStatement stmt) throws DRDAProtocolException,SQLException,     {,         try {,             parseSQLDTA_work(stmt);,         } ,         catch (SQLException se),         {,             skipRemainder(true);,             throw se;,         },     },     ,     /**,      * Parse SQLDTA - SQL program variable data,      * Instance Variables,      *  FDODSC - FD:OCA data descriptor - required,      *  FDODTA - FD:OCA data - optional,      *    ,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void parseSQLDTA_work(DRDAStatement stmt) throws DRDAProtocolException,SQLException,     {,         String strVal;,         EnginePreparedStatement ps = stmt.getPreparedStatement();,         int codePoint;,         ParameterMetaData pmeta = null;, ,         // Clear params without releasing storage,         stmt.clearDrdaParams();, ,         int numVars = 0;,         boolean rtnParam = false;, ,         reader.markCollection();        ,         codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,                 switch (codePoint),                 {,                     // required,                     case CodePoint.FDODSC:,                         while (reader.getDdmLength() > 6) //we get parameter info til last 6 byte,                     {,                         int dtaGrpLen = reader.readUnsignedByte();,                         int numVarsInGrp = (dtaGrpLen - 3) / 3;,                         if (SanityManager.DEBUG) {,                             trace("num of vars in this group is: "+numVarsInGrp);,                         },                         reader.readByte();      // tripletType,                         reader.readByte();      // id,                         for (int j = 0; j < numVarsInGrp; j++),                         {,                             final byte t = reader.readByte();,                             if (SanityManager.DEBUG)  {,                                 trace("drdaType is: "+ "0x" +,                                       Integer.toHexString(t));,                             },                             int drdaLength = reader.readNetworkShort();,                             if (SanityManager.DEBUG) {,                                 trace("drdaLength is: "+drdaLength);,                             },                             stmt.addDrdaParam(t, drdaLength);,                         },                     },                     numVars = stmt.getDrdaParamCount();,                     if (SanityManager.DEBUG) {,                         trace("numVars = " + numVars);,                     },                     if (ps == null)     // it is a CallableStatement under construction,                     {,                         StringBuilder marks = new StringBuilder();  // construct parameter marks,                         marks.append("(?");,                         for (int i = 1; i < numVars; i++) {,                             marks.append(", ?");,                         },                         String prepareString = "call " + stmt.procName + marks.toString() + ")";,                         if (SanityManager.DEBUG) {,                             trace ("$$ prepareCall is: "+prepareString);,                         },                         CallableStatement cs = null;,                         try {,                             cs = (CallableStatement),                                 stmt.prepare(prepareString);            ,                             stmt.registerAllOutParams();,                         } catch (SQLException se) {,                             if (! stmt.outputExpected || ,                                 (!se.getSQLState().equals(,                                     SQLState.LANG_NO_METHOD_FOUND))) {,                                 throw se;,                             },                             if (SanityManager.DEBUG) {,                                 trace("****** second try with return parameter...");,                             },                             // Save first SQLException most likely suspect,                             if (numVars == 1) {,                                 prepareString = "? = call " + stmt.procName +"()";,                             } else {,                                 prepareString = "? = call " + stmt.procName +"("+marks.substring(3) + ")";,                             },                             if (SanityManager.DEBUG) {,                                 trace ("$$ prepareCall is: "+prepareString);,                             },                             try {,                                 cs = (CallableStatement) stmt.prepare(prepareString);,                             } catch (SQLException se2),                             {,                                 // The first exception is the most likely suspect,                                 throw se;,                             },                             rtnParam = true;,                         },                         ps = (EnginePreparedStatement) cs;,                         stmt.ps = ps;,                     }, ,                     pmeta = stmt.getParameterMetaData();, ,                     reader.readBytes(6);    // descriptor footer,                     break;,                 // optional,                 case CodePoint.FDODTA:,                     reader.readByte();  // row indicator,                     for (int i = 0; i < numVars; i++),                     {,                     ,                         if ((stmt.getParamDRDAType(i+1) & 0x1) == 0x1)  // nullable,                         {,                             int nullData = reader.readUnsignedByte();,                             if ((nullData & 0xFF) == FdocaConstants.NULL_DATA),                             {,                                 if (SanityManager.DEBUG) {,                                     trace("******param null");,                                 },                                 if (pmeta.getParameterMode(i + 1),                                     != ParameterMetaData.parameterModeOut) {,                                         ps.setNull(i+1, pmeta.getParameterType(i+1));,                                 },                                 if (stmt.isOutputParam(i+1)) {,                                     stmt.registerOutParam(i+1);,                                 },                                 continue;,                             },                         }, ,                         // not null, read and set it,                         readAndSetParams(i, stmt, pmeta);,                     },                     break;,                 case CodePoint.EXTDTA:,                     readAndSetAllExtParams(stmt, false);,                     break;,                 default:,                     invalidCodePoint(codePoint);, ,             },                 codePoint = reader.getCodePoint();,         }, , ,     }, ,     private int getByteOrder(),     {,         DRDAStatement stmt = database.getCurrentStatement();,         return ((stmt != null && stmt.typDefNam != null) ? stmt.byteOrder : database.byteOrder);,     }, ,     /** A cached {@code Calendar} instance using the GMT time zone. */,     private Calendar gmtCalendar;, ,     /**,      * Get a {@code Calendar} instance with time zone set to GMT. The instance,      * is cached for reuse by this thread. This calendar can be used to,      * consistently read and write date and time values using the same,      * calendar. Since the local default calendar may not be able to represent,      * all times (for instance because the time would fall into a non-existing,      * hour of the day when switching to daylight saving time, see DERBY-4582),,      * we use the GMT time zone which doesn't observe daylight saving time.,      *,      * @return a calendar in the GMT time zone,      */,     private Calendar getGMTCalendar() {,         if (gmtCalendar == null) {,             TimeZone gmt = TimeZone.getTimeZone("GMT");,             gmtCalendar = Calendar.getInstance(gmt);,         },         return gmtCalendar;,     }, ,     /**,      * Read different types of input parameters and set them in,      * PreparedStatement,      * @param i         index of the parameter,      * @param stmt      drda statement,      * @param pmeta     parameter meta data,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void readAndSetParams(int i,,                                   DRDAStatement stmt,,                                   ParameterMetaData pmeta),                 throws DRDAProtocolException, SQLException,     {,         PreparedStatement ps = stmt.getPreparedStatement();, ,         // mask out null indicator,         final int drdaType = ((stmt.getParamDRDAType(i+1) | 0x01) & 0xff);,         final int paramLenNumBytes = stmt.getParamLen(i+1);, ,         if (ps instanceof CallableStatement),         {,             if (stmt.isOutputParam(i+1)),             {,                 CallableStatement cs = (CallableStatement) ps;,                 cs.registerOutParameter(i+1, stmt.getOutputParamType(i+1));,             },         }, ,         switch (drdaType),         {,             case DRDAConstants.DRDA_TYPE_NBOOLEAN:,             {,                 boolean paramVal = (reader.readByte() == 1);,                 if (SanityManager.DEBUG) {,                     trace("boolean parameter value is: " + paramVal);,                 },                 ps.setBoolean(i+1, paramVal);,                 break;,             },             case DRDAConstants.DRDA_TYPE_NSMALL:,             {,                 short paramVal = (short) reader.readShort(getByteOrder());,                 if (SanityManager.DEBUG) {,                     trace("short parameter value is: "+paramVal);,                 },                 ps.setShort(i+1, paramVal);,                 break;,             },             case  DRDAConstants.DRDA_TYPE_NINTEGER:,             {,                 int paramVal = reader.readInt(getByteOrder());,                 if (SanityManager.DEBUG) {,                     trace("integer parameter value is: "+paramVal);,                 },                 ps.setInt(i+1, paramVal);,                 break;,             },             case DRDAConstants.DRDA_TYPE_NINTEGER8:,             {,                 long paramVal = reader.readLong(getByteOrder());,                 if (SanityManager.DEBUG) {,                     trace("parameter value is: "+paramVal);,                 },                 ps.setLong(i+1, paramVal);,                 break;,             },             case DRDAConstants.DRDA_TYPE_NFLOAT4:,             {,                 float paramVal = reader.readFloat(getByteOrder());,                 if (SanityManager.DEBUG) {,                     trace("parameter value is: "+paramVal);,                 },                 ps.setFloat(i+1, paramVal);,                 break;,             },             case DRDAConstants.DRDA_TYPE_NFLOAT8:,             {,                 double paramVal = reader.readDouble(getByteOrder());,                 if (SanityManager.DEBUG) {,                     trace("nfloat8 parameter value is: "+paramVal);,                 },                 ps.setDouble(i+1, paramVal);,                 break;,             },             case DRDAConstants.DRDA_TYPE_NDECIMAL:,             {,                 int precision = (paramLenNumBytes >> 8) & 0xff;,                 int scale = paramLenNumBytes & 0xff;,                 BigDecimal paramVal = reader.readBigDecimal(precision, scale);,                 if (SanityManager.DEBUG) {,                     trace("ndecimal parameter value is: "+paramVal);,                 },                 ps.setBigDecimal(i+1, paramVal);,                 break;,             },             case DRDAConstants.DRDA_TYPE_NDATE:,             {,                 String paramVal = reader.readStringData(10).trim();  //parameter may be char value,                 if (SanityManager.DEBUG) {,                     trace("ndate parameter value is: \""+paramVal+"\"");,                 },                 try {,                     Calendar cal = getGMTCalendar();,                     ps.setDate(i+1, parseDate(paramVal, cal), cal);,                 } catch (java.lang.IllegalArgumentException e) {,                     // Just use SQLSTATE as message since, if user wants to,                     // retrieve it, the message will be looked up by the,                     // sqlcamessage() proc, which will get the localized,                     // message based on SQLSTATE, and will ignore the,                     // the message we use here...,                     throw new SQLException(SQLState.LANG_DATE_SYNTAX_EXCEPTION,,                         SQLState.LANG_DATE_SYNTAX_EXCEPTION.substring(0,5));,                 },                 break;,             },             case DRDAConstants.DRDA_TYPE_NTIME:,             {,                 String paramVal = reader.readStringData(8).trim();  //parameter may be char value,                 if (SanityManager.DEBUG) {,                     trace("ntime parameter value is: "+paramVal);,                 },                 try {,                     Calendar cal = getGMTCalendar();,                     ps.setTime(i+1, parseTime(paramVal, cal), cal);,                 } catch (java.lang.IllegalArgumentException e) {,                     throw new SQLException(SQLState.LANG_DATE_SYNTAX_EXCEPTION,,                         SQLState.LANG_DATE_SYNTAX_EXCEPTION.substring(0,5));,                 },                 break;,             },             case DRDAConstants.DRDA_TYPE_NTIMESTAMP:,             {,                 // JCC represents ts in a slightly different format than Java standard, so,                 // we do the conversion to Java standard here.,                 int timestampLength = appRequester.getTimestampLength();,                 ,                 String paramVal = reader.readStringData( timestampLength ).trim();  //parameter may be char value,                 if (SanityManager.DEBUG) {,                     trace("ntimestamp parameter value is: "+paramVal);,                 },                 try {,                     Calendar cal = getGMTCalendar();,                     ps.setTimestamp(i+1, parseTimestamp(paramVal, cal), cal);,                 } catch (java.lang.IllegalArgumentException e1) {,                 // thrown by parseTimestamp(...) for bad syntax...,                     throw new SQLException(SQLState.LANG_DATE_SYNTAX_EXCEPTION,,                         SQLState.LANG_DATE_SYNTAX_EXCEPTION.substring(0,5));,                 },                 break;,             },             case DRDAConstants.DRDA_TYPE_NCHAR:,             case DRDAConstants.DRDA_TYPE_NVARCHAR:,             case DRDAConstants.DRDA_TYPE_NLONG:,             case DRDAConstants.DRDA_TYPE_NVARMIX:,             case DRDAConstants.DRDA_TYPE_NLONGMIX:,             {,                 String paramVal = reader.readLDStringData(stmt.ccsidMBCEncoding);,                 if (SanityManager.DEBUG) {,                     trace("char/varchar parameter value is: "+paramVal);,                 },                 ps.setString(i+1, paramVal);,                 break;,             },             case  DRDAConstants.DRDA_TYPE_NFIXBYTE:,             {,                 byte[] paramVal = reader.readBytes();,                 if (SanityManager.DEBUG) {,                     trace("fix bytes parameter value is: "+ convertToHexString(paramVal));,                 },                 ps.setBytes(i+1, paramVal);,                 break;,             },             case DRDAConstants.DRDA_TYPE_NVARBYTE:,             case DRDAConstants.DRDA_TYPE_NLONGVARBYTE:,             {,                 int length = reader.readNetworkShort(); //protocol control data always follows big endian,                 if (SanityManager.DEBUG) {,                     trace("===== binary param length is: " + length);,                 },                 byte[] paramVal = reader.readBytes(length);,                 ps.setBytes(i+1, paramVal);,                 break;,             },             case DRDAConstants.DRDA_TYPE_NUDT:,             {,                 Object paramVal = readUDT();,                 ps.setObject(i+1, paramVal);,                 break;,             },             case DRDAConstants.DRDA_TYPE_NLOBBYTES:,             case DRDAConstants.DRDA_TYPE_NLOBCMIXED:,             case DRDAConstants.DRDA_TYPE_NLOBCSBCS:,             case DRDAConstants.DRDA_TYPE_NLOBCDBCS:,              {,                  long length = readLobLength(paramLenNumBytes);,                  if (length != 0) //can be -1 for CLI if "data at exec" mode, see clifp/exec test,                  {,                     stmt.addExtPosition(i);,                  },                  else   /* empty */,                  {,                      if (drdaType == DRDAConstants.DRDA_TYPE_NLOBBYTES) {,                          ps.setBytes(i + 1, new byte[0]);,                      } else {,                          ps.setString(i + 1, "");,                      },                  },                  break;,              },                         case DRDAConstants.DRDA_TYPE_NLOBLOC:,                         {,                             //read the locator value,                             int paramVal = reader.readInt(getByteOrder());,                             ,                             if (SanityManager.DEBUG) {,                                 trace("locator value is: "+paramVal);,                             },                             ,                             //Map the locator value to the Blob object in the,                             //Hash map.,                             java.sql.Blob blobFromLocator = (java.sql.Blob),                             database.getConnection().getLOBMapping(paramVal);,                             ,                             //set the PreparedStatement parameter to the mapped,                             //Blob object.,                             ps.setBlob(i+1, blobFromLocator);,                             break;,                         },                         case DRDAConstants.DRDA_TYPE_NCLOBLOC:,                         {,                             //read the locator value.,                             int paramVal = reader.readInt(getByteOrder());,                             ,                             if (SanityManager.DEBUG) {,                                 trace("locator value is: "+paramVal);,                             },                             ,                             //Map the locator value to the Clob object in the,                             //Hash Map.,                             java.sql.Clob clobFromLocator = (java.sql.Clob),                             database.getConnection().getLOBMapping(paramVal);,                             ,                             //set the PreparedStatement parameter to the mapped,                             //Clob object.,                             ps.setClob(i+1, clobFromLocator);,                             break;,                         },             default:,                 {,                 String paramVal = reader.readLDStringData(stmt.ccsidMBCEncoding);,                 if (SanityManager.DEBUG) {,                     trace("default type parameter value is: "+paramVal);,                 },                 ps.setObject(i+1, paramVal);,             },         },     }, ,     /** Read a UDT from the stream */,     private Object readUDT() throws DRDAProtocolException,     {,         int length = reader.readNetworkShort(); //protocol control data always follows big endian,         if (SanityManager.DEBUG) { trace("===== udt param length is: " + length); },         byte[] bytes = reader.readBytes(length);,         ,         try {,             ByteArrayInputStream bais = new ByteArrayInputStream( bytes );,             ObjectInputStream ois = new ObjectInputStream( bais );, ,             return ois.readObject();,         },         catch (Exception e),         {,             markCommunicationsFailure,                 ( e,"DRDAConnThread.readUDT()", "", e.getMessage(), "*" );,             return null;,         },     }, , ,     private long readLobLength(int extLenIndicator) ,         throws DRDAProtocolException,     {,         switch (extLenIndicator),         {,             case 0x8002:,                 return (long) reader.readNetworkShort();,             case 0x8004:,                 return (long) reader.readNetworkInt();,             case 0x8006:,                 return (long) reader.readNetworkSixByteLong();,             case 0x8008:,                 return (long) reader.readNetworkLong();,             default:,                 throwSyntaxrm(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN, extLenIndicator);,                 return 0L;,         },         , , ,     }, ,     /**,      * Parse a date string as it is received from the client.,      *,      * @param dateString the date string to parse,      * @param cal the calendar in which the date is parsed,      * @return a Date object representing the date in the specified calendar,      * @see org.apache.derby.client.am.DateTime#dateToDateBytes,      * @throws IllegalArgumentException if the date is not correctly formatted,      */,     private java.sql.Date parseDate(String dateString, Calendar cal) {,         // Get each component out of YYYY-MM-DD,         String[] components = dateString.split("-");,         if (components.length != 3) {,             throw new IllegalArgumentException();,         }, ,         cal.clear();, ,         // Set date components,         cal.set(Calendar.YEAR, Integer.parseInt(components[0]));,         cal.set(Calendar.MONTH, Integer.parseInt(components[1]) - 1);,         cal.set(Calendar.DAY_OF_MONTH, Integer.parseInt(components[2]));, ,         // Normalize time components as specified by java.sql.Date,         cal.set(Calendar.HOUR_OF_DAY, 0);,         cal.set(Calendar.MINUTE, 0);,         cal.set(Calendar.SECOND, 0);,         cal.set(Calendar.MILLISECOND, 0);, ,         return new java.sql.Date(cal.getTimeInMillis());,     }, ,     /**,      * Parse a time string as it is received from the client.,      *,      * @param timeString the time string to parse,      * @param cal the calendar in which the time is parsed,      * @return a Date object representing the time in the specified calendar,      * @see org.apache.derby.client.am.DateTime#timeToTimeBytes,      * @throws IllegalArgumentException if the time is not correctly formatted,      */,     private Time parseTime(String timeString, Calendar cal) {,         // Get each component out of HH:MM:SS,         String[] components = timeString.split(":");,         if (components.length != 3) {,             throw new IllegalArgumentException();,         }, ,         cal.clear();, ,         // Normalize date components as specified by java.sql.Time,         cal.set(Calendar.YEAR, 1970);,         cal.set(Calendar.MONTH, Calendar.JANUARY);,         cal.set(Calendar.DAY_OF_MONTH, 1);, ,         // Set time components,         cal.set(Calendar.HOUR_OF_DAY, Integer.parseInt(components[0]));,         cal.set(Calendar.MINUTE, Integer.parseInt(components[1]));,         cal.set(Calendar.SECOND, Integer.parseInt(components[2]));, ,         // No millisecond resolution for Time,         cal.set(Calendar.MILLISECOND, 0);, ,         return new Time(cal.getTimeInMillis());,     }, ,     /**,      * Parse a timestamp string as it is received from the client.,      *,      * @param timeString the time string to parse,      * @param cal the calendar in which the timestamp is parsed,      * @return a Date object representing the timestamp in the specified,      * calendar,      * @see org.apache.derby.client.am.DateTime#timestampToTimestampBytes,      * @throws IllegalArgumentException if the timestamp is not correctly,      * formatted,      */,     private Timestamp parseTimestamp(String timeString, Calendar cal) {,         // Get each component out of YYYY-MM-DD-HH.MM.SS.fffffffff,         String[] components = timeString.split("[-.]");,         if (components.length != 7) {,             throw new IllegalArgumentException();,         }, ,         cal.clear();,         cal.set(Calendar.YEAR, Integer.parseInt(components[0]));,         cal.set(Calendar.MONTH, Integer.parseInt(components[1]) - 1);,         cal.set(Calendar.DAY_OF_MONTH, Integer.parseInt(components[2]));,         cal.set(Calendar.HOUR_OF_DAY, Integer.parseInt(components[3]));,         cal.set(Calendar.MINUTE, Integer.parseInt(components[4]));,         cal.set(Calendar.SECOND, Integer.parseInt(components[5]));, ,         int nanos = 0;, ,         final int radix = 10;,         String nanoString = components[6];, ,         // Get up to nine digits from the nano second component,         for (int i = 0; i < 9; i++) {,             // Scale up the intermediate result,             nanos *= radix;, ,             // Add the next digit, if there is one. Continue the loop even if,             // there are no more digits, since we still need to scale up the,             // intermediate result as if the fraction part were padded with,             // zeros.,             if (i < nanoString.length()) {,                 int digit = Character.digit(nanoString.charAt(i), radix);,                 if (digit == -1) {,                     // not a digit,                     throw new IllegalArgumentException();,                 },                 nanos += digit;,             },         }, ,         Timestamp ts = new Timestamp(cal.getTimeInMillis());,         ts.setNanos(nanos);,         return ts;,     }, ,     private void readAndSetAllExtParams(final DRDAStatement stmt, final boolean streamLOB) ,         throws SQLException, DRDAProtocolException,     {,         final int numExt = stmt.getExtPositionCount();,         for (int i = 0; i < numExt; i++),                     {,                         int paramPos = stmt.getExtPosition(i);,                         // Only the last EXTDTA is streamed.  This is because all of ,                         // the parameters have to be set before execution and are ,                         // consecutive in the network server stream, so only the last,                         // one can be streamed.,                         final boolean doStreamLOB = (streamLOB && i == numExt -1);,                         readAndSetExtParam(paramPos,,                                            stmt,,                                            stmt.getParamDRDAType(paramPos+1),,                                            stmt.getParamLen(paramPos+1),,                                            doStreamLOB);,                         // Each extdta in it's own dss,                         if (i < numExt -1),                         {,                             correlationID = reader.readDssHeader();,                             int codePoint = reader.readLengthAndCodePoint( true );,                         },                     }, ,     },     , ,     /**,      * Read different types of input parameters and set them in PreparedStatement,      * @param i zero-based index of the parameter,      * @param stmt          associated ps,      * @param drdaType  drda type of the parameter,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void readAndSetExtParam( int i, DRDAStatement stmt,,                                      int drdaType, int extLen, boolean streamLOB),                 throws DRDAProtocolException, SQLException,         {,             // Note the switch from zero-based to one-based index below.,             drdaType = (drdaType & 0x000000ff); // need unsigned value,             boolean checkNullability = false;,             if (sqlamLevel >= MGRLVL_7 && FdocaConstants.isNullable(drdaType)) {,                 checkNullability = true;,             }, ,             final EXTDTAReaderInputStream stream =,                 reader.getEXTDTAReaderInputStream(checkNullability);, ,             // Determine encoding first, mostly for debug/tracing purposes,             String encoding = "na";,             switch (drdaType) {,                 case DRDAConstants.DRDA_TYPE_LOBCSBCS:,                 case DRDAConstants.DRDA_TYPE_NLOBCSBCS:,                     encoding = stmt.ccsidSBCEncoding;,                     break;,                 case DRDAConstants.DRDA_TYPE_LOBCDBCS:,                 case DRDAConstants.DRDA_TYPE_NLOBCDBCS:,                     encoding = stmt.ccsidDBCEncoding;,                     break;,                 case DRDAConstants.DRDA_TYPE_LOBCMIXED:,                 case DRDAConstants.DRDA_TYPE_NLOBCMIXED:,                     encoding = stmt.ccsidMBCEncoding;,                     break;,             }, ,             traceEXTDTARead(drdaType, i+1, stream, streamLOB, encoding);, ,             try {,                 switch (drdaType),                 {,                     case  DRDAConstants.DRDA_TYPE_LOBBYTES:,                     case  DRDAConstants.DRDA_TYPE_NLOBBYTES:,                         setAsBinaryStream(stmt, i+1, stream, streamLOB);,                         break;,                     case DRDAConstants.DRDA_TYPE_LOBCSBCS:,                     case DRDAConstants.DRDA_TYPE_NLOBCSBCS:,                     case DRDAConstants.DRDA_TYPE_LOBCDBCS:,                     case DRDAConstants.DRDA_TYPE_NLOBCDBCS:,                     case DRDAConstants.DRDA_TYPE_LOBCMIXED:,                     case DRDAConstants.DRDA_TYPE_NLOBCMIXED:,                         setAsCharacterStream(stmt, i+1, stream, streamLOB,,                                 encoding);,                         break;,                     default:,                         invalidValue(drdaType);,                 },                  ,             },             catch (java.io.UnsupportedEncodingException e) {,                 throw new SQLException (e.getMessage());,                 ,             } catch( IOException e ){,                 throw new SQLException ( e.getMessage() );,                 ,             },         }, ,     /**,      * Parse EXCSQLIMM - Execute Immediate Statement,      * Instance Variables,      *  RDBNAM - relational database name - optional,      *  PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required,      *  RDBCMTOK - RDB Commit Allowed - optional,      *  MONITOR - Monitor Events - optional,      *,      * Command Objects,      *  TYPDEFNAM - Data Type Definition Name - optional,      *  TYPDEFOVR - TYPDEF Overrides -optional,      *  SQLSTT - SQL Statement -required,      *,      * @return update count,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private long parseEXCSQLIMM() throws DRDAProtocolException,SQLException,     {,         int codePoint;,         reader.markCollection();,         Pkgnamcsn pkgnamcsn = null;,         codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch (codePoint),             {,                 // optional,                 case CodePoint.RDBNAM:,                     setDatabase(CodePoint.EXCSQLIMM);,                     break;,                 // required,                 case CodePoint.PKGNAMCSN:,                     pkgnamcsn = parsePKGNAMCSN();,                     break;,                 case CodePoint.RDBCMTOK:,                     parseRDBCMTOK();,                     break;,                 //optional,                 case CodePoint.MONITOR:,                     parseMONITOR();,                     break;,                 default:,                     invalidCodePoint(codePoint);, ,             },             codePoint = reader.getCodePoint();,         },         DRDAStatement drdaStmt =  database.getDefaultStatement(pkgnamcsn);,         // initialize statement for reuse,         drdaStmt.initialize();,         String sqlStmt = parseEXECSQLIMMobjects();,         EngineStatement statement = drdaStmt.getStatement();,         statement.clearWarnings();,         if (pendingStatementTimeout >= 0) {,             statement.setQueryTimeout(pendingStatementTimeout);,             pendingStatementTimeout = -1;,         },         long updCount = statement.executeLargeUpdate(sqlStmt);,         return updCount;,     }, ,     /**,      * Parse EXCSQLSET - Execute Set SQL Environment,      * Instance Variables,      *  RDBNAM - relational database name - optional,      *  PKGNAMCT - RDB Package Name, Consistency Token  - optional,      *  MONITOR - Monitor Events - optional,      *,      * Command Objects,      *  TYPDEFNAM - Data Type Definition Name - required,      *  TYPDEFOVR - TYPDEF Overrides - required,      *  SQLSTT - SQL Statement - required (at least one; may be more),      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private boolean parseEXCSQLSET() throws DRDAProtocolException,SQLException,     {, ,         int codePoint;,         reader.markCollection();, , ,         codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch (codePoint),             {,                 // optional,                 case CodePoint.RDBNAM:,                     setDatabase(CodePoint.EXCSQLSET);,                     break;,                 // optional,                 case CodePoint.PKGNAMCT:,                     // we are going to ignore this for EXCSQLSET,                     // since we are just going to reuse an existing statement,                     String pkgnamct = parsePKGNAMCT();,                     break;,                 // optional,                 case CodePoint.MONITOR:,                     parseMONITOR();,                     break;,                 // required,                 case CodePoint.PKGNAMCSN:,                     // we are going to ignore this for EXCSQLSET.,                     // since we are just going to reuse an existing statement.,                     // NOTE: This codepoint is not in the DDM spec for 'EXCSQLSET',,                     // but since it DOES get sent by jcc1.2, we have to have,                     // a case for it...,                     Pkgnamcsn pkgnamcsn = parsePKGNAMCSN();,                     break;,                 default:,                     invalidCodePoint(codePoint);, ,             },             codePoint = reader.getCodePoint();,         }, ,         parseEXCSQLSETobjects();,         return true;,     }, ,     /**,      * Parse EXCSQLIMM objects,      * Objects,      *  TYPDEFNAM - Data type definition name - optional,      *  TYPDEFOVR - Type defintion overrides,      *  SQLSTT - SQL Statement required,      *,      * If TYPDEFNAM and TYPDEFOVR are supplied, they apply to the objects,      * sent with the statement.  Once the statement is over, the default values,      * sent in the ACCRDB are once again in effect.  If no values are supplied,,      * the values sent in the ACCRDB are used.,      * Objects may follow in one DSS or in several DSS chained together.,      * ,      * @return SQL Statement,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private String parseEXECSQLIMMobjects() throws DRDAProtocolException, SQLException,     {,         String sqlStmt = null;,         int codePoint;,         DRDAStatement stmt = database.getDefaultStatement();,         do,         {,             correlationID = reader.readDssHeader();,             while (reader.moreDssData()),             {,                 codePoint = reader.readLengthAndCodePoint( false );,                 switch(codePoint),                 {,                     // optional,                     case CodePoint.TYPDEFNAM:,                         setStmtOrDbByteOrder(false, stmt, parseTYPDEFNAM());,                         break;,                     // optional,                     case CodePoint.TYPDEFOVR:,                         parseTYPDEFOVR(stmt);,                         break;,                     // required,                     case CodePoint.SQLSTT:,                         sqlStmt = parseEncodedString();,                         if (SanityManager.DEBUG) {,                             trace("sqlStmt = " + sqlStmt);,                         },                         break;,                     default:,                         invalidCodePoint(codePoint);,                 },             },         } while (reader.isChainedWithSameID());, ,         // SQLSTT is required,         if (sqlStmt == null) {,             missingCodePoint(CodePoint.SQLSTT);,         },         return sqlStmt;,     }, ,     /**,      * Parse EXCSQLSET objects,      * Objects,      *  TYPDEFNAM - Data type definition name - optional,      *  TYPDEFOVR - Type defintion overrides - optional,      *  SQLSTT - SQL Statement - required (a list of at least one),      *,      * Objects may follow in one DSS or in several DSS chained together.,      * ,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void parseEXCSQLSETobjects(),         throws DRDAProtocolException, SQLException,     {, ,         boolean gotSqlStt = false;,         boolean hadUnrecognizedStmt = false;, ,         DRDAStatement drdaStmt = database.getDefaultStatement();,         drdaStmt.initialize();, ,         do,         {,             correlationID = reader.readDssHeader();,             while (reader.moreDssData()),             {, ,                 int codePoint = reader.readLengthAndCodePoint(false);, ,                 switch(codePoint),                 {,                     // optional,                     case CodePoint.TYPDEFNAM:,                         setStmtOrDbByteOrder(false, drdaStmt, parseTYPDEFNAM());,                         break;,                     // optional,                     case CodePoint.TYPDEFOVR:,                         parseTYPDEFOVR(drdaStmt);,                         break;,                     // required,                     case CodePoint.SQLSTT:,                         String sqlStmt = parseEncodedString();,                         if (sqlStmt != null) {,                         // then we have at least one SQL Statement.,                             gotSqlStt = true;,                         }, ,                         if (sqlStmt.startsWith(TIMEOUT_STATEMENT)) {,                             String timeoutString = sqlStmt.substring(TIMEOUT_STATEMENT.length());,                             pendingStatementTimeout = Integer.parseInt(timeoutString);,                             break;,                         }, ,                         if (canIgnoreStmt(sqlStmt)) {,                         // We _know_ Derby doesn't recognize this,                         // statement; don't bother trying to execute it.,                         // NOTE: at time of writing, this only applies,                         // to "SET CLIENT" commands, and it was decided,                         // that throwing a Warning for these commands,                         // would confuse people, so even though the DDM,                         // spec says to do so, we choose not to (but,                         // only for SET CLIENT cases).  If this changes,                         // at some point in the future, simply remove,                         // the follwing line; we will then throw a,                         // warning., //                          hadUnrecognizedStmt = true;,                             break;,                         }, ,                         if (SanityManager.DEBUG) {,                             trace("sqlStmt = " + sqlStmt);,                         }, ,                         // initialize statement for reuse,                         drdaStmt.initialize();,                         drdaStmt.getStatement().clearWarnings();,                         try {,                             drdaStmt.getStatement().executeUpdate(sqlStmt);,                         } catch (SQLException e) {, ,                             // if this is a syntax error, then we take it,                             // to mean that the given SET statement is not,                             // recognized; take note (so we can throw a,                             // warning later), but don't interfere otherwise.,                             if (e.getSQLState().equals(SYNTAX_ERR)) {,                                 hadUnrecognizedStmt = true;,                             } else {,                                 // something else; assume it's serious.,                                 throw e;,                             },                         },                         break;,                     default:,                         invalidCodePoint(codePoint);,                 },             }, ,         } while (reader.isChainedWithSameID());, ,         // SQLSTT is required.,         if (!gotSqlStt) {,             missingCodePoint(CodePoint.SQLSTT);,         }, ,         // Now that we've processed all SET statements (assuming no,         // severe exceptions), check for warnings and, if we had any,,         // note this in the SQLCARD reply object (but DON'T cause the,         // EXCSQLSET statement to fail).,         if (hadUnrecognizedStmt) {,             SQLWarning warn = new SQLWarning("One or more SET statements " +,                 "not recognized.", "01000");,             throw warn;,         } // end if.,     }, ,     private boolean canIgnoreStmt(String stmt),     {,         return (stmt.indexOf("SET CLIENT") != -1);,     }, ,     /**,      * Write RDBUPDRM,      * Instance variables,      *  SVRCOD - Severity code - Information only - required,      *  RDBNAM - Relational database name -required,      *  SRVDGN - Server Diagnostic Information -optional,      *,      * @exception DRDAProtocolException,      */,     private void writeRDBUPDRM() throws DRDAProtocolException,     {,         database.RDBUPDRM_sent = true;,         writer.createDssReply();,         writer.startDdm(CodePoint.RDBUPDRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, CodePoint.SVRCOD_INFO);,         writeRDBNAM(database.getDatabaseName());,         writer.endDdmAndDss();,     }, , ,     private String parsePKGNAMCT() throws DRDAProtocolException,     {,         reader.skipBytes();,         return null;,     }, ,     /**,      * Parse PKGNAMCSN - RDB Package Name, Consistency Token, and Section Number,      * Instance Variables,      *   NAMESYMDR - database name - not validated,      *   RDBCOLID - RDB Collection Identifier,      *   PKGID - RDB Package Identifier,      *   PKGCNSTKN - RDB Package Consistency Token,      *   PKGSN - RDB Package Section Number,      *,      * @return <code>Pkgnamcsn</code> value,      * @throws DRDAProtocolException,      */,     private Pkgnamcsn parsePKGNAMCSN() throws DRDAProtocolException,     {,         if (reader.getDdmLength() == CodePoint.PKGNAMCSN_LEN),         {,             // This is a scalar object with the following fields,             reader.readString(rdbnam, CodePoint.RDBNAM_LEN, true);,             if (SanityManager.DEBUG) {,                 trace("rdbnam = " + rdbnam);,             },                         ,             // A check that the rdbnam field corresponds to a database,             // specified in a ACCRDB term.,             // The check is not performed if the client is DNC_CLIENT,             // with version before 10.3.0 because these clients,             // are broken and send incorrect database name,             // if multiple connections to different databases,             // are created,                         ,             // This check was added because of DERBY-1434  ,             // check the client version first,             if (appRequester.greaterThanOrEqualTo(10,3,0) ) {,                 // check the database name,                 if (!rdbnam.toString().equals(database.getDatabaseName())) {,                     rdbnamMismatch(CodePoint.PKGNAMCSN);,                 },             }, ,             reader.readString(rdbcolid, CodePoint.RDBCOLID_LEN, true);,             if (SanityManager.DEBUG)  {,                 trace("rdbcolid = " + rdbcolid);,             }, ,             reader.readString(pkgid, CodePoint.PKGID_LEN, true);,             if (SanityManager.DEBUG) {,                 trace("pkgid = " + pkgid);,             }, ,             // we need to use the same UCS2 encoding, as this can be,             // bounced back to jcc (or keep the byte array),             reader.readString(pkgcnstkn, CodePoint.PKGCNSTKN_LEN, false);,             if (SanityManager.DEBUG) {,                 trace("pkgcnstkn = " + pkgcnstkn);,             }, ,             pkgsn = reader.readNetworkShort();,             if (SanityManager.DEBUG) {,                 trace("pkgsn = " + pkgsn);,             },         },         else    // extended format,         {,             int length = reader.readNetworkShort();,             if (length < CodePoint.RDBNAM_LEN || length > CodePoint.RDBNAM_MAX_NAME) {,                 badObjectLength(CodePoint.RDBNAM);,             },             reader.readString(rdbnam, length, true);,             if (SanityManager.DEBUG) {,                 trace("rdbnam = " + rdbnam);,             }, ,             // A check that the rdbnam field corresponds to a database,             // specified in a ACCRDB term.,             // The check is not performed if the client is DNC_CLIENT,             // with version before 10.3.0 because these clients,             // are broken and send incorrect database name,             // if multiple connections to different databases,             // are created,                         ,             // This check was added because of DERBY-1434,                         ,             // check the client version first,             if ( appRequester.getClientType() != AppRequester.DNC_CLIENT,                  || appRequester.greaterThanOrEqualTo(10,3,0) ) {,                 // check the database name,                 if (!rdbnam.toString().equals(database.getDatabaseName())) {,                     rdbnamMismatch(CodePoint.PKGNAMCSN);,                 },             }, ,             //RDBCOLID can be variable length in this format,             length = reader.readNetworkShort();,             reader.readString(rdbcolid, length, true);,             if (SanityManager.DEBUG) {,                 trace("rdbcolid = " + rdbcolid);,             }, ,             length = reader.readNetworkShort();,             if (length != CodePoint.PKGID_LEN) {,                 badObjectLength(CodePoint.PKGID);,             },             reader.readString(pkgid, CodePoint.PKGID_LEN, true);,             if (SanityManager.DEBUG) {,                 trace("pkgid = " + pkgid);,             }, ,             reader.readString(pkgcnstkn, CodePoint.PKGCNSTKN_LEN, false);,             if (SanityManager.DEBUG) {,                 trace("pkgcnstkn = " + pkgcnstkn);,             }, ,             pkgsn = reader.readNetworkShort();,             if (SanityManager.DEBUG) {,                 trace("pkgsn = " + pkgsn);,             },         }, ,         // In most cases, the pkgnamcsn object is equal to the,         // previously returned object. To avoid allocation of a new,         // object in these cases, we first check to see if the old,         // object can be reused.,         if ((prevPkgnamcsn == null) ||,             rdbnam.wasModified() ||,             rdbcolid.wasModified() ||,             pkgid.wasModified() ||,             pkgcnstkn.wasModified() ||,             (prevPkgnamcsn.getPkgsn() != pkgsn)),         {,             // The byte array returned by pkgcnstkn.getBytes() might,             // be modified by DDMReader.readString() later, so we have,             // to create a copy of the array.,             byte[] token = new byte[pkgcnstkn.length()];,             System.arraycopy(pkgcnstkn.getBytes(), 0, token, 0, token.length);, ,             prevPkgnamcsn =,                 new Pkgnamcsn(rdbnam.toString(), rdbcolid.toString(),,                               pkgid.toString(), pkgsn,,                               new ConsistencyToken(token));,         }, ,         return prevPkgnamcsn;,     }, ,     /**,      * Parse SQLSTT Dss,      * @exception DRDAProtocolException,      */,     private String parseSQLSTTDss() throws DRDAProtocolException,     {,         correlationID = reader.readDssHeader();,         int codePoint = reader.readLengthAndCodePoint( false );,         String strVal = parseEncodedString();,         if (SanityManager.DEBUG) {,             trace("SQL Statement = " + strVal);,         },         return strVal;,     }, ,     /**,      * Parse an encoded data string from the Application Requester,      *,      * @return string value,      * @exception DRDAProtocolException,      */,     private String parseEncodedString() throws DRDAProtocolException,     {,         return (sqlamLevel < 7) ? parseVCMorVCS() : parseNOCMorNOCS();,     }, ,     /**,      * Parse variable character mixed byte or variable character single byte,      * Format,      *  I2 - VCM Length,      *  N bytes - VCM value,      *  I2 - VCS Length,      *  N bytes - VCS value ,      * Only 1 of VCM length or VCS length can be non-zero,      *,      * @return string value,      */,     private String parseVCMorVCS() throws DRDAProtocolException,     {,         String strVal = null;,         int vcm_length = reader.readNetworkShort();,         if (vcm_length > 0) {,             strVal = parseCcsidMBC(vcm_length);,         },         int vcs_length = reader.readNetworkShort();,         if (vcs_length > 0),         {,             if (strVal != null) {,                 agentError ("Both VCM and VCS have lengths > 0");,             },             strVal = parseCcsidSBC(vcs_length);,         },         return strVal;,     },     /**,      * Parse nullable character mixed byte or nullable character single byte,      * Format,      *  1 byte - null indicator,      *  I4 - mixed character length,      *  N bytes - mixed character string,      *  1 byte - null indicator,      *  I4 - single character length,      *  N bytes - single character length string,      *,      * @return string value,      * @exception DRDAProtocolException,      */,     private String parseNOCMorNOCS() throws DRDAProtocolException,     {,         byte nocm_nullByte = reader.readByte();,         String strVal = null;,         int length;,         if (nocm_nullByte != NULL_VALUE),         {,             length = reader.readNetworkInt();,             strVal = parseCcsidMBC(length);,         },         byte nocs_nullByte = reader.readByte();,         if (nocs_nullByte != NULL_VALUE),         {,             if (strVal != null) {,                 agentError("Both CM and CS are non null");,             },             length = reader.readNetworkInt();,             strVal = parseCcsidSBC(length);,         },         return strVal;,     },     /**,      * Parse mixed character string,      * ,      * @return string value,      * @exception DRDAProtocolException,      */,     private String parseCcsidMBC(int length) throws DRDAProtocolException,     {,         String strVal = null;,         DRDAStatement  currentStatement;, ,         currentStatement = database.getCurrentStatement();,         if (currentStatement == null),         {,             currentStatement = database.getDefaultStatement();,             currentStatement.initialize();,         },         String ccsidMBCEncoding = currentStatement.ccsidMBCEncoding;, ,         if (length == 0) {,             // Can't return null here as that will indicate that the cp is ,             // missing, when it in fact was present, but contained an empty string,             return ""; ,         },         byte [] byteStr = reader.readBytes(length);,         if (ccsidMBCEncoding != null),         {,             try {,                 strVal = new String(byteStr, 0, length, ccsidMBCEncoding);,             } catch (UnsupportedEncodingException e) {,                 agentError("Unsupported encoding " + ccsidMBCEncoding +,                     "in parseCcsidMBC");,             },         },         else,         {,             agentError("Attempt to decode mixed byte string without CCSID being set");,         },         return strVal;,     },     /**,      * Parse single byte character string,      * ,      * @return string value,      * @exception DRDAProtocolException,      */,     private String parseCcsidSBC(int length) throws DRDAProtocolException,     {,         String strVal = null;,         DRDAStatement  currentStatement;,         ,         currentStatement = database.getCurrentStatement();,         if (currentStatement == null),         {,             currentStatement = database.getDefaultStatement();,             currentStatement.initialize();,         },         String ccsidSBCEncoding = currentStatement.ccsidSBCEncoding;,         System.out.println("ccsidSBCEncoding - " + ccsidSBCEncoding);,         ,         if (length == 0) {,             return null;,         },         byte [] byteStr = reader.readBytes(length);,         if (ccsidSBCEncoding != null),         {,             try {,                 strVal = new String(byteStr, 0, length, ccsidSBCEncoding);,             } catch (UnsupportedEncodingException e) {,                 agentError("Unsupported encoding " + ccsidSBCEncoding +,                     "in parseCcsidSBC");,             },         },         else,         {,             agentError("Attempt to decode single byte string without CCSID being set");,         },         return strVal;,     },     /**,      * Parse CLSQRY,      * Instance Variables,      *  RDBNAM - relational database name - optional,      *  PKGNAMCSN - RDB Package Name, Consistency Token and Section Number - required,      *  QRYINSID - Query Instance Identifier - required - level 7,      *  MONITOR - Monitor events - optional.,      *,      * @return DRDAstatement being closed,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private DRDAStatement parseCLSQRY() throws DRDAProtocolException, SQLException,     {,         Pkgnamcsn pkgnamcsn = null;,         reader.markCollection();,         long qryinsid = 0;,         boolean gotQryinsid = false;, ,         int codePoint = reader.getCodePoint();,         while (codePoint != -1),         {,             switch (codePoint),             {,                 // optional,                 case CodePoint.RDBNAM:,                     setDatabase(CodePoint.CLSQRY);,                     break;,                     // required,                 case CodePoint.PKGNAMCSN:,                     pkgnamcsn = parsePKGNAMCSN();,                     break;,                 case CodePoint.QRYINSID:,                     qryinsid = reader.readNetworkLong();,                     gotQryinsid = true;,                     break;,                 // optional,                 case CodePoint.MONITOR:,                     parseMONITOR();,                     break;,                 default:,                     invalidCodePoint(codePoint);,             },             codePoint = reader.getCodePoint();,         },         // check for required variables,         if (pkgnamcsn == null) {,             missingCodePoint(CodePoint.PKGNAMCSN);,         },         if (sqlamLevel >= MGRLVL_7 && !gotQryinsid) {,             missingCodePoint(CodePoint.QRYINSID);,         }, ,         DRDAStatement stmt = database.getDRDAStatement(pkgnamcsn);,         if (stmt == null),         {,             //XXX should really throw a SQL Exception here,             invalidValue(CodePoint.PKGNAMCSN);,         }, ,         if (stmt.wasExplicitlyClosed()),         {,             // JCC still sends a CLSQRY even though we have,             // implicitly closed the resultSet.,             // Then complains if we send the writeQRYNOPRM,             // So for now don't send it,             // Also metadata calls seem to get bound to the same,             // PGKNAMCSN, so even for explicit closes we have,             // to ignore.,             //writeQRYNOPRM(CodePoint.SVRCOD_ERROR);,         }, ,         stmt.CLSQRY();,        ,         return stmt;,     }, ,     /**,      * Parse MONITOR,      * DRDA spec says this is optional.  Since we,      * don't currently support it, we just ignore.,      */,     private void parseMONITOR() ,         throws DRDAProtocolException,     {,         // Just ignore it.,         reader.skipBytes();,     }, ,     private void writeSQLCARDs(SQLException e, long updateCount),                                     throws DRDAProtocolException,     {,         writeSQLCARDs(e, updateCount, false);,     }, ,     private void writeSQLCARDs(SQLException e, long updateCount, boolean sendSQLERRRM),                                     throws DRDAProtocolException,     {, ,         if (e == null),         {,             writeSQLCARD(e, updateCount, 0);,             return;,         }, ,         // instead of writing a chain of sql error or warning, we send the first one, this is,         // jcc/db2 limitation, see beetle 4629, ,         // If it is a real SQL Error write a SQLERRRM first,         int severity = getExceptionSeverity(e);,         if (severity > CodePoint.SVRCOD_ERROR),         {,             // For a session ending error > CodePoint.SRVCOD_ERROR you cannot,             // send a SQLERRRM. A CMDCHKRM is required.  In XA if there is a,             // lock timeout it ends the whole session. I am not sure this ,             // is the correct behaviour but if it occurs we have to send ,             // a CMDCHKRM instead of SQLERRM,             writeCMDCHKRM(severity);,         },         else if (sendSQLERRRM),         {,             writeSQLERRRM(severity);,         },         writeSQLCARD(e, updateCount, 0);,     }, ,     /**,      * <p>,      * Get the SQLCODE to send for an exception or a warning.,      * </p>,      *,      * <p>,      * The client expects a negative SQLCODE for exceptions and a positive,      * SQLCODE for warnings. SQLCODE 0 means there is no error or warning,      * condition. SQLCODE is also used to encode the severity of the condition,      * (as returned by {@code SQLException.getErrorCode()}).,      * </p>,      *,      * <p>,      * For warnings, the SQLCODE is 10000, which is identical to,      * {@link ExceptionSeverity#WARNING_SEVERITY}.,      * </p>,      *,      * <p>,      * For exceptions, the SQLCODE is set to {@code -severity-1}, which allows,      * all non-negative severity values to be encoded. (Derby only uses,      * non-negative severity values in the first place.),      * </p>,      *,      * @param e the exception or warning to get the SQLCODE for,      * @return the value to send as SQLCODE,      */,     private int getSqlCode(SQLException e),     {,         if (e == null) {,             return 0;,         }, ,         // All SQLWarnings should have warning severity. However,,         // DataTruncation conditions for write operations (with SQL state,         // 22001) are thrown as exceptions, even though DataTruncation,         // technically is a sub-class of SQLWarning.,         if (e instanceof SQLWarning &&,                 !SQLState.LANG_STRING_TRUNCATION.equals(e.getSQLState())) {,             return ExceptionSeverity.WARNING_SEVERITY;,         }, ,         // The exception represents an error condition, so encode the severity,         // as a negative value in the SQLCODE. Negative severity values are,         // changed to 0 (NO_APPLICABLE_SEVERITY).,         int severity =,                 Math.max(ExceptionSeverity.NO_APPLICABLE_SEVERITY,,                          e.getErrorCode());,         return -severity - 1;,     }, ,     private void writeSQLCARD(SQLException e,,         long updateCount, long rowCount ) throws DRDAProtocolException,     {,         writer.createDssObject();,         writer.startDdm(CodePoint.SQLCARD);,         writeSQLCAGRP(e, updateCount, rowCount);,         writer.endDdmAndDss();, ,         // If we have a shutdown exception, restart the server.,         if (e != null) {,             String sqlState = e.getSQLState();,             if (sqlState.regionMatches(0,,               SQLState.CLOUDSCAPE_SYSTEM_SHUTDOWN, 0, 5)) {,             // then we're here because of a shutdown exception;,             // "clean up" by restarting the server.,                 try {,                     server.startNetworkServer();,                 } catch (Exception restart),                 // any error messages should have already been printed,,                 // so we ignore this exception here.,                 {},             },         }, ,     }, ,     /**,      * Write a null SQLCARD as an object,      *,      * @exception DRDAProtocolException,      */,     private void writeNullSQLCARDobject(),         throws DRDAProtocolException,     {,         writer.createDssObject();,         writer.startDdm(CodePoint.SQLCARD);,         writeSQLCAGRP(nullSQLState, 0, 0, 0);,         writer.endDdmAndDss();,     },     /**,      * Write SQLERRRM,      *,      * Instance Variables,      *  SVRCOD - Severity Code - required,      *,      * @param   severity    severity of error,      *,      * @exception DRDAProtocolException,      */,     private void writeSQLERRRM(int severity) throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.SQLERRRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, severity);,         writer.endDdmAndDss ();, ,     }, ,     /**,      * Write CMDCHKRM,      *,      * Instance Variables,      *  SVRCOD - Severity Code - required,      *,      * @param   severity    severity of error,      *,      * @exception DRDAProtocolException,      */,     private void writeCMDCHKRM(int severity) throws DRDAProtocolException,     {,         writer.createDssReply();,         writer.startDdm(CodePoint.CMDCHKRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, severity);,         writer.endDdmAndDss ();, ,     }, ,     /**,      * Translate from Derby exception severity to SVRCOD,      *,      * @param e SQLException,      */,     private int getExceptionSeverity (SQLException e),     {,         int severity= CodePoint.SVRCOD_INFO;, ,         if (e == null) {,             return severity;,         }, ,         int ec = e.getErrorCode();,         switch (ec),         {,             case ExceptionSeverity.STATEMENT_SEVERITY:,             case ExceptionSeverity.TRANSACTION_SEVERITY:,                 severity = CodePoint.SVRCOD_ERROR;,                 break;,             case ExceptionSeverity.WARNING_SEVERITY:,                 severity = CodePoint.SVRCOD_WARNING;,                 break;,             case ExceptionSeverity.SESSION_SEVERITY:,             case ExceptionSeverity.DATABASE_SEVERITY:,             case ExceptionSeverity.SYSTEM_SEVERITY:,                 severity = CodePoint.SVRCOD_SESDMG;,                 break;,             default:,                 String sqlState = e.getSQLState();,                 if (sqlState != null && sqlState.startsWith("01")) {,                     // warning,                     severity = CodePoint.SVRCOD_WARNING;,                 } else {,                     severity = CodePoint.SVRCOD_ERROR;,                 },         }, ,         return severity;, ,     },     /**,      * Write SQLCAGRP,      *,      * SQLCAGRP : FDOCA EARLY GROUP,      * SQL Communcations Area Group Description,      *,      * FORMAT FOR SQLAM <= 6,      *   SQLCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLSTATE; DRDA TYPE FCS; ENVLID 0x30; Length Override 5,      *   SQLERRPROC; DRDA TYPE FCS; ENVLID 0x30; Length Override 8,      *   SQLCAXGRP; DRDA TYPE N-GDA; ENVLID 0x52; Length Override 0,      *,      * FORMAT FOR SQLAM >= 7,      *   SQLCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLSTATE; DRDA TYPE FCS; ENVLID 0x30; Length Override 5,      *   SQLERRPROC; DRDA TYPE FCS; ENVLID 0x30; Length Override 8,      *   SQLCAXGRP; DRDA TYPE N-GDA; ENVLID 0x52; Length Override 0,      *   SQLDIAGGRP; DRDA TYPE N-GDA; ENVLID 0x56; Length Override 0,      *,      * @param e     SQLException encountered,      * ,      * @exception DRDAProtocolException,      */,     private void writeSQLCAGRP(SQLException e, long updateCount, long rowCount),         throws DRDAProtocolException,     {,         int sqlcode = getSqlCode(e);, ,         if (e == null) {,             // Forwarding to the optimized version when there is no,             // exception object,             writeSQLCAGRP(nullSQLState, sqlcode, updateCount, rowCount);,             return;,         }, ,         if (rowCount < 0 && updateCount < 0),         {,             writer.writeByte(CodePoint.NULLDATA);,             return;,         },             ,         if (SanityManager.DEBUG && server.debugOutput() && sqlcode < 0) {,             trace("handle SQLException here");,             trace("reason is: "+e.getMessage());,             trace("SQLState is: "+e.getSQLState());,             trace("vendorCode is: "+e.getErrorCode());,             trace("nextException is: "+e.getNextException());,             server.consoleExceptionPrint(e);,             trace("wrapping SQLException into SQLCARD...");,         },         ,         //null indicator,         writer.writeByte(0);, ,         // SQLCODE,         writer.writeInt(sqlcode);, ,         // SQLSTATE,         writer.writeString(e.getSQLState());, ,         // SQLERRPROC,         // Write the byte[] constant rather than the string, for efficiency,         writer.writeBytes( getProductIDBytes() );, ,         // SQLCAXGRP,         writeSQLCAXGRP(updateCount, rowCount, buildSqlerrmc(e), e.getNextException());,     }, ,     /**,      * Same as writeSQLCAGRP, but optimized for the case,          * when there is no real exception, i.e. the exception is null, or "End,          * of data",      *,      * SQLCAGRP : FDOCA EARLY GROUP,      * SQL Communcations Area Group Description,      *,      * FORMAT FOR SQLAM <= 6,      *   SQLCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLSTATE; DRDA TYPE FCS; ENVLID 0x30; Length Override 5,      *   SQLERRPROC; DRDA TYPE FCS; ENVLID 0x30; Length Override 8,      *   SQLCAXGRP; DRDA TYPE N-GDA; ENVLID 0x52; Length Override 0,      *,      * FORMAT FOR SQLAM >= 7,      *   SQLCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLSTATE; DRDA TYPE FCS; ENVLID 0x30; Length Override 5,      *   SQLERRPROC; DRDA TYPE FCS; ENVLID 0x30; Length Override 8,      *   SQLCAXGRP; DRDA TYPE N-GDA; ENVLID 0x52; Length Override 0,      *   SQLDIAGGRP; DRDA TYPE N-GDA; ENVLID 0x56; Length Override 0,      *,      * @param sqlState     SQLState (already converted to UTF8),      * @param sqlcode    sqlcode,          * @param updateCount,          * @param rowCount,      * ,      * @exception DRDAProtocolException,      */, ,     private void writeSQLCAGRP(byte[] sqlState, int sqlcode, ,                                long updateCount, long rowCount) throws DRDAProtocolException,     {,         if (rowCount < 0 && updateCount < 0) {,             writer.writeByte(CodePoint.NULLDATA);,             return;,         },         ,         //null indicator,         writer.writeByte(0);,         ,         // SQLCODE,         writer.writeInt(sqlcode);, ,         // SQLSTATE,         writer.writeBytes(sqlState);, ,         // SQLERRPROC,         writer.writeBytes( getProductIDBytes() );, ,         // SQLCAXGRP (Uses null as sqlerrmc since there is no error),         writeSQLCAXGRP(updateCount, rowCount, null, null);,     },     ,     ,     // Delimiters for SQLERRMC values.,     // The token delimiter value will be used to parse the MessageId from the ,     // SQLERRMC in MessageService.getLocalizedMessage and the MessageId will be,     // used to retrive the localized message. If this delimiter value is changed,     // please make sure to make appropriate changes in,     // MessageService.getLocalizedMessage that gets called from ,     // SystemProcedures.SQLCAMESSAGE,     /**,      * <code>SQLERRMC_TOKEN_DELIMITER</code> separates message argument tokens ,      */,     private static String SQLERRMC_TOKEN_DELIMITER = new String(new char[] {(char)20});, ,     /**,      * <code>SQLERRMC_PREFORMATTED_MESSAGE_DELIMITER</code>, When full message text is ,      * sent for severe errors. This value separates the messages. ,      */,     private static String SQLERRMC_PREFORMATTED_MESSAGE_DELIMITER = "::";,     ,     /**,      * Create error message or message argements to return to client.  ,      * The SQLERRMC will normally be passed back  to the server in a call ,      * to the SYSIBM.SQLCAMESSAGE but for severe exceptions the stored procedure ,      * call cannot be made. So for Severe messages we will just send the message text.,      * ,      * This method will also truncate the value according the client capacity.,      * CCC can only handle 70 characters.,      * ,      * Server sends the sqlerrmc using UTF8 encoding to the client.,      * To get the message, client sends back information to the server,      * calling SYSIBM.SQLCAMESSAGE (see Sqlca.getMessage).  Several parameters ,      * are sent to this procedure including the locale, the sqlerrmc that the ,      * client received from the server. ,      * On server side, the procedure SQLCAMESSAGE in SystemProcedures then calls,      * the MessageService.getLocalizedMessage to retrieve the localized error message. ,      * In MessageService.getLocalizedMessage the sqlerrmc that is passed in, ,      * is parsed to retrieve the message id. The value it uses to parse the MessageId,      * is char value of 20, otherwise it uses the entire sqlerrmc as the message id. ,      * This messageId is then used to retrieve the localized message if present, to ,      * the client.,      * ,      * @param se  SQLException to build SQLERRMC,      *  ,      * @return  String which is either the message arguments to be passed to ,      *          SYSIBM.SQLCAMESSAGE or just message text for severe errors.  ,      */,     private String buildSqlerrmc (SQLException se) ,     {,         boolean severe = (se.getErrorCode() >=  ExceptionSeverity.SESSION_SEVERITY);    ,         String sqlerrmc;, ,         // get exception which carries Derby messageID and args, per DERBY-1178,         StandardException ferry = StandardException.getArgumentFerry(se);, ,         if (se instanceof DataTruncation) {,             // Encode DataTruncation in a special way.,             sqlerrmc = buildDataTruncationSqlerrmc((DataTruncation) se);,         } else if (ferry != null && !severe) {,             // All other non-severe Derby exceptions are encoded here.,             sqlerrmc = buildTokenizedSqlerrmc(se);,         } else {,             // If this is not a Derby exception or is a severe excecption where,             // we have no hope of succussfully calling the SYSIBM.SQLCAMESSAGE send,             // preformatted message using the server locale,             sqlerrmc = buildPreformattedSqlerrmc(se);,         }, ,         // Truncate the sqlerrmc to a length that the client can support.,         int maxlen = (sqlerrmc == null) ? -1 : Math.min(sqlerrmc.length(),,                     appRequester.supportedMessageParamLength());,         if ((maxlen >= 0) && (sqlerrmc.length() > maxlen)) {,             // have to truncate so the client can handle it.,             sqlerrmc = sqlerrmc.substring(0, maxlen);,         }, ,         return sqlerrmc;,     }, ,     /**,      * Build preformatted SQLException text ,      * for severe exceptions or SQLExceptions that are not Derby exceptions.,      * Just send the message text localized to the server locale.,      * ,      * @param se  SQLException for which to build SQLERRMC,      * @return preformated message text ,      *          with messages separted by SQLERRMC_PREFORMATED_MESSAGE_DELIMITER,      * ,      */,     private String  buildPreformattedSqlerrmc(SQLException se) {,         if (se == null) {,             return "";,         },         ,          // String buffer to build up message,         StringBuilder sb = new StringBuilder();,         sb.append(se.getLocalizedMessage());,         while ((se = se.getNextException()) != null) {,             sb.append(SQLERRMC_PREFORMATTED_MESSAGE_DELIMITER);,             sb.append("SQLSTATE: ");,             sb.append(se.getSQLState());,         },         return sb.toString();,     }, ,     /**,      * Build Tokenized SQLERRMC to just send the tokenized arguments to the client.,      * for a Derby SQLException or an SQLException thrown by user code.,      * Message argument tokens are separated by SQLERRMC_TOKEN_DELIMITER ,      * Multiple messages are separated by SystemProcedures.SQLERRMC_MESSAGE_DELIMITER,      * ,      *                 ...,      * @param se   SQLException to print,      * ,      */,     private String buildTokenizedSqlerrmc(SQLException se) {,         ,         String sqlerrmc = "";,         do {,             StandardException ferry = StandardException.getArgumentFerry(se);,             if (ferry != null),             {,                 String messageId = ferry.getMessageId();,                 // arguments are variable part of a message,                 Object[] args = ferry.getArguments();,                 for (int i = 0; args != null &&  i < args.length; i++) {,                     sqlerrmc += args[i] + SQLERRMC_TOKEN_DELIMITER;,                 },                 sqlerrmc += messageId;,                 se = se.getNextException();,             },             else,             {   ,                 // this could happen for instance if an SQLException was thrown,                 // from a stored procedure.,                 StringBuilder sb = new StringBuilder();,                 sb.append(se.getLocalizedMessage());,                 se = se.getNextException();,                 if (se != null) {,                     sb.append(SQLERRMC_TOKEN_DELIMITER);,                     sb.append("SQLSTATE: ").append(se.getSQLState());,                 },                 sqlerrmc += sb.toString();,             },             if (se != null),             {,                 sqlerrmc += SystemProcedures.SQLERRMC_MESSAGE_DELIMITER + se.getSQLState() + ":";,             },         } while (se != null);,         return sqlerrmc;,     }, ,     /**,      * Build the SQLERRMC for a {@code java.sql.DataTruncation} warning.,      * Serialize all the fields of the {@code DataTruncation} instance in the,      * order in which they appear in the parameter list of the constructor.,      *,      * @param dt the {@code DataTruncation} instance to serialize,      * @return the SQLERRMC string with all fields of the warning,      */,     private String buildDataTruncationSqlerrmc(DataTruncation dt) {,         return dt.getIndex() + SQLERRMC_TOKEN_DELIMITER +,                dt.getParameter() + SQLERRMC_TOKEN_DELIMITER +,                dt.getRead() + SQLERRMC_TOKEN_DELIMITER +,                dt.getDataSize() + SQLERRMC_TOKEN_DELIMITER +,                dt.getTransferSize();,     },     ,     /**,      * Write SQLCAXGRP,      *,      * SQLCAXGRP : EARLY FDOCA GROUP,      * SQL Communications Area Exceptions Group Description,      *,      * FORMAT FOR SQLAM <= 6,      *   SQLRDBNME; DRDA TYPE FCS; ENVLID 0x30; Length Override 18,      *   SQLERRD1; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD2; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD3; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD4; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD5; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD6; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLWARN0; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN1; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN2; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN3; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN4; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN5; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN6; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN7; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN8; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN9; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARNA; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLERRMSG_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 70,      *   SQLERRMSG_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 70,      *,      * FORMAT FOR SQLAM >= 7,      *   SQLERRD1; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD2; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD3; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD4; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD5; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLERRD6; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLWARN0; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN1; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN2; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN3; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN4; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN5; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN6; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN7; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN8; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARN9; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLWARNA; DRDA TYPE FCS; ENVLID 0x30; Length Override 1,      *   SQLRDBNAME; DRDA TYPE VCS; ENVLID 0x32; Length Override 1024,      *   SQLERRMSG_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 70,      *   SQLERRMSG_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 70,      * @param nextException SQLException encountered,      * @param sqlerrmc sqlcode,      * ,      * @exception DRDAProtocolException,      */,     private void writeSQLCAXGRP(long updateCount,  long rowCount, String sqlerrmc,,                 SQLException nextException) throws DRDAProtocolException,     {,         writer.writeByte(0);        // SQLCAXGRP INDICATOR,         if (sqlamLevel < 7),         {,             writeRDBNAM(database.getDatabaseName());,             writeSQLCAERRWARN(updateCount, rowCount);,         },         else,         {,             // SQL ERRD1 - D6, WARN0-WARNA (35 bytes),             writeSQLCAERRWARN(updateCount, rowCount);,             writer.writeShort(0);  //CCC on Win does not take RDBNAME,         },         writeVCMorVCS(sqlerrmc);,         if (sqlamLevel >= 7) {,             writeSQLDIAGGRP(nextException);,         },     }, ,     /**,      * Write the ERR and WARN part of the SQLCA,      *,      * @param updateCount,      * @param rowCount ,      */,     private void writeSQLCAERRWARN(long updateCount, long rowCount) ,     {,         // SQL ERRD1 = Sqlca.HIGH_ORDER_ROW_COUNT,         writer.writeInt((int)((rowCount>>>32)));,         // SQL ERRD2 = Sqlca.LOW_ORDER_ROW_COUNT,         writer.writeInt((int)(rowCount & 0x0000000ffffffffL));,         // SQL ERRD3 = Sqlca.LOW_ORDER_UPDATE_COUNT,         writer.writeInt( (int)(updateCount & 0x0000000ffffffffL) );,         // SQL ERRD4 = Sqlca.HIGH_ORDER_UPDATE_COUNT,         writer.writeInt( (int)(updateCount>>>32) );,         // SQL ERRD5 - D6 (8 bytes),         writer.writeBytes(errD5_D6); // byte[] constant,         // WARN0-WARNA (11 bytes),         writer.writeBytes(warn0_warnA); // byte[] constant,     }, ,     /**,      * Write SQLDIAGGRP: SQL Diagnostics Group Description - Identity 0xD1,      * Nullable Group,      * SQLDIAGSTT; DRDA TYPE N-GDA; ENVLID 0xD3; Length Override 0,      * SQLDIAGCN;  DRFA TYPE N-RLO; ENVLID 0xF6; Length Override 0,      * SQLDIAGCI;  DRDA TYPE N-RLO; ENVLID 0xF5; Length Override 0,      */,     private void writeSQLDIAGGRP(SQLException nextException) ,         throws DRDAProtocolException,     {,         // for now we only want to send ROW_DELETED and ROW_UPDATED warnings,         // as extended diagnostics,         // move to first ROW_DELETED or ROW_UPDATED exception. These have been,         // added to the end of the warning chain.,         while (!(nextException == null ||,                  SQLState.ROW_UPDATED.equals(nextException.getSQLState()) ||,                  SQLState.ROW_DELETED.equals(nextException.getSQLState()))) {,             nextException = nextException.getNextException();,         }, ,         if ((nextException == null) || ,                 (diagnosticLevel == CodePoint.DIAGLVL0)) {,             writer.writeByte(CodePoint.NULLDATA);,             return;,         },         writer.writeByte(0); // SQLDIAGGRP indicator, ,         writeSQLDIAGSTT();,         writeSQLDIAGCI(nextException);,         writeSQLDIAGCN();,     }, ,     /*,      * writeSQLDIAGSTT: Write NULLDATA for now,      */,     private void writeSQLDIAGSTT(),         throws DRDAProtocolException,     {,         writer.writeByte(CodePoint.NULLDATA);,     }, ,     /**,      * writeSQLDIAGCI: SQL Diagnostics Condition Information Array - Identity 0xF5,      * SQLNUMROW; ROW LID 0x68; ELEMENT TAKEN 0(all); REP FACTOR 1,      * SQLDCIROW; ROW LID 0xE5; ELEMENT TAKEN 0(all); REP FACTOR 0(all),      */,     private void writeSQLDIAGCI(SQLException nextException),         throws DRDAProtocolException,     {,         SQLException se = nextException;,         long rowNum = 1;, ,         /* Write the number of next exceptions to expect */,         writeSQLNUMROW(se);, ,         while (se != null),         {,             String sqlState = se.getSQLState();, ,             // SQLCode > 0 -> Warning,             // SQLCode = 0 -> Info,             // SQLCode < 0 -> Error,             int severity = getExceptionSeverity(se);,             int sqlCode = -1;,             if (severity == CodePoint.SVRCOD_WARNING) {,                 sqlCode = 1;,             } else if (severity == CodePoint.SVRCOD_INFO) {,                 sqlCode = 0;,             }, ,             String sqlerrmc = "";,             if (diagnosticLevel == CodePoint.DIAGLVL1) {,                 sqlerrmc = se.getLocalizedMessage();,             }, ,             // arguments are variable part of a message,             // only send arguments for diagnostic level 0,             if (diagnosticLevel == CodePoint.DIAGLVL0) {,                 // we are only able to get arguments of Derby exceptions,                 StandardException ferry =,                         StandardException.getArgumentFerry(se);,                 if (ferry != null) {,                     Object[] args = ferry.getArguments();,                     for (int i = 0; args != null &&  i < args.length; i++) {,                         sqlerrmc += args[i].toString() + SQLERRMC_TOKEN_DELIMITER;,                     },                 },             }, ,             writeSQLDCROW(rowNum++, sqlCode, sqlState, getDbName(), sqlerrmc);, ,             se = se.getNextException();,         },     }, ,     /**,      * writeSQLNUMROW: Writes SQLNUMROW : FDOCA EARLY ROW,      * SQL Number of Elements Row Description,      * FORMAT FOR SQLAM LEVELS,      * SQLNUMGRP; GROUP LID 0x58; ELEMENT TAKEN 0(all); REP FACTOR 1,      */,     private void writeSQLNUMROW(SQLException nextException),          throws DRDAProtocolException,     {,         writeSQLNUMGRP(nextException);,     }, ,     /**,      * writeSQLNUMGRP: Writes SQLNUMGRP : FDOCA EARLY GROUP,      * SQL Number of Elements Group Description,      * FORMAT FOR ALL SQLAM LEVELS,      * SQLNUM; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      */,     private void writeSQLNUMGRP(SQLException nextException),          throws DRDAProtocolException,     {,         int i=0;,         SQLException se;, ,         /* Count the number of chained exceptions to be sent */,         for (se = nextException; se != null; se = se.getNextException()) {,             i++;,         },         writer.writeShort(i);,     }, ,     /**,      * writeSQLDCROW: SQL Diagnostics Condition Row - Identity 0xE5,      * SQLDCGRP; GROUP LID 0xD5; ELEMENT TAKEN 0(all); REP FACTOR 1,      */,     private void writeSQLDCROW(long rowNum, int sqlCode, String sqlState, String dbname,,          String sqlerrmc) throws DRDAProtocolException,     {,         writeSQLDCGRP(rowNum, sqlCode, sqlState, dbname, sqlerrmc);,     }, ,     /**,      * writeSQLDCGRP: SQL Diagnostics Condition Group Description,      * ,      * SQLDCCODE; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      * SQLDCSTATE; DRDA TYPE FCS; ENVLID Ox30; Lengeh Override 5,      * SQLDCREASON; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      * SQLDCLINEN; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      * SQLDCROWN; DRDA TYPE FD; ENVLID 0x0E; Lengeh Override 31,      * SQLDCER01; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      * SQLDCER02; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      * SQLDCER03; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      * SQLDCER04; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      * SQLDCPART; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      * SQLDCPPOP; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      * SQLDCMSGID; DRDA TYPE FCS; ENVLID 0x30; Length Override 10,      * SQLDCMDE; DRDA TYPE FCS; ENVLID 0x30; Length Override 8,      * SQLDCPMOD; DRDA TYPE FCS; ENVLID 0x30; Length Override 5,      * SQLDCRDB; DRDA TYPE VCS; ENVLID 0x32; Length Override 255,      * SQLDCTOKS; DRDA TYPE N-RLO; ENVLID 0xF7; Length Override 0,      * SQLDCMSG_m; DRDA TYPE NVMC; ENVLID 0x3F; Length Override 32672,      * SQLDCMSG_S; DRDA TYPE NVCS; ENVLID 0x33; Length Override 32672,      * SQLDCCOLN_m; DRDA TYPE NVCM ; ENVLID 0x3F; Length Override 255,      * SQLDCCOLN_s; DRDA TYPE NVCS; ENVLID 0x33; Length Override 255,      * SQLDCCURN_m; DRDA TYPE NVCM; ENVLID 0x3F; Length Override 255,      * SQLDCCURN_s; DRDA TYPE NVCS; ENVLID 0x33; Length Override 255,      * SQLDCPNAM_m; DRDA TYPE NVCM; ENVLID 0x3F; Length Override 255,      * SQLDCPNAM_s; DRDA TYPE NVCS; ENVLID 0x33; Length Override 255,      * SQLDCXGRP; DRDA TYPE N-GDA; ENVLID 0xD3; Length Override 1,      */,     private void writeSQLDCGRP(long rowNum, int sqlCode, String sqlState, String dbname,,          String sqlerrmc) throws DRDAProtocolException,     {,         // SQLDCCODE,         writer.writeInt(sqlCode);, ,         // SQLDCSTATE,         writer.writeString(sqlState);, , ,         writer.writeInt(0);                     // REASON_CODE,         writer.writeInt(0);                     // LINE_NUMBER,         writer.writeLong(rowNum);               // ROW_NUMBER, ,         byte[] byteArray = new byte[1];,         writer.writeScalarPaddedBytes(byteArray, 47, (byte) 0);, ,         writer.writeShort(0);                   // CCC on Win does not take RDBNAME,         writer.writeByte(CodePoint.NULLDATA);   // MESSAGE_TOKENS,         writer.writeLDString(sqlerrmc);         // MESSAGE_TEXT, ,         writeVCMorVCS(null);                    // COLUMN_NAME,         writeVCMorVCS(null);                    // PARAMETER_NAME,         writeVCMorVCS(null);                    // EXTENDED_NAME,         writer.writeByte(CodePoint.NULLDATA);   // SQLDCXGRP,     }, ,     /*,      * writeSQLDIAGCN: Write NULLDATA for now,      */,     private void writeSQLDIAGCN(),         throws DRDAProtocolException,     {,         writer.writeByte(CodePoint.NULLDATA);,     }, ,     /** ,      * Write SQLDARD,      *,      * SQLDARD : FDOCA EARLY ARRAY,      * SQL Descriptor Area Row Description with SQL Communications Area,      *,      * FORMAT FOR SQLAM <= 6,      *   SQLCARD; ROW LID 0x64; ELEMENT TAKEN 0(all); REP FACTOR 1,      *   SQLNUMROW; ROW LID 0x68; ELEMENT TAKEN 0(all); REP FACTOR 1,      *   SQLDAROW; ROW LID 0x60; ELEMENT TAKEN 0(all); REP FACTOR 0(all),      *,      * FORMAT FOR SQLAM >= 7,      *   SQLCARD; ROW LID 0x64; ELEMENT TAKEN 0(all); REP FACTOR 1,      *   SQLDHROW; ROW LID 0xE0; ELEMENT TAKEN 0(all); REP FACTOR 1,      *   SQLNUMROW; ROW LID 0x68; ELEMENT TAKEN 0(all); REP FACTOR 1,      *,      * @param stmt  prepared statement,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeSQLDARD(DRDAStatement stmt, boolean rtnOutput, SQLException e) throws DRDAProtocolException, SQLException,     {,         PreparedStatement ps = stmt.getPreparedStatement();,         ResultSetMetaData rsmeta = ps.getMetaData();,         ParameterMetaData pmeta = stmt.getParameterMetaData();,         int numElems = 0;,         if (e == null || e instanceof SQLWarning),         {,             if (rtnOutput && (rsmeta != null)) {,                 numElems = rsmeta.getColumnCount();,             } else if ((! rtnOutput) && (pmeta != null)) {,                 numElems = pmeta.getParameterCount();,             },         }, ,         writer.createDssObject();, ,         // all went well we will just write a null SQLCA,         writer.startDdm(CodePoint.SQLDARD);,         writeSQLCAGRP(e, 0, 0);, ,         if (sqlamLevel >= MGRLVL_7) {,             writeSQLDHROW(ps.getResultSetHoldability());,         }, ,         //SQLNUMROW,         if (SanityManager.DEBUG) {,             trace("num Elements = " + numElems);,         },         writer.writeShort(numElems);, ,         for (int i=0; i < numElems; i++) {,             writeSQLDAGRP (rsmeta, pmeta, i, rtnOutput);,         },         writer.endDdmAndDss();, ,     },     /**,      * Write QRYDSC - Query Answer Set Description,      *,      * @param stmt DRDAStatement we are working on,      * @param FDODSConly    simply the FDODSC, without the wrap,      *,      * Instance Variables,      *   SQLDTAGRP - required,      * ,      * Only 84 columns can be sent in a single QRYDSC.  If there are more columns,      * they must be sent in subsequent QRYDSC.,      * If the QRYDSC will not fit into the current block, as many columns as can,      * fit are sent and then the remaining are sent in the following blocks.,      * ,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeQRYDSC(DRDAStatement stmt, boolean FDODSConly),         throws DRDAProtocolException, SQLException,     {, ,         ResultSet rs = null;,         ResultSetMetaData rsmeta = null;,         ParameterMetaData pmeta = null;,         if (!stmt.needsToSendParamData) {,             rs = stmt.getResultSet();,         },         if (rs == null) {,             // this is a CallableStatement, use parameter meta data,             pmeta = stmt.getParameterMetaData();,         } else {,             rsmeta = rs.getMetaData();,         }, ,         int  numCols = (rsmeta != null ? rsmeta.getColumnCount() : pmeta.getParameterCount());,         int numGroups = 1;,         int colStart = 1;,         int colEnd = numCols;,         int blksize = stmt.getBlksize() > 0 ? stmt.getBlksize() : CodePoint.QRYBLKSZ_MAX;, ,         // check for remaining space in current query block,         // Need to mod with blksize so remaining doesn't go negative. 4868,         int remaining = blksize - (writer.getDSSLength()  % blksize) - (3 + ,                 FdocaConstants.SQLCADTA_SQLDTARD_RLO_SIZE);, , ,         // calcuate how may columns can be sent in the current query block,         int firstcols = remaining/FdocaConstants.SQLDTAGRP_COL_DSC_SIZE;, ,         // check if it doesn't all fit into the first block and ,         //  under FdocaConstants.MAX_VARS_IN_NGDA,         if (firstcols < numCols || numCols > FdocaConstants.MAX_VARS_IN_NGDA),         {,             // we are limited to FdocaConstants.MAX_VARS_IN_NGDA,             if (firstcols > FdocaConstants.MAX_VARS_IN_NGDA),             {,                 if (SanityManager.DEBUG) {,                     SanityManager.ASSERT(numCols > FdocaConstants.MAX_VARS_IN_NGDA,,                         "Number of columns " + numCols + ,                         " is less than MAX_VARS_IN_NGDA");,                 },                 numGroups = numCols/FdocaConstants.MAX_VARS_IN_NGDA;,                 // some left over,                 if (FdocaConstants.MAX_VARS_IN_NGDA * numGroups < numCols) {,                     numGroups++;,                 },                 colEnd = FdocaConstants.MAX_VARS_IN_NGDA;,             },             else,             {,                 colEnd = firstcols;,                 numGroups += (numCols-firstcols)/FdocaConstants.MAX_VARS_IN_NGDA;,                 if (FdocaConstants.MAX_VARS_IN_NGDA * numGroups < numCols) {,                     numGroups++;,                 },             },         }, ,         if (! FDODSConly),         {,             writer.createDssObject();,             writer.startDdm(CodePoint.QRYDSC);,         }, ,         for (int i = 0; i < numGroups; i++),         {,             writeSQLDTAGRP(stmt, rsmeta, pmeta, colStart, colEnd, ,                             (i == 0 ? true : false));,             colStart = colEnd + 1;,             // 4868 - Limit range to MAX_VARS_IN_NGDA (used to have extra col),             colEnd = Math.min(,                     colEnd + FdocaConstants.MAX_VARS_IN_NGDA,,                     numCols);,         },         writer.writeBytes(FdocaConstants.SQLCADTA_SQLDTARD_RLO);,         if (!FDODSConly) {,             writer.endDdmAndDss();,         },     },     /**,      * Write SQLDTAGRP,      * SQLDAGRP : Late FDOCA GROUP,      * SQL Data Value Group Descriptor,      *  LENGTH - length of the SQLDTAGRP,      *  TRIPLET_TYPE - NGDA for first, CPT for following,      *  ID - SQLDTAGRP_LID for first, NULL_LID for following,      *  For each column,      *    DRDA TYPE ,      *    LENGTH OVERRIDE,      *      For numeric/decimal types,      *        PRECISON,      *        SCALE,      *      otherwise,      *        LENGTH or DISPLAY_WIDTH,      *,      * @param stmt      drda statement,      * @param rsmeta    resultset meta data,      * @param pmeta     parameter meta data for CallableStatement,      * @param colStart  starting column for group to send,      * @param colEnd    end column to send,      * @param first     is this the first group,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeSQLDTAGRP(DRDAStatement stmt, ResultSetMetaData rsmeta, ,                                 ParameterMetaData pmeta,,                                 int colStart, int colEnd, boolean first),         throws DRDAProtocolException, SQLException,     {, ,         int length =  (FdocaConstants.SQLDTAGRP_COL_DSC_SIZE * ,                     ((colEnd+1) - colStart)) + 3;,         writer.writeByte(length);,         if (first),         {, ,             writer.writeByte(FdocaConstants.NGDA_TRIPLET_TYPE);,             writer.writeByte(FdocaConstants.SQLDTAGRP_LID);,         },         else,         {,             //continued,             writer.writeByte(FdocaConstants.CPT_TRIPLET_TYPE);,             writer.writeByte(FdocaConstants.NULL_LID);, ,         }, ,                            , ,         boolean hasRs = (rsmeta != null);   //  if don't have result, then we look at parameter meta, ,         for (int i = colStart; i <= colEnd; i++),         {,             boolean nullable = hasRs ?,                 (rsmeta.isNullable(i) == ResultSetMetaData.columnNullable) :,                 (pmeta.isNullable(i) == ParameterMetaData.parameterNullable);,             int colType = (hasRs ? rsmeta.getColumnType(i) : pmeta.getParameterType(i));,             int[] outlen = {-1};,             int drdaType = FdocaConstants.mapJdbcTypeToDrdaType( colType, nullable, appRequester, outlen );,                 , ,             boolean isDecimal = ((drdaType | 1) == DRDAConstants.DRDA_TYPE_NDECIMAL);,             int precision = 0, scale = 0;,             if (hasRs),             {,                 precision = rsmeta.getPrecision(i);,                 scale = rsmeta.getScale(i);,                 stmt.setRsDRDAType(i,drdaType);,                 stmt.setRsPrecision(i, precision);,                 stmt.setRsScale(i,scale);,             }, ,             else if (isDecimal),             {,                 if (stmt.isOutputParam(i)),                 {,                     precision = pmeta.getPrecision(i);,                     scale = pmeta.getScale(i);,                     ((CallableStatement) stmt.ps).registerOutParameter(i,Types.DECIMAL,scale);,                   ,                 }, ,             }, ,             if (SanityManager.DEBUG) {,                 trace("jdbcType=" + colType + "  \tdrdaType=" + Integer.toHexString(drdaType));,             }, ,             // Length or precision and scale for decimal values.,             writer.writeByte(drdaType);,             if (isDecimal),             {,                 writer.writeByte(precision);,                 writer.writeByte(scale);,             },             else if (outlen[0] != -1),             {,                 writer.writeShort(outlen[0]);,             },             else if (hasRs),             {,                 writer.writeShort(rsmeta.getColumnDisplaySize(i));,             },             else,             {,                 writer.writeShort(stmt.getParamLen(i));,             },         },     }, , , , ,     /**,      * Holdability passed in as it can represent the holdability of,      * the statement or a specific result set.,      * @param holdability HOLD_CURSORS_OVER_COMMIT or CLOSE_CURSORS_AT_COMMIT,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeSQLDHROW(int holdability) throws DRDAProtocolException,SQLException,     {,         if (JVMInfo.JDK_ID < 2) //write null indicator for SQLDHROW because there is no holdability support prior to jdk1.3,         {,             writer.writeByte(CodePoint.NULLDATA);,             return;,         }, ,         writer.writeByte(0);        // SQLDHROW INDICATOR, ,         //SQLDHOLD,         writer.writeShort(holdability);,         ,         //SQLDRETURN,         writer.writeShort(0);,         //SQLDSCROLL,         writer.writeShort(0);,         //SQLDSENSITIVE,         writer.writeShort(0);,         //SQLDFCODE,         writer.writeShort(0);,         //SQLDKEYTYPE,         writer.writeShort(0);,         //SQLRDBNAME,         writer.writeShort(0);   //CCC on Windows somehow does not take any dbname,         //SQLDSCHEMA,         writeVCMorVCS(null);, ,     }, ,     /**,      * Write QRYDTA - Query Answer Set Data,      *  Contains some or all of the answer set data resulting from a query,      *  If the client is not using rowset processing, this routine attempts,      *  to pack as much data into the QRYDTA as it can. This may result in,      *  splitting the last row across the block, in which case when the,      *  client calls CNTQRY we will return the remainder of the row.,      *,      *  Splitting a QRYDTA block is expensive, for several reasons:,      *  - extra logic must be run, on both client and server side,      *  - more network round-trips are involved,      *  - the QRYDTA block which contains the continuation of the split,      *    row is generally wasteful, since it contains the remainder of,      *    the split row but no additional rows.,      *  Since splitting is expensive, the server makes some attempt to,      *  avoid it. Currently, the server's algorithm for this is to,      *  compute the length of the current row, and to stop trying to pack,      *  more rows into this buffer if another row of that length would,      *  not fit. However, since rows can vary substantially in length,,      *  this algorithm is often ineffective at preventing splits. For,      *  example, if a short row near the end of the buffer is then,      *  followed by a long row, that long row will be split. It is possible,      *  to improve this algorithm substantially:,      *  - instead of just using the length of the previous row as a guide,      *    for whether to attempt packing another row in, use some sort of,      *    overall average row size computed over multiple rows (e.g., all,      *    the rows we've placed into this QRYDTA block, or all the rows,      *    we've process for this result set),      *  - when we discover that the next row will not fit, rather than,      *    splitting the row across QRYDTA blocks, if it is relatively,      *    small, we could just hold the entire row in a buffer to place,      *    it entirely into the next QRYDTA block, or reset the result,      *    set cursor back one row to "unread" this row.,      *  - when splitting a row across QRYDTA blocks, we tend to copy,      *    data around multiple times. Careful coding could remove some,      *    of these copies.,      *  However, it is important not to over-complicate this code: it is,      *  better to be correct than to be efficient, and there have been,      *  several bugs in the split logic already.,      *,      * Instance Variables,      *   Byte string,      *,      * @param stmt  DRDA statement we are processing,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeQRYDTA (DRDAStatement stmt) ,         throws DRDAProtocolException, SQLException,     {,         boolean getMoreData = true;,         boolean sentExtData = false;,         int startLength = 0;,         writer.createDssObject();, ,         if (SanityManager.DEBUG) {,             trace("Write QRYDTA");,         },         writer.startDdm(CodePoint.QRYDTA);,         // Check to see if there was leftover data from splitting,         // the previous QRYDTA for this result set. If there was, and,         // if we have now sent all of it, send any EXTDTA for that row,         // and increment the rowCount which we failed to increment in,         // writeFDODTA when we realized the row needed to be split.,         if (processLeftoverQRYDTA(stmt)),         {,             if (stmt.getSplitQRYDTA() == null),             {,                 stmt.rowCount += 1;,                 if (stmt.getExtDtaObjects() != null) {,                     writeEXTDTA(stmt);,                 },             },             return;,         }, ,         while(getMoreData),         {,             sentExtData = false;,             getMoreData = writeFDODTA(stmt);, ,             if (stmt.getExtDtaObjects() != null &&,                     stmt.getSplitQRYDTA() == null),             {,                 writer.endDdmAndDss();,                 writeEXTDTA(stmt);,                 getMoreData=false;,                 sentExtData = true;,             }, ,             // if we don't have enough room for a row of the ,             // last row's size, don't try to cram it in.,             // It would get split up but it is not very efficient.,             if (getMoreData == true),             {,                 int endLength = writer.getDSSLength();,                 int rowsize = endLength - startLength;,                 if ((stmt.getBlksize() - endLength ) < rowsize) {,                     getMoreData = false;,                 }, ,                 startLength = endLength;,             }, ,         },         // If we sent extDta we will rely on,         // writeScalarStream to end the dss with the proper chaining.,         // otherwise end it here.,         if (!sentExtData) {,             writer.endDdmAndDss();,         }, ,         if (!stmt.hasdata()) {,             final boolean qryclsOnLmtblkprc =,                 appRequester.supportsQryclsimpForLmtblkprc();,             if (stmt.isRSCloseImplicit(qryclsOnLmtblkprc)) {,                 stmt.rsClose();,             },         },     }, ,     /**,      * This routine places some data into the current QRYDTA block using,      * FDODTA (Formatted Data Object DaTA rules).,      *,      * There are 3 basic types of processing flow for this routine:,      * - In normal non-rowset, non-scrollable cursor flow, this routine,      *   places a single row into the QRYDTA block and returns TRUE,,      *   indicating that the caller can call us back to place another,      *   row into the result set if he wishes. (The caller may need to,      *   send Externalized Data, which would be a reason for him NOT to,      *   place any more rows into the QRYDTA).,      * - In ROWSET processing, this routine places an entire ROWSET of,      *   rows into the QRYDTA block and returns FALSE, indicating that,      *   the QRYDTA block is full and should now be sent.,      * - In callable statement processing, this routine places the,      *   results from the output parameters of the called procedure into,      *   the QRYDTA block. This code path is really dramatically,      *   different from the other two paths and shares only a very small,      *   amount of common code in this routine.,      *,      * In all cases, it is possible that the data we wish to return may,      * not fit into the QRYDTA block, in which case we call splitQRYDTA,      * to split the data and remember the remainder data in the result set.,      * Splitting the data is relatively rare in the normal cursor case,,      * because our caller (writeQRYDTA) uses a coarse estimation,      * technique to avoid calling us if he thinks a split is likely.,      *,      * The overall structure of this routine is implemented as two,      * loops:,      * - the outer "do ... while ... " loop processes a ROWSET, one row,      *   at a time. For non-ROWSET cursors, and for callable statements,,      *   this loop executes only once.,      * - the inner "for ... i < numCols ..." loop processes each column,      *   in the current row, or each output parmeter in the procedure.,      *,      * Most column data is written directly inline in the QRYDTA block.,      * Some data, however, is written as Externalized Data. This is,      * commonly used for Large Objects. In that case, an Externalized,      * Data Pointer is written into the QRYDTA block, and the actual,      * data flows in separate EXTDTA blocks which are returned,      * after this QRYDTA block.,      */,     private boolean writeFDODTA (DRDAStatement stmt) ,         throws DRDAProtocolException, SQLException,     {,         boolean hasdata;,         int blksize = stmt.getBlksize() > 0 ? stmt.getBlksize() : CodePoint.QRYBLKSZ_MAX;,         long rowCount = 0;,         ResultSet rs =null;,         boolean moreData = (stmt.getQryprctyp(),                             == CodePoint.LMTBLKPRC);,         int  numCols;, ,         if (!stmt.needsToSendParamData),         {,             rs = stmt.getResultSet();,         }, ,         if (rs != null),         {,             numCols = stmt.getNumRsCols();,             if (stmt.isScrollable()) {,                 hasdata = positionCursor(stmt, rs);,             } else {,                 hasdata = rs.next();,             },         },         else    // it's for a CallableStatement,         {,             hasdata = stmt.hasOutputParams();,             numCols = stmt.getDrdaParamCount();,         }, , ,         do {,             if (!hasdata),             {,                 doneData(stmt, rs);,                 moreData = false;,                 return moreData;,             },             ,             // Send ResultSet warnings if there are any,             SQLWarning sqlw = (rs != null)? rs.getWarnings(): null;,             if (rs != null) {,                 rs.clearWarnings();,             }, ,             // for updatable, insensitive result sets we signal the,             // row updated condition to the client via a warning to be ,             // popped by client onto its rowUpdated state, i.e. this ,             // warning should not reach API level.,             if (rs != null && rs.rowUpdated()) {,                 SQLWarning w = new SQLWarning("", SQLState.ROW_UPDATED,,                         ExceptionSeverity.WARNING_SEVERITY);,                 if (sqlw != null) {,                     sqlw.setNextWarning(w);,                 } else {,                     sqlw = w;,                 },             },             // Delete holes are manifest as a row consisting of a non-null,             // SQLCARD and a null data group. The SQLCARD has a warning,             // SQLSTATE of 02502,             if (rs != null && rs.rowDeleted()) {,                 SQLWarning w = new SQLWarning("", SQLState.ROW_DELETED,,                         ExceptionSeverity.WARNING_SEVERITY);,                 if (sqlw != null) {,                     sqlw.setNextWarning(w);,                 } else {,                     sqlw = w;,                 },             }, ,             // Save the position where we start writing the warnings in case,             // we need to add more warnings later.,             final int sqlcagrpStart = writer.getBufferPosition();, ,             if (sqlw == null) {,                 writeSQLCAGRP(nullSQLState, 0, -1, -1);,             } else {,                 writeSQLCAGRP(sqlw, 1, -1);,             }, ,             // Save the position right after the warnings so we know where to,             // insert more warnings later.,             final int sqlcagrpEnd = writer.getBufferPosition();, ,             // if we were asked not to return data, mark QRYDTA null; do not,             // return yet, need to make rowCount right,             // if the row has been deleted return QRYDTA null (delete hole),             boolean noRetrieveRS = (rs != null && ,                     (!stmt.getQryrtndta() || rs.rowDeleted()));,             if (noRetrieveRS) {,                 writer.writeByte(0xFF);  //QRYDTA null indicator: IS NULL,             } else {,                 writer.writeByte(0);  //QRYDTA null indicator: not null,             }, ,             for (int i = 1; i <= numCols; i++),             {,                 if (noRetrieveRS) {,                     break;,                 }, ,                 int drdaType;,                 int ndrdaType;,                 int precision;,                 int scale;, ,                 boolean valNull;,                 if (rs != null),                 {,                     drdaType =   stmt.getRsDRDAType(i) & 0xff;,                     precision = stmt.getRsPrecision(i);,                     scale = stmt.getRsScale(i);,                     ndrdaType = drdaType | 1;, ,                     if (SanityManager.DEBUG) {,                         trace("!!drdaType = " + java.lang.Integer.toHexString(drdaType) + ,                                  " precision=" + precision +" scale = " + scale);,                     },                     switch (ndrdaType),                     {,                         case DRDAConstants.DRDA_TYPE_NLOBBYTES:,                         case  DRDAConstants.DRDA_TYPE_NLOBCMIXED:,                             EXTDTAInputStream extdtaStream=  ,                                 EXTDTAInputStream.getEXTDTAStream(rs, i, drdaType);,                             writeFdocaVal(i, extdtaStream, drdaType, precision,,                                     scale, extdtaStream.isNull(), stmt, false);,                             break;,                         case DRDAConstants.DRDA_TYPE_NINTEGER:,                             int ival = rs.getInt(i);,                             valNull = rs.wasNull();,                             if (SanityManager.DEBUG) {,                                 trace("====== writing int: "+ ival + " is null: " + valNull);,                             },                             writeNullability(drdaType,valNull);,                             if (!valNull) {,                                 writer.writeInt(ival);,                             },                             break;,                         case DRDAConstants.DRDA_TYPE_NSMALL:,                             short sval = rs.getShort(i);,                             valNull = rs.wasNull();,                             if (SanityManager.DEBUG) {,                                 trace("====== writing small: "+ sval + " is null: " + valNull);,                             },                             writeNullability(drdaType,valNull);,                             if (!valNull) {,                                 writer.writeShort(sval);,                             },                             break;,                         case DRDAConstants.DRDA_TYPE_NINTEGER8:,                             long lval = rs.getLong(i);,                             valNull = rs.wasNull();,                             if (SanityManager.DEBUG) {,                                 trace("====== writing long: "+ lval + " is null: " + valNull);,                             },                             writeNullability(drdaType,valNull);,                             if (!valNull) {,                                 writer.writeLong(lval);,                             },                             break;,                         case DRDAConstants.DRDA_TYPE_NFLOAT4:,                             float fval = rs.getFloat(i);,                             valNull = rs.wasNull();,                             if (SanityManager.DEBUG) {,                                 trace("====== writing float: "+ fval + " is null: " + valNull);,                             },                             writeNullability(drdaType,valNull);,                             if (!valNull) {,                                 writer.writeFloat(fval);,                             },                             break;,                         case DRDAConstants.DRDA_TYPE_NFLOAT8:,                             double dval = rs.getDouble(i);,                             valNull = rs.wasNull();,                             if (SanityManager.DEBUG) {,                                 trace("====== writing double: "+ dval + " is null: " + valNull);,                             },                             writeNullability(drdaType,valNull);,                             if (!valNull) {,                                 writer.writeDouble(dval);,                             },                             break;,                         case DRDAConstants.DRDA_TYPE_NCHAR:,                         case DRDAConstants.DRDA_TYPE_NVARCHAR:,                         case DRDAConstants.DRDA_TYPE_NVARMIX:,                         case DRDAConstants.DRDA_TYPE_NLONG:,                         case DRDAConstants.DRDA_TYPE_NLONGMIX:,                             String valStr = rs.getString(i);,                             if (SanityManager.DEBUG) {,                                 trace("====== writing char/varchar/mix :"+ valStr + ":");,                             },                             writeFdocaVal(i, valStr, drdaType,,                                           precision, scale, rs.wasNull(),,                                           stmt, false);,                             break;,                         default:,                             Object val =,                                 getObjectForWriteFdoca(rs, i, drdaType);,                             writeFdocaVal(i, val, drdaType,,                                           precision, scale, rs.wasNull(),,                                           stmt, false);,                     },                 },                 else,                 {,                                     ,                     drdaType =   stmt.getParamDRDAType(i) & 0xff;,                     precision = stmt.getParamPrecision(i);,                     scale = stmt.getParamScale(i);,                     ,                     if (stmt.isOutputParam(i)) {,                         int[] outlen = new int[1];,                         drdaType = FdocaConstants.mapJdbcTypeToDrdaType( stmt.getOutputParamType(i), true, appRequester, outlen );,                         precision = stmt.getOutputParamPrecision(i);,                         scale = stmt.getOutputParamScale(i);,                                                 ,                         if (SanityManager.DEBUG) {,                             trace("***getting Object "+i);,                         },                         Object val = getObjectForWriteFdoca(,                                 (CallableStatement) stmt.ps, i, drdaType);,                         valNull = (val == null);,                         writeFdocaVal(i, val, drdaType, precision, scale,,                                       valNull, stmt, true);,                     },                     else {,                         writeFdocaVal(i, null, drdaType, precision, scale,,                                       true, stmt, true);,                     },                 },             }, ,             DataTruncation truncated = stmt.getTruncationWarnings();,             if (truncated != null) {,                 // Some of the data was truncated, so we need to add a,                 // truncation warning. Save a copy of the row data, then move,                 // back to the SQLCAGRP section and overwrite it with the new,                 // warnings, and finally re-insert the row data after the new,                 // SQLCAGRP section.,                 byte[] data = writer.getBufferContents(sqlcagrpEnd);,                 writer.setBufferPosition(sqlcagrpStart);,                 if (sqlw != null) {,                     truncated.setNextWarning(sqlw);,                 },                 writeSQLCAGRP(truncated, 1, -1);,                 writer.writeBytes(data);,                 stmt.clearTruncationWarnings();,             }, ,             // does all this fit in one QRYDTA,             if (writer.getDSSLength() > blksize),             {,                 splitQRYDTA(stmt, blksize);,                 return false;,             }, ,             if (rs == null) {,                 return moreData;,             }, ,             //get the next row,             rowCount++;,             if (rowCount < stmt.getQryrowset()),             {,                 hasdata = rs.next();,             },             /*(1) scrollable we return at most a row set; OR (2) no retrieve data,              */,             else if (stmt.isScrollable() || noRetrieveRS),             {,                 moreData=false;,             }, ,         } while (hasdata && rowCount < stmt.getQryrowset());, ,         // add rowCount to statement row count,         // for non scrollable cursors,         if (!stmt.isScrollable()) {,             stmt.rowCount += rowCount;,         }, ,         if (!hasdata),         {,             doneData(stmt, rs);,             moreData=false;,         }, ,         if (!stmt.isScrollable()) {,             stmt.setHasdata(hasdata);,         }, ,         return moreData;,     }, ,     /**,      * <p>,      * Get a column value of the specified type from a {@code ResultSet}, in,      * a form suitable for being writted by {@link #writeFdocaVal}. For most,      * types, this means just calling {@code ResultSet.getObject(int)}.,      * </p>,      *,      * <p>,      * The only exception currently is the data types representing dates and,      * times, as they need to be fetched using the same,      * {@code java.util.Calendar} as {@link #writeFdocaVal} uses when writing,      * them (DERBY-4582).,      * </p>,      *,      * <p>,      * <b>Note:</b> Changes made in this method should also be made in the,      * corresponding method for {@code CallableStatement}:,      * {@link #getObjectForWriteFdoca(java.sql.CallableStatement, int, int)}.,      * </p>,      *,      * @param rs the result set to fetch the object from,      * @param index the column index,      * @param drdaType the DRDA type of the object to fetch,      * @return an object with the value of the column,      * @throws if a database error occurs while fetching the column value,      * @see #getObjectForWriteFdoca(java.sql.CallableStatement, int, int),      */,     private Object getObjectForWriteFdoca(ResultSet rs, int index, int drdaType),             throws SQLException {,         // convert to corresponding nullable type to reduce number of cases,         int ndrdaType = drdaType | 1;,         switch (ndrdaType) {,             case DRDAConstants.DRDA_TYPE_NDATE:,                 return rs.getDate(index, getGMTCalendar());,             case DRDAConstants.DRDA_TYPE_NTIME:,                 return rs.getTime(index, getGMTCalendar());,             case DRDAConstants.DRDA_TYPE_NTIMESTAMP:,                 return rs.getTimestamp(index, getGMTCalendar());,             default:,                 return rs.getObject(index);,         },     }, ,     /**,      * <p>,      * Get the value of an output parameter of the specified type from a,      * {@code CallableStatement}, in a form suitable for being writted by,      * {@link #writeFdocaVal}. For most types, this means just calling,      * {@code CallableStatement.getObject(int)}.,      * </p>,      *,      * <p>,      * This method should behave like the corresponding method for,      * {@code ResultSet}, and changes made to one of these methods, must be,      * reflected in the other method. See,      * {@link #getObjectForWriteFdoca(java.sql.ResultSet, int, int)},      * for details.,      * </p>,      *,      * @param cs the callable statement to fetch the object from,      * @param index the parameter index,      * @param drdaType the DRDA type of the object to fetch,      * @return an object with the value of the output parameter,      * @throws if a database error occurs while fetching the parameter value,      * @see #getObjectForWriteFdoca(java.sql.ResultSet, int, int),      */,     private Object getObjectForWriteFdoca(CallableStatement cs,,                                           int index, int drdaType),             throws SQLException {,         // convert to corresponding nullable type to reduce number of cases,         int ndrdaType = drdaType | 1;,         switch (ndrdaType) {,             case DRDAConstants.DRDA_TYPE_NDATE:,                 return cs.getDate(index, getGMTCalendar());,             case DRDAConstants.DRDA_TYPE_NTIME:,                 return cs.getTime(index, getGMTCalendar());,             case DRDAConstants.DRDA_TYPE_NTIMESTAMP:,                 return cs.getTimestamp(index, getGMTCalendar());,             case DRDAConstants.DRDA_TYPE_NLOBBYTES:,             case  DRDAConstants.DRDA_TYPE_NLOBCMIXED:,                 return EXTDTAInputStream.getEXTDTAStream(cs, index, drdaType);,             default:,                 return cs.getObject(index);,         },     }, ,     /**,      * Split QRYDTA into blksize chunks,      *,      * This routine is called if the QRYDTA data will not fit. It writes,      * as much data as it can, then stores the remainder in the result,      * set. At some later point, when the client returns with a CNTQRY,,      * we will call processLeftoverQRYDTA to handle that data.,      *,      * The interaction between DRDAConnThread and DDMWriter is rather,      * complicated here. This routine gets called because DRDAConnThread,      * realizes that it has constructed a QRYDTA message which is too,      * large. At that point, we need to reclaim the "extra" data and,      * hold on to it. To aid us in that processing, DDMWriter provides,      * the routines getDSSLength, copyDSSDataToEnd, and truncateDSS.,      * For some additional detail on this complex sub-protocol, the,      * interested reader should study bug DERBY-491 and 492 at:,      * http://issues.apache.org/jira/browse/DERBY-491 and,      * http://issues.apache.org/jira/browse/DERBY-492,      *,      * @param stmt DRDA statment,      * @param blksize size of query block,      * ,      * @throws SQLException,      * @throws DRDAProtocolException,      */,     private void splitQRYDTA(DRDAStatement stmt, int blksize) throws SQLException, ,             DRDAProtocolException,     {,         // make copy of extra data,         byte [] temp = writer.copyDSSDataToEnd(blksize);,         // truncate to end of blocksize,         writer.truncateDSS(blksize);,         if (temp.length == 0) {,             agentError("LMTBLKPRC violation: splitQRYDTA was " +,                 "called to split a QRYDTA block, but the " +,                 "entire row fit successfully into the " +,                 "current block. Server rowsize computation " +,                 "was probably incorrect (perhaps an off-by-" +,                 "one bug?). QRYDTA blocksize: " + blksize);,         },         stmt.setSplitQRYDTA(temp);,     },     /**,      * Process remainder data resulting from a split.,      *,      * This routine is called at the start of building each QRYDTA block.,      * Normally, it observes that there is no remainder data from the,      * previous QRYDTA block, and returns FALSE, indicating that there,      * was nothing to do.,      *,      * However, if it discovers that the previous QRYDTA block was split,,      * then it retrieves the remainder data from the result set, writes,      * as much of it as will fit into the QRYDTA block (hopefully all of,      * it will fit, but the row may be very long), and returns TRUE,,      * indicating that this QRYDTA block has been filled with remainder,      * data and should now be sent immediately.,      */,     private boolean processLeftoverQRYDTA(DRDAStatement stmt),         throws SQLException,DRDAProtocolException,     {,         byte []leftovers = stmt.getSplitQRYDTA();,         if (leftovers == null) {,             return false;,         },         int blksize = stmt.getBlksize() > 0 ? stmt.getBlksize() : CodePoint.QRYBLKSZ_MAX;,         blksize = blksize - 10; //DSS header + QRYDTA and length,         if (leftovers.length < blksize),         {,             writer.writeBytes(leftovers, 0, leftovers.length);,             stmt.setSplitQRYDTA(null);,         },         else,         {,             writer.writeBytes(leftovers, 0, blksize);,             byte []newLeftovers = new byte[leftovers.length-blksize];,             System.arraycopy(,                 leftovers, blksize, newLeftovers, 0, newLeftovers.length);,             stmt.setSplitQRYDTA(newLeftovers);,         },         // finish off query block and send,         writer.endDdmAndDss();,         return true;,     }, , ,     /**,      * Done data,      * Send SQLCARD for the end of the data,      * ,      * @param stmt DRDA statement,      * @param rs Result set,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void doneData(DRDAStatement stmt, ResultSet rs) ,             throws DRDAProtocolException, SQLException,     {,         if (SanityManager.DEBUG) {,             trace("*****NO MORE DATA!!");,         },         int blksize = stmt.getBlksize() > 0 ? stmt.getBlksize() : CodePoint.QRYBLKSZ_MAX;,         if (rs != null),         {,             if (stmt.isScrollable()),             {,                                 //keep isAfterLast and isBeforeFirst to be able ,                                 //to reposition after counting rows,                                 boolean isAfterLast = rs.isAfterLast();,                                 boolean isBeforeFirst = rs.isBeforeFirst();,                                 ,                 // for scrollable cursors - calculate the row count,                 // since we may not have gone through each row,                 rs.last();,                 stmt.rowCount  = rs.getRow();, ,                                 // reposition after last or before first,                                 if (isAfterLast) {,                                     rs.afterLast();,                                 },                                 if (isBeforeFirst) {,                                     rs.beforeFirst();,                                 } ,             },             else  // non-scrollable cursor,             {,                 final boolean qryclsOnLmtblkprc =,                     appRequester.supportsQryclsimpForLmtblkprc();,                 if (stmt.isRSCloseImplicit(qryclsOnLmtblkprc)) {,                     stmt.rsClose();,                     stmt.rsSuspend();,                 },              ,             },         }, ,         // For scrollable cursor's QRYSCRAFT, when we reach here, DRDA spec says sqlstate,         // is 00000, sqlcode is not mentioned.  But DB2 CLI code expects sqlcode to be 0.,         // We return sqlcode 0 in this case, as the DB2 server does.,         boolean isQRYSCRAFT = (stmt.getQryscrorn() == CodePoint.QRYSCRAFT);, ,         // Using sqlstate 00000 or 02000 for end of data.,                 writeSQLCAGRP((isQRYSCRAFT ? eod00000 : eod02000),,                               (isQRYSCRAFT ? 0 : 100), 0, stmt.rowCount);,                 ,         writer.writeByte(CodePoint.NULLDATA);,         // does all this fit in one QRYDTA,         if (writer.getDSSLength() > blksize),         {,             splitQRYDTA(stmt, blksize);,         },     },     /**,      * Position cursor for insensitive scrollable cursors,      *,      * @param stmt  DRDA statement,      * @param rs    Result set,      */,     private boolean positionCursor(DRDAStatement stmt, ResultSet rs) ,         throws SQLException, DRDAProtocolException,     {,         boolean retval = false;,         switch (stmt.getQryscrorn()),         {,             case CodePoint.QRYSCRREL:,                                 int rows = (int)stmt.getQryrownbr();,                                 if ((rs.isAfterLast() && rows > 0) || (rs.isBeforeFirst() && rows < 0)) {,                                     retval = false;,                                 } else {,                                     retval = rs.relative(rows);,                                 },                                 break;,             case CodePoint.QRYSCRABS:,                 // JCC uses an absolute value of 0 which is not allowed in JDBC,                 // We translate it into beforeFirst which seems to work.,                 if (stmt.getQryrownbr() == 0),                 {,                     rs.beforeFirst();,                     retval = false;,                 },                 else,                 {,                     retval = rs.absolute((int)stmt.getQryrownbr());,                 },                 break;,             case CodePoint.QRYSCRAFT:,                 rs.afterLast();,                 retval = false;,                 break;,             case CodePoint.QRYSCRBEF:,                 rs.beforeFirst();,                 retval = false;,                 break;,             default:      ,                 agentError("Invalid value for cursor orientation "+ stmt.getQryscrorn());,         },         return retval;,     },     /**,      * Write SQLDAGRP,      * SQLDAGRP : EARLY FDOCA GROUP,      * SQL Data Area Group Description,      *,      * FORMAT FOR SQLAM <= 6,      *   SQLPRECISION; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      *   SQLSCALE; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      *   SQLLENGTH; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *   SQLTYPE; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      *   SQLCCSID; DRDA TYPE FB; ENVLID 0x26; Length Override 2,      *   SQLNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 30,      *   SQLNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 30,      *   SQLLABEL_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 30,      *   SQLLABEL_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 30,      *   SQLCOMMENTS_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 254,      *   SQLCOMMENTS_m; DRDA TYPE VCS; ENVLID 0x32; Length Override 254,      *,      * FORMAT FOR SQLAM == 6,      *   SQLPRECISION; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      *   SQLSCALE; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      *   SQLLENGTH; DRDA TYPE I8; ENVLID 0x16; Length Override 8,      *   SQLTYPE; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      *   SQLCCSID; DRDA TYPE FB; ENVLID 0x26; Length Override 2,      *   SQLNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 30,      *   SQLNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 30,      *   SQLLABEL_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 30,      *   SQLLABEL_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 30,      *   SQLCOMMENTS_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 254,      *   SQLCOMMENTS_m; DRDA TYPE VCS; ENVLID 0x32; Length Override 254,      *   SQLUDTGRP; DRDA TYPE N-GDA; ENVLID 0x51; Length Override 0,      *,      * FORMAT FOR SQLAM >= 7,      *   SQLPRECISION; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      *   SQLSCALE; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      *   SQLLENGTH; DRDA TYPE I8; ENVLID 0x16; Length Override 8,      *   SQLTYPE; DRDA TYPE I2; ENVLID 0x04; Length Override 2,      *   SQLCCSID; DRDA TYPE FB; ENVLID 0x26; Length Override 2,      *   SQLDOPTGRP; DRDA TYPE N-GDA; ENVLID 0xD2; Length Override 0,      *,      * @param rsmeta    resultset meta data,      * @param pmeta     parameter meta data,      * @param elemNum   column number we are returning (in case of result set), or,,      *                  parameter number (in case of parameter),      * @param rtnOutput whether this is for a result set,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeSQLDAGRP(ResultSetMetaData rsmeta,,                                ParameterMetaData pmeta,,                                int elemNum, boolean rtnOutput),         throws DRDAProtocolException, SQLException,     {,         //jdbc uses offset of 1, ,         int jdbcElemNum = elemNum +1;,         // length to be retreived as output parameter,         int[]  outlen = {-1};  , ,         int elemType = rtnOutput ? rsmeta.getColumnType(jdbcElemNum) : pmeta.getParameterType(jdbcElemNum);, ,         int precision = Math.min(,                 FdocaConstants.NUMERIC_MAX_PRECISION,,                 rtnOutput ? rsmeta.getPrecision(jdbcElemNum) :,                             pmeta.getPrecision(jdbcElemNum));, ,         // 2-byte precision,         writer.writeShort(precision);,         // 2-byte scale,         int scale = (rtnOutput ? rsmeta.getScale(jdbcElemNum) : pmeta.getScale(jdbcElemNum));,         writer.writeShort(scale);, ,         boolean nullable = rtnOutput ?,          (rsmeta.isNullable(jdbcElemNum) == ResultSetMetaData.columnNullable) :,          (pmeta.isNullable(jdbcElemNum) == ParameterMetaData.parameterNullable);,         ,         int sqlType = SQLTypes.mapJdbcTypeToDB2SqlType(elemType,,                                                        nullable, appRequester,,                                                        outlen);, ,         if (outlen[0] == -1) //some types not set,         {,             switch (elemType),             {,                 case Types.DECIMAL:,                 case Types.NUMERIC:,                     scale = rtnOutput ? rsmeta.getScale(jdbcElemNum) : pmeta.getScale(jdbcElemNum);,                     outlen[0] = ((precision <<8) | scale);,                     if (SanityManager.DEBUG) {,                         trace("\n\nprecision =" +precision +,                           " scale =" + scale);,                     },                     break;,                 default:,                     outlen[0] = Math.min(FdocaConstants.LONGVARCHAR_MAX_LEN,,                                         (rtnOutput ? rsmeta.getColumnDisplaySize(jdbcElemNum) :,                                                 pmeta.getPrecision(jdbcElemNum)));,             },         }, ,         switch (elemType),         {,             case Types.BINARY:,             case Types.VARBINARY:,             case Types.LONGVARBINARY:,             case Types.BLOB:            //for CLI describe to be correct,             case Types.CLOB:,                 outlen[0] = (rtnOutput ? rsmeta.getPrecision(jdbcElemNum) :,                                             pmeta.getPrecision(jdbcElemNum));,         }, ,         if (SanityManager.DEBUG) {,             trace("SQLDAGRP len =" + java.lang.Integer.toHexString(outlen[0]) + "for type:" + elemType);,         }, ,        // 8 or 4 byte sqllength,         if (sqlamLevel >= MGRLVL_6) {,             writer.writeLong(outlen[0]);,         } else {,             writer.writeInt(outlen[0]);,         }, , ,         String typeName = rtnOutput ? rsmeta.getColumnTypeName(jdbcElemNum) :,                                         pmeta.getParameterTypeName(jdbcElemNum);,         if (SanityManager.DEBUG) {,             trace("jdbcType =" + typeName + "  sqlType =" + sqlType + "len =" +outlen[0]);,         }, ,         writer.writeShort(sqlType);, ,         // CCSID,         // CCSID should be 0 for Binary Types.,         ,         if (elemType == java.sql.Types.CHAR ||,             elemType == java.sql.Types.VARCHAR,             || elemType == java.sql.Types.LONGVARCHAR,             || elemType == java.sql.Types.CLOB) {,             writer.writeScalar2Bytes(1208);,         } else {,             writer.writeScalar2Bytes(0);,         }, ,         if (sqlamLevel < MGRLVL_7) ,         {, ,             //SQLName,             writeVCMorVCS(rtnOutput ? rsmeta.getColumnName(jdbcElemNum) : null);,             //SQLLabel,             writeVCMorVCS(null);,             //SQLComments,             writeVCMorVCS(null);, ,             if (sqlamLevel == MGRLVL_6) {,                 writeSQLUDTGRP(rsmeta, pmeta, jdbcElemNum, rtnOutput);,             },         },         else,         {,             writeSQLDOPTGRP(rsmeta, pmeta, jdbcElemNum, rtnOutput);,         }, ,     }, ,     /**,      * Write variable character mixed byte or single byte,      * The preference is to write mixed byte if it is defined for the server,,      * since that is our default and we don't allow it to be changed, we always,      * write mixed byte.,      * ,      * @param s string to write,      * @exception DRDAProtocolException,      */,     private void writeVCMorVCS(String s),         throws DRDAProtocolException,     {,         //Write only VCM and 0 length for VCS, ,         if (s == null),         {,             writer.writeShort(0);,             writer.writeShort(0);,             return;,         }, ,         // VCM,         writer.writeLDString(s);,         // VCS,         writer.writeShort(0);,     }, ,   ,     /**,      * Write SQLUDTGRP (SQL Descriptor User-Defined Type Group Descriptor),      * ,      * This is the format from the DRDA spec, Volume 1, section 5.6.4.10.,      * However, this format is not rich enough to carry the information needed,      * by JDBC. This format does not have a subtype code for JAVA_OBJECT and,      * this format does not convey the Java class name needed,      * by ResultSetMetaData.getColumnClassName().,      *,      *   SQLUDXTYPE; DRDA TYPE I4; ENVLID 0x02; Length Override 4,      *                        Constants which map to java.sql.Types constants DISTINCT, STRUCT, and REF.,      *                        But DRDA does not define a constant which maps to java.sql.Types.JAVA_OBJECT.,      *   SQLUDTRDB; DRDA TYPE VCS; ENVLID 0x32; Length Override 255,      *                       Database name.,      *   SQLUDTSCHEMA_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255,      *   SQLUDTSCHEMA_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255,      *                         Schema name. One of the above.,      *   SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255,      *   SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255,      *                         Unqualified UDT name. One of the above.,      *,      * Instead, we use the following format and only for communication between,      * Derby servers and Derby clients which are both at version 10.6 or higher.,      * For all other client/server combinations, we send null.,      *,      *   SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255,      *   SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255,      *                         Fully qualified UDT name. One of the above.,      *   SQLUDTCLASSNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN,      *   SQLUDTCLASSNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN,      *                         Name of the Java class bound to the UDT. One of the above.,      *,      * @param rsmeta    resultset meta data,      * @param pmeta     parameter meta data,      * @param jdbcElemNum   column number we are returning (in case of result set), or,,      *                  parameter number (in case of parameter),      * @param rtnOutput whether this is for a result set,      *,      * @throws DRDAProtocolException,      * @throws SQLException,      */,     private void writeSQLUDTGRP(ResultSetMetaData rsmeta,,                                 ParameterMetaData pmeta,,                                 int jdbcElemNum, boolean rtnOutput),         throws DRDAProtocolException,SQLException,     {,         int jdbcType = rtnOutput ?,             rsmeta.getColumnType( jdbcElemNum) : pmeta.getParameterType( jdbcElemNum );, ,         if ( !(jdbcType == Types.JAVA_OBJECT) || !appRequester.supportsUDTs() ),         {,             writer.writeByte(CodePoint.NULLDATA);,             return;,         },         ,         String typeName = rtnOutput ?,             rsmeta.getColumnTypeName( jdbcElemNum ) : pmeta.getParameterTypeName( jdbcElemNum );,         String className = rtnOutput ?,             rsmeta.getColumnClassName( jdbcElemNum ) : pmeta.getParameterClassName( jdbcElemNum );,         ,         writeVCMorVCS( typeName );,         writeVCMorVCS( className );,     }, ,     private void writeSQLDOPTGRP(ResultSetMetaData rsmeta,,                                  ParameterMetaData pmeta,,                                  int jdbcElemNum, boolean rtnOutput),         throws DRDAProtocolException,SQLException,     {, ,         writer.writeByte(0);,         //SQLUNAMED,         writer.writeShort(0);,         //SQLName,         writeVCMorVCS(rtnOutput ? rsmeta.getColumnName(jdbcElemNum) : null);,         //SQLLabel,         writeVCMorVCS(null);,         //SQLComments,         writeVCMorVCS(null);,         //SQLDUDTGRP ,         writeSQLUDTGRP(rsmeta, pmeta, jdbcElemNum, rtnOutput);,         //SQLDXGRP,         writeSQLDXGRP(rsmeta, pmeta, jdbcElemNum, rtnOutput);,     }, , ,     private void writeSQLDXGRP(ResultSetMetaData rsmeta,,                                ParameterMetaData pmeta,,                                int jdbcElemNum, boolean rtnOutput),         throws DRDAProtocolException,SQLException,     {,         // Null indicator indicates we have data,         writer.writeByte(0);,         //   SQLXKEYMEM; DRDA TYPE I2; ENVLID 0x04; Length Override 2,         // Hard to get primary key info. Send 0 for now,         writer.writeShort(0);,         //   SQLXUPDATEABLE; DRDA TYPE I2; ENVLID 0x04; Length Override 2,         writer.writeShort(rtnOutput ? rsmeta.isWritable(jdbcElemNum) : false);, ,         //   SQLXGENERATED; DRDA TYPE I2; ENVLID 0x04; Length Override 2,         if (rtnOutput && rsmeta.isAutoIncrement(jdbcElemNum)) {,             writer.writeShort(2);,         } else {,             writer.writeShort(0);,         }, ,         //   SQLXPARMMODE; DRDA TYPE I2; ENVLID 0x04; Length Override 2,         if (pmeta != null && !rtnOutput),         {,             int mode = pmeta.getParameterMode(jdbcElemNum);,             if (mode ==  ParameterMetaData.parameterModeUnknown),             {,                 // For old style callable statements. We assume in/out if it,                 // is an output parameter.,                 int type =  DRDAStatement.getOutputParameterTypeFromClassName(,                                                                               pmeta.getParameterClassName(jdbcElemNum));,                 if (type != DRDAStatement.NOT_OUTPUT_PARAM) {,                     mode = ParameterMetaData.parameterModeInOut;,                 },             },             writer.writeShort(mode);,         },         else,         {,             writer.writeShort(0);,         },     ,         //   SQLXRDBNAM; DRDA TYPE VCS; ENVLID 0x32; Length Override 1024,         // JCC uses this as the catalog name so we will send null.,         writer.writeShort(0);, ,         //   SQLXCORNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255,         //   SQLXCORNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255,         writeVCMorVCS(null);, ,         //   SQLXBASENAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255,         //   SQLXBASENAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255,         writeVCMorVCS(rtnOutput ? rsmeta.getTableName(jdbcElemNum) : null);, ,         //   SQLXSCHEMA_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255,         //   SQLXSCHEMA_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255,         writeVCMorVCS(rtnOutput ? rsmeta.getSchemaName(jdbcElemNum): null);, , ,         //   SQLXNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255,         //   SQLXNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255,         writeVCMorVCS(rtnOutput ? rsmeta.getColumnName(jdbcElemNum): null);,         ,     }, ,   /**,    * Write Fdoca Value to client ,    * @param index     Index of column being returned,    * @param val       Value to write to client,    * @param drdaType  FD:OCA DRDA Type from FdocaConstants,    * @param precision Precision,    * @param stmt       Statement being processed,    * @param isParam   True when writing a value for a procedure parameter,    *,    * @exception DRDAProtocolException  ,    * ,    * @exception SQLException,    *,    * @see FdocaConstants,    */, ,     protected void writeFdocaVal(int index, Object val, int drdaType,,                                  int precision, int scale, boolean valNull,,                                  DRDAStatement stmt, boolean isParam),             throws DRDAProtocolException, SQLException,     {,         writeNullability(drdaType,valNull);, ,         if (! valNull),         {,             int ndrdaType = drdaType | 1;,             long valLength = 0;,             switch (ndrdaType),             {,                 case DRDAConstants.DRDA_TYPE_NBOOLEAN:,                     writer.writeBoolean( ((Boolean) val).booleanValue() );,                     break;,                 case DRDAConstants.DRDA_TYPE_NSMALL:,                     // DB2 does not have a BOOLEAN java.sql.bit type,,                     // so we need to send it as a small,                     if (val instanceof Boolean),                     {,                         writer.writeShort(((Boolean) val).booleanValue());,                     },                     else,                     {,                         writer.writeShort(((Number) val).shortValue());,                     },                     break;,                 case  DRDAConstants.DRDA_TYPE_NINTEGER:,                     writer.writeInt(((Integer) val).intValue());,                     break;,                 case DRDAConstants.DRDA_TYPE_NINTEGER8:,                     writer.writeLong(((Long) val).longValue());,                     break;,                 case DRDAConstants.DRDA_TYPE_NFLOAT4:,                     writer.writeFloat(((Float) val).floatValue());,                     break;,                 case DRDAConstants.DRDA_TYPE_NFLOAT8:,                     writer.writeDouble(((Double) val).doubleValue());,                     break;,                 case DRDAConstants.DRDA_TYPE_NDECIMAL:,                     if (precision == 0) {,                         precision = FdocaConstants.NUMERIC_DEFAULT_PRECISION;,                     },                     BigDecimal bd = (java.math.BigDecimal) val;,                     writer.writeBigDecimal(bd,precision,scale);,                     break;,                 case DRDAConstants.DRDA_TYPE_NDATE:,                     writer.writeString(formatDate((java.sql.Date) val));,                     break;,                 case DRDAConstants.DRDA_TYPE_NTIME:,                     writer.writeString(formatTime((Time) val));,                     break;,                 case DRDAConstants.DRDA_TYPE_NTIMESTAMP:,                     writer.writeString(formatTimestamp((Timestamp) val));,                     break;,                 case DRDAConstants.DRDA_TYPE_NCHAR:,                     writer.writeString(((String) val).toString());,                     break;,                 case DRDAConstants.DRDA_TYPE_NVARCHAR:,                 case DRDAConstants.DRDA_TYPE_NVARMIX:,                 case DRDAConstants.DRDA_TYPE_NLONG:,                 case DRDAConstants.DRDA_TYPE_NLONGMIX:,                     //WriteLDString and generate warning if truncated,                     // which will be picked up by checkWarning(),                     writer.writeLDString(val.toString(), index, stmt, isParam);,                     break;,                 case DRDAConstants.DRDA_TYPE_NLOBBYTES:,                 case DRDAConstants.DRDA_TYPE_NLOBCMIXED:, ,                     // do not send EXTDTA for lob of length 0, beetle 5967,                     if( ! ((EXTDTAInputStream) val).isEmptyStream() ){,                         stmt.addExtDtaObject(val, index);,                     ,                     //indicate externalized and size is unknown.,                     writer.writeExtendedLength(0x8000);,                     ,                     }else{,                     writer.writeExtendedLength(0);,                     ,                     },                     ,                     break;,                     ,                 case  DRDAConstants.DRDA_TYPE_NFIXBYTE:,                     writer.writeBytes((byte[]) val);,                     break;,                 case DRDAConstants.DRDA_TYPE_NVARBYTE:,                 case DRDAConstants.DRDA_TYPE_NLONGVARBYTE:,                         writer.writeLDBytes((byte[]) val, index);,                     break;,                 case DRDAConstants.DRDA_TYPE_NLOBLOC:,                 case DRDAConstants.DRDA_TYPE_NCLOBLOC:,                     writer.writeInt(((EngineLOB)val).getLocator());,                     break;,                 case DRDAConstants.DRDA_TYPE_NUDT:,                     writer.writeUDT( val, index );,                     break;,                 default:,                     if (SanityManager.DEBUG) {,                         trace("ndrdaType is: "+ndrdaType);,                     },                     writer.writeLDString(val.toString(), index, stmt, isParam);,             },         },     }, ,     /**,      * write nullability if this is a nullable drdatype and FDOCA null,      * value if appropriate,      * @param drdaType      FDOCA type,      * @param valNull       true if this is a null value. False otherwise,      * ,      **/,     private void writeNullability(int drdaType, boolean valNull),     {,         if(FdocaConstants.isNullable(drdaType)),         {,             if (valNull),             {,                 writer.writeByte(FdocaConstants.NULL_DATA);,             },             else,             {,                 writer.writeByte(FdocaConstants.INDICATOR_NULLABLE);,             },         },         ,     }, ,     /**,      * Convert a {@code java.sql.Date} to a string with the format expected,      * by the client.,      *,      * @param date the date to format,      * @return a string on the format YYYY-MM-DD representing the date,      * @see org.apache.derby.client.am.DateTime#dateBytesToDate,      */,     private String formatDate(java.sql.Date date) {,         Calendar cal = getGMTCalendar();,         cal.clear();,         cal.setTime(date);, ,         char[] buf = "YYYY-MM-DD".toCharArray();,         padInt(buf, 0, 4, cal.get(Calendar.YEAR));,         padInt(buf, 5, 2, cal.get(Calendar.MONTH) + 1);,         padInt(buf, 8, 2, cal.get(Calendar.DAY_OF_MONTH));, ,         return new String(buf);,     }, ,     /**,      * Convert a {@code java.sql.Time} to a string with the format expected,      * by the client.,      *,      * @param time the time to format,      * @return a string on the format HH:MM:SS representing the time,      * @see org.apache.derby.client.am.DateTime#timeBytesToTime,      */,     private String formatTime(Time time) {,         Calendar cal = getGMTCalendar();,         cal.clear();,         cal.setTime(time);, ,         char[] buf = "HH:MM:SS".toCharArray();,         padInt(buf, 0, 2, cal.get(Calendar.HOUR_OF_DAY));,         padInt(buf, 3, 2, cal.get(Calendar.MINUTE));,         padInt(buf, 6, 2, cal.get(Calendar.SECOND));, ,         return new String(buf);,     }, ,     /**,      * Convert a {@code java.sql.Timestamp} to a string with the format,      * expected by the client.,      *,      * @param ts the timestamp to format,      * @return a string on the format YYYY-MM-DD-HH.MM.SS.ffffff[fff],      * @see org.apache.derby.client.am.DateTime#timestampBytesToTimestamp,      */,     private String formatTimestamp(Timestamp ts) {,         Calendar cal = getGMTCalendar();,         cal.clear();,         cal.setTime(ts);, ,         char[] buf = new char[appRequester.getTimestampLength()];,         padInt(buf, 0, 4, cal.get(Calendar.YEAR));,         buf[4] = '-';,         padInt(buf, 5, 2, cal.get(Calendar.MONTH) + 1);,         buf[7] = '-';,         padInt(buf, 8, 2, cal.get(Calendar.DAY_OF_MONTH));,         buf[10] = '-';,         padInt(buf, 11, 2, cal.get(Calendar.HOUR_OF_DAY));,         buf[13] = '.';,         padInt(buf, 14, 2, cal.get(Calendar.MINUTE));,         buf[16] = '.';,         padInt(buf, 17, 2, cal.get(Calendar.SECOND));,         buf[19] = '.';, ,         int nanos = ts.getNanos();,         if (appRequester.supportsTimestampNanoseconds()) {,             padInt(buf, 20, 9, nanos);,         } else {,             padInt(buf, 20, 6, nanos / 1000);,         }, ,         return new String(buf);,     }, ,     /**,      * Insert an integer into a char array and pad it with leading zeros if,      * its string representation is shorter than {@code length} characters.,      *,      * @param buf the char array,      * @param offset where in the array to start inserting the value,      * @param length the desired length of the inserted string,      * @param value the integer value to insert,      */,     private void padInt(char[] buf, int offset, int length, int value) {,         final int radix = 10;,         for (int i = offset + length - 1; i >= offset; i--) {,             buf[i] = Character.forDigit(value % radix, radix);,             value /= radix;,         },     }, ,     /**,      * Methods to keep track of required codepoints,      */,     /**,      * Copy a list of required code points to template for checking,      *,      * @param req list of required codepoints,      */,     private void copyToRequired(int [] req),     {,         currentRequiredLength = req.length;,         if (currentRequiredLength > required.length) {,             required = new int[currentRequiredLength];,         },         System.arraycopy(req, 0, required, 0, req.length);,     },     /**,      * Remove codepoint from required list,      *,      * @param codePoint - code point to be removed,      */,     private void removeFromRequired(int codePoint),     {,         for (int i = 0; i < currentRequiredLength; i++) {,             if (required[i] == codePoint) {,                 required[i] = 0;,             },         },     },     /**,      * Check whether we have seen all the required code points,      *,      * @param codePoint code point for which list of code points is required,      */,     private void checkRequired(int codePoint) throws DRDAProtocolException,     {,         int firstMissing = 0;,         for (int i = 0; i < currentRequiredLength; i++),         {,             if (required[i] != 0),             {,                 firstMissing = required[i];,                 break;,             },         },         if (firstMissing != 0) {,             missingCodePoint(firstMissing);,         },     },     /**,      * Error routines,      */,     /**,      * Seen too many of this code point,      *,      * @param codePoint  code point which has been duplicated,      *,      * @exception DRDAProtocolException,      */,     private void tooMany(int codePoint) throws DRDAProtocolException,     {,         throwSyntaxrm(CodePoint.SYNERRCD_TOO_MANY, codePoint);,     },     /**,      * Object too big,      *,      * @param codePoint  code point with too big object,      * @exception DRDAProtocolException,      */,     private void tooBig(int codePoint) throws DRDAProtocolException,     {,         throwSyntaxrm(CodePoint.SYNERRCD_TOO_BIG, codePoint);,     },      ,     ,     /**,      * Invalid non-derby client tried to connect.,      * thrown a required Value not found error and log a message to derby.log,      * ,      * @param prdid product id that does not match DNC ,      * @throws DRDAProtocolException,      */,     private void invalidClient(String prdid) throws DRDAProtocolException {,         Monitor.logMessage(new Date(),                 + " : ",                 + server.localizeMessage("DRDA_InvalidClient.S",,                         new String[] { prdid }));,         requiredValueNotFound(CodePoint.PRDID);, ,     },     ,     /*** Required value not found.,      * ,      * @param codePoint code point with invalid value,      * ,      */,     private void requiredValueNotFound(int codePoint) throws DRDAProtocolException {,         throwSyntaxrm(CodePoint.SYNERRCD_REQ_VAL_NOT_FOUND, codePoint);,     },     ,     ,     /**,      * Object length not allowed,      *,      * @param codePoint  code point with bad object length,      * @exception DRDAProtocolException,      */,     private void badObjectLength(int codePoint) throws DRDAProtocolException,     {,         throwSyntaxrm(CodePoint.SYNERRCD_OBJ_LEN_NOT_ALLOWED, codePoint);,     },     /**,      * RDB not found,      *,      * @param rdbnam  name of database,      * @exception DRDAProtocolException,      */,     private void rdbNotFound(String rdbnam) throws DRDAProtocolException,     {,         Object[] oa = {rdbnam};,         throw new,             DRDAProtocolException(DRDAProtocolException.DRDA_Proto_RDBNFNRM,,                                   this,0,,                                   DRDAProtocolException.NO_ASSOC_ERRCD, oa);,     },     /**,      * Invalid value for this code point,      *,      * @param codePoint  code point value,      * @exception DRDAProtocolException,      */,     private void invalidValue(int codePoint) throws DRDAProtocolException,     {,         throwSyntaxrm(CodePoint.SYNERRCD_REQ_VAL_NOT_FOUND, codePoint);,     },     /**,      * Invalid codepoint for this command,      *,      * @param codePoint code point value,      *,      * @exception DRDAProtocolException,      */,     protected void invalidCodePoint(int codePoint) throws DRDAProtocolException,     {,         throwSyntaxrm(CodePoint.SYNERRCD_INVALID_CP_FOR_CMD, codePoint);,     },     /**,      * Don't support this code point,      *,      * @param codePoint  code point value,      * @exception DRDAProtocolException,      */,     protected void codePointNotSupported(int codePoint) throws DRDAProtocolException,     {,         throw new,             DRDAProtocolException(DRDAProtocolException.DRDA_Proto_CMDNSPRM,,                                   this,codePoint,,                                   DRDAProtocolException.NO_ASSOC_ERRCD);,     },     /**,      * Don't support this value,      *,      * @param codePoint  code point value,      * @exception DRDAProtocolException,      */,     private void valueNotSupported(int codePoint) throws DRDAProtocolException,     {,         throw new,             DRDAProtocolException(DRDAProtocolException.DRDA_Proto_VALNSPRM,,                                   this,codePoint,,                                   DRDAProtocolException.NO_ASSOC_ERRCD);,     },     /**,      * Verify that the code point is the required code point,      *,      * @param codePoint code point we have,      * @param reqCodePoint code point required at this time,      *,      * @exception DRDAProtocolException,      */,     private void verifyRequiredObject(int codePoint, int reqCodePoint),         throws DRDAProtocolException,     {,         if (codePoint != reqCodePoint ),         {,             throwSyntaxrm(CodePoint.SYNERRCD_REQ_OBJ_NOT_FOUND,codePoint);,         },     },     /**,      * Verify that the code point is in the right order,      *,      * @param codePoint code point we have,      * @param reqCodePoint code point required at this time,      *,      * @exception DRDAProtocolException,      */,     private void verifyInOrderACCSEC_SECCHK(int codePoint, int reqCodePoint),         throws DRDAProtocolException,     {,         if (codePoint != reqCodePoint ),         {,             throw,                 new DRDAProtocolException(DRDAProtocolException.DRDA_Proto_PRCCNVRM,,                                           this, codePoint,,                                           CodePoint.PRCCNVCD_ACCSEC_SECCHK_WRONG_STATE);,         },     }, ,     /**,      * Database name given under code point doesn't match previous database names,      *,      * @param codePoint codepoint where the mismatch occurred,      *,      * @exception DRDAProtocolException,      */,     private void rdbnamMismatch(int codePoint),         throws DRDAProtocolException,     {,         throw new DRDAProtocolException(DRDAProtocolException.DRDA_Proto_PRCCNVRM,,                                           this, codePoint,,                                           CodePoint.PRCCNVCD_RDBNAM_MISMATCH);,     },     /**,      * Close the current session,      */,     private void closeSession(),     {,         if (session == null) {,             return;,         }, ,         /* DERBY-2220: Rollback the current XA transaction if it is,            still associated with the connection. */,         if (xaProto != null) {,             xaProto.rollbackCurrentTransaction();,         }, ,         server.removeFromSessionTable(session.connNum);,         try {,             session.close();,         } catch (SQLException se),         {,             // If something went wrong closing down the session.,             // Print an error to the console and close this ,             //thread. (6013),             sendUnexpectedException(se);,             close();,         },         finally {,             session = null;,             database = null;,             appRequester=null;,             sockis = null;,             sockos=null;,             databaseAccessException=null;,         },     }, ,     /**,      * Handle Exceptions - write error protocol if appropriate and close session,      *  or thread as appropriate,      */,     private void handleException(Exception e),     {,         try {,             if (e instanceof DRDAProtocolException) {,                 // protocol error - write error message,                 sendProtocolException((DRDAProtocolException) e);,             } else {,                 // something unexpected happened,                 sendUnexpectedException(e);,                 server.consoleExceptionPrintTrace(e);,             },         } finally {,             // always close the session and stop the thread after handling,             // these exceptions,             closeSession();,             close();,         },     },     ,     /**,      * Notice the client about a protocol error.,      *,      * @param de <code>DRDAProtocolException</code> to be sent,      */,     private void sendProtocolException(DRDAProtocolException de) {,         String dbname = getDbName();,         try {,             println2Log(dbname, session.drdaID, de.getMessage());,             server.consoleExceptionPrintTrace(de);,             reader.clearBuffer();,             de.write(writer);,             finalizeChain();,         } catch (DRDAProtocolException ioe) {,             // There may be an IO exception in the write.,             println2Log(dbname, session.drdaID, de.getMessage());,             server.consoleExceptionPrintTrace(ioe);,         },     }, ,     /**,      * Send unpexpected error to the client,      * @param e Exception to be sent,      */,     private void sendUnexpectedException(Exception e),     {, ,         DRDAProtocolException unExpDe;,         try {,             String dbname = getDbName();,             println2Log(dbname,session.drdaID, e.getMessage());,             server.consoleExceptionPrintTrace(e);,             unExpDe = DRDAProtocolException.newAgentError(this,,                                                           CodePoint.SVRCOD_PRMDMG,  ,                                                           dbname, e.getMessage());,         ,             reader.clearBuffer();,             unExpDe.write(writer);,             finalizeChain();,         },         catch (DRDAProtocolException nde) ,         {,             // we can't tell the client, but we tried.,         },         ,     }, , ,     /**,      * Test if DRDA connection thread is closed,      *,      * @return true if close; false otherwise,      */,     private boolean closed(),     {,         return close;,     },     /**,      * Get whether connections are logged,      *,      * @return true if connections are being logged; false otherwise,      */,     private boolean getLogConnections(),     {,         return logConnections;,     },     /**,      * Get time slice value for length of time to work on a session,      *,      * @return time slice,      */,     private long getTimeSlice(),     {,         return timeSlice;,     },     /**,      * Send string to console,      *,      * @param value - value to print on console,      */,     protected  void trace(String value),     {,         if (SanityManager.DEBUG && server.debugOutput() == true) {,             server.consoleMessage(value, true);,         },     }, , ,     /**,      * Sends a trace string to the console when reading an EXTDTA value (if,      * tracing is enabled).,      *,      * @param drdaType the DRDA type of the EXTDTA value,      * @param index the one-based parameter index,      * @param stream the stream being read,      * @param streamLOB whether or not the value is being streamed as the last,      *      parameter value in the DRDA protocol flow,      * @param encoding the encoding of the data, if any,      */,     private void traceEXTDTARead(int drdaType, int index,,                                  EXTDTAReaderInputStream stream,,                                  boolean streamLOB, String encoding) {,         if (SanityManager.DEBUG && server.debugOutput() == true) {,             StringBuilder sb = new StringBuilder("Reading/setting EXTDTA: ");,             // Data: t<type>/i<ob_index>/<streamLOB>/<encoding>/,             //       <statusByteExpected>/b<byteLength>,             sb.append("t").append(drdaType).append("/i").append(index).,                     append("/").append(streamLOB).,                     append("/").append(encoding).append("/").,                     append(stream.readStatusByte). append("/b");,             if (stream == null) {,                 sb.append("NULL");,             } else if (stream.isLayerBStream()) {,                 sb.append("UNKNOWN_LENGTH");,             } else {,                 sb.append(,                         ((StandardEXTDTAReaderInputStream)stream).getLength());,             },             trace(sb.toString());,         },     }, ,     /***,      * Show runtime memory,      *,      ***/,     public static void showmem() {,         Runtime rt = Runtime.getRuntime();,         Date d = new Date();,         rt.gc();,         System.out.println("total memory: ",                            + rt.totalMemory(),                            + " free: ",                            + rt.freeMemory(),                            + " " + d.toString());, ,     }, ,     /**,      * convert byte array to a Hex string,      * ,      * @param buf buffer to  convert,      * @return hex string representation of byte array,      */,     private String convertToHexString(byte [] buf),     {,         return "0x" + StringUtil.toHexString(buf, 0, buf.length);,     },     /**,      * check that the given typdefnam is acceptable,      * ,      * @param typdefnam ,      *,      * @exception DRDAProtocolException,      */,     private void checkValidTypDefNam(String typdefnam),         throws DRDAProtocolException,     {,         if (!(typdefnam.equals("QTDSQL370"),                 || typdefnam.equals("QTDSQL400"),                 || typdefnam.equals("QTDSQLX86"),                 || typdefnam.equals("QTDSQLASC"),                 || typdefnam.equals("QTDSQLVAX"),                 || typdefnam.equals("QTDSQLJVM"))) {,             invalidValue(CodePoint.TYPDEFNAM);,         },     },     /**,      * Check that the length is equal to the required length for this codepoint,      *,      * @param codepoint codepoint we are checking,      * @param reqlen    required length,      * ,      * @exception DRDAProtocolException,      */,     private void checkLength(int codepoint, int reqlen),         throws DRDAProtocolException,     {,         long len = reader.getDdmLength();,         if (len < reqlen) {,             badObjectLength(codepoint);,         } else if (len > reqlen) {,             tooBig(codepoint);,         },     },     /**,      * Read and check a boolean value,      * ,      * @param codepoint codePoint to be used in error reporting,      * @return true or false depending on boolean value read,      *,      * @exception DRDAProtocolException,      */,     private boolean readBoolean(int codepoint) throws DRDAProtocolException,     {,         checkLength(codepoint, 1);,         byte val = reader.readByte();,         if (val == CodePoint.TRUE) {,             return true;,         } else if (val == CodePoint.FALSE) {,             return false;,         } else {,             invalidValue(codepoint);,             return false;   // to shut the compiler up,         },     },     /**,      * Create a new database and intialize the ,      * DRDAConnThread database.,      * ,      * @param dbname database name to initialize. If ,      * dbnam is non null, add database to the current session,      *,      */,     private void initializeDatabase(String dbname),     {,         Database db;,         if (appRequester.isXARequester()),         {,             db = new XADatabase(dbname);,         },         else,         {,             db = new Database(dbname);,         },         if (dbname != null) {,             session.addDatabase(db);,             session.database = db;,         },         database = db;,     },     /**,      * Set the current database,      * ,      * @param codePoint     codepoint we are processing,      *,      * @exception DRDAProtocolException,      */,     private void setDatabase(int codePoint) throws DRDAProtocolException,     {,         String dbname = parseRDBNAM();,         // using same database so we are done,         if (database != null && database.getDatabaseName().equals(dbname)) {,             return;,         },         Database d = session.getDatabase(dbname);,         if (d == null) {,             rdbnamMismatch(codePoint);,         } else {,             database = d;,         },         session.database = d;,     },     /**,      * Write ENDUOWRM,      * Instance Variables,      *  SVCOD - severity code - WARNING - required,      *  UOWDSP - Unit of Work Disposition - required,      *  RDBNAM - Relational Database name - optional,      *  SRVDGN - Server Diagnostics information - optional,      *,      * @param opType - operation type 1 - commit, 2 -rollback,      */,     private void writeENDUOWRM(int opType),     {,         writer.createDssReply();,         writer.startDdm(CodePoint.ENDUOWRM);,         writer.writeScalar2Bytes(CodePoint.SVRCOD, CodePoint.SVRCOD_WARNING);,         writer.writeScalar1Byte(CodePoint.UOWDSP, opType);,         writer.endDdmAndDss();,     }, ,   void writeEXTDTA (DRDAStatement stmt) throws SQLException, DRDAProtocolException,   {,       ArrayList<Object> extdtaValues = stmt.getExtDtaObjects();,     // build the EXTDTA data, if necessary,     if (extdtaValues == null) {,         return;,     },     boolean chainFlag, chainedWithSameCorrelator;,     boolean writeNullByte = false;, ,     for (int i = 0; i < extdtaValues.size(); i++) {,         // is this the last EXTDTA to be built?,         if (i != extdtaValues.size() - 1) { // no,             chainFlag = true;,             chainedWithSameCorrelator = true;,         },         else { // yes,             chainFlag = false; //last blob DSS stream itself is NOT chained with the NEXT DSS,             chainedWithSameCorrelator = false;,         }, ,         ,         if ((sqlamLevel >= MGRLVL_7) && stmt.isExtDtaValueNullable(i)) {,             writeNullByte = true;,         },         ,         Object o  = extdtaValues.get(i);,         if (o instanceof EXTDTAInputStream) {,             EXTDTAInputStream stream = (EXTDTAInputStream) o;,                         ,             try{,                         stream.initInputStream();,             writer.writeScalarStream (chainedWithSameCorrelator,,                                       CodePoint.EXTDTA,,                                       stream,,                                       writeNullByte);,             ,             }finally{,                 // close the stream when done,                 closeStream(stream);,         },             ,         },     },     // reset extdtaValues after sending,     stmt.clearExtDtaObjects();, ,   }, , ,     /**,      * Check SQLWarning and write SQLCARD as needed.,      * ,      * @param conn      connection to check,      * @param stmt      statement to check,      * @param rs        result set to check,      * @param updateCount   update count to include in SQLCARD,      * @param alwaysSend    whether always send SQLCARD regardless of,      *                      the existance of warnings,      * @param sendWarn  whether to send any warnings or not.,      *,      * @exception DRDAProtocolException,      */,     private void checkWarning(Connection conn, Statement stmt, ResultSet rs,,                           long updateCount, boolean alwaysSend, boolean sendWarn),         throws DRDAProtocolException, SQLException,     {,         // instead of writing a chain of sql warning, we send the first one, this is,         // jcc/db2 limitation, see beetle 4629,         SQLWarning reportWarning = null;,         try,         {,             if (stmt != null),             {,                 SQLWarning warning = stmt.getWarnings();,                 if (warning != null),                 {,                     stmt.clearWarnings();,                     reportWarning = warning;,                 },             },             if (rs != null),             {,                 SQLWarning warning = rs.getWarnings();,                 if (warning != null),                 {,                     rs.clearWarnings();,                     if (reportWarning == null) {,                         reportWarning = warning;,                     },                 },             },             if (conn != null),             {,                 SQLWarning warning = conn.getWarnings();,                 if (warning != null),                 {,                     conn.clearWarnings();,                     if (reportWarning == null) {,                         reportWarning = warning;,                     },                 },             },             ,         },         catch (SQLException se),         {,             if (SanityManager.DEBUG) {,                 trace("got SQLException while trying to get warnings.");,             },         }, , ,         if ((alwaysSend || reportWarning != null) && sendWarn) {,             writeSQLCARDs(reportWarning, updateCount);,         },     }, ,     boolean hasSession() {,         return session != null;,     },     ,     long getBytesRead() {,         return reader.totalByteCount;,     },     ,     long getBytesWritten() {,         return writer.totalByteCount;,     }, ,     protected String buildRuntimeInfo(String indent, LocalizedResource localLangUtil ),     {,         if (!hasSession()) {,             return "";,         } else {,             return session.buildRuntimeInfo("", localLangUtil) + "\n";,         },     }, , ,     /**,      * Finalize the current DSS chain and send it if,      * needed.,      */,     private void finalizeChain() throws DRDAProtocolException {,         writer.finalizeChain(reader.getCurrChainState(), getOutputStream());,     }, ,     /**,      *  Validate SECMEC_USRSSBPWD (Strong Password Substitute) can be used as,      *  DRDA security mechanism.,      *,      *  Here we check that the target server can support SECMEC_USRSSBPWD,      *  security mechanism based on the environment, application,      *  requester's identity (PRDID) and connection URL.,      *,      *  IMPORTANT NOTE:,      *  --------------,      *  SECMEC_USRSSBPWD is ONLY supported by the target server if:,      *      - current authentication provider is Derby BUILTIN or,      *        NONE. (database / system level) (Phase I),      *      - database-level password must have been encrypted with the,      *        SHA-1 based authentication scheme,      *      - Application requester is 'DNC' (Derby Network Client),      *        (Phase I),      *,      *  @return security check code - 0 if everything O.K.,      */,     private int validateSecMecUSRSSBPWD() throws  DRDAProtocolException,     {,         AuthenticationService authenticationService = null;,         org.apache.derby.iapi.db.Database databaseObj = null;,         String srvrlslv = appRequester.srvrlslv;, ,         // Check if application requester is the Derby Network Client (DNC),         //,         // We use a trick here - as the product ID is not yet available,         // since ACCRDB message is only coming later, we check the server,         // release level field sent as part of the initial EXCSAT message;,         // indeed, the product ID (PRDID) is prefixed to in the field.,         // Derby always sets it as part of the EXCSAT message so if it is,         // not available, we stop here and inform the requester that,         // SECMEC_USRSSBPWD cannot be supported for this connection.,         if ((srvrlslv == null) || (srvrlslv.length() == 0) ||,             (srvrlslv.length() < CodePoint.PRDID_MAX) ||,             (srvrlslv.indexOf(DRDAConstants.DERBY_DRDA_CLIENT_ID),                     == -1)) {,             return CodePoint.SECCHKCD_NOTSUPPORTED; // Not Supported,         }, , ,         // Client product version is extracted from the srvrlslv field.,         // srvrlslv has the format <PRDID>/<ALTERNATE VERSION FORMAT>,         // typically, a known Derby client has a four part version number,         // with a pattern such as DNC10020/10.2.0.3 alpha. If the alternate,         // version format is not specified, clientProductVersion_ will just,         // be set to the srvrlslvl. Final fallback will be the product id.,         //,         // SECMEC_USRSSBPWD is only supported by the Derby engine and network,         // server code starting at version major '10' and minor '02'. Hence,,         // as this is the same for the derby client driver, we need to ensure,         // our DNC client is at version and release level of 10.2 at least.,         // We set the client version in the application requester and check,         // if it is at the level we require at a minimum.,         appRequester.setClientVersion(,                 srvrlslv.substring(0, (int) CodePoint.PRDID_MAX));, ,         if (appRequester.supportsSecMecUSRSSBPWD() == false) {,             return CodePoint.SECCHKCD_NOTSUPPORTED; // Not Supported,         }, ,         String dbName = database.getShortDbName();,         // Check if the database is available (booted),         // ,         // First we need to have the database name available and it should,         // have been set as part of the ACCSEC request (in the case of a Derby,         // 'DNC' client),         if ((dbName == null) || (dbName.length() == 0)),         {,             // No database specified in the connection URL attributes,             //,             // In this case, we get the authentication service handle from the,             // local driver, as the requester may simply be trying to shutdown,             // the engine.,             authenticationService = ((InternalDriver),               NetworkServerControlImpl.getDriver()).getAuthenticationService();,         },         else,         {,             // We get the authentication service from the database as this,             // last one might have specified its own auth provider (at the,             // database level).,             // ,             // if monitor is never setup by any ModuleControl, getMonitor,             // returns null and no Derby database has been booted. ,             if (Monitor.getMonitor() != null) {,                 databaseObj = (org.apache.derby.iapi.db.Database),                     Monitor.findService(Property.DATABASE_MODULE, dbName);,             }, ,             if (databaseObj == null),             {,                 // If database is not found, try connecting to it. ,                 database.makeDummyConnection();, ,                 // now try to find it again,                 databaseObj = (org.apache.derby.iapi.db.Database),                     Monitor.findService(Property.DATABASE_MODULE, dbName);,             }, ,             // If database still could not be found, it means the database,             // does not exist - we just return security mechanism not,             // supported down below as we could not verify we can handle,             // it.,             try {,                 if (databaseObj != null) {,                     authenticationService =,                         databaseObj.getAuthenticationService();,                 },             } catch (StandardException se) {,                 println2Log(null, session.drdaID, se.getMessage());,                 // Local security service non-retryable error.,                 return CodePoint.SECCHKCD_0A;,             }, ,         }, ,         // Now we check if the authentication provider is NONE or BUILTIN,         if (authenticationService != null),         {,             String authClassName = authenticationService.getClass().getName();,                 ,             if (!authClassName.equals(AUTHENTICATION_PROVIDER_BUILTIN_CLASS) &&,                 !authClassName.equals(AUTHENTICATION_PROVIDER_NONE_CLASS)) {,                 return CodePoint.SECCHKCD_NOTSUPPORTED; // Not Supported,             },         }, ,         // SECMEC_USRSSBPWD target initialization,         try {,             myTargetSeed = DecryptionManager.generateSeed();,             database.secTokenOut = myTargetSeed;,         } catch (SQLException se) {,             println2Log(null, session.drdaID, se.getMessage());,             // Local security service non-retryable error.,            return CodePoint.SECCHKCD_0A;,         },                                 ,         return 0; // SECMEC_USRSSBPWD is supported,     }, ,     /**,      * Close a stream.,      *,      * @param stream the stream to close (possibly {@code null}),      * @throws SQLException wrapped around an {@code IOException} if closing,      * the stream failed,      */,     private static void closeStream(InputStream stream) throws SQLException {,         try {,             if (stream != null) {,                 stream.close();,             },         } catch (IOException e) {,             throw Util.javaException(e);,         },     },     ,     ,     private static InputStream,         convertAsByteArrayInputStream( EXTDTAReaderInputStream stream ),         throws IOException {, ,         // Suppress the exception that may be thrown when reading the status,         // byte here, we want the embedded statement to fail while executing.,         stream.setSuppressException(true);, ,         final int byteArrayLength = ,             stream instanceof StandardEXTDTAReaderInputStream ?,             (int) ( ( StandardEXTDTAReaderInputStream ) stream ).getLength() : ,             1 + stream.available(); // +1 to avoid infinite loop, ,         // TODO: We will run into OOMEs for large values here.,         //       Could avoid this by saving value temporarily to disk, for,         //       instance by using the existing LOB code.,         PublicBufferOutputStream pbos = ,             new PublicBufferOutputStream( byteArrayLength );, ,         byte[] buffer = new byte[Math.min(byteArrayLength, 32*1024)];,         ,         int c;,         ,         while( ( c = stream.read( buffer,,                                   0,,                                   buffer.length ) ) > -1 ) {,             pbos.write( buffer, 0, c );,         }, ,         // Check if the client driver encountered any errors when reading the,         // source on the client side.,         if (stream.isStatusSet() &&,                 stream.getStatus() != DRDAConstants.STREAM_OK) {,             // Create a stream that will just fail when accessed.,             return new FailingEXTDTAInputStream(stream.getStatus());,         } else {,             return new ByteArrayInputStream( pbos.getBuffer(),,                                              0,,                                              pbos.getCount() );,         }, ,     },     ,     ,     private static class PublicBufferOutputStream extends ByteArrayOutputStream{,         ,         PublicBufferOutputStream(int size){,             super(size);,         },         ,         public byte[] getBuffer(){,             return buf;,         },         ,         public int getCount(){,             return count;,         },         ,     },     ,     /**,      * Sets the specified character EXTDTA parameter of the embedded statement.,      *,      * @param stmt the DRDA statement to use,      * @param i the one-based index of the parameter,      * @param extdtaStream the EXTDTA stream to read data from,      * @param streamLOB whether or not the stream content is streamed as the,      *      last value in the DRDA protocol flow,      * @param encoding the encoding of the EXTDTA stream,      * @throws IOException if reading from the stream fails,      * @throws SQLException if setting the stream fails,      */,     private static void setAsCharacterStream(,                                          DRDAStatement stmt,,                                          int i,,                                          EXTDTAReaderInputStream extdtaStream,,                                          boolean streamLOB,,                                          String encoding),            throws IOException, SQLException {,         PreparedStatement ps = stmt.getPreparedStatement();,         ,         // DERBY-3085. Save the stream so it can be drained later,         // if not  used.,         if (streamLOB) {,             stmt.setStreamedParameter(extdtaStream);,         },         ,         final InputStream is = ,             streamLOB ?,             (InputStream) extdtaStream :,             convertAsByteArrayInputStream( extdtaStream );,         ,         final InputStreamReader streamReader = ,             new InputStreamReader( is,,                                    encoding ) ;,         ,         ps.setCharacterStream(i, streamReader);,     }, ,     /**,      * Sets the specified binary EXTDTA parameter of the embedded statement.,      *,      * @param stmt the DRDA statement to use,      * @param index the one-based index of the parameter,      * @param stream the EXTDTA stream to read data from,      * @param streamLOB whether or not the stream content is streamed as the,      *      last value in the DRDA protocol flow,      * @throws IOException if reading from the stream fails,      * @throws SQLException  if setting the stream fails,      */,     private static void setAsBinaryStream(DRDAStatement stmt,,                                           int index,,                                           EXTDTAReaderInputStream stream,,                                           boolean streamLOB),             throws IOException, SQLException {,         int type = stmt.getParameterMetaData().getParameterType(index);,         boolean useSetBinaryStream = (type == Types.BLOB);,         PreparedStatement ps = stmt.getPreparedStatement();, ,         if (streamLOB && useSetBinaryStream) {,             // Save the streamed parameter so we can drain it if it does not,             // get used by embedded when the statement is executed. DERBY-3085,             stmt.setStreamedParameter(stream);,             if (stream == null) {,                 ps.setBytes(index, null);,             } else if (!stream.isLayerBStream()) {,                 int length = (int)((StandardEXTDTAReaderInputStream),                                                             stream).getLength();,                 ps.setBinaryStream(index, stream, length);, ,             } else {,                 ps.setBinaryStream(index, stream);,             },         } else {,             if (stream == null) {,                 ps.setBytes(index, null);,             } else {,                 InputStream bais = convertAsByteArrayInputStream(stream);,                 ps.setBinaryStream(index, bais, bais.available());,             },         },     }],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/derby/impl/drda/DRDAProtocolExceptionInfo.java,,59-64,[    {,     this.errorCodePoint = errorCodePoint;,     this.svrcod = svrcod;,     this.errCdCodePoint = errCdCodePoint;,     this.sendsCodpntArg = sendsCodpntArg;,     }],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/drda/DRDAProtocolException.java,,371-371,[        if (rdbnam != null && agent != null)],,
STYLE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,getRsLen,248-248,[        return rsLens[index -1];],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,362-362,[        maxblkext = 0;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,376-376,[        nbrrow = 0;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,363-363,[        outovropt = 0;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,370-370,[        qryblkrst = false;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,365-365,[        qryrelscr = false;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,367-367,[        qryrfrtbl = false;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,369-369,[        qryrowsns = false; ],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,358-358,[        rowCount = 0;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,377-377,[        rslsetflg = null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,375-375,[        rtnextdta = 0;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/drda/DRDAResultSet.java,hasLobColumns,414-414,[        ResultSetMetaData rsmd = rs.getMetaData();],,
CORRECTNESS,UWF_NULL_FIELD,org/apache/derby/impl/drda/DRDAResultSet.java,,248-248,[        return rsLens[index -1];],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/drda/DRDAStatement.java,getSQLText,1704-1704,[        catch (Exception e)],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/drda/DRDAStatement.java,getSQLText,1702-1702,[            retVal = (String) sh.invoke(getPreparedStatement(),args);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/drda/DRDAStatement.java,getSQLText,1704-1704,[        catch (Exception e)],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/drda/DRDAStatement.java,setupCallableStatementParams,1441-1454,[            switch (parameterMode) {,                 case (ParameterMetaData.parameterModeIn):,                     break;,                 case (ParameterMetaData.parameterModeOut):,                 case (ParameterMetaData.parameterModeInOut):,                     outputFlag = true;,                     break;,                 case (ParameterMetaData.parameterModeUnknown):,                     // It's only unknown if array,                     String objectType = pmeta.getParameterClassName(i+1);,                     parameterType =,                         getOutputParameterTypeFromClassName(objectType);,                     if (parameterType  != NOT_OUTPUT_PARAM),                         outputFlag = true;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAStatement.java,,316-316,[        this.ccsidDBC = database.ccsidDBC;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAStatement.java,,317-317,[        this.ccsidMBC = database.ccsidMBC;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAStatement.java,,315-315,[        this.ccsidSBC = database.ccsidSBC;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/DRDAStatement.java,,1102-1102,[        maxrslcnt = 0;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/drda/DRDAXAProtocol.java,getResourceAdapter,719-719,[        return ((XADatabase)connThread.getDatabase()).getResourceAdapter();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/drda/DRDAXAProtocol.java,getXAResource,606-606,[        return ((XADatabase) connThread.getDatabase()).getXAResource();],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/drda/DRDAXAProtocol.java,parseSYNCCTL,146-147,[                commitTransaction(xid,xaflags);,                 break;],,parseSYNCCTL,150-151,[                commitTransaction(xid, xaflags);,                 break;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/drda/Database.java,makeDummyConnection,283-283,[        } catch (SQLException se) {} // Simply do nothing],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/DecryptionManager.java,obtainPublicKey,157-157,[    byte[] publicEnc =   keyPair_.getPublic().getEncoded();],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/drda/DssTrace.java,run,192-192,[                                    PrintWriter pw =],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/drda/DssTrace.java,,187-201,[                            new PrivilegedExceptionAction<PrintWriter>() {,                                 public PrintWriter run(),                                         throws SecurityException, IOException {,                                     File f = new File(fileName);,                                     boolean exists = f.exists();,                                     PrintWriter pw =,                                         new PrintWriter(,                                             new java.io.BufferedWriter(,                                                 new java.io.FileWriter(,                                                     fileName),,                                                 4096));,                                     if (!exists) {,                                         FileUtil.limitAccessToOwner(f);,                                     },                                     return pw;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/drda/DssTrace.java,,215-237,[                                    new PrivilegedExceptionAction<Void>() {,                                         public Void run() throws IOException {,                                             // DERBY-4128: First try to create the,                                             // directory with mkdir(), as that doesn't,                                             // require read permission for the parent,                                             // directory. It will only succeed if the,                                             // parent directory exists. If mkdir(),                                             // fails, retry with mkdirs(), which will,                                             // create the parent directories as needed,,                                             // but which also requires that read,                                             // permission for the parent directory,                                             // has been granted.,                                             boolean created = traceDirectory.mkdir();,                                             if (!created) {,                                                 created =,                                                         traceDirectory.mkdirs();,                                             }, ,                                             if (created) {,                                                 FileUtil.limitAccessToOwner(,                                                         traceDirectory);,                                             },                                             return null;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/drda/EXTDTAInputStream.java,initInputStream,330-330,[    if (! is.markSupported()) {],,initInputStream,299-299,[    InputStream is = null;],,initInputStream,329-329,[        else { badDRDAType( ndrdaType ); }],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/FdocaConstants.java,,121-121,[    protected static int LONGVARCHAR_LEN_NUMBYTES = 2;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/drda/FdocaConstants.java,,126-126,[    protected static int NUMERIC_DEFAULT_SCALE=15;],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/impl/drda/NaiveTrustManager.java,getSocketFactory,67-68,[        if (thisManager == null) {,             thisManager = new TrustManager [] {new NaiveTrustManager()};],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/impl/drda/NaiveTrustManager.java,getSocketFactory,89-89,[            ks.load(new FileInputStream(keyStore),],,getSocketFactory,90-90,[                    keyStorePassword.toCharArray());],,getSocketFactory,92-92,[            KeyManagerFactory kmf = ],,getSocketFactory,93-93,[                KeyManagerFactory.getInstance("SunX509", "SunJSSE");],,getSocketFactory,94-94,[            kmf.init(ks, keyStorePassword.toCharArray());],,getSocketFactory,96-96,[            ctx.init(kmf.getKeyManagers(),],,getSocketFactory,99-99,[        } else {],,getSocketFactory,105-105,[        return ctx.getSocketFactory();],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/drda/NaiveTrustManager.java,getSocketFactory,89-89,[            ks.load(new FileInputStream(keyStore),],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,createServerSocket,723-723,[            return (SSLServerSocket)ssf.createServerSocket(portNumber,],,createServerSocket,730-730,[                (SSLServerSocket)ssf2.createServerSocket(portNumber,],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,consolePrintAndIgnore,995-995,[        } catch (Exception ce) {} ],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,blockingStart,983-983,[            } catch (Exception e) {}],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,clientSocketError,2865-2865,[        } catch (Exception ce) {} // catch the exception consolePropertyMessage will],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,unknownHostException,2709-2709,[        } catch (Exception e)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,processCommands,1708-1708,[            int codesetLen = reader.readByte();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,throwSQLException,3412-3412,[                ce = se;],,throwSQLException,3418-3418,[                ce = ne;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,throwSQLWarning,3472-3472,[                ce = se;],,throwSQLWarning,3478-3478,[                ce = ne;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,processCommands,1690-1690,[            String protocolStr = reader.readCmdString(4);],,
PERFORMANCE,DM_BOXED_PRIMITIVE_TOSTRING,org/apache/derby/impl/drda/NetworkServerControlImpl.java,pingWithNoOpen,1299-1299,[                        (new Integer(portNumber)).toString(), ],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/drda/NetworkServerControlImpl.java,getCLSSysInfo,2242-2242,[        return bos.toString();],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/drda/NetworkServerControlImpl.java,getNetSysInfo,2215-2215,[        sysinfo.append(bos.toString());],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/drda/NetworkServerControlImpl.java,getNetSysInfo,2213-2213,[        PrintStream ps =  new PrintStream(bos);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/drda/NetworkServerControlImpl.java,makePrintWriter,519-519,[            return new PrintWriter(out, true /* flush the buffer at the end of each line */);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/drda/NetworkServerControlImpl.java,shutdown,1135-1135,[            setLogWriter(new PrintWriter(silentStream));],,
PERFORMANCE,DM_GC,org/apache/derby/impl/drda/NetworkServerControlImpl.java,buildRuntimeInfo,4086-4086,[        rt.gc();],,
PERFORMANCE,DM_GC,org/apache/derby/impl/drda/NetworkServerControlImpl.java,startNetworkServer,1047-1047,[                        System.gc();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/drda/NetworkServerControlImpl.java,pingWithNoOpen,1297-1297,[                consolePropertyMessage("DRDA_NoIO.S",],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/derby/impl/drda/NetworkServerControlImpl.java,writeCommandHeader,2752-2752,[            if (clientLocale != null && clientLocale != DEFAULT_LOCALE)],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/drda/NetworkServerControlImpl.java,,3339-3339,[        if (currentSession != null && ],,,3342-3342,[            locMsg = localizeMessage(messageKey, currentSession.langUtil, args);],,,2238-2238,[        if (currentSession != null && currentSession.langUtil != null)],,,2239-2239,[        localLangUtil = currentSession.langUtil;],,,2102-2102,[            if (currentSession != null && currentSession.langUtil != null &&],,,2105-2105,[                locMsg.append(se.getSQLState()+":"+ ],,,1837-1837,[            currentSession = null;],,,1702-1702,[                currentSession = session;],,,1723-1723,[                currentSession = null;],,,2197-2197,[        if (currentSession != null && currentSession.langUtil != null)],,,2198-2198,[        localLangUtil = currentSession.langUtil;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/drda/NetworkServerControlImpl.java,,2496-2496,[                    databaseArg = args[pos];],,,1778-1778,[                    databaseArg = reader.readCmdString();],,,1781-1781,[                    if (databaseArg != null)],,,1782-1782,[                        connectToDatabase(writer, databaseArg, userArg, passwordArg);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/drda/NetworkServerControlImpl.java,,2532-2532,[                        sessionArg = Integer.parseInt(args[pos]);],,,2307-2307,[                    trace(sessionArg, on);],,,2308-2308,[                    consoleTraceMessage(sessionArg, on);],,,3658-3658,[        if (sessionArg == 0)],,,3680-3680,[            Session session = sessionTable.get(sessionArg);],,,1754-1754,[                    sessionArg = reader.readNetworkInt();],,,1762-1762,[                        if (sessionArg != 0)],,,1763-1763,[                            sendMessage(writer, ERROR,  ],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/drda/NetworkServerControlImpl.java,runQueueAdd,2385-2385,[            runQueue.notify();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,setLogWriter,554-554,[            logWriter = outWriter;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,logConnectionsChange,1851-1851,[        consolePropertyMessage( messageID, args );],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,pingWithNoOpen,1291-1291,[                writeLDString(database);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,pingWithNoOpen,1293-1293,[                writeLDString(password);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,pingWithNoOpen,1292-1292,[                writeLDString(user);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,processCommands,1704-1704,[                session.langUtil = new LocalizedResource(codeset,locale,DRDA_PROP_MESSAGES);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/drda/NetworkServerControlImpl.java,readBytesReply,3047-3047,[        return null;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/drda/NetworkServerControlImpl.java,startNetworkServer,1054-1054,[                catch (Exception e) {],,
CORRECTNESS,SA_FIELD_SELF_COMPARISON,org/apache/derby/impl/drda/NetworkServerControlImpl.java,startNetworkServer,1017-1017,[            if (restartCheck == this.restartFlag) {],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/drda/NetworkServerControlImpl.java,buildRuntimeInfo,4068-4068,[                s += sessionInfo + "\n";],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/drda/NetworkServerControlImpl.java,processCommands,1727-1824,[            switch(command),             {,                 case COMMAND_SHUTDOWN:,                     if (version == SHUTDOWN_WITH_CREDENTIAL_PROTOCOL_VERSION) {,                         //Protocol version of client is not at default protocol,                         //of 1 because this version of shutdown command has,                         //username and password supplied with it. When the,                         //protocol version of client is ,                         //SHUTDOWN_WITH_CREDENTIAL_PROTOCOL_VERSION, then we ,                         //know to expect username and password,                         // DERBY-2109: receive user credentials for shutdown,                         // System Privileges check,                         userArg = reader.readCmdString();,                         passwordArg = reader.readCmdString();,                     },                     try {,                         checkShutdownPrivileges();,                         sendOK(writer);,                         directShutdownInternal();,                     } catch (SQLException sqle) {,                         sendSQLMessage(writer, sqle, SQLERROR);,                         // also print a message to the console,                         consolePropertyMessage("DRDA_ShutdownWarning.I",,                                                sqle.getMessage());,                     },                     break;,                 case COMMAND_TRACE:,                     sessionArg = reader.readNetworkInt();,                     boolean on = (reader.readByte() == 1);,                     if (setTrace(on)),                     {,                         sendOK(writer);,                     },                     else,                     {,                         if (sessionArg != 0),                             sendMessage(writer, ERROR,  ,                                 localizeMessage("DRDA_SessionNotFound.U", ,                                         (session.langUtil == null) ? langUtil : session.langUtil,,                                         new String [] {Integer.toString(sessionArg)}));,                         else,                             sendMessage(writer, ERROR,  ,                                         localizeMessage("DRDA_ErrorStartingTracing.S",null));          ,                     },                     break;,                 case COMMAND_TRACEDIRECTORY:,                     setTraceDirectory(reader.readCmdString());,                     sendOK(writer);,                     consolePropertyMessage("DRDA_TraceDirectoryChange.I", traceDirectory);,                     break;,                 case COMMAND_TESTCONNECTION:,                     databaseArg = reader.readCmdString();,                     userArg = reader.readCmdString();,                     passwordArg = reader.readCmdString();,                     if (databaseArg != null),                         connectToDatabase(writer, databaseArg, userArg, passwordArg);,                     else,                         sendOK(writer);,                     break;,                 case COMMAND_LOGCONNECTIONS:,                     boolean log = (reader.readByte() == 1);,                     setLogConnections(log);,                     sendOK(writer);,                     logConnectionsChange( log );,                     break;,                 case COMMAND_SYSINFO:,                     sendSysInfo(writer);,                     break;,                 case COMMAND_PROPERTIES:,                     sendPropInfo(writer);,                     break;,                 case COMMAND_RUNTIME_INFO:,                     sendRuntimeInfo(writer);,                     break;,                 case COMMAND_MAXTHREADS:,                     int max = reader.readNetworkInt();,                     try {,                         setMaxThreads(max);,                     }catch (Exception e) {,                         sendMessage(writer, ERROR, e.getMessage());,                         return;,                     },                     int newval = getMaxThreads();,                     sendOKInt(writer, newval);,                     consolePropertyMessage("DRDA_MaxThreadsChange.I", ,                         String.valueOf(newval));,                     break;,                 case COMMAND_TIMESLICE:,                     int timeslice = reader.readNetworkInt();,                     try {,                         setTimeSlice(timeslice);,                     }catch (Exception e) {,                         sendMessage(writer, ERROR, e.getMessage());,                         return;,                     },                     newval = getTimeSlice();,                     sendOKInt(writer, newval);,                     consolePropertyMessage("DRDA_TimeSliceChange.I", ],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/impl/drda/NetworkServerControlImpl.java,init,492-492,[            prdId += "0";],,init,493-493,[        prdId += majorStr;],,init,496-496,[            prdId += "0";],,init,498-498,[        prdId += minorStr;],,init,500-500,[        prdId += drdaMaintStr;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/impl/drda/NetworkServerControlImpl.java,startNetworkServer,1046-1046,[                        cloudscapeDriver = null;    // so it gets collected.],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/drda/NetworkServerControlImpl.java,writeShort,2815-2822,[            commandOs.writeByte((byte)((value & 0xf0) >> 8 ));,             commandOs.writeByte((byte)(value & 0x0f));,         },         catch (IOException e),         {,             clientSocketError(e);,         },     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/drda/NetworkServerControlImpl.java,,895-898,[                                new PrivilegedAction<Void>() {,                                     public Void run() {,                                         threadi.interrupt();,                                         return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/drda/NetworkServerControlImpl.java,,1125-1133,[            FilterOutputStream silentStream = new FilterOutputStream(null) {,                 public void write(int b) {,                 }, ,                 public void flush() {,                 }, ,                 public void close() {,                 }],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/drda/NetworkServerControlImpl.java,run,2625-2625,[                                                createSocket(hostAddress, portNumber);],,run,2632-2632,[                                                createSocket(hostAddress, portNumber);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/drda/NetworkServerControlImpl.java,,4152-4159,[                new PrivilegedExceptionAction<ProductVersionHolder>() {,                     public ProductVersionHolder run(),                             throws UnknownHostException, IOException {,                         InputStream versionStream =,                             getClass().getResourceAsStream(,                                 ProductGenusNames.NET_INFO);,                         return ProductVersionHolder.,                                 getProductVersionHolderFromMyEnv(versionStream);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/drda/Utf8CcsidManager.java,convertFromJavaString,56-56,[        return null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/drda/XADatabase.java,,139-139,[        return this.ra;],,,99-99,[            ra = xaDataSource.getResourceAdapter();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/drda/XADatabase.java,makeConnection,78-78,[            } catch (Exception e) {],,
PERFORMANCE,DM_GC,org/apache/derby/impl/drda/memCheck.java,freeMemory,67-67,[        rt.gc();],,
PERFORMANCE,DM_GC,org/apache/derby/impl/drda/memCheck.java,getMemInfo,51-51,[    rt.gc();],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/drda/memCheck.java,,27-82,[    int delay = 200000;,     boolean stopNow = false;, , public memCheck () {}, , public  memCheck (int num) {,     delay = num;, }, , public void run () {,     while (stopNow == false) {,         try {,             showmem();,             sleep(delay);,         } catch (java.lang.InterruptedException ie) {,             System.out.println("memcheck interrupted");,             stopNow = true;,         },     }, }, ,     public static String getMemInfo() {,     Runtime rt = null;,     rt = Runtime.getRuntime();,     rt.gc();,     return "total memory: " ,         + rt.totalMemory(),         + " free: ",         + rt.freeMemory();,     ,     }, ,     public static long totalMemory() {,         Runtime rt = Runtime.getRuntime();,         return rt.totalMemory();,     }, ,     public static long freeMemory() {,         ,         Runtime rt =  Runtime.getRuntime();,         rt.gc();,         return rt.freeMemory();,     }, ,     public static void showmem() {,     Date d = null;,     d = new Date();,     System.out.println(getMemInfo() + " " + d.toString());, , }, , public static void main (String argv[]) {,     System.out.println("memCheck starting");,     memCheck mc = new memCheck();,     mc.run();, }],,
MT_CORRECTNESS,RU_INVOKE_RUN,org/apache/derby/impl/drda/memCheck.java,main,81-81,[    mc.run();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/io/BaseStorageFactory.java,newStorageFile,169-169,[            return new DirFile( (DirFile) directoryName, fileName);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/derby/impl/io/BaseStorageFactory.java,readOnlyTempRoot,279-279,[		temp.delete();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/io/DirFile.java,renameTo,377-377,[        boolean rename_status = super.renameTo( (File) newName);],,renameTo,395-395,[            rename_status = super.renameTo((File) newName);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/derby/impl/io/DirFile.java,renameTo,387-387,[                Thread.sleep(1000 * retry_count);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/io/DirFile.java,getOutputStream,133-133,[        OutputStream result = new FileOutputStream(this, append);],,getOutputStream,135-135,[        if (!exists) {],,getOutputStream,137-137,[                limitAccessToOwner();],,getOutputStream,138-138,[            } catch (FileNotFoundException fnfe) {],,getOutputStream,140-140,[                throw fnfe;],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/derby/impl/io/DirFile.java,releaseExclusiveFileLock,324-324,[                delete();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/impl/io/DirFile.java,,64-451,[        super( path);,     }, ,     /**,      * Construct a DirFile from a directory name and a file name.,      *,      * @param directoryName The directory part of the path name.,      * @param fileName The name of the file within the directory.,      */,     DirFile( String directoryName, String fileName),     {,         super( directoryName, fileName);,     }, ,     /**,      * Construct a DirFile from a directory name and a file name.,      *,      * @param directoryName The directory part of the path name.,      * @param fileName The name of the file within the directory.,      */,     DirFile( DirFile directoryName, String fileName),     {,         super( (File) directoryName, fileName);,     }, ,     /**,      * Get the name of the parent directory if this name includes a parent.,      *,      * @return An StorageFile denoting the parent directory of this StorageFile, if it has a parent, null if,      *         it does not have a parent.,      */,     public StorageFile getParentDir(),     {,         String parent = getParent();,         if( parent == null),             return null;,         return new DirFile( parent);,     },     ,     /**,      * Creates an output stream from a file name.,      *,      * @return an output stream suitable for writing to the file.,      *,      * @exception FileNotFoundException if the file exists but is a directory,      *            rather than a regular file, does not exist but cannot be created, or,      *            cannot be opened for any other reason.,      */,     public OutputStream getOutputStream( ) throws FileNotFoundException,     {,         return getOutputStream(false);,     },     ,     /**,      * Creates an output stream from a file name.,      *,      * @param append If true then data will be appended to the end of the file, if it already exists.,      *               If false and a normal file already exists with this name the file will first be truncated,      *               to zero length.,      *,      * @return an output stream suitable for writing to the file.,      *,      * @exception FileNotFoundException if the file exists but is a directory,      *            rather than a regular file, does not exist but cannot be created, or,      *            cannot be opened for any other reason.,      */,     public OutputStream getOutputStream( final boolean append) throws FileNotFoundException,     {,         boolean exists = exists();,         OutputStream result = new FileOutputStream(this, append);, ,         if (!exists) {,             try {,                 limitAccessToOwner();,             } catch (FileNotFoundException fnfe) {,                 // Throw FileNotFoundException unchanged.,                 throw fnfe;,             } catch (IOException ioe) {,                 // Other IOExceptions should be wrapped, since,                 // FileNotFoundException is the only one we are allowed,                 // to throw here.,                 FileNotFoundException e = new FileNotFoundException();,                 e.initCause(ioe);,                 throw e;,             },         }, ,         return result;,     }, ,     /**,      * Creates an input stream from a file name.,      *,      * @return an input stream suitable for reading from the file.,      *,      * @exception FileNotFoundException if the file is not found.,      */,     public InputStream getInputStream( ) throws FileNotFoundException,     {,         return new FileInputStream( (File) this);,     }, ,     /**,      * Get an exclusive lock. This is used to ensure that two or more JVMs do not open the same database,      * at the same time.,      *,      *,      * @return EXCLUSIVE_FILE_LOCK_NOT_AVAILABLE if the lock cannot be acquired because it is already held.<br>,      *    EXCLUSIVE_FILE_LOCK if the lock was successfully acquired.<br>,      *    NO_FILE_LOCK_SUPPORT if the system does not support exclusive locks.<br>,      */,     public synchronized int getExclusiveFileLock() throws StandardException,     {,         boolean validExclusiveLock = false;,         int status;, ,         /*,         ** There can be  a scenario where there is some other JVM that is before jkdk1.4,         ** had booted the system and jdk1.4 trying to boot it, in this case we will get the,         ** Exclusive Lock even though some other JVM has already booted the database. But,         ** the lock is not a reliable one , so we should  still throw the warning.,         ** The Way we identify this case is if "dbex.lck" file size  is differen,         ** for pre jdk1.4 jvms and jdk1.4 or above.,         ** Zero size "dbex.lck" file  is created by a jvm i.e before jdk1.4 and,         ** File created by jdk1.4 or above writes EXCLUSIVE_FILE_LOCK value into the file.,         ** If we are unable to acquire the lock means other JVM that,         ** currently booted the system is also JDK1.4 or above;,         ** In this case we could confidently throw a exception instead of,         ** of a warning.,         **/, ,         try,         {,             //create the file that us used to acquire exclusive lock if it does not exists.,             if (createNewFile()),             {,                 validExclusiveLock = true;,             },             else if (length() > 0),             {,                 validExclusiveLock = true;,             }, ,             //If we can acquire a reliable exclusive lock , try to get it.,             if (validExclusiveLock),             {,                 int retries = InterruptStatus.MAX_INTERRUPT_RETRIES;,                 while (true) {,                     lockFileOpen = new RandomAccessFile((File) this, "rw");,                     limitAccessToOwner(); // tamper-proof..,                     lockFileChannel = lockFileOpen.getChannel();, ,                     try {,                         dbLock =lockFileChannel.tryLock();,                         if(dbLock == null) {,                             lockFileChannel.close();,                             lockFileChannel=null;,                             lockFileOpen.close();,                             lockFileOpen = null;,                             status = EXCLUSIVE_FILE_LOCK_NOT_AVAILABLE;,                         } else {,                             lockFileOpen.writeInt(EXCLUSIVE_FILE_LOCK);,                             lockFileChannel.force(true);,                             status = EXCLUSIVE_FILE_LOCK;,                         },                     } catch (AsynchronousCloseException e) {,                         // JDK bug 6979009: use AsynchronousCloseException,                         // instead of the logically correct,                         // ClosedByInterruptException, ,                         InterruptStatus.setInterrupted();,                         lockFileOpen.close();, ,                         if (retries-- > 0) {,                             continue;,                         } else {,                             throw e;,                         },                     }, ,                     break;,                 },             },             else,             {,                 status = NO_FILE_LOCK_SUPPORT;,             }, ,         } catch(IOException ioe),         {,             // do nothing - it may be read only medium, who knows what the,             // problem is, ,             //release all the possible resource we created in this functions.,             releaseExclusiveFileLock();,             status = NO_FILE_LOCK_SUPPORT;,             if (SanityManager.DEBUG),             {,                 SanityManager.THROWASSERT("Unable to Acquire Exclusive Lock on ",                                           + getPath(), ioe);,             },         } catch (OverlappingFileLockException ofle),         {,             //,             // Under Java 6 and later, this exception is raised if the database,             // has been opened by another Derby instance in a different,             // ClassLoader in this VM. See DERBY-700.,             //,             // The OverlappingFileLockException is raised by the,             // lockFileChannel.tryLock() call above.,             //,             try {,                 lockFileChannel.close();,                 lockFileOpen.close();,             } catch (IOException e),             {,                 if (SanityManager.DEBUG),                 {,                     SanityManager.THROWASSERT("Error closing file channel ",                                               + getPath(), e);,                 },             },             lockFileChannel = null;,             lockFileOpen = null;,             status = EXCLUSIVE_FILE_LOCK_NOT_AVAILABLE;,         }, ,         return status;,     } // end of getExclusiveFileLock, , 	/**,      * Release the resource associated with an earlier acquired exclusive lock,      *,      * @see #getExclusiveFileLock,      */,     public synchronized void releaseExclusiveFileLock(),     {,         try,         {,             if (dbLock!=null),             {,                 dbLock.release();,                 dbLock = null;,             }, ,             if (lockFileChannel != null),             {,                 lockFileChannel.close();,                 lockFileChannel = null;,             }, ,             if (lockFileOpen != null),             {,                 lockFileOpen.close();,                 lockFileOpen = null;,             }, ,             // delete the exclusive lock file name.,             if (exists()),             {,                 delete();,             },         },         catch (IOException ioe),         {,             // do nothing - it may be read only medium, who knows what the,             // problem is,         },     } // End of releaseExclusiveFileLock, ,     /**,      * Get a random access (read/write) file.,      *,      * @param mode "r", "rw", "rws", or "rwd". The "rws" and "rwd" modes specify,      *             that the data is to be written to persistent store, consistent with the,      *             java.io.RandomAccessFile class ("synchronized" with the persistent,      *             storage, in the file system meaning of the word "synchronized").  However,      *             the implementation is not required to implement the "rws" or "rwd",      *             modes. The implementation may treat "rws" and "rwd" as "rw". It is up to,      *             the user of this interface to call the StorageRandomAccessFile.sync,      *             method. If the "rws" or "rwd" modes are supported and the,      *             RandomAccessFile was opened in "rws" or "rwd" mode then the,      *             implementation of StorageRandomAccessFile.sync need not do anything.,      *,      * @return an object that can be used for random access to the file.,      *,      * @exception IllegalArgumentException if the mode argument is not equal to one of "r", "rw".,      * @exception FileNotFoundException if the file exists but is a directory rather than a regular,      *              file, or cannot be opened or created for any other reason .,      */,     public StorageRandomAccessFile getRandomAccessFile( String mode) throws FileNotFoundException,     {,         return new DirRandomAccessFile( (File) this, mode);,     } // end of getRandomAccessFile, ,     /**,      * Rename the file denoted by this name. ,      *,      * Note that StorageFile objects are immutable. This method renames the ,      * underlying file, it does not change this StorageFile object. The ,      * StorageFile object denotes the same name as before, however the exists(),      * method will return false after the renameTo method executes successfully.,      *,      * <p>,      * It is not specified whether this method will succeed if a file ,      * already exists under the new name.,      *,      * @param newName the new name.,      *,      * @return <b>true</b> if the rename succeeded, <b>false</b> if not.,      */,     public boolean renameTo( StorageFile newName),     {,         boolean rename_status = super.renameTo( (File) newName);,         int     retry_count   = 1;, ,         while (!rename_status && (retry_count <= 5)),         {,             // retry operation, hoping a temporary I/O resource issue is ,             // causing the failure., ,             try,             {,                 Thread.sleep(1000 * retry_count);,             },             catch (InterruptedException ie),             {,                 // This thread received an interrupt as well, make a note.,                 InterruptStatus.setInterrupted();,             }, ,             rename_status = super.renameTo((File) newName);, ,             retry_count++;,         }, ,         return(rename_status);,     }, ,     /**,      * Deletes the named file and, if it is a directory, all the files and directories it contains.,      *,      * @return <b>true</b> if the named file or directory is successfully deleted, <b>false</b> if not,      */,     public boolean deleteAll(),     {,         // Nothing to do if the file doesn't exist.,         if (!exists()) {,             return false;,         }, ,         // If the file is a directory, delete its contents recursively.,         // File.list() will return null if it is not a directory, or if the,         // contents of the directory cannot be read. Skip the recursive step,         // in both of those cases. If it turns out that the file in fact is a,         // directory, and we couldn't delete its contents, the delete() call,         // at the end of this method will return false to notify the caller,         // that the directory could not be deleted.,         String[] childList = super.list();,         if (childList != null),         {,             String parentName = getPath();,             for( int i = 0; i < childList.length; i++),             {,                 if( childList[i].equals( ".") || childList[i].equals( "..")),                     continue;,                 DirFile child = new DirFile( parentName, childList[i]);,                 if( ! child.deleteAll()),                     return false;,             },         }, ,         // Finally, attempt to delete the file (or directory) and return,         // whether or not we succeeded.,         return delete();,     } // end of deleteAll, , 	/**, 	 * @see org.apache.derby.io.StorageFile#getURL(), 	 */, 	public URL getURL() throws MalformedURLException {, 		, 		return toURI().toURL();, 	}, ,     public void limitAccessToOwner() throws IOException {,         FileUtil.limitAccessToOwner(this);,     }],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/io/DirStorageFactory.java,sync,140-140,[        ((FileOutputStream) stream).getFD().sync();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/io/InputStreamFile.java,list,133-133,[        return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/io/JarDBFile.java,getEntry,85-85,[        return storageFactory.zipData.getEntry( path);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/io/JarDBFile.java,getInputStream,114-114,[            return storageFactory.zipData.getInputStream(zipEntry);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/io/JarDBFile.java,getURL,135-135,[        File pathFile = new File(storageFactory.zipData.getName());],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/io/vfmem/VirtualFile.java,list,75-75,[            return null;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/jdbc/BinaryToRawStream.java,,53-53,[		this.parent     = parent;],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/derby/impl/jdbc/EmbedBlob.java,handleStreamValue,228-228,[                SanityManager.ASSERT(dvdStream instanceof Resetable);],,
MT_CORRECTNESS,DC_DOUBLECHECK,org/apache/derby/impl/jdbc/EmbedBlob.java,length,387-397,[        if (streamLength != -1),             return streamLength;,         ,         boolean pushStack = false;,         try,         {,            // we have a stream,             synchronized (getConnectionSynchronization()),             {,                 EmbedConnection ec = getEmbedConnection();,                 pushStack = !ec.isClosed();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedBlob.java,getBinaryStream,1108-1108,[            throw Util.generateCsSQLException(],,getBinaryStream,1113-1113,[            throw Util.generateCsSQLException(],,getBinaryStream,1118-1118,[            throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedBlob.java,getBytes,468-468,[                throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedBlob.java,getBytes,465-465,[                throw StandardException.newException(],,getBytes,528-528,[                e = StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedBlob.java,position,731-731,[                throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedBlob.java,position,629-629,[                throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedBlob.java,setBinaryStream,975-975,[                throw Util.generateCsSQLException(],,setBinaryStream,978-978,[                throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedBlob.java,setBlobPosition,320-320,[                throw StandardException.newException(],,setBlobPosition,329-329,[                throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedBlob.java,setBytes,920-920,[            throw Util.generateCsSQLException(SQLState.BLOB_POSITION_TOO_LARGE,],,setBytes,923-923,[            throw Util.generateCsSQLException(SQLState.BLOB_BAD_POSITION,],,setBytes,927-927,[            throw Util.generateCsSQLException(SQLState.BLOB_INVALID_OFFSET,],,setBytes,931-931,[            throw Util.generateCsSQLException(SQLState.BLOB_NONPOSITIVE_LENGTH,],,setBytes,938-938,[            throw Util.generateCsSQLException(SQLState.BLOB_LENGTH_TOO_LONG,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedBlob.java,truncate,1017-1017,[                throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedCallableStatement.java,registerOutParameter,215-215,[			throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/jdbc/EmbedCallableStatement.java,getObject,698-698,[            throw Util.generateCsSQLException(SQLState.INVALID_API_PARAMETER, map, "map",],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/jdbc/EmbedCallableStatement.java,getObject,1474-1474,[            throw Util.generateCsSQLException(SQLState.INVALID_API_PARAMETER, map, "map",],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedClob.java,getCharacterStream,739-739,[            throw Util.generateCsSQLException(],,getCharacterStream,744-744,[            throw Util.generateCsSQLException(],,getCharacterStream,749-749,[            throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedClob.java,getSubString,207-207,[            throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedClob.java,getSubString,204-204,[            throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedClob.java,position,319-319,[            throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedClob.java,position,435-435,[            throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedClob.java,setString,588-588,[            throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedClob.java,setString,560-560,[            throw Util.generateCsSQLException(],,setString,603-603,[            throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedClob.java,truncate,667-667,[            throw Util.generateCsSQLException(],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/jdbc/EmbedConnection.java,releaseSavepoint,3590-3590,[                getLanguageConnection().releaseSavePoint(],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/jdbc/EmbedConnection.java,rollback,3559-3559,[                getLanguageConnection().internalRollbackToSavepoint(],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/jdbc/EmbedConnection.java,checkUserIsNotARole,1379-1379,[				TransactionController tc = lcc.getTransactionExecute();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/jdbc/EmbedConnection.java,<init>,255-255,[			EmbedConnectionContext context = pushConnectionContext(tr.getContextManager());],,<init>,553-553,[				context = pushConnectionContext(tr.getContextManager());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedConnection.java,addLOBMapping,3290-3290,[		getlobHMObj().put(new Integer(loc), LOBReference);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedConnection.java,getLOBMapping,3309-3309,[		return getlobHMObj().get(new Integer(key));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedConnection.java,removeLOBMapping,3300-3300,[		getlobHMObj().remove(new Integer(key));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedConnection.java,setTransactionIsolation,2240-2240,[			throw newSQLException(SQLState.UNIMPLEMENTED_ISOLATION_LEVEL, new Integer(level));],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/jdbc/EmbedConnection.java,setTypeMap,2315-2315,[            throw newSQLException(SQLState.INVALID_API_PARAMETER, map, "map",],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/jdbc/EmbedConnection.java,checkDatabaseCreatePrivileges,2689-2719,[        if (System.getSecurityManager() == null) {,             return;,         },         if (dbname == null) {,             throw new NullPointerException("dbname can't be null");,         },         ,         // the check,         try {,             // raises IOException if dbname is non-canonicalizable,             final String url,                 = (DatabasePermission.URL_PROTOCOL_DIRECTORY,                    + stripSubSubProtocolPrefix(dbname));,             final Permission dp,                 = new DatabasePermission(url, DatabasePermission.CREATE);,             ,             factory.checkSystemPrivileges(user, dp);,         } catch (AccessControlException ace) {,             throw newSQLException(,                     SQLState.AUTH_DATABASE_CREATE_MISSING_PERMISSION,,                     user, dbname, ace);,         } catch (IOException ioe) {,             throw newSQLException(,                     SQLState.AUTH_DATABASE_CREATE_EXCEPTION,,                     dbname, (Object)ioe); // overloaded method,         } catch (Exception e) {,             throw newSQLException(,                     SQLState.AUTH_DATABASE_CREATE_EXCEPTION,,                     dbname, (Object)e); // overloaded method,         },     }],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/derby/impl/jdbc/EmbedConnectionContext.java,getResultSet,132-132,[		EmbedResultSet rs = conn.getLocalDriver().newEmbedResultSet(conn, executionResultSet, ],,getResultSet,130-130,[		EmbedConnection conn = connRef.get();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/jdbc/EmbedDatabaseMetaData.java,doGetBestRowId,2165-2165,[			ResultSet rs = ps.executeQuery();],,doGetBestRowId,2166-2166,[			done = rs.next();],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/derby/impl/jdbc/EmbedDatabaseMetaData.java,PBloadQueryDescriptions,160-160,[                InputStream is = getClass().getResourceAsStream(files[i]);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedParameterSetMetaData.java,checkPosition,216-216,[			throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedPreparedStatement.java,setScale,1617-1617,[			throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/jdbc/EmbedResultSet.java,adjustScale,3305-3305,[				int origvaluelen = value.getLength();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/jdbc/EmbedResultSet.java,deleteRow,4107-4107,[					ps.executeSubStatement(activation, act, true, 0L);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/jdbc/EmbedResultSet.java,getClob,4358-4358,[                LanguageConnectionContext lcc = ec.getLanguageConnection();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/jdbc/EmbedResultSet.java,insertRow,3934-3934,[					ps.executeSubStatement(activation, act, true, 0L);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/jdbc/EmbedResultSet.java,updateRow,4026-4026,[				ps.executeSubStatement(activation, act, true, 0L);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedResultSet.java,adjustScale,3300-3300,[				throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedResultSet.java,checksBeforeUpdateXXX,2458-2458,[        throw Util.generateCsSQLException(SQLState.LANG_INVALID_COLUMN_POSITION,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedResultSet.java,getColumn,4698-4698,[		  throw newSQLException(SQLState.COLUMN_NOT_FOUND, ],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedResultSet.java,getColumnType,355-355,[			throw newSQLException(SQLState.COLUMN_NOT_FOUND, ],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedResultSet.java,setFetchSize,2300-2300,[			throw Util.generateCsSQLException(SQLState.INVALID_FETCH_SIZE,],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/derby/impl/jdbc/EmbedResultSet.java,compareTo,4771-4773,[		EmbedResultSet olrs = (EmbedResultSet) other;, , 		return order - olrs.order;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/jdbc/EmbedResultSet.java,,1163-1163,[				currentStream = r;],,,4556-4556,[		if (currentStream != null) {],,,4571-4571,[				currentStream = null;],,,1206-1206,[			currentStream = ret;],,,1315-1315,[            currentStream = stream;],,,4561-4561,[					if (currentStream != null) {],,,4562-4562,[						if (currentStream instanceof java.io.Reader)],,,4565-4565,[							((java.io.InputStream) currentStream).close();],,,4563-4563,[							((java.io.Reader) currentStream).close();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/impl/jdbc/EmbedResultSet.java,getSQLText,4633-4636,[		if (stmt == null), 			return null;, , 		return stmt.getSQLText();],,getSQLtext,205-205,[	{	return	SQLtext; }],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/jdbc/EmbedResultSet.java,getObject,1870-1870,[            throw Util.generateCsSQLException(SQLState.INVALID_API_PARAMETER, map, "map",],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/jdbc/EmbedResultSet.java,getBytes,913-913,[				return null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java,validColumnNumber,337-337,[			    throw Util.generateCsSQLException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedStatement.java,setFetchDirection,905-905,[                    throw newSQLException(SQLState.INVALID_FETCH_DIRECTION, ],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedStatement.java,setFetchSize,941-941,[	        throw newSQLException(SQLState.INVALID_ST_FETCH_SIZE, new Integer(rows));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedStatement.java,setLargeMaxRows,496-496,[			throw newSQLException(SQLState.INVALID_MAX_ROWS_VALUE, new Long(max));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedStatement.java,setMaxFieldSize,435-435,[			throw newSQLException(SQLState.INVALID_MAXFIELD_SIZE, new Integer(max));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EmbedStatement.java,setQueryTimeout,538-538,[            throw newSQLException(SQLState.INVALID_QUERYTIMEOUT_VALUE,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/EncryptedLOBFile.java,getBlocks,79-79,[            throw new IndexOutOfBoundsException (],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/impl/jdbc/LOBInputStream.java,reInitialize,198-200,[        updateCount = control.getUpdateCount();,         pos = 0;,     }],,reinitialize,173-177,[		if (variantType != CONSTANT), 		{, 			orderableCache = null;, 		}, 	}],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/jdbc/LOBStreamControl.java,init,116-116,[            throw (IOException) pae.getCause();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/LOBStreamControl.java,copyData,389-389,[                    throw new EOFException(MessageService.getTextMessage(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/LOBStreamControl.java,copyUtf8Data,485-485,[            throw new EOFException(MessageService.getTextMessage(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/LOBStreamControl.java,isValidOffset,188-188,[            throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/LOBStreamControl.java,isValidPostion,165-165,[            throw StandardException.newException(],,isValidPostion,168-168,[            throw StandardException.newException(],,isValidPostion,174-174,[                    throw StandardException.newException(],,isValidPostion,177-177,[                throw StandardException.newException(],,isValidPostion,181-181,[                throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/LOBStreamControl.java,updateData,137-137,[                throw StandardException.newException(],,updateData,144-144,[                throw StandardException.newException(],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/jdbc/LOBStreamControl.java,,510-510,[        dataBytes = null;],,,210-210,[                init(dataBytes, pos);],,,565-565,[                byte [] tmpBytes = dataBytes;],,,574-574,[                System.arraycopy (dataBytes, 0, tmpByte, 0, (int) stPos);],,,579-579,[                dataBytes = tmpByte;            ],,,577-577,[                    System.arraycopy (dataBytes, (int) endPos, tmpByte, ],,,124-124,[        dataBytes = null;],,,248-248,[                init(dataBytes, pos);],,,337-337,[            return dataBytes.length;],,,267-267,[            if (dataBytes.length == pos)],,,269-269,[            return dataBytes [(int) pos] & 0xff;],,,129-129,[        if (dataBytes == null) {],,,142-142,[            if (pos > dataBytes.length) {],,,148-148,[                if (pos + len < dataBytes.length) {],,,131-131,[                dataBytes = new byte [len];],,,132-132,[                System.arraycopy(bytes, offset, dataBytes, (int) pos, len);],,,149-149,[                    System.arraycopy(bytes, offset, dataBytes, (int) pos, len);],,,153-153,[                    System.arraycopy(dataBytes, 0 , tmpBytes, 0, (int) pos);],,,155-155,[                    dataBytes = tmpBytes;],,,351-351,[            System.arraycopy(dataBytes, 0, tmpByte, 0, (int) size);],,,355-355,[                dataBytes = new byte [(int) size];],,,356-356,[                read(dataBytes, 0, dataBytes.length, 0);],,,352-352,[            dataBytes = tmpByte;],,,282-282,[        if (pos >= dataBytes.length)],,,284-284,[        int lengthFromPos = dataBytes.length - (int) pos;],,,286-286,[        System.arraycopy(dataBytes, (int) pos, b, off, actualLength);],,,172-172,[            if (dataBytes == null) {],,,176-176,[            } else if (dataBytes.length < pos)],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/jdbc/LOBStreamControl.java,,511-511,[        if (tmpFile != null) {],,,512-512,[            releaseTempFile(tmpFile);],,,513-513,[            tmpFile = null;],,,213-213,[        tmpFile.seek(pos);],,,214-214,[        tmpFile.write(b);],,,215-215,[        return tmpFile.getFilePointer();],,,587-587,[            LOBFile oldFile = tmpFile;],,,600-600,[            tmpFile.write (buf);],,,597-597,[                tmpFile.write (tmpByte, 0, actualLength);],,,608-608,[                    tmpFile.write (tmpByte, 0, rdLen);],,,119-119,[        conn.addLobFile(tmpFile);],,,251-251,[        tmpFile.seek(pos);],,,252-252,[        tmpFile.write(b, off, len);],,,253-253,[        return tmpFile.getFilePointer();],,,338-338,[        return tmpFile.length();],,,271-271,[        if (tmpFile.getFilePointer() != pos)],,,274-274,[            return tmpFile.readByte() & 0xff;],,,272-272,[            tmpFile.seek(pos);],,,361-361,[                tmpFile.setLength(size);],,,358-358,[                releaseTempFile(tmpFile);],,,359-359,[                tmpFile = null;],,,308-308,[        tmpFile.seek(pos);],,,309-309,[        return tmpFile.read (buff, off, len);],,,180-180,[            if (pos > tmpFile.length())],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/jdbc/LOBStreamControl.java,,624-624,[        return updateCount;],,,203-203,[        updateCount++;],,,613-613,[        updateCount++;],,,243-243,[        updateCount++;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/jdbc/LOBStreamControl.java,,497-500,[        AccessController.doPrivileged(new PrivilegedAction<Object>() {,             public Object run() {,                 file.delete();,                 return null;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/jdbc/PositionedStoreStream.java,<init>,89-89,[        ((Resetable)in).initStream();],,<init>,90-90,[        ((Resetable)in).resetStream();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/jdbc/StoreStreamClob.java,,272-276,[                    new FilterReader(this.internalReader) {,                         public void close() {,                             // Do nothing.,                             // Stream will be closed when the Clob is released.,                         }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/jdbc/TemporaryClob.java,,534-534,[                this.cachedCharLength = knownLength;],,,531-531,[                this.cachedCharLength = this.bytes.copyUtf8Data(],,,606-606,[                    byteLength(bytes.getLength()).],,,507-507,[                this.cachedCharLength = knownLength;],,,501-501,[                this.cachedCharLength = this.bytes.copyUtf8Data(],,,371-371,[        long prevLength = cachedCharLength;],,,410-410,[                    cachedCharLength = prevLength;],,,407-407,[                    cachedCharLength = newLength; // The Clob grew.],,,583-583,[        cachedCharLength = 0;],,,451-451,[            cachedCharLength = newCharLength;],,,325-325,[        if (cachedCharLength == 0) {],,,329-329,[        return cachedCharLength;],,,326-326,[            cachedCharLength = UTF8Util.skipUntilEOF(],,,340-340,[        return (cachedCharLength == 0 ? -1 : cachedCharLength);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/jdbc/TemporaryClob.java,,296-296,[        if (this.internalReader == null) {],,,310-310,[            this.internalReader.reposition(characterPosition);],,,300-300,[                    conChild.getConnectionSynchronization());],,,301-301,[            this.unclosableInternalReader =],,,573-573,[        if (internalReader != null) {],,,574-574,[            internalReader.close();],,,575-575,[            internalReader = null;],,,151-151,[            if (internalReader != null) {],,,152-152,[                internalReader.close();],,,153-153,[                internalReader = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/jdbc/TemporaryClob.java,,314-314,[        return this.unclosableInternalReader;],,,301-301,[            this.unclosableInternalReader =],,,576-576,[            unclosableInternalReader = null;],,,154-154,[                unclosableInternalReader = null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/jdbc/TemporaryClob.java,,302-306,[                    new FilterReader(this.internalReader) {,                         public void close() {,                             // Do nothing.,                             // Stream will be closed when the Clob is released.,                         }],,
BAD_PRACTICE,SR_NOT_CHECKED,org/apache/derby/impl/jdbc/UTF8Reader.java,<init>,137-137,[                csd.getStream().skip(csd.getDataOffset() - csd.getCurBytePos());],,
BAD_PRACTICE,SR_NOT_CHECKED,org/apache/derby/impl/jdbc/UpdatableBlobStream.java,skip,93-93,[            skip(pos);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/Util.java,newBatchUpdateException,326-326,[                return (BatchUpdateException) constructor.newInstance],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/jdbc/Util.java,newBatchUpdateException,329-329,[            catch (Exception e)],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,map,505-505,[		String userPassword = (String) value;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,validate,394-394,[        String      stringValue = (String) value;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,getDatabaseProperty,354-354,[			tc = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,getProperty,282-282,[			tc = null;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,parsePasswordThreshold,470-470,[                else { return new Double( expirationThreshold ); }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,parsePasswordLifetime,460-460,[                return new Long( passwordLifetime );],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,hashPasswordSHA1Scheme,575-575,[		algorithm.reset();],,hashPasswordSHA1Scheme,566-566,[		MessageDigest algorithm = null;],,hashPasswordSHA1Scheme,570-570,[		} catch (NoSuchAlgorithmException nsae)],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,substitutePassword,751-751,[        messageDigest.reset();],,substitutePassword,725-725,[        MessageDigest messageDigest = null;],,substitutePassword,739-739,[        } catch (NoSuchAlgorithmException nsae)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,authenticate,252-252,[		return this.authenticationScheme.authenticateUser(userName,],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/jdbc/authentication/LDAPAuthenticationSchemeImpl.java,authenticateUser,170-170,[            DirContext ctx =   privInitialDirContext(env);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/jdbc/authentication/LDAPAuthenticationSchemeImpl.java,,201-203,[                    new PrivilegedExceptionAction<DirContext>() {,                         public DirContext run() throws NamingException {,                             return new InitialDirContext(env);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/jdbc/authentication/LDAPAuthenticationSchemeImpl.java,,386-388,[                    new PrivilegedExceptionAction<FileOutputStream>() {,                         public FileOutputStream run() throws IOException {,                             return new FileOutputStream("DerbyLDAP.out");],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/jdbc/authentication/NativeAuthenticationServiceImpl.java,isCredentialsService,367-367,[        String canonicalDB = Monitor.getMonitor().getCanonicalServiceName( canonicalDatabaseName );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/jdbc/authentication/NativeAuthenticationServiceImpl.java,authenticateLocally,537-537,[            if ( actualPassword != null ) { Arrays.fill( actualPassword, (char) 0 ); }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/jdbc/authentication/NativeAuthenticationServiceImpl.java,authenticateLocally,536-536,[            if ( candidatePassword != null ) { Arrays.fill( candidatePassword, (char) 0 ); }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/jdbc/authentication/NativeAuthenticationServiceImpl.java,authenticateLocally,527-527,[            if ( (candidatePassword == null) || (actualPassword == null)) { return false; }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/jdbc/authentication/NativeAuthenticationServiceImpl.java,authenticateLocally,527-527,[            if ( (candidatePassword == null) || (actualPassword == null)) { return false; }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/jdbc/authentication/NativeAuthenticationServiceImpl.java,callDataSourceSetter,456-456,[        } catch (Exception e)  { throw wrap( e ); }   ],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/derby/impl/jdbc/authentication/NativeAuthenticationServiceImpl.java,authenticateLocally,517-517,[            hasher.hashPasswordIntoString( userName, userPassword ).toCharArray();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/jdbc/authentication/NativeAuthenticationServiceImpl.java,callDataSourceSetter,455-457,[            ds.getClass().getMethod( methodName, new Class[] { String.class } ).invoke( ds, new Object[] { value } );,         } catch (Exception e)  { throw wrap( e ); }   ,     }],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/load/ColumnInfo.java,<init>,90-90,[            sName = ((EngineConnection) conn).getCurrentSchemaName();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/load/ColumnInfo.java,initializeColumnInfo,189-189,[			int numPrecRadix = rs.getInt(10);],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/impl/load/ColumnInfo.java,<init>,138-138,[				int cIndex = (new Integer(columnIndex )).intValue();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/impl/load/ColumnInfo.java,getExpectedVtiColumnTypes,496-496,[                                        colTypeOffset))).intValue();],,getExpectedVtiColumnTypes,498-498,[                                          colTypeOffset+1))).intValue();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/load/ColumnInfo.java,<init>,138-138,[				int cIndex = (new Integer(columnIndex )).intValue();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/load/ColumnInfo.java,getExpectedVtiColumnTypes,495-495,[            int colIndex = (new Integer(colTypeInfo.substring(6, ],,getExpectedVtiColumnTypes,497-497,[            int colType = (new Integer(colTypeInfo.substring(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/load/ColumnInfo.java,initializeColumnInfo,197-197,[                jdbcColumnTypes.add(new Integer(dataType));],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/load/ColumnInfo.java,,53-53,[	private boolean createolumnNames = true;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/load/ControlInfo.java,getColumnWidths,139-139,[      return null;],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/load/Export.java,run,162-162,[                        return new Boolean(file.exists());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/load/Export.java,,160-162,[                new PrivilegedAction<Boolean>() {,                     public Boolean run() {,                         return new Boolean(file.exists());],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/load/ExportAbstract.java,stringifyObject,138-138,[        ObjectOutputStream oos = new ObjectOutputStream( dbaos );],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/load/ExportAbstract.java,getOneRowAtATime,131-131,[    return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/load/ExportAbstract.java,doAllTheWork,189-189,[						exportResultSetForObject.getColumnDefinition(),],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/load/ExportAbstract.java,getOneRowAtATime,82-82,[       int columnCount = exportResultSetForObject.getColumnCount();],,getOneRowAtATime,130-130,[	exportResultSetForObject.close();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/load/ExportAbstract.java,getOneRowAtATime,97-97,[                       exportWriteData.writeBinaryColumnToExternalFile(is);],,getOneRowAtATime,104-104,[                       exportWriteData.writeCharColumnToExternalFile(ir);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/impl/load/ExportResultSetForObject.java,getResultSet,82-82,[        rs = expStmt.executeQuery(selectQuery);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/load/ExportResultSetForObject.java,,59-59,[			this.schemaName = schemaName;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/load/ExportResultSetForObject.java,,60-60,[			this.tableName = tableName;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/load/ExportResultSetForObject.java,getMetaDataInfo,106-106,[        ResultSetMetaData metaData = rs.getMetaData();],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/load/ExportWriteData.java,openFiles,114-114,[        aStream = dataCodeset == null ?],,openFiles,142-142,[            lobCharStream =  dataCodeset == null ?],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/load/ExportWriteData.java,openFiles,109-109,[        anOutputStream = new FileOutputStream(outputFileName);],,openFiles,110-110,[        FileUtil.limitAccessToOwner(outputFile);],,openFiles,146-146,[    } catch (Exception e) {],,openFiles,151-151,[        if (aStream == null) {],,openFiles,160-160,[            aStream.close();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/load/ExportWriteData.java,openFiles,146-146,[    } catch (Exception e) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/load/ExportWriteDataAbstract.java,,64-64,[    this.columnLengths = columnLengths;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/load/ExportWriteDataAbstract.java,,47-47,[    nullString = controlFileReader.getNullString();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/load/Import.java,<init>,81-81,[            _importers.put( new Integer( importCounter ), this );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/load/Import.java,formatImportError,335-335,[        StandardException se = StandardException.newException],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/load/Import.java,performImport,194-194,[        Integer     importCounter = new Integer( bumpImportCounter() );],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/impl/load/Import.java,performImport,285-285,[            statement.executeUpdate(lockSql);],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/load/Import.java,performImport,278-278,[            PreparedStatement ips = connection.prepareStatement(insertSql);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/load/ImportLobFile.java,getCharacterStream,172-172,[        lobReader = dataCodeset == null ?],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/load/ImportLobFile.java,getClobDataLength,193-193,[        lobReader = dataCodeset == null ?],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/load/ImportLobFile.java,getString,139-139,[        lobReader = dataCodeset == null ?],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/load/ImportLobFile.java,,75-77,[                (new java.security.PrivilegedExceptionAction<RandomAccessFile>(){,                         public RandomAccessFile run() throws IOException{,                             return new RandomAccessFile(lobFile, "r");],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/load/ImportReadData.java,realOpenFile,249-249,[    java.io.Reader rd = dataCodeset == null ?],,
CORRECTNESS,NP_UNWRITTEN_FIELD,org/apache/derby/impl/load/ImportReadData.java,readNextFixedRow,702-702,[  		 int colWidth = columnWidths[i];],,
CORRECTNESS,NP_UNWRITTEN_FIELD,org/apache/derby/impl/load/ImportReadData.java,readNextFixedRow,720-720,[            if (tempString[colStart+i] != recordSeparator[i])],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/derby/impl/load/ImportReadData.java,reCheckRestOfTheCharacters,475-475,[                   reCheckRestOfTheCharacters(totalCharsSoFar-fieldStartDelimiterIndex,],,reCheckRestOfTheCharacters,550-550,[            reCheckRestOfTheCharacters(totalCharsSoFar-fieldStopDelimiterIndex,],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/load/ImportReadData.java,,124-124,[    format = controlFileReader.getFormat();],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/load/ImportReadData.java,,702-702,[  		 int colWidth = columnWidths[i];],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/load/ImportReadData.java,,674-674,[    while ((readLength +=],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/load/ImportReadData.java,,674-674,[    while ((readLength +=],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/load/ImportResultSetMetaData.java,getUDTClass,142-142,[        String columnName = getColumnName( column );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/bytecode/BCClass.java,,141-144,[				(new java.security.PrivilegedAction<String>(){, , 					public String run(){, 						return System.getProperty(Property.SYSTEM_HOME_PROPERTY,".");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/services/bytecode/BCJava.java,type,247-247,[			VMTypeIdCacheable vtic = (VMTypeIdCacheable) vmTypeIdCache.find(javaType);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/services/bytecode/BCJava.java,vmType,276-276,[			VMTypeIdCacheable vtic = (VMTypeIdCacheable) vmTypeIdCache.find(md);],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/derby/impl/services/bytecode/BCMethod.java,writeExceptions,361-361,[					String e = thrownExceptions.get(i).toString();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/services/bytecode/BCMethod.java,describeMethod,645-645,[			if (declaringClass == null)],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/impl/services/bytecode/BCMethod.java,describeMethod,649-649,[		int cpi = modClass.addMethodReference(declaringClass, methodName,],,describeMethod,641-641,[		if ((declaringClass == null) && (opcode != VMOpcode.INVOKESTATIC)) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/impl/services/bytecode/BCMethod.java,describeMethod,645-645,[			if (declaringClass == null)],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/services/bytecode/CodeChunk.java,splitExpressionOut,1897-1898,[                earliestIndepPC[stack] = earliestIndepPC[stack -1];,                 break;],,splitExpressionOut,1902-1903,[                earliestIndepPC[stack] = earliestIndepPC[stack -1];,                 break;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/services/bytecode/CodeChunk.java,findConditionalPCs,1164-1164,[            return null;],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/derby/impl/services/bytecode/CodeChunk.java,getVariableStackDelta,1083-1085,[            stackDelta = -1; // for instance reference for method call.,         case VMOpcode.INVOKESTATIC:,             stackDelta += (width - CodeChunk.parameterWordCount(vmDescriptor));],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/bytecode/GClass.java,writeClassFile,92-92,[				throw (FileNotFoundException)pae.getCause();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/bytecode/GClass.java,,85-88,[						new PrivilegedExceptionAction<FileOutputStream>() {, 							public FileOutputStream run(), 							throws FileNotFoundException {, 								return new FileOutputStream(classFile);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/services/bytecode/d_BCValidate.java,checkMethod,173-173,[			} catch (Exception e) {],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/services/bytecode/d_BCValidate.java,checkMethod,183-183,[					sig = sig + debugParameterTypes[i];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/services/cache/CacheEntry.java,keep,172-172,[            callback.access();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/services/cache/CachedItem.java,,115-115,[		settingIdentity_ = true;],,,251-251,[		while (settingIdentity_) {],,,241-241,[		settingIdentity_ = false;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/services/cache/CachedItem.java,clean,173-173,[		entry.clean(forRemove);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/services/daemon/BasicDaemon.java,,226-226,[		if (serviceNow && !awakened)],,,548-548,[		if (!awakened) {],,,549-549,[			awakened = true;	// I am being awakened for urgent work.],,,575-575,[				if (!awakened) {],,,588-588,[			urgentOnly = awakened;],,,597-597,[			awakened = false;			// reset this for next time],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/services/daemon/BasicDaemon.java,,481-481,[		if (stopped)			// already stopped],,,403-403,[			stopped = true;],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/derby/impl/services/daemon/BasicDaemon.java,rest,577-577,[					wait(DaemonService.TIMER_DELAY);],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java,processingLoop,918-918,[                        tc = null;],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java,invalidateStatements,785-785,[                    sleep(100*(1+retries)); // adaptive sleeping...],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/derby/impl/services/daemon/IndexStatisticsDaemonImpl.java,updateIndexStatsMinion,651-651,[                        sleep(100*retries);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/daemon/SingleThreadDaemonFactory.java,,57-60,[             new PrivilegedAction<Object>() {,                 public Object run()  {,                     daemonThread.setContextClassLoader(null);,                     return null;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/jce/JCECipherFactory.java,privAccessFile,1044-1044,[			throw (java.io.IOException)pae.getException();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/jce/JCECipherFactory.java,privAccessGetInputStream,1067-1067,[	        throw (StandardException)pae.getException();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/services/jce/JCECipherFactory.java,changeBootPassword,804-804,[		String newkey = saveSecretKey(generatedKey, newBPAscii);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/services/jce/JCECipherFactory.java,changeBootPassword,782-782,[			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/services/jce/JCECipherFactory.java,generateKey,309-309,[			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH, new Integer(MIN_BOOTPASS_LENGTH));],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/services/jce/JCECipherFactory.java,verifyKey,954-954,[                DataInputStream dis = new DataInputStream(verifyKeyInputStream);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/services/jce/JCECipherFactory.java,changeBootPassword,781-781,[		if (newBPAscii == null || newBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/services/jce/JCECipherFactory.java,changeBootPassword,776-776,[		if (oldBPAscii == null || oldBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/jmx/JMXManagementService.java,jmxRegister,266-266,[            throw (JMException) pae.getException();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/services/jmx/JMXManagementService.java,registerMBean,231-231,[            registeredMbeans.put(beanName, standardMBean);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/services/jmx/JMXManagementService.java,stop,151-151,[                new HashSet<ObjectName>(registeredMbeans.keySet()))],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/derby/impl/services/jmx/JMXManagementService.java,startManagement,372-372,[                jmxRegister(registeredMbeans.get(mbeanName), mbeanName);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/jmx/JMXManagementService.java,,173-175,[                    .doPrivileged(new PrivilegedAction<MBeanServer>() {,                         public MBeanServer run() {,                             return ManagementFactory.getPlatformMBeanServer();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/jmx/JMXManagementService.java,,215-225,[                new StandardMBean(bean, beanInterface) {,                 ,                 /**,                  * Hide the implementation name from JMX clients,                  * by providing the interface name as the class,                  * name for the MBean. Allows the permissions,                  * in a policy file to be granted to the public,                  * MBean interfaces.,                  */,                 protected String getClassName(MBeanInfo info) {,                     return beanInterface.getName();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/services/locks/AbstractPool.java,validate,419-419,[				getWaitValue((String) value,  Property.DEADLOCK_TIMEOUT_DEFAULT);],,validate,421-421,[				getWaitValue((String) value,  Property.WAIT_TIMEOUT_DEFAULT);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/impl/services/locks/AbstractPool.java,zeroDurationlockObject,297-317,[		boolean success = lockTable.zeroDurationLockObject(, 			compatibilitySpace, ref, qualifier, timeout);, ,         if (!success) {, ,             // zeroDurationLockObject should only return false if we have,             // requested that we shouldn't wait for locks. Otherwise, an,             // exception should have been thrown.,             if (SanityManager.DEBUG) {,                 SanityManager.ASSERT(noLockWait(timeout, compatibilitySpace),,                                      "Should have timed out");,             }, ,             // If this is a timed wait, we should behave as if we timed out and,             // throw LOCK_TIMEOUT.,             if (timeout == C_LockFactory.TIMED_WAIT) {,                 throw StandardException.newException(SQLState.LOCK_TIMEOUT);,             },         }, ,         return success;],,zeroDurationLockObject,818-884,[            if (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {,                 D_LockControl.debugLock(,                     "Zero Duration Lock Request before Grant: ",,                     space, null, ref, qualifier, timeout);,                 if (SanityManager.DEBUG_ON(Constants.LOCK_STACK_TRACE)) {,                     // The following will print the stack trace of the lock,                     // request to the log.,                     Throwable t = new Throwable();,                     java.io.PrintWriter istream =,                         SanityManager.GET_DEBUG_STREAM();,                     istream.println("Stack trace of lock request:");,                     t.printStackTrace(istream);,                 },             },         }, ,         // Very fast zeroDurationLockObject() for unlocked objects.,         // If no entry exists in the lock manager for this reference,         // then it must be unlocked.,         // If the object is locked then we perform a grantable,         // check, skipping over any waiters.,         // If the caller wants to wait and the lock cannot,         // be granted then we do the slow join the queue and,         // release the lock method., ,         Entry entry = locks.get(ref);,         if (entry == null) {,             return true;,         }, ,         entry.lock();,         try {,             Control control = entry.control;,             if (control == null) {,                 return true;,             }, ,             // If we are grantable, ignoring waiting locks then,             // we can also grant this request now, as skipping,             // over the waiters won't block them as we release,             // the lock rightway.,             if (control.isGrantable(true, space, qualifier)) {,                 return true;,             }, ,             // can't be granted and are not willing to wait.,             if (AbstractPool.noLockWait(timeout, space)) {,                 return false;,             },         } finally {,             entry.unlock();,         }, ,         Lock lock = lockObject(space, ref, qualifier, timeout);, ,         if (SanityManager.DEBUG) {,             if (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {,                 D_LockControl.debugLock(,                     "Zero Lock Request Granted: ",,                     space, null, ref, qualifier, timeout);,             },         }, ,         // and simply unlock it once,         unlock(lock, 1);, ,         return true;],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/services/locks/ActiveLock.java,wakeUp,141-141,[		notify();],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/derby/impl/services/locks/ActiveLock.java,waitForGrant,115-115,[					wait();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/locks/ConcurrentLockSet.java,lockObject,455-455,[        ActiveLock waitingLock = (ActiveLock) lockItem;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/services/locks/ConcurrentLockSet.java,lockObject,385-385,[                            lockDebug += toDebugString();],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/services/locks/ConcurrentLockSet.java,lockObject,456-456,[        lockItem = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/services/locks/ConcurrentLockSet.java,unlock,741-741,[			item = null;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/services/locks/ConcurrentLockSet.java,toDebugString,933-933,[                    str += "\n  lock[" + i + "]: " +],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/services/locks/Deadlock.java,buildException,512-512,[						conglomId = new Long(tc.findConglomid(containerId.longValue()));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/services/locks/Deadlock.java,handle,427-427,[		return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/services/locks/Deadlock.java,look,334-334,[		return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/services/locks/LockSpace.java,addLock,124-124,[			callback.reached(this, group, limit,],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/services/locks/Timeout.java,dumpLock,312-312,[                catch( Exception e )],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/services/locks/Timeout.java,buildLockTableString,171-171,[        catch (Exception se)],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/services/locks/Timeout.java,dumpLock,296-296,[                conglomId = new Long( tc.findConglomid( value.longValue() ) );],,dumpLock,309-309,[                    containerId = new Long( tc.findContainerid( conglomId.longValue() ) );],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/impl/services/locks/Timeout.java,buildLockTableString,169-169,[            tabInfo = new TableNameInfo( lcc, true );],,buildLockTableString,164-164,[        if( lcc != null )],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/services/locks/Timeout.java,dumpLock,371-371,[            if( VirtualLockTable.CONTAINERID != null )],,dumpLock,355-355,[                if( VirtualLockTable.CONTAINERID != null )],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/services/locks/Timeout.java,dumpLock,312-312,[                catch( Exception e )],,dumpLock,353-353,[            }catch( Exception e )],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/services/monitor/BaseMonitor.java,readApplicationProperties,1376-1376,[			} catch (IOException e) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/services/monitor/BaseMonitor.java,dumpTempWriter,1945-1945,[				new ByteArrayInputStream(tmpArray.getInternalByteArray())));],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/services/monitor/BaseMonitor.java,getTempWriter,1931-1931,[			tmpWriter = new PrintWriter(tmpArray);],,
PERFORMANCE,DM_NEW_FOR_GETCLASS,org/apache/derby/impl/services/monitor/BaseMonitor.java,getImplementations,1175-1175,[					Class[] csParams = { new java.util.Properties().getClass()};],,getImplementations,1186-1186,[					Class[] bootParams = {Boolean.TYPE, new java.util.Properties().getClass()};],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/services/monitor/BaseMonitor.java,newInstanceFromIdentifier,698-698,[		throw StandardException.newException(SQLState.REGISTERED_CLASS_INSTANCE_ERROR,],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/services/monitor/BaseMonitor.java,newInstance,781-798,[			Class factoryClass = Class.forName(className);, 			return factoryClass.newInstance();, 		}, 		catch (ClassNotFoundException e) {, 			report(className + " " + e.toString());, 		}, 		catch (InstantiationException e) {, 			report(className + " " + e.toString());, 		},  		catch (IllegalAccessException e) {, 			report(className + " " + e.toString());, 		}, 		catch (LinkageError le) {, 			report(className + " " + le.toString());, 			reportException(le);, 		}, , 		return null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/services/monitor/ModuleInstance.java,,73-73,[		this.service = service;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/monitor/StorageFactoryService.java,createDataWarningFile,472-472,[        catch( PrivilegedActionException pae) { throw (StandardException) pae.getException();}],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/monitor/StorageFactoryService.java,recreateServiceRoot,706-706,[                        throw Monitor.exceptionStartingModule( (IOException) pae.getException());],,recreateServiceRoot,755-755,[                    { throw Monitor.exceptionStartingModule( (IOException)pae.getException());}],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/monitor/StorageFactoryService.java,saveServiceProperties,530-530,[        }catch( PrivilegedActionException pae) { throw (StandardException) pae.getException();}],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/monitor/StorageFactoryService.java,saveServiceProperties,425-425,[        catch( PrivilegedActionException pae) { throw (StandardException) pae.getException();}],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/services/monitor/StorageFactoryService.java,run,1016-1016,[                        return new Boolean(file.exists());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/monitor/StorageFactoryService.java,,1014-1016,[                new PrivilegedAction<Boolean>() {,                     public Boolean run() {,                         return new Boolean(file.exists());],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/services/monitor/StorageFactoryService.java,run,279-279,[                                serviceProperties.load(new BufferedInputStream(is));],,run,294-294,[                                    serviceProperties.load(new BufferedInputStream(is));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derby/impl/services/monitor/StorageFactoryService.java,run,366-366,[                            BufferedWriter bOut = new BufferedWriter(],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/monitor/StorageFactoryService.java,,341-420,[                {,                     public Object run() throws StandardException,                     {,                         StorageFile backupFile = replace,                             ? storageFactory.newStorageFile(,                                 PersistentService.PROPERTIES_NAME.concat("old")),                             : null;,                         StorageFile servicePropertiesFile = storageFactory.newStorageFile( PersistentService.PROPERTIES_NAME);,                         FileOperationHelper foh = new FileOperationHelper();, ,                         if (replace),                         {,                             foh.renameTo(,                                     servicePropertiesFile, backupFile, true);,                         }, ,                         OutputStream os = null;,                         try,                         {,                             os = servicePropertiesFile.getOutputStream();,                             properties.store(os, serviceName +,                                 MessageService.getTextMessage(,                                     MessageId.SERVICE_PROPERTIES_DONT_EDIT));,                             // The eof token should match the ISO-8859-1 encoding ,                             // of the rest of the properties file written with store.,                             BufferedWriter bOut = new BufferedWriter(,                                     new OutputStreamWriter(os,"ISO-8859-1"));,                             bOut.write(SERVICE_PROPERTIES_EOF_TOKEN);,                             bOut.newLine();,                             storageFactory.sync( os, false);,                             bOut.close();,                             os.close();,                             os = null; ,                         },                         catch (IOException ioe),                         {,                             if (backupFile != null),                             {,                                 // Rename the old properties file back again.,                                 foh.renameTo(backupFile, servicePropertiesFile,,                                         false);,                             },                             if (replace),                             {,                                 throw StandardException.newException(,                                         SQLState.SERVICE_PROPERTIES_EDIT_FAILED,,                                         ioe);,                             },                             else,                             {,                                 throw Monitor.exceptionStartingModule(ioe);,                             },                         },                         finally,                         {,                             if (os != null),                             {,                                 try,                                 {,                                     os.close();,                                 },                                 catch (IOException ioe),                                 {,                                     // Ignore exception on close,                                 },                             },                         }, 		,                         if (backupFile != null),                         {,                             if (!foh.delete(backupFile, false)),                             {,                                 Monitor.getStream().printlnWithHeader(,                                     MessageService.getTextMessage(,                                         MessageId.SERVICE_PROPERTIES_BACKUP_DEL_FAILED,,                                         getMostAccuratePath(backupFile)));,                                 ,                             },                         },                         return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/monitor/StorageFactoryService.java,,438-467,[                    {,                         public Object run() throws StandardException,                         {,                             OutputStreamWriter osw=null; ,                             try ,                             {,                                 StorageFile fileReadMe = storageFactory.newStorageFile(,                                     PersistentService.DB_README_FILE_NAME);,                                 osw = new OutputStreamWriter(fileReadMe.getOutputStream(),"UTF8");,                                 osw.write(MessageService.getTextMessage(,                                         MessageId.README_AT_DB_LEVEL));,                             },                             catch (IOException ioe),                             {,                             },                             finally,                             {,                                 if (osw != null),                                 {,                                     try,                                     {,                                         osw.close();,                                     },                                     catch (IOException ioe),                                     {,                                         // Ignore exception on close,                                     },                                 },                             },                             return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/monitor/StorageFactoryService.java,,492-526,[                {,                     public Object run() throws StandardException,                     {,                         // Since this is the backup location, we cannot use,                         // storageFactory.newStorageFile as in the other,                         // variant of this method:,                         File servicePropertiesFile = ,                             new File(serviceName, PersistentService.PROPERTIES_NAME);, ,                         FileOutputStream fos = null;,                         try {, ,                             fos = new FileOutputStream(servicePropertiesFile);,                             FileUtil.limitAccessToOwner(servicePropertiesFile);, ,                             properties.store(fos, ,                                              serviceName + ,                                              MessageService.getTextMessage(,                                                   MessageId.SERVICE_PROPERTIES_DONT_EDIT));,                             fos.getFD().sync();,                             fos.close();,                             fos = null;,                         } catch (IOException ioe) {,                             if (fos != null) {,                                 try {,                                     fos.close();,                                 } catch (IOException ioe2) {,                                 },                                 fos = null;,                             }, ,                             throw Monitor.exceptionStartingModule(ioe);,                         }, 		,                         return null;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/services/monitor/StorageFactoryService.java,run,1123-1123,[                    catch (Exception se) { continue; }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/services/monitor/StorageFactoryService.java,nextElement,1085-1085,[            return contents[index++];],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/services/monitor/TopService.java,addToProtocol,411-411,[		String identifier = module.getIdentifier();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/services/monitor/TopService.java,,328-328,[		ModuleInstance module = new ModuleInstance(instance, key.getIdentifier(), service,],,,128-128,[		return topModule.getInstance();],,,177-177,[			if (topModule != null) {],,,179-179,[					SanityManager.ASSERT(topModule.isTypeAndName(serviceType,],,,187-187,[			while (!inShutdown && (topModule == null)) {],,,164-164,[			return (topModule != null);],,,108-108,[                topModule = module;],,,120-120,[				addToProtocol(userKey, topModule);],,,152-152,[		if (topModule != null)],,,153-153,[			return topModule.isTypeAndName(serviceType, key.getFactoryInterface(), otherCanonicalName);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/impl/services/monitor/UpdateServiceProperties.java,,56-138,[		super(actualSet);, 		this.serviceType = serviceType;, 		this.serviceName = serviceName;, 		this.serviceBooted = serviceBooted;, 	}, , 	//look at the comments for serviceBooted at the top to understand this., 	public void setServiceBooted() {, 		serviceBooted = true;, 	}, ,     public void setStorageFactory( WritableStorageFactory storageFactory),     {,         this.storageFactory = storageFactory;,     }, ,     public WritableStorageFactory getStorageFactory(),     {,         return storageFactory;,     },     , 	/*, 	** Methods of Hashtable (overridden), 	*/, , 	/**	, 		Put the key-value pair in the Properties set and, 		mark this set as modified., , 		@see Hashtable#put, 	*/, 	public Object put(Object key, Object value) {, 		Object ref = defaults.put(key, value);, 		if (!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX)), 			update();, 		return ref;, 	}, , 	/**	, 		Remove the key-value pair from the Properties set and, 		mark this set as modified., , 		@see Hashtable#remove, 	*/, 	public Object remove(Object key) {, 		Object ref = defaults.remove(key);, 		if ((ref != null) &&, 			(!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX))), 			update();, 		return ref;, 	}, , 	/**, 	   Saves the service properties to the disk., 	 */, 	public void saveServiceProperties(), 	{,         if( SanityManager.DEBUG),             SanityManager.ASSERT( storageFactory != null,,                                   "UpdateServiceProperties.saveServiceProperties() called before storageFactory set.");, 		try{, 			serviceType.saveServiceProperties(serviceName, storageFactory,, 					BaseMonitor.removeRuntimeProperties(defaults), false);, 		} catch (StandardException mse) {, 			throw new PassThroughException(mse);, 		}, 	}, , 	/*, 	** Class specific methods., 	*/, , 	private void update() {, , 		try {, 			//look at the comments for serviceBooted at the top to understand this if., 			if (serviceBooted), 				serviceType.saveServiceProperties(serviceName, storageFactory,, 					BaseMonitor.removeRuntimeProperties(defaults), true);, 		} catch (StandardException mse) {, 			throw new PassThroughException(mse);, 		}, 	}],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/reflect/DatabaseClasses.java,WriteClassFile,189-189,[                throw (IOException) pae.getCause();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/services/reflect/DatabaseClasses.java,WriteClassFile,168-202,[        int lastDot = fullyQualifiedName.lastIndexOf((int)'.');,         String filename = fullyQualifiedName.substring(lastDot+1,fullyQualifiedName.length()).concat(".class");, , 		Object env = Monitor.getMonitor().getEnvironment();, 		File dir = env instanceof File ? (File) env : null;, ,         final File classFile = new File(dir, filename);, , 		// find the error stream, 		HeaderPrintWriter errorStream = Monitor.getStream();, , 		try {,             FileOutputStream fis;,             try {,                 fis = AccessController.doPrivileged(,                         new PrivilegedExceptionAction<FileOutputStream>() {,                             public FileOutputStream run() throws IOException {,                                 return new FileOutputStream(classFile);,                             },                         });,             } catch (PrivilegedActionException pae) {,                 throw (IOException) pae.getCause();,             }, 			fis.write(bytecode.getArray(),, 				bytecode.getOffset(), bytecode.getLength());, 			fis.flush();, 			if (t!=null) {				, 				errorStream.printlnWithHeader(MessageService.getTextMessage(MessageId.CM_WROTE_CLASS_FILE, fullyQualifiedName, classFile, t));, 			}, 			fis.close();, 		} catch (IOException e) {, 			if (SanityManager.DEBUG), 				SanityManager.THROWASSERT("Unable to write .class file", e);, 		}, 	}],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/services/reflect/JarLoader.java,initialize,119-119,[                    throw (IOException) pae.getException();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/services/reflect/JarLoader.java,getSigners,497-497,[                return null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/services/reflect/UpdateLoader.java,,362-362,[		return version;],,,279-279,[		version++;],,,366-366,[		version++;],,,291-291,[		version++;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/services/reflect/UpdateLoader.java,,101-101,[        this.normalizeToUpper = normalizeToUpper;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/services/reflect/UpdateLoader.java,,102-102,[		this.parent = parent;],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/services/stream/BasicHeaderPrintWriter.java,<init>,62-62,[		super(writeTo, true);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/services/stream/RollingFileStream.java,,186-186,[        this.meter.write(b);],,,542-542,[        if (limit > 0 && meter.written >= limit) {],,,358-358,[        if (null != meter) {],,,359-359,[            meter.close();],,,534-534,[        meter = new MeteredStream(fout, len);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/stream/RollingFileStream.java,,418-421,[        String value = AccessController.doPrivileged(new PrivilegedAction<String>() {, ,             public String run() {,                 return System.getProperty(property);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/stream/RollingFileStream.java,,439-443,[            fis = AccessController.doPrivileged(new PrivilegedExceptionAction<FileOutputStream>() {, ,                 public FileOutputStream run() throws FileNotFoundException {,                     FileOutputStream res = new FileOutputStream(filename, append);,                     return res;],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/services/stream/RollingFileStream.java,run,464-464,[                return new Boolean(file.exists());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/stream/RollingFileStream.java,,461-464,[        Boolean value = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {, ,             public Boolean run() {,                 return new Boolean(file.exists());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/derby/impl/services/stream/RollingFileStream.java,run,481-481,[                file.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/stream/RollingFileStream.java,,478-482,[        AccessController.doPrivileged(new PrivilegedAction<Object>() {, ,             public Object run() {,                 file.delete();,                 return null;],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/services/stream/RollingFileStream.java,run,498-498,[                return new Boolean(file1.renameTo(file2));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/stream/RollingFileStream.java,,495-498,[        Boolean value = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {, ,             public Boolean run() {,                 return new Boolean(file1.renameTo(file2));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/services/stream/RollingFileStream.java,run,515-515,[                return new Long(file.length());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/services/stream/RollingFileStream.java,,512-515,[        Long value = AccessController.doPrivileged(new PrivilegedAction<Long>() {, ,             public Long run() {,                 return new Long(file.length());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/derby/impl/services/stream/RollingFileStream.java,,567-584,[        MeteredStream(OutputStream out, int written) {,             this.out = out;,             this.written = written;,         }, ,         public void write(int b) throws IOException {,             out.write(b);,             written++;,         },         ,         public int getWritten() {,             return written;,         }, ,         @Override,         public void close() throws IOException {,             out.close();,         }        ],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/services/stream/SingleStream.java,PBmakeFileHPW,204-204,[				fos = new FileOutputStream(streamFile);],,PBmakeFileHPW,205-205,[            FileUtil.limitAccessToOwner(streamFile);],,PBmakeFileHPW,206-206,[		} catch (IOException ioe) {],,PBmakeFileHPW,207-207,[			return useDefaultStream(header, ioe);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/services/stream/SingleStream.java,stop,100-100,[		((BasicHeaderPrintWriter) theStream).complete();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/services/uuid/BasicUUID.java,readMSB,155-155,[		catch (Exception e)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/services/uuid/BasicUUIDFactory.java,<init>,72-72,[			if (s != null)],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/sql/CursorInfo.java,<init>,84-84,[        this.updateColumns = (updateColumns == null) ?],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/GenericParameter.java,,45-45,[	private static int DECIMAL_PARAMETER_DEFAULT_PRECISION = 31;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/GenericParameter.java,,46-46,[	private static int DECIMAL_PARAMETER_DEFAULT_SCALE = 15;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/GenericParameterValueSet.java,checkNoDeclaredOutputParameters,409-417,[			switch (gp.parameterMode) {,             case (ParameterMetaData.parameterModeIn):, 				break;,             case (ParameterMetaData.parameterModeInOut):,             case (ParameterMetaData.parameterModeOut):, 				hasDeclaredOutputParameter = true;, 				break;,             case (ParameterMetaData.parameterModeUnknown):,                 gp.parameterMode = (ParameterMetaData.parameterModeIn);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/GenericPreparedStatement.java,getParameterType,529-529,[			throw StandardException.newException],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/sql/GenericPreparedStatement.java,,1237-1237,[			if (!isValid || (inUseCount != 0))],,,286-286,[			inUseCount++;],,,670-670,[			inUseCount--;],,,675-675,[			if (inUseCount != 0) {],,
MT_CORRECTNESS,ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD,org/apache/derby/impl/sql/GenericStatement.java,prepMinion,259-259,[						preparedStmt = new GenericPreparedStatement(this);],,
STYLE,DMI_NONSERIALIZABLE_OBJECT_WRITTEN,org/apache/derby/impl/sql/GenericStorablePreparedStatement.java,writeExternal,185-185,[		out.writeObject(executionConstants);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/LanguageDbPropertySetter.java,validate,68-68,[			if (lcc.usesSqlAuthorization() && !Boolean.valueOf((String)value).booleanValue())],,
BAD_PRACTICE,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,org/apache/derby/impl/sql/catalog/DDColumnDependableFinder.java,,67-136,[		super(formatId);, 	}, , 	/**, 	 * Constructor given referenced column bit map byte array as in FormatableBitSet, 	 */,     DDColumnDependableFinder(int formatId, byte[] columnBitMap), 	{, 		super(formatId);, 		this.columnBitMap = columnBitMap;, 	}, ,     ////////////////////////////////////////////////////////////////////////,     //,     //  DDColumnDependable METHODS,     //,     ////////////////////////////////////////////////////////////////////////, , 	/**, 	 * Find a dependable object, which is essentially a table descriptor with, 	 * referencedColumnMap field set., 	 *, 	 * @param	dd data dictionary, 	 * @param	dependableObjectID dependable object ID (table UUID), 	 * @return	a dependable, a table descriptor with referencedColumnMap, 	 *			field set, 	 */, 	Dependable findDependable(DataDictionary dd, UUID dependableObjectID), 		throws StandardException, 	{, 		TableDescriptor td = dd.getTableDescriptor(dependableObjectID);, 		if (td != null)  // see beetle 4444, 			td.setReferencedColumnMap(new FormatableBitSet(columnBitMap));, 		return td;, 	}, ,     //////////////////////////////////////////////////////////////////,     //,     //  FORMATABLE METHODS,     //,     //////////////////////////////////////////////////////////////////, , 	/**, 	 * Read this object from a stream of stored objects.  Just read the, 	 * byte array, besides what the parent does., 	 *, 	 * @param in read this., 	 */, 	public void readExternal( ObjectInput in ), 			throws IOException, ClassNotFoundException, 	{, 		super.readExternal(in);, 		FormatableHashtable fh = (FormatableHashtable)in.readObject();, 		columnBitMap = (byte[])fh.get("columnBitMap");, 	}, , 	/**, 	 * Write this object to a stream of stored objects.  Just write the, 	 * byte array, besides what the parent does., 	 *, 	 * @param out write bytes here., 	 */, 	public void writeExternal( ObjectOutput out ), 			throws IOException, 	{, 		super.writeExternal(out);, 		FormatableHashtable fh = new FormatableHashtable();, 		fh.put("columnBitMap", columnBitMap);, 		out.writeObject(fh);, 	}],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/DD_Version.java,handleMinorRevisionChange,570-570,[				lastRun = this;],,handleMinorRevisionChange,565-565,[				lastRun = fromVersion;],,
BAD_PRACTICE,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,org/apache/derby/impl/sql/catalog/DDdependableFinder.java,,69-282,[	{, 		this.formatId = formatId;, 	}, , 	//////////////////////////////////////////////////////////////////, 	//, 	//	OBJECT SUPPORT, 	//, 	//////////////////////////////////////////////////////////////////, , 	public	String	toString(), 	{, 		return	getSQLObjectType();, 	}, , 	//////////////////////////////////////////////////////////////////, 	//, 	//	VACUOUS FORMATABLE INTERFACE. ALL THAT A VACUOUSDEPENDABLEFINDER, 	//	NEEDS TO DO IS STAMP ITS FORMAT ID ONTO THE OUTPUT STREAM., 	//, 	//////////////////////////////////////////////////////////////////, , 	/**, 	 * Read this object from a stream of stored objects. Nothing to, 	 * do. Our persistent representation is just a 2-byte format id., 	 *, 	 * @param in read this., 	 */,     public void readExternal( ObjectInput in ), 			throws IOException, ClassNotFoundException, 	{, 	}, , 	/**, 	 * Write this object to a stream of stored objects. Again, nothing, 	 * to do. We just stamp the output stream with our Format id., 	 *, 	 * @param out write bytes here., 	 */,     public void writeExternal( ObjectOutput out ), 			throws IOException, 	{, 	}, , 	/**, 	 * Get the formatID which corresponds to this class., 	 *, 	 *	@return	the formatID of this class, 	 */, 	public	final int	getTypeFormatId()	, 	{, 		return formatId;, 	}, , 	////////////////////////////////////////////////////////////////////////, 	//, 	//	DDdependable METHODS, 	//, 	////////////////////////////////////////////////////////////////////////, , 	/**, 	  * @see DependableFinder#getSQLObjectType, 	  */, 	public	String	getSQLObjectType(), 	{, 		switch (formatId), 		{, 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.ALIAS;, , 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.CONGLOMERATE;, , 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.CONSTRAINT;, , 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.DEFAULT;, , 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:, 				return Dependable.FILE;, , 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.SCHEMA;, , 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.STORED_PREPARED_STATEMENT;, , 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.TABLE;, , 			case StoredFormatIds.COLUMN_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.COLUMNS_IN_TABLE;, , 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.TRIGGER;, , 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.VIEW;, , 			case StoredFormatIds.TABLE_PERMISSION_FINDER_V01_ID:, 				return Dependable.TABLE_PERMISSION;, 			, 			case StoredFormatIds.COLUMNS_PERMISSION_FINDER_V01_ID:, 				return Dependable.COLUMNS_PERMISSION;, , 			case StoredFormatIds.ROUTINE_PERMISSION_FINDER_V01_ID:, 				return Dependable.ROUTINE_PERMISSION;, , 			case StoredFormatIds.ROLE_GRANT_FINDER_V01_ID:, 				return Dependable.ROLE_GRANT;, , 			case StoredFormatIds.SEQUENCE_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.SEQUENCE;, , 			case StoredFormatIds.PERM_DESCRIPTOR_FINDER_V01_ID:, 				return Dependable.PERM;, , 			default:, 				if (SanityManager.DEBUG), 				{, 					SanityManager.THROWASSERT(, 						"getSQLObjectType() called with unexpeced formatId = " + formatId);, 				}, 				return null;, 		}, 	}, , 	/**, 		Get the dependable for the given UUID, 		@exception StandardException thrown on error, 	*/, 	public final Dependable getDependable(DataDictionary dd, UUID dependableObjectID), 		throws StandardException, 	{,         Dependable dependable = findDependable(dd, dependableObjectID);,         if (dependable == null),             throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND,,                     getSQLObjectType(), dependableObjectID);,         return dependable;,     },         ,        ,     /**,      * Find the dependable for getDependable.,      * Can return a null references, in which case getDependable(),      * will thrown an exception.,      */,     Dependable findDependable(DataDictionary dd, UUID dependableObjectID),         throws StandardException,     {     , 		switch (formatId), 		{, 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getAliasDescriptor(dependableObjectID);, , 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getConglomerateDescriptor(dependableObjectID);, , 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getConstraintDescriptor(dependableObjectID);, , 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:, 				ColumnDescriptor	cd = dd.getColumnDescriptorByDefaultId(dependableObjectID);,                 if (cd != null),                     return new DefaultDescriptor(, 												dd, , 												cd.getDefaultUUID(), cd.getReferencingUUID(), , 												cd.getPosition());,                 return null;, , 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:,                 return dd.getFileInfoDescriptor(dependableObjectID);, , 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getSchemaDescriptor(dependableObjectID, null);, , 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getSPSDescriptor(dependableObjectID);, , 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getTableDescriptor(dependableObjectID);, , 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getTriggerDescriptor(dependableObjectID);,  , 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getViewDescriptor(dependableObjectID);, ,             case StoredFormatIds.COLUMNS_PERMISSION_FINDER_V01_ID:,                 return dd.getColumnPermissions(dependableObjectID);, , 			case StoredFormatIds.TABLE_PERMISSION_FINDER_V01_ID:,                 return dd.getTablePermissions(dependableObjectID);, , 			case StoredFormatIds.ROUTINE_PERMISSION_FINDER_V01_ID:,                 return dd.getRoutinePermissions(dependableObjectID);, , 		    case StoredFormatIds.ROLE_GRANT_FINDER_V01_ID:, 				return dd.getRoleGrantDescriptor(dependableObjectID);, , 			case StoredFormatIds.SEQUENCE_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getSequenceDescriptor(dependableObjectID);, , 			case StoredFormatIds.PERM_DESCRIPTOR_FINDER_V01_ID:,                 return dd.getGenericPermissions(dependableObjectID);, , 		default:, 				if (SanityManager.DEBUG), 				{, 					SanityManager.THROWASSERT(, 						"getDependable() called with unexpeced formatId = " + formatId);, 				},                 return null;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,addConstraintDescriptor,6284-6284,[				addSubKeyConstraint((KeyConstraintDescriptor) descriptor, tc);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,dropAllPermDescriptors,14224-14224,[            perm = (PermissionsDescriptor) rf.buildDescriptor(curRow, (TupleDescriptor) null, this);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,dropAllRoutinePermDescriptors,3149-3149,[			perm = (PermissionsDescriptor)rf.buildDescriptor(curRow, (TupleDescriptor) null, this);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,dropColumnPermDescriptor,3692-3692,[			perm = (PermissionsDescriptor)rf.buildDescriptor(curRow, (TupleDescriptor) null, this);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,dropTablePermDescriptor,3661-3661,[			perm = (PermissionsDescriptor)rf.buildDescriptor(curRow, (TupleDescriptor) null, this);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,getAllDependencyDescriptorsList,7403-7403,[				     rf.buildDescriptor(outRow,],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,getConstraintDescriptorViaHeap,6018-6018,[				cd = (ConstraintDescriptor) rf.buildDescriptor(],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,getConstraintDescriptorViaIndex,5914-5914,[			cd = (ConstraintDescriptor) rf.buildDescriptor(],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,getRoleGrantGraph,3362-3362,[			grantDescr = (RoleGrantDescriptor)rf.buildDescriptor(],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,hashAllConglomerateDescriptorsByNumber,6773-6773,[			cd = (ConglomerateDescriptor) rf.buildDescriptor(],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,hashAllTableDescriptorsByTableId,6833-6833,[				rf.buildDescriptor(],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,upgradeJarStorage,8197-8197,[                    buildDescriptor(outRow, null, this);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,visitPermsByGrantee,3601-3601,[						buildDescriptor(outRow,],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,addRemovePermissionsDescriptor,13465-13465,[            rl = heapCC.newRowLocationTemplate();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,populateSYSDUMMY1,8874-8874,[		int insertRetCode = ti.insertRow(row, tc);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,upgradeSYSROUTINEPERMS_10_6,2746-2746,[		int deleteCount = rpTI.deleteRow(tc, rpKeyRow, SYSROUTINEPERMSRowFactory.GRANTEE_ALIAS_GRANTOR_INDEX_NUM);],,
BAD_PRACTICE,DM_EXIT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,getDescriptorViaIndexMinion,9393-9393,[                    System.exit(1);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,hashAllConglomerateDescriptorsByNumber,6777-6777,[			Long hashKey = new Long(cd.getConglomerateNumber());],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,,13251-13251,[			InputStream is = getClass().getResourceAsStream(spsSet);],,,13241-13241,[		spsSet = net ? "metadata_net.properties" : "/org/apache/derby/impl/jdbc/metadata.properties";],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,create_10_3_system_procedures_SYSIBM,12163-12163,[            createSystemProcedureOrFunction(],,create_10_3_system_procedures_SYSIBM,12357-12357,[            createSystemProcedureOrFunction(],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,create_10_3_system_procedures_SYSIBM,12163-12163,[            createSystemProcedureOrFunction(],,create_10_3_system_procedures_SYSIBM,12357-12357,[            createSystemProcedureOrFunction(],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,initSystemIndexVariables,9733-9733,[			initSystemIndexVariables(retval);],,initSystemIndexVariables,9621-9621,[		if (retval == null)],,initSystemIndexVariables,9631-9631,[			switch (catalogNumber)],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,run,13251-13251,[			InputStream is = getClass().getResourceAsStream(spsSet);],,run,13252-13252,[			p.load(is);],,run,13254-13254,[		} catch (IOException ioe) {}],,run,13255-13255,[		return p;],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,run,13251-13251,[			InputStream is = getClass().getResourceAsStream(spsSet);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,computeAutoincRowLocations,8631-8631,[			return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,justTheRequiredColumns,5081-5081,[			return null;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,addConstraintDescriptor,6269-6298,[		switch (type), 		{, 			case DataDictionary.PRIMARYKEY_CONSTRAINT:, 			case DataDictionary.FOREIGNKEY_CONSTRAINT:, 			case DataDictionary.UNIQUE_CONSTRAINT:, 				if (SanityManager.DEBUG), 				{, 					if (!(descriptor instanceof KeyConstraintDescriptor)), 					{, 						SanityManager.THROWASSERT(, 							"descriptor expected to be instanceof KeyConstraintDescriptor, " +, 							"not, " + descriptor.getClass().getName());, 					}, 				}, , 				addSubKeyConstraint((KeyConstraintDescriptor) descriptor, tc);, 				break;, , 			case DataDictionary.CHECK_CONSTRAINT:, 				if (SanityManager.DEBUG), 				{, 					if (!(descriptor instanceof CheckConstraintDescriptor)), 					{, 						SanityManager.THROWASSERT("descriptor expected "+, 							"to be instanceof CheckConstraintDescriptorImpl, " +, 							"not, " + descriptor.getClass().getName());, 					}, 				}, , 				addDescriptor(descriptor, null, SYSCHECKS_CATALOG_NUM, true, tc);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,dropConstraintDescriptor,6413-6424,[		switch (descriptor.getConstraintType()), 		{, 			case DataDictionary.PRIMARYKEY_CONSTRAINT: , 			case DataDictionary.FOREIGNKEY_CONSTRAINT: , 			case DataDictionary.UNIQUE_CONSTRAINT: , 				dropSubKeyConstraint(, 							descriptor,, 							tc);, 				break;, , 			case DataDictionary.CHECK_CONSTRAINT: , 				dropSubCheckConstraint(],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,getNonCoreTIByNumber,9631-9727,[			switch (catalogNumber), 			{, 			  case SYSCONSTRAINTS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSCONSTRAINTSRowFactory(, 												luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSKEYS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSKEYSRowFactory(, 												luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSDEPENDS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSDEPENDSRowFactory(, 												luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSVIEWS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSVIEWSRowFactory(, 												luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSCHECKS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSCHECKSRowFactory(, 												luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSFOREIGNKEYS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSFOREIGNKEYSRowFactory(, 												luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSSTATEMENTS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSSTATEMENTSRowFactory(, 												luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSFILES_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSFILESRowFactory(, 												luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSALIASES_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSALIASESRowFactory(, 												luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSTRIGGERS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSTRIGGERSRowFactory(,                                           this, luuidFactory, exFactory, dvf));, 				break;, , 			  case SYSSTATISTICS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSSTATISTICSRowFactory(, 												 luuidFactory, exFactory, dvf));					 , 				break;, , 			  case SYSDUMMY1_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSDUMMY1RowFactory(, 												 luuidFactory, exFactory, dvf));					 , 				break;, , 			  case SYSTABLEPERMS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSTABLEPERMSRowFactory(, 												 luuidFactory, exFactory, dvf));					 , 				break;, , 			  case SYSCOLPERMS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSCOLPERMSRowFactory(, 												 luuidFactory, exFactory, dvf));					 , 				break;, , 			  case SYSROUTINEPERMS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSROUTINEPERMSRowFactory(, 												 luuidFactory, exFactory, dvf));					 , 				break;, , 			  case SYSROLES_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSROLESRowFactory(, 											 luuidFactory, exFactory, dvf));, , 				break;, ,               case SYSSEQUENCES_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSSEQUENCESRowFactory(, 											 luuidFactory, exFactory, dvf));, , 				break;, ,               case SYSPERMS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSPERMSRowFactory(, 											 luuidFactory, exFactory, dvf));, , 				break;            , ,               case SYSUSERS_CATALOG_NUM:, 				retval = new TabInfoImpl(new SYSUSERSRowFactory(],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,updateConstraintDescriptor,6370-6382,[				switch (colsToSet[i]), 				{, 					case SYSCONSTRAINTSRowFactory.SYSCONSTRAINTS_CONSTRAINTID:, 						bArray[0] = true;, 						break;, , 					case SYSCONSTRAINTSRowFactory.SYSCONSTRAINTS_CONSTRAINTNAME:, 					case SYSCONSTRAINTSRowFactory.SYSCONSTRAINTS_SCHEMAID:, 						bArray[1] = true;, 						break;, 					, 					case SYSCONSTRAINTSRowFactory.SYSCONSTRAINTS_TABLEID:, 						bArray[2] = true;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,updateTriggerDescriptor,5459-5471,[				switch (colsToSet[i]), 				{, 					case SYSTRIGGERSRowFactory.SYSTRIGGERS_TRIGGERID:, 						bArray[0] = true;, 						break;, , 					case SYSTRIGGERSRowFactory.SYSTRIGGERS_TRIGGERNAME:, 					case SYSTRIGGERSRowFactory.SYSTRIGGERS_SCHEMAID:, 						bArray[1] = true;, 						break;, 					, 					case SYSTRIGGERSRowFactory.SYSTRIGGERS_TABLEID:, 						bArray[2] = true;],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,addRemovePermissionsDescriptor,13534-13534,[            else if( changedColCount > 0)],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,locateSchemaRow,1722-1722,[		return locateSchemaRowBody(],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,doneReading,1167-1167,[					readersInDDLMode--;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,startReading,1106-1106,[                        readersInDDLMode++;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,startWriting,1296-1296,[					ddlUsers++;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,transactionFinished,1331-1331,[			ddlUsers--;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/catalog/DropDependencyFilter.java,,60-60,[	DataValueFactory	dataValueFactory = null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/catalog/NameTDCacheable.java,createIdentity,86-86,[		if (td != null)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/catalog/OIDTDCacheable.java,createIdentity,83-83,[		if (td != null)],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/sql/catalog/PermissionsCacheable.java,createIdentity,200-200,[								  "Invalid class, " + key.getClass().getName()],,createIdentity,203-203,[		if( key == null)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/catalog/SPSNameCacheable.java,createIdentity,103-103,[		if (spsd != null)],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSALIASESRowFactory.java,makeRow,152-152,[			AliasDescriptor 		ad = (AliasDescriptor)td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCHECKSRowFactory.java,makeRow,117-117,[			CheckConstraintDescriptor cd = (CheckConstraintDescriptor)td;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSCHECKSRowFactory.java,buildDescriptor,185-185,[		ddg = dd.getDataDescriptorGenerator();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCOLPERMSRowFactory.java,makeRow,120-120,[            ColPermsDescriptor cpd = (ColPermsDescriptor) td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCOLPERMSRowFactory.java,buildIndexKeyRow,225-225,[            colPerms = (ColPermsDescriptor) perm;],,buildIndexKeyRow,213-213,[            ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCOLPERMSRowFactory.java,orPermissions,253-253,[        ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCOLPERMSRowFactory.java,removePermissions,289-289,[        ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/SYSCOLPERMSRowFactory.java,buildIndexKeyRow,199-227,[        switch( indexNumber),         {,         case GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM:,             // RESOLVE We do not support the FOR GRANT OPTION, so column permission rows are unique on the,             // grantee, table UUID, and type columns. The grantor column will always have the name of the owner of the,             // table. So the index key, used for searching the index, only has grantee, table UUID, and type columns.,             // It does not have a grantor column.,             //,             // If we support FOR GRANT OPTION then there may be multiple table permissions rows for a,             // (grantee, tableID, type) combination. We must either handle the multiple rows, which is necessary for,             // checking permissions, or add a grantor column to the key, which is necessary for granting or revoking,             // permissions.,             row = getExecutionFactory().getIndexableRow( 3);,             row.setColumn(1, getAuthorizationID( perm.getGrantee()));,             ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;,             String tableUUIDStr = colPerms.getTableUUID().toString();,             row.setColumn(2, new SQLChar(tableUUIDStr));,             row.setColumn(3, new SQLChar(colPerms.getType()));,             break;,         case COLPERMSID_INDEX_NUM:,             row = getExecutionFactory().getIndexableRow( 1);,             String colPermsUUIDStr = perm.getObjectID().toString();,             row.setColumn(1, new SQLChar(colPermsUUIDStr));,             break;,         case TABLEID_INDEX_NUM:,             row = getExecutionFactory().getIndexableRow( 1);,             colPerms = (ColPermsDescriptor) perm;,             tableUUIDStr = colPerms.getTableUUID().toString();,             row.setColumn(1, new SQLChar(tableUUIDStr));],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCOLUMNSRowFactory.java,makeRow,169-169,[			ColumnDescriptor  column = (ColumnDescriptor)td;],,makeRow,245-245,[			ColumnDescriptor  column = (ColumnDescriptor)td;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSCOLUMNSRowFactory.java,buildDescriptor,335-335,[		DataDescriptorGenerator	ddg = dd.getDataDescriptorGenerator();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSCOLUMNSRowFactory.java,buildDescriptor,413-413,[		autoincInc = row.getColumn(SYSCOLUMNS_AUTOINCREMENTINC).getLong();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSCOLUMNSRowFactory.java,buildDescriptor,410-410,[		autoincStart = row.getColumn(SYSCOLUMNS_AUTOINCREMENTSTART).getLong();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/catalog/SYSCOLUMNSRowFactory.java,makeRow,176-176,[			colID = new Integer(column.getPosition() );],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCONGLOMERATESRowFactory.java,makeRow,137-137,[		ConglomerateDescriptor  conglomerate = (ConglomerateDescriptor)td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCONGLOMERATESRowFactory.java,makeRow,150-150,[				SchemaDescriptor sd = (SchemaDescriptor)parent;],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/sql/catalog/SYSCONGLOMERATESRowFactory.java,makeRow,162-162,[			supportsIndex = new Boolean( conglomerate.isIndex() );],,makeRow,164-164,[			supportsConstraint = new Boolean( conglomerate.isConstraint() );],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/catalog/SYSCONGLOMERATESRowFactory.java,makeRow,158-158,[			conglomNumber = new Long( conglomerate.getConglomerateNumber() );],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCONSTRAINTSRowFactory.java,makeRow,145-145,[			ConstraintDescriptor constraint = (ConstraintDescriptor)td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCONSTRAINTSRowFactory.java,buildDescriptor,605-605,[				constraintDesc = ddg.newCheckConstraintDescriptor(],,buildDescriptor,612-612,[											parentTupleDescriptor).getConstraintText(),],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSCONSTRAINTSRowFactory.java,buildDescriptor,416-416,[				conglomDesc = td.getConglomerateDescriptor( ],,buildDescriptor,440-440,[					conglomDesc = td.getConglomerateDescriptor( ],,buildDescriptor,451-451,[				referencedConstraintId = ((SubKeyConstraintDescriptor) ],,buildDescriptor,543-543,[				constraintDesc = ddg.newPrimaryKeyConstraintDescriptor(],,buildDescriptor,558-558,[				constraintDesc = ddg.newUniqueConstraintDescriptor(],,buildDescriptor,579-579,[				constraintDesc = ddg.newForeignKeyConstraintDescriptor(],,buildDescriptor,587-587,[											parentTupleDescriptor).getIndexId(),],,buildDescriptor,592-592,[											parentTupleDescriptor).getRaDeleteRule(),],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSCONSTRAINTSRowFactory.java,buildDescriptor,450-450,[				keyColumns = conglomDesc.getIndexDescriptor().baseColumnPositions();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/catalog/SYSCONSTRAINTSRowFactory.java,buildDescriptor,437-437,[					if (scd != null)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/catalog/SYSCONSTRAINTSRowFactory.java,buildDescriptor,365-365,[		if (scd != null)],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/derby/impl/sql/catalog/SYSCONSTRAINTSRowFactory.java,buildDescriptor,392-396,[				typeSet = true;, 				// fall through, , 			case 'U' :, 				if (! typeSet)],,buildDescriptor,399-404,[					typeSet = true;, 				}, 				// fall through, , 			case 'F' :, 				if (! typeSet)],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/SYSCONSTRAINTSRowFactory.java,buildDescriptor,540-605,[		switch (constraintIType), 		{, 			case DataDictionary.PRIMARYKEY_CONSTRAINT : , 				constraintDesc = ddg.newPrimaryKeyConstraintDescriptor(, 										td, , 										constraintName, ,                                         deferrable,,                                         initiallyDeferred,, 										keyColumns,//genReferencedColumns(dd, td), //int referencedColumns[],, 										constraintUUID,, 										((SubKeyConstraintDescriptor) , 											parentTupleDescriptor).getIndexId(),, 										schema,,                                         enforced,, 										referenceCount);, 				break;, , 			case DataDictionary.UNIQUE_CONSTRAINT :, 				constraintDesc = ddg.newUniqueConstraintDescriptor(, 										td, , 										constraintName, ,                                         deferrable,,                                         initiallyDeferred,, 										keyColumns,//genReferencedColumns(dd, td), //int referencedColumns[],, 										constraintUUID,, 										((SubKeyConstraintDescriptor) , 											parentTupleDescriptor).getIndexId(),, 										schema,,                                         enforced,, 										referenceCount);, 				break;, , 			case DataDictionary.FOREIGNKEY_CONSTRAINT : , 				if (SanityManager.DEBUG), 				{, 					SanityManager.ASSERT(referenceCount == 0, , 						"REFERENCECOUNT column is nonzero for fk constraint");, 				}, 					, 				constraintDesc = ddg.newForeignKeyConstraintDescriptor(, 										td, , 										constraintName, ,                                         deferrable,,                                         initiallyDeferred,, 										keyColumns,//genReferencedColumns(dd, td), //int referencedColumns[],, 										constraintUUID,, 										((SubKeyConstraintDescriptor) , 											parentTupleDescriptor).getIndexId(),, 										schema,, 										referencedConstraintId,,                                         enforced,, 										((SubKeyConstraintDescriptor) , 											parentTupleDescriptor).getRaDeleteRule(),, 										((SubKeyConstraintDescriptor) , 											parentTupleDescriptor).getRaUpdateRule(), 										);, 				break;, , 			case DataDictionary.CHECK_CONSTRAINT :, 				if (SanityManager.DEBUG), 				{, 					SanityManager.ASSERT(referenceCount == 0, , 						"REFERENCECOUNT column is nonzero for check constraint");, 				}, 					, 				constraintDesc = ddg.newCheckConstraintDescriptor(],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSDEPENDSRowFactory.java,makeRow,124-124,[			DependencyDescriptor dd = (DependencyDescriptor)td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSFILESRowFactory.java,makeRow,140-140,[			FileInfoDescriptor descriptor = (FileInfoDescriptor)td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSFOREIGNKEYSRowFactory.java,makeRow,126-126,[			ForeignKeyConstraintDescriptor cd = (ForeignKeyConstraintDescriptor)td;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSFOREIGNKEYSRowFactory.java,buildDescriptor,204-204,[		ddg = dd.getDataDescriptorGenerator();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSKEYSRowFactory.java,makeRow,106-106,[			KeyConstraintDescriptor	constraint = (KeyConstraintDescriptor)td;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSKEYSRowFactory.java,buildDescriptor,174-174,[		ddg = dd.getDataDescriptorGenerator();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSPERMSRowFactory.java,makeRow,195-195,[            PermDescriptor sd = (PermDescriptor) td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSPERMSRowFactory.java,buildIndexKeyRow,122-122,[                String permUUIDStr = ((PermDescriptor) perm).getUUID().toString();],,buildIndexKeyRow,116-116,[            String protectedObjectsIDStr = ((PermDescriptor) perm).getPermObjectId().toString();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/SYSPERMSRowFactory.java,buildIndexKeyRow,108-123,[        switch (indexNumber) {,         case GRANTEE_OBJECTID_GRANTOR_INDEX_NUM:,             // RESOLVE We do not support the FOR GRANT OPTION, so generic permission rows are unique on the,             // grantee and object UUID columns. The grantor column will always have the name of the owner of the,             // object. So the index key, used for searching the index, only has grantee and object UUID columns.,             // It does not have a grantor column.,             row = getExecutionFactory().getIndexableRow( 2 );,             row.setColumn(1, getAuthorizationID( perm.getGrantee()));,             String protectedObjectsIDStr = ((PermDescriptor) perm).getPermObjectId().toString();,             row.setColumn(2, new SQLChar(protectedObjectsIDStr));,             break;, ,         case PERMS_UUID_IDX_NUM:,                 row = getExecutionFactory().getIndexableRow(1);,                 String permUUIDStr = ((PermDescriptor) perm).getUUID().toString();,                 row.setColumn(1, new SQLChar(permUUIDStr));],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSROLESRowFactory.java,makeRow,128-128,[            RoleGrantDescriptor rgd = (RoleGrantDescriptor)td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSROUTINEPERMSRowFactory.java,makeRow,104-104,[            RoutinePermsDescriptor rpd = (RoutinePermsDescriptor) td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSROUTINEPERMSRowFactory.java,buildIndexKeyRow,198-198,[            routineUUIDStr = ((RoutinePermsDescriptor) perm).getRoutineUUID().toString();],,buildIndexKeyRow,188-188,[            String routineUUIDStr = ((RoutinePermsDescriptor) perm).getRoutineUUID().toString();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/SYSROUTINEPERMSRowFactory.java,buildIndexKeyRow,172-199,[        switch( indexNumber),         {,         case GRANTEE_ALIAS_GRANTOR_INDEX_NUM:,             // RESOLVE We do not support the FOR GRANT OPTION, so rougine permission rows are unique on the,             // grantee and alias UUID columns. The grantor column will always have the name of the owner of the,             // routine. So the index key, used for searching the index, only has grantee and alias UUID columns.,             // It does not have a grantor column.,             //,             // If we support FOR GRANT OPTION then there may be multiple routine permissions rows for a,             // (grantee, aliasID) combination. Since there is only one kind of routine permission (execute),             // execute permission checking need not worry about multiple routine permission rows for a,             // (grantee, aliasID) combination, it only cares whether there are any. Grant and revoke must,             // look through multiple rows to see if the current user has grant/revoke permission and use,             // the full key in checking for the pre-existence of the permission being granted or revoked.,             row = getExecutionFactory().getIndexableRow( 2);,             row.setColumn(1, getAuthorizationID( perm.getGrantee()));,             String routineUUIDStr = ((RoutinePermsDescriptor) perm).getRoutineUUID().toString();,             row.setColumn(2, new SQLChar(routineUUIDStr));,             break;,         case ROUTINEPERMSID_INDEX_NUM:,             row = getExecutionFactory().getIndexableRow( 1);,             String routinePermsUUIDStr = perm.getObjectID().toString();,             row.setColumn(1, new SQLChar(routinePermsUUIDStr));,             break;,         case ALIASID_INDEX_NUM:,             row = getExecutionFactory().getIndexableRow( 1);,             routineUUIDStr = ((RoutinePermsDescriptor) perm).getRoutineUUID().toString();,             row.setColumn(1, new SQLChar(routineUUIDStr));],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSSCHEMASRowFactory.java,makeRow,132-132,[			SchemaDescriptor	schemaDescriptor = (SchemaDescriptor)td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSSEQUENCESRowFactory.java,makeRow,132-132,[            SequenceDescriptor sd = (SequenceDescriptor) td;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/catalog/SYSSEQUENCESRowFactory.java,buildDescriptor,255-255,[        else { currentValue = new Long( col.getLong() ) ; }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSSTATEMENTSRowFactory.java,buildDescriptor,274-274,[		DataDescriptorGenerator		ddg = dd.getDataDescriptorGenerator();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSSTATISTICSRowFactory.java,makeRow,152-152,[			StatisticsDescriptor statDesc = (StatisticsDescriptor)td;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSSTATISTICSRowFactory.java,buildDescriptor,211-211,[		Timestamp updateTime = (Timestamp) col.getObject();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/SYSSTATISTICSRowFactory.java,buildDescriptor,219-219,[		boolean valid = col.getBoolean();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSTABLEPERMSRowFactory.java,makeRow,116-116,[            TablePermsDescriptor tpd = (TablePermsDescriptor) td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSTABLEPERMSRowFactory.java,buildIndexKeyRow,248-248,[            tableUUIDStr = ((TablePermsDescriptor) perm).getTableUUID().toString();],,buildIndexKeyRow,238-238,[            String tableUUIDStr = ((TablePermsDescriptor) perm).getTableUUID().toString();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSTABLEPERMSRowFactory.java,orPermissions,275-275,[        TablePermsDescriptor tablePerms = (TablePermsDescriptor) perm;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSTABLEPERMSRowFactory.java,removePermissions,320-320,[        TablePermsDescriptor tablePerms = (TablePermsDescriptor) perm;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/SYSTABLEPERMSRowFactory.java,buildIndexKeyRow,224-249,[        switch( indexNumber),         {,         case GRANTEE_TABLE_GRANTOR_INDEX_NUM:,             // RESOLVE We do not support the FOR GRANT OPTION, so table permission rows are unique on the,             // grantee and table UUID columns. The grantor column will always have the name of the owner of the,             // table. So the index key, used for searching the index, only has grantee and table UUID columns.,             // It does not have a grantor column.,             //,             // If we support FOR GRANT OPTION then there may be multiple table permissions rows for a,             // (grantee, tableID) combination. We must either handle the multiple rows, which is necessary for,             // checking permissions, or add a grantor column to the key, which is necessary for granting or revoking,             // permissions.,             row = getExecutionFactory().getIndexableRow( 2);,             row.setColumn(1, getAuthorizationID( perm.getGrantee()));,             String tableUUIDStr = ((TablePermsDescriptor) perm).getTableUUID().toString();,             row.setColumn(2, new SQLChar(tableUUIDStr));,             break;,         case TABLEPERMSID_INDEX_NUM:,             row = getExecutionFactory().getIndexableRow( 1);,             String tablePermsUUIDStr = perm.getObjectID().toString();,             row.setColumn(1, new SQLChar(tablePermsUUIDStr));,             break;,         case TABLEID_INDEX_NUM:,             row = getExecutionFactory().getIndexableRow( 1);,             tableUUIDStr = ((TablePermsDescriptor) perm).getTableUUID().toString();,             row.setColumn(1, new SQLChar(tableUUIDStr));],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSTABLESRowFactory.java,makeRow,142-142,[			SchemaDescriptor schema = (SchemaDescriptor)parent;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSTABLESRowFactory.java,makeRow,141-141,[			TableDescriptor descriptor = (TableDescriptor)td;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/catalog/SYSTABLESRowFactory.java,buildEmptyIndexRow,240-253,[		switch( indexNumber ), 		{, 		    case SYSTABLES_INDEX1_ID:, 				/* 1st column is TABLENAME (varchar(128)) */, 				row.setColumn(1, new SQLVarchar());, , 				/* 2nd column is SCHEMAID (UUID - char(36)) */, 				row.setColumn(2, new SQLChar());, , 				break;, , 		    case SYSTABLES_INDEX2_ID:, 				/* 1st column is TABLEID (UUID - char(36)) */, 				row.setColumn(1,new SQLChar());],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSTRIGGERSRowFactory.java,makeRow,198-198,[			TriggerDescriptor triggerDescriptor = (TriggerDescriptor)td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSUSERSRowFactory.java,makeRow,127-127,[                UserDescriptor descriptor = (UserDescriptor) td;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/catalog/SYSVIEWSRowFactory.java,makeRow,119-119,[			ViewDescriptor vd = (ViewDescriptor)td;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/catalog/SequenceUpdater.java,getCurrentValueAndAdvance,341-341,[                updateCurrentValueOnDisk( new Long( currentValue ), null );],,getCurrentValueAndAdvance,347-347,[                if ( updateCurrentValueOnDisk( new Long( currentValue ), new Long( lastAllocatedValue ) ) )],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/catalog/TDCacheable.java,checkConsistency,119-119,[										td.getHeapConglomerateId()) ||],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/catalog/TabInfoImpl.java,getRowLocation,810-810,[			ExecRow notUsed = getRowInternal(tc, heapCC, key, indexNumber, rl);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/compile/AccessPathImpl.java,,45-45,[    private String          accessPathName =  "";],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java,generateOperator,1350-1351,[				mb.push(Orderable.ORDER_OP_EQUALS);, 				break;],,generateOperator,1354-1355,[				mb.push(Orderable.ORDER_OP_EQUALS);, 				break;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java,generateNegate,1373-1387,[        switch (relOpType), 		{, 			case RelationalOperator.EQUALS_RELOP:, 				mb.push(false);, 				break;, 			case RelationalOperator.NOT_EQUALS_RELOP:, 				mb.push(true);, 				break;, 			case RelationalOperator.LESS_THAN_RELOP:, 			case RelationalOperator.LESS_EQUALS_RELOP:, 				mb.push(!keyColumnOnLeft(optTable));, 				break;, 			case RelationalOperator.GREATER_THAN_RELOP:, 			case RelationalOperator.GREATER_EQUALS_RELOP:, 				mb.push(keyColumnOnLeft(optTable));],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java,generateOperator,1347-1364,[        switch (relOpType), 		{, 			case RelationalOperator.EQUALS_RELOP:, 				mb.push(Orderable.ORDER_OP_EQUALS);, 				break;, , 			case RelationalOperator.NOT_EQUALS_RELOP:, 				mb.push(Orderable.ORDER_OP_EQUALS);, 				break;, , 			case RelationalOperator.LESS_THAN_RELOP:, 			case RelationalOperator.GREATER_EQUALS_RELOP:, 				mb.push(keyColumnOnLeft(optTable) ? , 						Orderable.ORDER_OP_LESSTHAN : Orderable.ORDER_OP_LESSOREQUALS);, 				break;, 			case RelationalOperator.LESS_EQUALS_RELOP:, 			case RelationalOperator.GREATER_THAN_RELOP:, 				mb.push(keyColumnOnLeft(optTable) ? ],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/compile/CastNode.java,getCastFromCharConstant,536-536,[					return getCastFromIntegralType((new Double(cleanCharValue)).longValue(),],,getCastFromCharConstant,562-562,[					doubleValue = new Double(cleanCharValue);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/compile/CastNode.java,getCastFromIntegralType,662-662,[                   TypeId.getBuiltInTypeId(destJDBCTypeId),],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/compile/CastNode.java,getCastFromIntegralType,656-656,[                   TypeId.getBuiltInTypeId(destJDBCTypeId),],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/CastNode.java,bindExpression,310-362,[			switch (sourceJDBCTypeId), 			{, 				case Types.BIT:, 				case Types.BOOLEAN:, 					// (BIT is boolean), 					if (destJDBCTypeId == Types.BIT || destJDBCTypeId == Types.BOOLEAN), 					{, 						retNode = castOperand;, 					}, 					else if (destJDBCTypeId == Types.CHAR), 					{, 						BooleanConstantNode bcn = (BooleanConstantNode) castOperand;, 						String booleanString = bcn.getValueAsString();,                        retNode = new CharConstantNode(,                                 booleanString,,                                 getTypeServices().getMaximumWidth(),,                                 getContextManager());, 					}, 					break;, , 					case Types.CHAR:, 						retNode = getCastFromCharConstant(destJDBCTypeId);, 						break;, , 					case Types.DATE:, 					case Types.TIME:, 					case Types.TIMESTAMP:, 						if (destJDBCTypeId == Types.CHAR), 						{, 							String castValue =  , 								((UserTypeConstantNode) castOperand)., 											getObjectValue()., 												toString();,                            retNode = new CharConstantNode(,                                castValue,,                                getTypeServices().getMaximumWidth(),,                                getContextManager());, 						}, 						break;, , 					case Types.DECIMAL:, 						// ignore decimal -> decimal casts for now, 						if (destJDBCTypeId == Types.DECIMAL ||, 							destJDBCTypeId == Types.NUMERIC), 							break;, 						// fall through, 					case Types.TINYINT:, 					case Types.SMALLINT:, 					case Types.INTEGER:, 					case Types.BIGINT:, 					case Types.DOUBLE:, 					case Types.REAL:, 						retNode = getCastFromNumericType(],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/compile/CharConstantNode.java,<init>,105-105,[           newValue = newValue + ' ';],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/compile/ColumnOrdering.java,toString,184-184,[				retval += " Table " + tables.get(i) +],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/compile/ColumnReference.java,remapColumnReferencesToExpressions,853-853,[			if (sourceRC == null)],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/compile/CompilerContextImpl.java,getSavedObjects,334-334,[		if (savedObjects == null) return null;],,
STYLE,UC_USELESS_CONDITION_TYPE,org/apache/derby/impl/sql/compile/CompilerContextImpl.java,getUniqueClassName,231-231,[    		SanityManager.ASSERT(nextClassName <= Long.MAX_VALUE);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/derby/impl/sql/compile/CompilerContextImpl.java,getRequiredPermissionsList,929-929,[                        requiredUsagePrivileges.get(objectID),],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/ConcatenationOperatorNode.java,resolveConcatOperation,389-423,[			switch (rightTypeId.getJDBCTypeId()) {, 			case Types.CHAR:, 			case Types.BINARY:, 				if (resultLength > Limits.DB2_CHAR_MAXWIDTH) {, 					if (rightTypeId.getJDBCTypeId() == Types.CHAR), 						//operands CHAR(A) CHAR(B) and A+B>254 then result is, 						// VARCHAR(A+B), 						higherType = TypeId.VARCHAR_NAME;, 					else, 						//operands CHAR FOR BIT DATA(A) CHAR FOR BIT DATA(B), 						// and A+B>254 then result is VARCHAR FOR BIT DATA(A+B), 						higherType = TypeId.VARBIT_NAME;, 				}, 				break;, , 			case Types.VARCHAR:, 			case Types.VARBINARY:, 				if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH) {, 					if (rightTypeId.getJDBCTypeId() == Types.VARCHAR), 						//operands CHAR(A) VARCHAR(B) and A+B>4000 then result, 						// is LONG VARCHAR, 						higherType = TypeId.LONGVARCHAR_NAME;, 					else, 						//operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT DATA(B), 						// and A+B>4000 then result is LONG VARCHAR FOR BIT DATA, 						higherType = TypeId.LONGVARBIT_NAME;, 				}, 				break;, , 			case Types.CLOB:, 			case Types.BLOB:, 				//operands CHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G)), 				//operands CHAR FOR BIT DATA(A), BLOB(B) then result is, 				// BLOB(MIN(A+B,2G)), 				resultLength = clobBlobHandling(rightType, leftType);],,resolveConcatOperation,427-438,[			switch (rightTypeId.getJDBCTypeId()) {, 			case Types.CHAR: //operands CHAR(A) VARCHAR(B) and A+B>4000 then, 							 // result is LONG VARCHAR, 			case Types.VARCHAR: //operands VARCHAR(A) VARCHAR(B) and A+B>4000, 								// then result is LONG VARCHAR, 				if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH), 					higherType = TypeId.LONGVARCHAR_NAME;, 				break;, , 			case Types.CLOB:, 				//operands VARCHAR(A), CLOB(B) then result is CLOB(MIN(A+B,2G)), 				resultLength = clobBlobHandling(rightType, leftType);],,resolveConcatOperation,442-456,[			switch (rightTypeId.getJDBCTypeId()) {, 			case Types.BINARY: //operands CHAR FOR BIT DATA(A) VARCHAR FOR BIT, 							   // DATA(B) and A+B>4000 then result is LONG, 							   // VARCHAR FOR BIT DATA, 			case Types.VARBINARY://operands VARCHAR FOR BIT DATA(A) VARCHAR FOR, 								 // BIT DATA(B) and A+B>4000 then result is LONG, 								 // VARCHAR FOR BIT DATA, 				if (resultLength > Limits.DB2_CONCAT_VARCHAR_LENGTH), 					higherType = TypeId.LONGVARBIT_NAME;, 				break;, , 			case Types.BLOB:, 				//operands VARCHAR FOR BIT DATA(A), BLOB(B) then result is, 				// BLOB(MIN(A+B,2G)), 				resultLength = clobBlobHandling(rightType, leftType);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/CreateIndexNode.java,makeConstantAction,242-242,[			ColumnDescriptor columnDescriptor = td.getColumnDescriptor(columnNames[i]);],,makeConstantAction,282-282,[                    td.getUUID(),],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/CreateIndexNode.java,referencesSessionSchema,218-218,[		return isSessionSchema(td.getSchemaName());],,
STYLE,UC_USELESS_CONDITION_TYPE,org/apache/derby/impl/sql/compile/CreateSequenceNode.java,bindStatement,195-195,[            if (_maxValue.longValue() <= Long.MIN_VALUE || _maxValue.longValue() > Long.MAX_VALUE) {],,
STYLE,UC_USELESS_CONDITION_TYPE,org/apache/derby/impl/sql/compile/CreateSequenceNode.java,bindStatement,187-187,[            if (_minValue.longValue() < Long.MIN_VALUE || _minValue.longValue() >= Long.MAX_VALUE) {],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/sql/compile/CreateTableNode.java,bindStatement,355-355,[				if (dtd.getTypeId().isStringTypeId() && ],,bindStatement,336-336,[				if ((dtd != null) && !dtd.isUserCreatableType())],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/compile/CreateTriggerNode.java,justTheRequiredColumns,690-690,[			return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/CreateTriggerNode.java,makeConstantAction,945-945,[                                            compSchemaDescriptor.getUUID(),],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/CreateTriggerNode.java,makeConstantAction,934-934,[											triggerSchemaDescriptor.getSchemaName(),],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/CurrentDatetimeOperatorNode.java,generateExpression,143-151,[		switch (whichType) {, 			case CURRENT_DATE: , 				acb.getCurrentDateExpression(mb);, 				break;, 			case CURRENT_TIME: , 				acb.getCurrentTimeExpression(mb);, 				break;, 			case CURRENT_TIMESTAMP: , 				acb.getCurrentTimestampExpression(mb);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/CurrentOfNode.java,getExposedName,544-544,[		return exposedTableName.getFullTableName();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/CurrentOfNode.java,generate,495-495,[		rmb.push(preStmt.getObjectName());],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/impl/sql/compile/DDLStatementNode.java,checkTableDescriptor,416-416,[		throw StandardException.newException(sqlState, ],,checkTableDescriptor,376-376,[		String sqlState = null;],,checkTableDescriptor,378-378,[		switch (td.getTableType()) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/DDLStatementNode.java,checkTableDescriptor,378-411,[		switch (td.getTableType()) {, 		case TableDescriptor.VTI_TYPE:, 			sqlState = SQLState.LANG_INVALID_OPERATION_ON_SYSTEM_TABLE;, 			break;, , 		case TableDescriptor.SYSTEM_TABLE_TYPE:, 			if (doSystemTableCheck), 				/*, 				** Not on system tables (though there are no constraints on, 				** system tables as of the time this is writen, 				*/, 				sqlState = SQLState.LANG_INVALID_OPERATION_ON_SYSTEM_TABLE;, 			else, 				//allow system table. The only time this happens currently is, 				//when user is requesting inplace compress on system table, 				return td;, 			break;, , 		case TableDescriptor.BASE_TABLE_TYPE:, 			/* need to IX lock table if we are a reader in DDL datadictionary, 			 * cache mode, otherwise we may interfere with another DDL thread, 			 * that is in execution phase; beetle 4343, also see $WS/docs/, 			 * language/SolutionsToConcurrencyIssues.txt (point f), 			 */, 			return lockTableForCompilation(td);, , 		case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:, 			return td;, , 		/*, 		** Make sure it is not a view, 		*/, 		case TableDescriptor.VIEW_TYPE:, 			sqlState = SQLState.LANG_INVALID_OPERATION_ON_VIEW;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/compile/DMLModStatementNode.java,getReadColMap,325-325,[		if (readColsBitSet == null) return null;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/sql/compile/DeleteNode.java,getEmptyDeleteNode,794-794,[        SelectNode rs = new SelectNode(null,],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/sql/compile/DeleteNode.java,getEmptyUpdateNode,837-837,[        SelectNode sn = new SelectNode(getSetClause(cdl),],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/DeleteNode.java,generate,607-607,[			mb.pushNewArray(ClassName.ResultSet, dependentNodes.length);  // new ResultSet[size]],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/DeleteNode.java,optimizeStatement,885-885,[			for(int index=0 ; index < dependentNodes.length ; index++)],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/sql/compile/DeleteNode.java,,489-489,[				  resultSet.isOneRowResultSet(),],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/DropAliasNode.java,aliasTypeName,149-164,[		switch ( actualType ), 		{, 			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:, 				typeName = "DERBY AGGREGATE";, 				break;, 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:, 				typeName = "PROCEDURE";, 				break;, 			case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:, 				typeName = "FUNCTION";, 				break;, 			case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:, 				typeName = "SYNONYM";, 				break;, 			case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:, 				typeName = "TYPE";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/DropIndexNode.java,makeConstantAction,121-121,[											 td.getUUID(),],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/DropTableNode.java,makeConstantAction,139-139,[			getSchemaDescriptor(td.getTableType() !=],,makeConstantAction,143-143,[			td.getUUID(),],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/DropTableNode.java,referencesSessionSchema,122-122,[		return isSessionSchema(td.getSchemaDescriptor());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/DropTriggerNode.java,makeConstantAction,96-96,[											td.getUUID());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/ExecSPSNode.java,getCursorInfo,204-204,[		return ps.getCursorInfo();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/ExecSPSNode.java,makeConstantAction,233-233,[		return ps.getConstantAction();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/ExecSPSNode.java,makeResultDescription,191-191,[		return ps.getResultDescription();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/FromBaseTable.java,changeAccessPath,3016-3016,[        Optimizer opt = ap.getOptimizer();],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/derby/impl/sql/compile/FromBaseTable.java,estimateCost,1599-1599,[			if (statStartStopSelectivity != 1.0d)],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/derby/impl/sql/compile/FromBaseTable.java,verifyProperties,696-696,[        StringUtil.SQLEqualsIgnoreCase(tableDescriptor.getSchemaName(), "SYS");],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/FromTable.java,rememberJoinStrategyAsBest,313-313,[        Optimizer opt = ap.getOptimizer();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/FromBaseTable.java,bindNonVTITables,2504-2504,[											    origTableName.getFullTableName());],,bindNonVTITables,2466-2466,[						origTableName.getFullTableName());],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/compile/FromVTI.java,getVTICosting,2043-2043,[        if ( !isDerbyStyleTableFunction ) { return (version2) ? (VTICosting) ps : (VTICosting) rs; }],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/compile/FromVTI.java,getNewInstance,822-822,[						paramObjects[index] = new Double((double) 0);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/compile/FromVTI.java,getNewInstance,818-818,[						paramObjects[index] = new Float((float) 0);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/compile/FromVTI.java,getNewInstance,769-769,[		if (paramTypeClasses != null)],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/derby/impl/sql/compile/GroupByNode.java,,1318-1343,[    private static class ExpressionSorter,         implements Comparator<SubstituteExpressionVisitor>, 	{, 		public int compare(SubstituteExpressionVisitor o1, SubstituteExpressionVisitor o2), 		{, 			try {, 				ValueNode v1 = o1.getSource();, 				ValueNode v2 = o2.getSource();, 				int refCount1, refCount2;,                 CollectNodesVisitor<ColumnReference> vis =,                     new CollectNodesVisitor<ColumnReference>(,                         ColumnReference.class);, 				v1.accept(vis);, 				refCount1 = vis.getList().size();,                 vis = new CollectNodesVisitor<ColumnReference>(,                         ColumnReference.class);, 				v2.accept(vis);, 				refCount2 = vis.getList().size();, 				// The ValueNode with the larger number of refs, 				// should compare lower. That way we are sorting, 				// the expressions in descending order of complexity., 				return refCount2 - refCount1;, 			}, 			catch (StandardException e), 			{, 				throw new RuntimeException(e);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/compile/HashJoinStrategy.java,findHashKeyColumns,656-656,[            return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/IntersectOrExceptNode.java,pushOrderingDown,202-202,[        for( int i = 0; i < intermediateOrderByColumns.length; i++)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/IntersectOrExceptNode.java,pushOrderingDown,213-213,[            if( intermediateOrderByDirection[i] < 0) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/IntersectOrExceptNode.java,pushOrderingDown,217-217,[            if( intermediateOrderByNullsLow[i]) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/JavaToSQLValueNode.java,generateExpression,151-151,[		resultType = getTypeId();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/JoinNode.java,bindExpression,923-923,[        ContextManager cm = getContextManager();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/JoinNode.java,deferredBindExpressions,794-794,[        CompilerContext cc = getCompilerContext();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/LockTableNode.java,referencesSessionSchema,166-166,[		return isSessionSchema(lockTableDescriptor.getSchemaName());],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/MatchingClauseNode.java,adjustThenColumns,1392-1392,[            ValueNode       value = lastLeftJoinRC.getExpression();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/MatchingClauseNode.java,buildThenColumnsForUpdate,496-496,[            ValueNode   origExpr = origRC.getExpression();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/MergeNode.java,associateColumn,256-256,[            String  columnsTableName = cr.getTableName();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/compile/MethodCallNode.java,resolveMethodCall,923-923,[                    requiredType = ((UserDefinedTypeIdImpl) returnType.getTypeId()).getClassName();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/MethodCallNode.java,generateVarargs,663-663,[                varargType = stripOneArrayLevel( varargType );],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/compile/MethodCallNode.java,getMethodParameterClasses,206-206,[				return null;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/MethodCallNode.java,resolveMethodCall,930-941,[						switch (returnType.getJDBCTypeId()) {, 						case java.sql.Types.BOOLEAN:, 						case java.sql.Types.SMALLINT:, 						case java.sql.Types.INTEGER:, 						case java.sql.Types.BIGINT:, 						case java.sql.Types.REAL:, 						case java.sql.Types.DOUBLE:, 							TypeCompiler tc = getTypeCompiler(returnTypeId);, 							requiredType = tc.getCorrespondingPrimitiveTypeName();, 							if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0), 							{, 								promoteName = returnTypeId.getCorrespondingJavaTypeName();],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/sql/compile/MethodCallNode.java,,1340-1340,[						if ((procedurePrimitiveArrayType != null)],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/compile/NewInvocationNode.java,bindExpression,264-264,[				parmTypes += (parmTypeNames[i].length() != 0 ?],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/compile/NewInvocationNode.java,,74-74,[        this.delimitedIdentifier = delimitedIdentifier;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/NextSequenceNode.java,generateExpression,133-133,[        String sequenceUUIDstring = sequenceDescriptor.getUUID().toString();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/sql/compile/NumericTypeCompiler.java,getPrecision,405-405,[			val = this.getScale(operator, leftType, rightType) +],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/sql/compile/OptTraceViewer.java,executeDDL,145-145,[        PreparedStatement   ddl = prepareStatement( conn, text );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/sql/compile/OptTraceViewer.java,loadTool,110-110,[        executeDDL( conn, createView );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/sql/compile/OptTraceViewer.java,prepareStatement,154-154,[        return conn.prepareStatement( text );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/OptTraceViewer.java,wrap,160-160,[        return new SQLException( t.getMessage(), t );],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/compile/OptimizerFactoryImpl.java,,46-46,[	protected String optimizerId = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/sql/compile/OptimizerTracer.java,unloadTool,166-166,[            else { pw = new PrintWriter( System.out ); }],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/sql/compile/OptimizerTracer.java,run,159-159,[                                 return new PrintWriter( configurationParameters[ 0 ] );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/sql/compile/OptimizerTracer.java,,155-160,[                     {,                          public PrintWriter run(),                          {,                              try {,                                  return new PrintWriter( configurationParameters[ 0 ] );,                              } catch (IOException ioe) { throw new IllegalArgumentException( ioe.getMessage(), ioe ); }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/OrderByList.java,estimateCost,662-662,[				resultToSort.getResultColumns().buildEmptyRow().getRowArray();],,estimateCost,665-665,[						resultToSort.getResultColumns().getTotalColumnSize();],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/sql/compile/ParameterNode.java,generateExpression,361-361,[		switch (dtd.getJDBCTypeId()) {],,generateExpression,338-338,[		if ((dtd != null) && dtd.getTypeId().isXMLTypeId()) {],,
STYLE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/compile/ParseException.java,getMessage,140-140,[      if (tok.kind == 0) {],,getMessage,147-147,[    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/compile/ParseException.java,getMessage,129-129,[        expected += tokenImage[expectedTokenSequences[i][j]] + " ";],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/derby/impl/sql/compile/Token.java,,28-106,[class Token {, ,   /**,    * An integer that describes the kind of this token.  This numbering,    * system is determined by JavaCCParser, and a table of these numbers is,    * stored in the file ...Constants.java.,    */,   public int kind;, ,   /**,    * beginLine and beginColumn describe the position of the first character,    * of this token; endLine and endColumn describe the position of the,    * last character of this token.,    */,   public int beginLine, beginColumn, endLine, endColumn;, ,   /**,    * beginOffset and endOffset are useful for siphoning substrings out of,    * the Statement so that we can recompile the substrings at upgrade time.,    * For instance, VIEW definitions and the Restrictions on Published Tables,    * need to be recompiled at upgrade time.,    */,   public int beginOffset, endOffset;, ,   /**,    * The string image of the token.,    */,   public String image;, ,   /**,    * A reference to the next regular (non-special) token from the input,    * stream.  If this is the last token from the input stream, or if the,    * token manager has not read tokens beyond this one, this field is,    * set to null.  This is true only if this token is also a regular,    * token.  Otherwise, see below for a description of the contents of,    * this field.,    */,   public Token next;, ,   /**,    * This field is used to access special tokens that occur prior to this,    * token, but after the immediately preceding regular (non-special) token.,    * If there are no such special tokens, this field is set to null.,    * When there are more than one such special token, this field refers,    * to the last of these special tokens, which in turn refers to the next,    * previous special token through its specialToken field, and so on,    * until the first special token (whose specialToken field is null).,    * The next fields of special tokens refer to other special tokens that,    * immediately follow it (without an intervening regular token).  If there,    * is no such token, this field is null.,    */,   public Token specialToken;, ,   /**,    * Returns the image.,    */,   @Override,   public String toString(),   {,      return image;,   }, ,   /**,    * Returns a new Token object, by default. However, if you want, you,    * can create and return subclass objects based on the value of ofKind.,    * Simply add the cases to the switch for all those special cases.,    * For example, if you have a subclass of Token called IDToken that,    * you want to create if ofKind is ID, simlpy add something like :,    *,    *    case MyParserConstants.ID : return new IDToken();,    *,    * to the following switch statement. Then you can cast matchedToken,    * variable to the appropriate type and use it in your lexical actions.,    */,   public static Token newToken(int ofKind),   {,      switch(ofKind),      {,        default : return new Token();],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/derby/impl/sql/compile/Predicate.java,compareTo,257-334,[        Predicate otherPred = other;, , 		/* Not all operators are "equal". If the predicates are on the, 		 * same key column, then a "=" opertor takes precedence over all, 		 * other operators.  This ensures that the "=" will be both the start, 		 * and stop predicates.  Otherwise, we could end up with it being one, 		 * but not the other and get incorrect results., 		 *, 		 * Also, we want "<>" to come after all the other operators., 		 * Other parts of the optimizer use the first predicate on an index, 		 * column to determine the cost of using the index, so we want the, 		 * "<>" to come last because it's not useful for limiting the scan., 		 *, 		 * In other words, P1 is before() P2 if:, 		 *		o  The P1.indexPosition < P2.indexPosition, 		 *	or  o  P1.indexPosition == P2.indexPosition and, 		 *		   P1's operator is ("=" or IS NULL) and, 		 *		   P2's operator is not ("=" or IS NULL), 		 * or	o  P1.indexPosition == P2.indexPosition and, 		 *		   P1's operator is not ("<>" or IS NOT NULL) and, 		 *		   P2's operator is ("<>" or IS NOT NULL), 		 *, 		 * (We have to impose an arbitrary, but reproducible ordering, 		 * on the the "=" predicates on the same column, otherwise an, 		 * ASSERTion, that after the predicates are order, Pn+1 is not, 		 * before() Pn, will be violated., 		 */, , 		int otherIndexPosition = otherPred.getIndexPosition();, , 		if (indexPosition < otherIndexPosition), 			return -1;, , 		if (indexPosition > otherIndexPosition), 			return 1;, , 		// initialize these flags as if they are for "in" operator, then, 		// change them if they are not, 		//, 		boolean thisIsEquals = false, otherIsEquals = false;, 		boolean thisIsNotEquals = true, otherIsNotEquals = true;, , 		/* The call to "isRelationalOpPredicate()" will return false, 		 * for a "probe predicate" because a probe predicate is really, 		 * a disguised IN list. But when it comes to sorting, the probe, 		 * predicate (which is of the form "<col> = ?") should be treated, 		 * as an equality--i.e. it should have precedence over any non-, 		 * equals predicate, per the comment at the start of this, 		 * method.  So that's what we're checking here., 		 */, 		if (this.isRelationalOpPredicate() || // this is not "in" or, 			this.isInListProbePredicate())    // this is a probe predicate, 		{, 			int thisOperator = ((RelationalOperator)andNode.getLeftOperand()).getOperator();, 			thisIsEquals = (thisOperator == RelationalOperator.EQUALS_RELOP ||, 								thisOperator == RelationalOperator.IS_NULL_RELOP);, 			thisIsNotEquals = (thisOperator == RelationalOperator.NOT_EQUALS_RELOP ||, 								   thisOperator == RelationalOperator.IS_NOT_NULL_RELOP);, 		}, , 		if (otherPred.isRelationalOpPredicate() || // other is not "in" or, 			otherPred.isInListProbePredicate())    // other is a probe predicate, 		{, 			int	otherOperator = ((RelationalOperator)(otherPred.getAndNode().getLeftOperand())).getOperator();, 			otherIsEquals = (otherOperator == RelationalOperator.EQUALS_RELOP ||, 								 otherOperator == RelationalOperator.IS_NULL_RELOP);, 			otherIsNotEquals = (otherOperator == RelationalOperator.NOT_EQUALS_RELOP ||, 								 otherOperator == RelationalOperator.IS_NOT_NULL_RELOP);, 		}, , 		boolean thisIsBefore = (thisIsEquals && ! otherIsEquals) || ( ! thisIsNotEquals && otherIsNotEquals);, 		if (thisIsBefore), 			return -1;, , 		boolean otherIsBefore = (otherIsEquals && ! thisIsEquals) || ( ! otherIsNotEquals && thisIsNotEquals);, 		if (otherIsBefore), 			return 1;, 		return 0;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/compile/QueryTreeNode.java,bindRowMultiSet,1424-1424,[        RowMultiSetImpl originalMultiSet = (RowMultiSetImpl) originalDTD.getTypeId().getBaseTypeId();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/compile/QueryTreeNode.java,bindUserType,1327-1327,[        UserDefinedTypeIdImpl userTypeID = (UserDefinedTypeIdImpl) originalDTD.getTypeId().getBaseTypeId();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/compile/QueryTreeNode.java,getUDTDesc,1375-1375,[        UserDefinedTypeIdImpl userTypeID = (UserDefinedTypeIdImpl) dtd.getTypeId().getBaseTypeId();],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/QueryTreeNode.java,getNullNode,930-933,[              VarbitConstantNode vcn =,                       new VarbitConstantNode(type.getTypeId(), cm);,               vcn.setType(type.getNullabilityType(true));,               return vcn;],,getNullNode,948-951,[              VarbitConstantNode vcn =,                       new VarbitConstantNode(type.getTypeId(), cm);,               vcn.setType(type.getNullabilityType(true));,               return vcn;],,getNullNode,954-957,[              VarbitConstantNode vcn =,                   new VarbitConstantNode(type.getTypeId(), cm);,               vcn.setType(type.getNullabilityType(true));,               return vcn;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/QueryTreeNode.java,getLongProperty,775-775,[        long longVal = -1;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/derby/impl/sql/compile/ResultColumn.java,compareTo,1438-1440,[        ResultColumn otherResultColumn = other;, , 		return this.getColumnPosition() - otherResultColumn.getColumnPosition();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/compile/ResultColumnList.java,updateArrays,4314-4314,[                seenMap.put(new Integer(vcId), new Integer(index));],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/derby/impl/sql/compile/ResultColumnList.java,hasConsistentTypeInfo,2994-2994,[					exDTS.getClass().getName())],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/sql/compile/ResultColumnList.java,commonCodeForUpdatableByCursor,2880-2880,[				resultColumn.markUpdatableByCursor();],,commonCodeForUpdatableByCursor,2878-2878,[				if (resultColumn == null && dealingWithSelectResultColumnList)],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/compile/ResultColumnList.java,getStreamStorableColIds,1107-1107,[		if (ssCount==0)return null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/compile/ResultColumnList.java,,2963-2963,[		this.forUpdate = forUpdate;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/compile/RowOrderingImpl.java,toString,390-390,[				retval += " ";],,
EXPERIMENTAL,SKIPPED_CLASS_TOO_BIG,org/apache/derby/impl/sql/compile/SQLParser.java,,69-22227,[        private static final String[] SAVEPOINT_CLAUSE_NAMES = {"UNIQUE", "ON ROLLBACK RETAIN LOCKS", "ON ROLLBACK RETAIN CURSORS"};, ,     /* Keep in synch with CreateAliasNode's index constants */,     private static final String[] ROUTINE_CLAUSE_NAMES =,         {,             null,,             "SPECIFIC",,             "RESULT SET",,             "LANGUAGE",,             "EXTERNAL NAME",,             "PARAMETER STYLE",,             "SQL",,             "DETERMINISTIC",,             "ON NULL INPUT",,             "RETURN TYPE",,             "EXTERNAL SECURITY",,             null,,          };,         /**, 	   Clauses required for Java routines. Numbers correspond, 	   to offsets in ROUTINE_CLAUSE_NAMES., 	   3 - "LANGUAGE", 	   4 - "EXTERNAL NAME", 	   5 - "PARAMETER STYLE", 	*/,         private static final int[] JAVA_ROUTINE_CLAUSES = {CreateAliasNode.LANGUAGE,CreateAliasNode.EXTERNAL_NAME,CreateAliasNode.PARAMETER_STYLE};,         private static final String[] TEMPORARY_TABLE_CLAUSE_NAMES = {"NOT LOGGED", "ON COMMIT", "ON ROLLBACK"};,         /* The default length of a char or bit if the length is omitted */,         private static final int        DEFAULT_STRING_COLUMN_LENGTH = 1;, ,         // Defines for ON or USING clauses,         private static final int        ON_OR_USING_CLAUSE_SIZE = 2;,         private static final int        ON_CLAUSE = 0;,         private static final int        USING_CLAUSE = 1;, ,         // Defines for optional table clauses,         private static final int        OPTIONAL_TABLE_CLAUSES_SIZE = 3;,         private static final int        OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES = 0;,         private static final int        OPTIONAL_TABLE_CLAUSES_DERIVED_RCL = 1;,         private static final int        OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME = 2;, ,         // Define for UTF8 max,         private static final int        MAX_UTF8_LENGTH = 65535;, ,     // Constants for set operator types,     private static final int NO_SET_OP = 0;,     private static final int UNION_OP = 1;,     private static final int UNION_ALL_OP = 2;,     private static final int EXCEPT_OP = 3;,     private static final int EXCEPT_ALL_OP = 4;,     private static final int INTERSECT_OP = 5;,     private static final int INTERSECT_ALL_OP = 6;, ,     // indexes into array of optional clauses for CREATE SEQUENCE statement,     private static final int IDX_DATA_TYPE = 0;,     private static final int IDX_START_WITH_OPTION = IDX_DATA_TYPE + 1;,     private static final int IDX_INCREMENT_BY_OPTION = IDX_START_WITH_OPTION + 1;,     private static final int IDX_MAX_VALUE_OPTION = IDX_INCREMENT_BY_OPTION + 1;,     private static final int IDX_MIN_VALUE_OPTION = IDX_MAX_VALUE_OPTION + 1;,     private static final int IDX_CYCLE_OPTION = IDX_MIN_VALUE_OPTION + 1;,     private static final int IDX_OPTION_COUNT = IDX_CYCLE_OPTION + 1;, ,     // indexes into array of clauses for OFFSET FETCH NEXT,     private static final int OFFSET_CLAUSE = 0;,     private static final int FETCH_FIRST_CLAUSE = OFFSET_CLAUSE + 1;,     private static final int OFFSET_CLAUSE_COUNT = FETCH_FIRST_CLAUSE + 1;, ,         private Object[]                                        paramDefaults;,         private String                                          statementSQLText;,     private OptimizerFactory            optimizerFactory;,         private ContextManager                          cm;,         private CompilerContext                         compilerContext;, ,         /* The number of the next ? parameter */,         private int                     parameterNumber;, ,         /* The list of ? parameters */,     private ArrayList<ParameterNode> parameterList;, ,         /* Remember if the last identifier or keyword was a, 	 * delimited identifier.  This is used for remembering, 	 * if the xxx in SERIALIZE(xxx) was a delimited identifier, 	 * because we need to know whether or not we can convert, 	 * xxx to upper case if we try to resolve it as a class, 	 * alias at bind time., 	 */,     private boolean lastTokenDelimitedIdentifier = false;,     private boolean nextToLastTokenDelimitedIdentifier = false;, , ,         /*, 	** Remember the last token we got that was an identifier, 	*/,         private Token   lastIdentifierToken;,         private Token   nextToLastIdentifierToken;,     private Token   thirdToLastIdentifierToken;, ,         static final String SINGLEQUOTES = "\'\'";,         static final String DOUBLEQUOTES = "\"\"";, ,         static final String DEFAULT_INDEX_TYPE = "BTREE";, ,         final void setCompilerContext(CompilerContext cc) {,                 this.compilerContext = cc;,                 this.cm = cc.getContextManager();,         }, ,         /**,       * Get the OptimizerFactory for this database., 	  *,       * @return The OptimizerFactory for this database., 	  * @exception StandardException		Thrown on error, 	  */,     private final OptimizerFactory getOptimizerFactory(),             throws StandardException,         {,         if ( optimizerFactory == null ),                 {,             optimizerFactory = getCompilerContext().getOptimizerFactory();,                 }, ,         return optimizerFactory;,         }, ,         private final CompilerContext getCompilerContext(),         {,                 return compilerContext;,         }, ,         private DataTypeDescriptor getDataTypeServices(int type, int precision, int scale,,                         int length),         throws StandardException,         {,                 return new DataTypeDescriptor(,                                         TypeId.getBuiltInTypeId(type),,                                         precision,,                                         scale,,                                         true, /* assume nullable for now, change it if not nullable */,                                         length,                                 );,         }, ,         private DataTypeDescriptor getJavaClassDataTypeDescriptor(TableName typeName),         throws StandardException,         {,                 return new DataTypeDescriptor,             (,                 TypeId.getUserDefinedTypeId( typeName.getSchemaName(), typeName.getTableName(), null ),,                 true,             );,         },         private LanguageConnectionContext getLanguageConnectionContext(),         {,                 return (LanguageConnectionContext) getContextManager().getContext(,                                                                                 LanguageConnectionContext.CONTEXT_ID);,         }, ,         /**, 		Utility method for checking that the underlying database has been, 		upgraded to the required level to use this functionality. Used to, 		disallow SQL statements that would leave on-disk formats that would, 		not be understood by a engine that matches the current upgrade level,         of the database. Throws an exception if the database is not at,         the required level., 		<P>, 		Typically used for CREATE statements at the parser level. Called usually just, 		before the node is created, or can be called in just a partial syntax fragment, 		, 		@param version Data Dictionary major version (DataDictionary.DD_ constant), 		@param feature SQL Feature name, for error text.,         @throws If the database is not at the required level., 	*/,         private boolean checkVersion(int version, String feature) throws StandardException,         {,                 return getLanguageConnectionContext(),                                 .getDataDictionary().checkVersion(version, feature);,         }, ,     /**, 		Utility method for checking that the underlying database uses SQL standard, 		permission checking (GRANT/REVOKE)., , 		@param command "GRANT", "REVOKE", "CREATE/DROP/SET ROLE" or CURRENT_ROLE,     */,         private void checkSqlStandardAccess( String command) throws StandardException,         {,                 if( getLanguageConnectionContext().usesSqlAuthorization()),                         return;, ,                 throw StandardException.newException(SQLState.LANG_GRANT_REVOKE_WITH_LEGACY_ACCESS,,                                                                                         command,,                                                                                         Property.SQL_AUTHORIZATION_PROPERTY,,                                                                                         "TRUE");,         }, ,     /**, 		Prevent NEXT VALUE FOR clauses when we get to the bind() phase.,     */,         private void forbidNextValueFor(),         {,         CompilerContext cc = getCompilerContext();, ,         cc.setReliability( cc.getReliability() | CompilerContext.NEXT_VALUE_FOR_ILLEGAL );,         }, ,         /**, 		Check that the current mode supports internal extensions., , 		@param feature Description of feature for exception., , 		@exception StandardException current mode does not support statement, 	*/,         private void checkInternalFeature(String feature) throws StandardException,         {,                 CompilerContext cc = getCompilerContext();,                 if ((cc.getReliability() & CompilerContext.INTERNAL_SQL_ILLEGAL) != 0),                         throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, feature);,         }, ,         /**, 	 * check if the type length is ok for the given type., 	 */,         private void checkTypeLimits(int type, int length),                 throws StandardException,         {,         boolean valid = true;, , ,         switch (type) {,                 case Types.BINARY:,                 case Types.CHAR:,                         if (length  > Limits.DB2_CHAR_MAXWIDTH),                                 valid = false;,                         break;, ,                 case Types.VARBINARY:,                 case Types.VARCHAR:,                         if (length  > Limits.DB2_VARCHAR_MAXWIDTH),                                 valid = false;, ,                         break;,                 default:,                         break;,         },         if (!valid)  // If these limits are too big ,                 {,                         DataTypeDescriptor charDTD =,                                 DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);, ,                         throw StandardException.newException(SQLState.LANG_DB2_LENGTH_PRECISION_SCALE_VIOLATION, charDTD.getSQLstring());,                 },         }, , , ,         // Get the current ContextManager,         private final ContextManager getContextManager(),         {,                 return cm;,         }, ,         private static void verifyImageLength(String image) throws StandardException,                 {,                 // beetle 2758.  For right now throw an error for literals > 64K,                 if (image.length() > MAX_UTF8_LENGTH),                         {,                 throw StandardException.newException(SQLState.LANG_INVALID_LITERAL_LENGTH);,                         },                 }, ,         /*, 	** Converts a delimited id to a canonical form., 	** Post process delimited identifiers to eliminate leading and, 	** trailing " and convert all occurrences of "" to "., 	*/,         private static String normalizeDelimitedID(String str),         {,                 str = StringUtil.compressQuotes(str, DOUBLEQUOTES);,                 return str;,         },         private static boolean isDATETIME(int val),         {,                 if (val == DATE || val == TIME || val == TIMESTAMP),                         return true;,                 else,                         return false;,         }, ,         /*, 	 * Generate a multiplicative operator node, if necessary., 	 *, 	 * If there are two operands, generate the multiplicative operator, 	 * that corresponds to the multiplicativeOperator parameter.  If there, 	 * is no left operand, just return the right operand., 	 *, 	 * @param leftOperand	The left operand, null if no operator, 	 * @param rightOperand	The right operand, 	 * @param multiplicativeOperator	An identifier from BinaryOperatorNode, 	 *									telling what operator to generate., 	 *, 	 * @return	The multiplicative operator, or the right operand if there is, 	 *			no operator., 	 *, 	 * @exception StandardException		Thrown on error, 	 */, ,         ValueNode multOp(ValueNode leftOperand,,                                                         ValueNode rightOperand,,                                                         int multiplicativeOperator),                                         throws StandardException,         {,                 if (leftOperand == null),                 {,                         return rightOperand;,                 }, ,                 switch (multiplicativeOperator),                 {,                   case BinaryOperatorNode.TIMES:,             return new BinaryArithmeticOperatorNode(,                 BinaryArithmeticOperatorNode.K_TIMES,,                 leftOperand,,                 rightOperand,,                 getContextManager());, ,                   case BinaryOperatorNode.DIVIDE:,             return new BinaryArithmeticOperatorNode(,                 BinaryArithmeticOperatorNode.K_DIVIDE,,                 leftOperand,,                 rightOperand,,                 getContextManager());,                   case BinaryOperatorNode.CONCATENATE:,               return new ConcatenationOperatorNode(,                                                                         leftOperand,,                                                                         rightOperand,,                                                                         getContextManager());, ,                   default:,                         if (SanityManager.DEBUG),                         SanityManager.THROWASSERT("Unexpected multiplicative operator " +,                                                                                 multiplicativeOperator);,                         return null;,                 },         }, ,         /**, 	 * Set up and like the parameters to the descriptors., 	 * Set all the ParameterNodes to point to the array of, 	 * parameter descriptors., 	 * , 	 *	@exception	StandardException, 	 */,          private void setUpAndLinkParameters(),                         throws StandardException,          {,                 CompilerContextImpl cc = (CompilerContextImpl) getCompilerContext();,                 cc.setParameterList(parameterList);,                 /* Link the untyped parameters to the array of parameter descriptors */, ,                 DataTypeDescriptor[] descriptors = cc.getParameterTypes();, ,                 ParameterNode                           newNode;,                 int                                                     paramCount;, ,                 /*, 		** Iterate through the list of untyped parameter nodes, set each one, 		** to point to the array of parameter descriptors., 		*/,                 paramCount = -1;,                 int plSize = parameterList.size();,                 for (int index = 0; index < plSize; index++),                 {,                         paramCount++;, ,                         newNode = (ParameterNode) parameterList.get(index);,                         newNode.setDescriptors(descriptors );,                 },         }, ,         /**, 	 *  Initializes the list of unnamed parameters, i.e., "?" parameters, 	 *, 	 *	Usually, this routine just gets an empty list for the unnamed parameters., 	 *, 	 *, 	 */,         void    initUnnamedParameterList(),         {,                 parameterList = new ArrayList<ParameterNode>();,         }, ,         /**, 	 * Makes a new unnamed ParameterNode and chains it onto parameterList., 	 *, 	 *	@return	new unnamed parameter., 	 *, 	 *	@exception	StandardException, 	 */,         ParameterNode   makeParameterNode(  ),                                         throws StandardException,         {,                 ParameterNode   parm;,                 DataValueDescriptor sdv = null;, ,                 if ((paramDefaults != null) && (parameterNumber < paramDefaults.length)),                 {,                         sdv = (DataValueDescriptor) paramDefaults[parameterNumber];,                 }, ,         parm = new ParameterNode(parameterNumber, sdv, getContextManager());, ,                 parameterNumber++;,                 parameterList.add(parm);, ,                 return parm;,         }, ,         /**, 	 * Translate a String containing a number into the appropriate type, 	 * of Numeric node., 	 *, 	 * @param num      the string containing the number, 	 * @param intsOnly accept only integers (not decimal), 	 *, 	 * @exception StandardException		Thrown on error, 	 */,         NumericConstantNode getNumericNode(String num, boolean intsOnly),                 throws StandardException,         {,                 ContextManager cm = getContextManager();, ,                 // first, see if it might be an integer,                 try,                 {,            return new NumericConstantNode(,                TypeId.getBuiltInTypeId(Types.INTEGER),,                Integer.valueOf(num),,                cm);,                 },                 catch (NumberFormatException nfe),                 {,                         // we catch because we want to continue on below,                 }, ,                 // next, see if it might be a long,                 try,                 {,             return new NumericConstantNode(,                 TypeId.getBuiltInTypeId(Types.BIGINT),,                 Long.valueOf(num),,                 cm);,                 },                 catch (NumberFormatException nfe),                 {,                         if (intsOnly) {,                                 throw nfe;,                         },                         // else we want to continue on below,                 }, ,        return new NumericConstantNode(,            TypeId.getBuiltInTypeId(Types.DECIMAL), new BigDecimal(num), cm);,         },         /**, 	 * Determine whether the current token represents one of, 	 * the built-in aliases., 	 *, 	 * @return	TRUE iff the current token names a built-in alias, 	 */,         private boolean isBuiltInAlias(),         {,                 boolean retval = false;, ,                 switch (token.kind),                 {,                   case UCASE:,                   case LCASE:,                   case SQRT:,                   case LOCATE:,                   case ABS:,                   case ABSVAL:,                   case SUBSTR:,                   case MOD:,                         retval = true;,                         break;, ,                   default:,                         retval = false;,                         break;,                 }, , ,                 return retval;,         }, , ,         /**, 	 * Determine whether the next sequence of tokens represents one of, 	 * the common (built-in) datatypes., 	 *, 	 * @param checkFollowingToken true if additonal token for NATIONAL, 	 *        or LONG should be checked, 	 * @return	TRUE iff the next set of tokens names a common datatype, 	 */,         boolean commonDatatypeName(boolean checkFollowingToken),         {,             return commonDatatypeName(1, checkFollowingToken);,         }, ,         /**, 	 * Determine whether the next sequence of tokens represents , 	 * a datatype (could be a common datatype or a schema qualified UDT name)., 	 *, 	 * @return	TRUE iff the next set of tokens names a datatype, 	 */,         boolean dataTypeCheck(int start),         {,         if ( commonDatatypeName( start, false ) ) { return true; }, ,         boolean retval = true;, ,                 switch (getToken(start).kind),                 {,                   case COMMA:,                   case LEFT_PAREN:,                   case RIGHT_PAREN:,                         retval = false;,             break;,         }, ,         return retval;,     }, ,         /**, 	 * Determine whether a sequence of tokens represents one of, 	 * the common (built-in) datatypes., 	 *, 	 * @param checkFollowingToken true if additonal token for NATIONAL, 	 *        or LONG should be checked, 	 * @param start starting token index of the sequence, 	 * @return	TRUE iff the next set of tokens names a common datatype, 	 */,         boolean commonDatatypeName(int start, boolean checkFollowingToken),         {,                 boolean retval = false;, ,                 switch (getToken(start).kind),                 {,                   case CHARACTER:,                   case CHAR:,                   case VARCHAR:,                   case NVARCHAR:,                   case NCHAR:,                   case BIT:,                   case NUMERIC:,                   case DECIMAL:,                   case DEC:,                   case INTEGER:,                   case INT:,                   case SMALLINT:,           case BIGINT:,                   case FLOAT:,                   case REAL:,                   case DATE:,                   case TIME:,                   case TIMESTAMP:,                   case BOOLEAN:,                   case DOUBLE:,                   case BLOB:,                   case CLOB:,                   case NCLOB:,                   case BINARY: // LARGE OBJECT,                   case XML:,                         retval = true;,                         break;, ,                   case LONG:,                         if (checkFollowingToken == true),                         {,                                 switch (getToken(start+1).kind),                                 {,                                   case VARCHAR:,                                   case NVARCHAR:,                                   case BINARY:,                                   case VARBINARY:,                                   case BIT:,                                         retval = true;,                                         break;,                                 },                                 break;,                         },                         else,                         {,                                 retval = true;,                                 break;,                         }, ,                   case NATIONAL:,                         if (checkFollowingToken == true),                         {,                                 switch (getToken(start+1).kind),                                 {,                                   case CHAR:,                                   case CHARACTER:,                                         retval = true;,                                         break;,                                 },                                 break;,                         },                         else,                         {,                                 retval = true;,                                 break;,                         },                 }, ,                 return retval;,         }, ,         /**, 	 * Get a DELETE node given the pieces., 	 *, 	 *, 	 *	@exception	StandardException, 	 */,          private StatementNode getDeleteNode(FromTable fromTable,,                                                                                  TableName tableName,,                                                                                  ValueNode whereClause),                 throws StandardException,         {,         FromList   fromList = new FromList(getContextManager());, ,                 fromList.addFromTable(fromTable);, ,         SelectNode resultSet = new SelectNode(null,,                                               fromList, /* FROM list */,                                               whereClause, /* WHERE clause */,                                               null, /* GROUP BY list */,                                               null, /* having clause */,                                               null, /* window list */,                                               null, /* optimizer plan override */,                                               getContextManager());, ,         StatementNode retval =,             new DeleteNode(tableName, resultSet, null, getContextManager());, ,                 setUpAndLinkParameters();, ,                 return retval;,         }, ,         /**, 	 * Get an UPDATE node given the pieces., 	 *, 	 *, 	 *	@exception	StandardException, 	 */,          private StatementNode getUpdateNode(FromTable fromTable,,                                                                                  TableName tableName,,                                                                                  ResultColumnList setClause,,                                                                                  ValueNode whereClause),                 throws StandardException,         {,         FromList   fromList = new FromList(getContextManager());, ,                 fromList.addFromTable(fromTable);, ,         SelectNode resultSet = new SelectNode(setClause,,                                               fromList, /* FROM list */,                                               whereClause, /* WHERE clause */,                                               null, /* GROUP BY list */,                                               null, /* having clause */,                                               null, /* window list */,                                               null, /* optimizer plan override */,                                               getContextManager());, ,         StatementNode retval =,             new UpdateNode(tableName, resultSet, null, getContextManager());, ,                 setUpAndLinkParameters();, ,                 return retval;,         }, ,     /**,      * Generate a trim operator node,      * @param trimSpec one of Leading, Trailing or Both.,      * @param trimChar the character to trim. Can be null in which case it defaults,      * to ' '.,      * @param trimSource expression to be trimmed.,      */,     private ValueNode getTrimOperatorNode(Integer trimSpec, ValueNode trimChar,,         ValueNode trimSource, ContextManager cm) throws StandardException,     {,         if (trimChar == null),         {,            trimChar = new CharConstantNode(" ", getContextManager());,         },         return new TernaryOperatorNode(,                                                         trimSource, // receiver,                                                         trimChar,   // leftOperand.,                                                         null,,                             TernaryOperatorNode.K_TRIM,,                             trimSpec.intValue(),,                                                         cm == null ? getContextManager() : cm);,     }, ,     private boolean ansiTrimSpecFollows(),     {,         return (getToken(2).kind == LEADING || getToken(2).kind == TRAILING,                 || getToken(2).kind == BOTH);,     }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of a remainingPredicate() rule., 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			remainingPredicate(), 	 */,         private boolean remainingPredicateFollows(),         {,                 boolean retval = false;, ,                 switch (getToken(1).kind),                 {,                   case EQUALS_OPERATOR:,                   case NOT_EQUALS_OPERATOR:,                   case NOT_EQUALS_OPERATOR2: // !=,                   case LESS_THAN_OPERATOR:,                   case GREATER_THAN_OPERATOR:,                   case LESS_THAN_OR_EQUALS_OPERATOR:,                   case GREATER_THAN_OR_EQUALS_OPERATOR:,                   case IN:,                   case LIKE:,                   case BETWEEN:,                         retval = true;,                         break;, ,                   case NOT:,                         switch (getToken(2).kind),                         {,                           case IN:,                           case LIKE:,                           case BETWEEN:,                                 retval = true;,                         },                         break;,                 }, ,                 return retval;,         }, , ,         /**, 	 * Determine whether the next token is a DROP, 	 *, 	 * @return	TRUE iff the next token is DROP, 	 */,         private boolean dropFollows(),         {,                 if (getToken(1).kind == DROP),                 { return true; },                 else { return false; },         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of a escapedValueFunction()., 	 *, 	 * We check only for the punctuation here, because identifiers are, 	 * very hard to check for in semantic lookahead., 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			escapedValueFunction(), 	 */,         private boolean escapedValueFunctionFollows(),         {,                 if (getToken(1).kind != LEFT_BRACE),                 {,                         return false;,                 }, ,                 return getToken(2).kind == FN;,         }, , ,     /**,        List of JDBC escape functions that map directly onto,        a function in the SYSFUN schema.,     */,         private static final String[] ESCAPED_SYSFUN_FUNCTIONS =,         {"ACOS", "ASIN", "ATAN", "ATAN2", "COS", "SIN", "TAN", "PI",,          "DEGREES", "RADIANS", "EXP", "LOG", "LOG10", "CEILING", "FLOOR",,          "SIGN", "RAND", "COT" };, ,     /**,        Convert a JDBC escaped function name to a function,        name in the SYSFUN schema. Returns null if no such,        function exists.,     */,         private String getEscapedSYSFUN(String name),         {,             name = StringUtil.SQLToUpperCase(name);, ,             for (int i = 0; i < ESCAPED_SYSFUN_FUNCTIONS.length; i++),             {,                 if (ESCAPED_SYSFUN_FUNCTIONS[i].equals(name)),                     return name;,             },             return null;,         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of a columnInvocation() rule.  columnInvocations start with, 	 * [ [ id . ] id . ] id . id (, 	 *, 	 * We check only for the punctuation here, because identifiers are, 	 * very hard to check for in semantic lookahead., 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			columnInvocation(), 	 */,         private boolean columnMethodInvocationFollows(),         {,                 int tokKind;, ,                 // First token must not be a built-in function name that can be,                 // followed immediately by a PERIOD. There are only a few of,                 // these - most built-in functions have a LEFT_PAREN following,                 // the function name., ,                 // if we run out of token, it's probably a syntax error,  ,                 // in fact,                 tokKind = getToken(1).kind;,                 if ( tokKind == EOF ) { return false; }, ,                 // disambiguate from named parameter reference,                 if ( getToken(1).image.charAt(0) == '?' ) { return false; }, ,                 if (tokKind == CURRENT_DATE ||,                         tokKind == CURRENT_TIME ||,                         tokKind == CURRENT_TIMESTAMP ||,                         tokKind == CURRENT && (isDATETIME(getToken(2).kind)) ),                 {,                         return false;,                 }, ,                 // Second token must be a PERIOD,                 if (getToken(2).kind != PERIOD),                 {,                         return false;,                 }, ,                 // We have established that we start with " id . ",                 tokKind = getToken(4).kind;,                 if (tokKind == LEFT_PAREN),                 {,                         // id.id(,                         return true;,                 }, ,                 // Not id.id(, so 4th token must be PERIOD,                 if (tokKind != PERIOD),                 {,                         return false;,                 }, ,                 tokKind = getToken(6).kind;,                 if (tokKind == LEFT_PAREN),                 {,                         // id.id.id(,                         return true;,                 }, ,                 // Not id.id.id(, so 6th token must be PERIOD,                 if (tokKind != PERIOD),                 {,                         return false;,                 }, ,                 tokKind = getToken(8).kind;,                 if (tokKind == LEFT_PAREN),                 {,                         // id.id.id.id(,                         return true;,                 }, ,                 return false;,         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of an aggregateNode()() rule.  aggregateNodes() start with one, 	 * of the built-in aggregate names, or with an identifier followed, 	 * by "( DISTINCT". A non-distinct user-defined aggregate invocation, 	 * is treated as a staticMethodInvocationAlias() by the parser,, 	 * and the binding phase figures out what it really is by looking, 	 * at the data dictionary., 	 *, 	 * We check only for the punctuation here, because identifiers are, 	 * very hard to check for in semantic lookahead., 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			aggregateNode(), 	 */,         private boolean aggregateFollows(),         {,                 boolean retval = false;, ,                 switch (getToken(1).kind),                 {,                   case MAX:,                   case AVG:,                   case MIN:,                   case SUM:,                         // This is a built-in aggregate,                         retval = true;,                         break;, ,                   case COUNT:,                         // COUNT is not a reserved word,                         // This may eclipse use of COUNT as a function or a procedure that is probably what we want,                         if (getToken(2).kind == LEFT_PAREN),                                 retval = true;,                   default:,                         // Not a built-in aggregate - assume the first token is an,                         // identifier, and see whether it is followed by " ( DISTINCT ",                         if (getToken(2).kind == LEFT_PAREN && getToken(3).kind == DISTINCT),                                 retval = true;,                         break;,                 }, ,                 return retval;,         }, , ,         /**, 	 * Return true if a builtin aggregate follows., 	 */,      private    boolean builtinAggregateFollows(),      {,                 switch (getToken(1).kind),                 {,                   case MAX:,                   case AVG:,                   case MIN:,                   case SUM:,                   case COUNT:,                         // This is a built-in aggregate,                         return true;, ,                   default:,                         return false;,                 },      }, ,         /**, 	 * Return true if the following tokens are the start of a,      * distinct user defined aggregate invocation. These have,      * the form,      *,      * aggName( distinct,      *,      * or,      *,      *  schemaName.aggName( distinct, 	 *, 	 */,         private boolean distinctUDAFollows(),         {,         if ( builtinAggregateFollows() ) { return false; }, ,         if (,            (getToken(2).kind == LEFT_PAREN) &&,            (getToken(3).kind == DISTINCT),            ),         { return true; },         else if (,            (getToken(2).kind == PERIOD) &&,            (getToken(4).kind == LEFT_PAREN) &&,            (getToken(5).kind == DISTINCT),            ),         { return true; }, ,                 return false;,         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning of a, 	 * window or aggregate function., 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			window or aggregate function, 	 */,         private boolean windowOrAggregateFunctionFollows(),         {,         if ( distinctUDAFollows() ) { return false; }, ,                 boolean retval = false;, ,                 switch (getToken(1).kind) {, ,                 case ROWNUMBER:, ,                 // case RANK:,                 // case DENSE_RANK:,                 // case PERCENT_RANK:,                 // case CUME_DIST:, ,                         retval = true;,                         break;, ,                 default:,                         retval = aggregateFollows();,                         break;,                 }, ,                 return retval;,         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of a miscBuiltins()., 	 *, 	 * We check only for the punctuation here, because identifiers are, 	 * very hard to check for in semantic lookahead., 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			aggregateNode(), 	 */,         private boolean miscBuiltinFollows(),         {,                 boolean retval = false;,                 int tokKind = getToken(1).kind;, ,                 if (getToken(0).kind == CALL),                         retval = true;, ,                 switch (tokKind),                 {,                   case GET_CURRENT_CONNECTION:,                   case CURRENT_DATE:,                   case CURRENT_TIME:,                   case CURRENT_TIMESTAMP:,                         retval = true;,                         break;, ,                   case CURRENT:,                         if (isDATETIME(getToken(2).kind)),                                 retval = true;,                         break;, ,                   case CAST:,                   case LEFT_PAREN:,                         retval = false;,                         break;, ,                   default:,                     if (getToken(2).kind == LEFT_PAREN),                                 retval = true;,                         break;,                 }, ,                 return retval;,         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of a subquery. A subquery can begin with an arbitrary number of, 	 * left parentheses, followed by either SELECT or VALUES., 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			subquery., 	 */,         private boolean subqueryFollows(),         {,                 int tokKind;,                 boolean retval = false;, ,                 for (int i = 1; true; i++),                 {,                         tokKind = getToken(i).kind;,                         if (tokKind == LEFT_PAREN),                         {,                                 // A subquery can start with an arbitrary number of left,                                 // parentheses.,                                 continue;,                         },                         else if (tokKind == SELECT || tokKind == VALUES),                         {,                                 // If the first token we find after all the left parentheses,                                 // is SELECT or VALUES, it's a subquery.,                                 retval = true;,                                 break;,                         },                         else,                         {,                                 // If the first token we find after all the left parentheses,                                 // is neither SELECT nor VALUES, it's not a subquery.,                                 break;,                         },                 }, ,                 return retval;,         }, , , ,     /**,      * Determine if we are seeing an offsetClause or the identifier OFFSET,      * (Derby does not make it a reserved word).  "n" must be an integer,      * literal or a dynamic parameter specification.,      *,      * @return true if it is an offsetClause.,      */,     private boolean seeingOffsetClause(),     {,         int nesting = 0;, ,         // Token number, i == 1: OFFSET,         int i = 2;, ,         int tokKind = getToken(i).kind;, ,         // check for integer literal or ? followed by ROW(S),         if (tokKind == PLUS_SIGN ||,             tokKind == MINUS_SIGN) {, ,             tokKind = getToken(++i).kind;, ,             if (tokKind == EXACT_NUMERIC) {, ,                 tokKind = getToken(++i).kind;, ,                 return (tokKind == ROW ||,                         tokKind == ROWS);,             },         } else if (tokKind == EXACT_NUMERIC ||,                    tokKind == QUESTION_MARK) {, ,             tokKind = getToken(++i).kind;, ,             return (tokKind == ROW ||,                     tokKind == ROWS);,         }, ,         return false;,     }, , ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of a rowValueConstructorList. A rowValueConstructorList is a comma-, 	 * separated list of expressions enclosed in parentheses. This presents, 	 * special problems, because an expression be nested within an, 	 * arbitrary number of parentheses. To determine whether a left, 	 * parenthesis introduces a rowValueConstructorList or an expression,, 	 * we need to find the closing parenthesis, and determine whether, 	 * the next token is a comma., 	 *, 	 * For example, the following is a rowValueConstructorList:, 	 *, 	 *		(((1)), 2), 	 *, 	 * and the following is just an expression:, 	 *, 	 *		(((1))), 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			subquery., 	 */,         private boolean rowValueConstructorListFollows(),         {,                 int nesting;,                 boolean retval = false;, ,                 // A rowValueConstructorList starts with a left parenthesis,                 if (getToken(1).kind == LEFT_PAREN),                 {,                         // Keep track of the nesting of parens while looking ahead,                         nesting = 1;,                         for (int i = 2; true; i++),                         {,                                 int tokKind = getToken(i).kind;, ,                                 // Special case for NULL/DEFAULT because they are not allowed in,                                 // a parenthesized expression, so (null)/(default) must be seen,                                 // as a rowValueConstructorList with one element.,                                 if (i == 2 && (tokKind == NULL || tokKind == _DEFAULT)),                                 {,                                         retval = true;,                                         break;,                                 }, ,                                 // There must be a COMMA at nesting level 1 (i.e. outside of,                                 // the first expression) for it to be a rowValueConstructorList,                                 if (nesting == 1 && tokKind == COMMA),                                 {,                                         retval = true;,                                         break;,                                 }, ,                                 // If we run out of tokens before finding the last closing,                                 // parenthesis, it's not a rowValueConstructorList (it's,                                 // probably a syntax error, in fact),                                 if (tokKind == EOF),                                 {,                                         break;,                                 }, ,                                 // Increase the nesting for each (, and decrease it for each ),                                 if (tokKind == LEFT_PAREN),                                 {,                                         nesting++;,                                 },                                 else if (tokKind == RIGHT_PAREN),                                 {,                                         nesting--;,                                 }, ,                                 // Don't look any farther than the last closing parenthesis,                                 if (nesting == 0),                                 {,                                         break;,                                 },                         },                 }, ,                 return retval;,         }, ,         /**, 	 * Determine whether the next token is the beginning of a propertyList(). , 	 * A properties list is the comment "--derby-properties" followed by a , 	 * dot-separated list, followed by an =, followed by a value all on that , 	 * comment line. This means that the comment should start with the word, 	 * "derby-properties"., 	 *, 	 * @return	TRUE iff the next token is derby-properties , 	 */,         private boolean derbyPropertiesListFollows(),         {,                 return,                         getToken(1).kind == DERBYDASHPROPERTIES;,         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of a newInvocation(). A newInvocation() begins with the word "new", 	 * followed by a dot-separated list of identifiers, followed, 	 * by a left parenthesis., 	 *, 	 * @param startToken	Token to look for new at, 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			newInvocation()., 	 */,         private boolean newInvocationFollows(int startToken),         {,                 boolean retval = false;, ,                 // newInvocation() starts with the word "new",                 if (getToken(startToken).kind == NEW),                 {,                         // Look at every other token. Ignore the identifiers, because,                         // they are hard to test for.,                         for (int i = 2 + startToken; true; i += 2),                         {,                                 int tokKind = getToken(i).kind;, ,                                 // If we find a left parenthesis without any intervening,                                 // cruft, we have found a newInvocation(),                                 if (tokKind == LEFT_PAREN),                                 {,                                         retval = true;,                                         break;,                                 },                                 else if (tokKind != PERIOD),                                 {,                                         // Anything other than a PERIOD is "cruft",                                         break;,                                 },                         },                 }, ,                 return retval;,         },         /**, 	 * Determine whether the next sequence of tokens is a class name, 	 *, 	 * @return	TRUE iff the next set of tokens is the java class name, 	 */,         boolean javaClassFollows(),         {,                 boolean retval = false;, ,                 // Look at every other token. Ignore the identifiers, because,                 // they are hard to test for.,                 for (int i = 2; true; i += 2),                 {,                         int tokKind = getToken(i).kind;, ,                         // If we find a '::' without any intervening,                         // cruft, we have found a javaClass,                         if (tokKind == DOUBLE_COLON),                         {,                                 retval = true;,                                 break;,                         },                         else if (tokKind != PERIOD),                         {,                                 // Anything other than a PERIOD is "cruft",                                 break;,                         },                 }, ,                 return retval;,         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of a FROM newInvocation(). A FROM newInvocation() begins with the words "from new", 	 * followed by a dot-separated list of identifiers, followed, 	 * by a left parenthesis., 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			FROM newInvocation()., 	 */,         private boolean fromNewInvocationFollows(),         {,                 boolean retval = false;, ,                 // FROM newInvocation() starts with the words "from new",                 return (getToken(1).kind == FROM && newInvocationFollows(2));,         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of a joinedTableExpression(). A joinedTableExpression() begins, 	 * with one of:, 	 *, 	 *	JOIN, 	 *	INNER JOIN, 	 *	CROSS JOIN, 	 *	LEFT OUTER JOIN, 	 *	RIGHT OUTER JOIN, 	 *	NATURAL [ { RIGHT | LEFT } [ OUTER ] | INNER ] JOIN, 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			joinedTableExpression()., 	 */,         private boolean joinedTableExpressionFollows(),         {,                 boolean retval = false;, ,                 int tokKind1 = getToken(1).kind;,                 int tokKind2 = getToken(2).kind;, ,                 if (tokKind1 == JOIN),                 {,                         retval = true;,                 },                 else if (tokKind1 == INNER && tokKind2 == JOIN),                 {,                         retval = true;,                 },                 else if (tokKind1 == CROSS && tokKind2 == JOIN),                 {,                         retval = true;,                 },                 else if (tokKind1 == NATURAL),                 {,                         retval = true;,                 },                 else if ((tokKind1 == LEFT || tokKind1 == RIGHT) && tokKind2 == OUTER),                 {,                         if (getToken(3).kind == JOIN),                         {,                                 retval = true;,                         },                 },                 else if ((tokKind1 == LEFT || tokKind1 == RIGHT) && tokKind2 == JOIN),                 {,                         retval = true;,                 }, ,                 return retval;,         }, ,         /**, 	 * Translate a token for the name of a built-in aggregate to a String, 	 * containing an aggregate name., 	 */,         private static String aggName(Token token),         {,                 String  retval = null;, ,                 switch (token.kind),                 {,                   case MAX:,                         retval = "MAX";,                         break;, ,                   case AVG:,                     retval = "AVG";,                         break;, ,                   case MIN:,                     retval = "MIN";,                         break;, ,                   case SUM:,                     retval = "SUM";,                         break;, ,                   case COUNT:,                     retval = "COUNT";,                         break;, ,                   default:,                         if (SanityManager.DEBUG),                         {,                                 SanityManager.THROWASSERT("Unexpected token type in aggName: " +,                                                                                         token.kind);,                         },                         break;,                 }, ,                 return retval;,         }, ,         /**, 	 * Translate a token for the name of a built-in aggregate to an, 	 * aggregate definition class., 	 */,         private static Class aggClass(Token token),         {,                 Class   retval = null;, ,                 switch (token.kind),                 {,                   case MAX:,                   case MIN:,                         retval = MaxMinAggregateDefinition.class;,                         break;, ,                   case AVG:,                   case SUM:,                         retval = SumAvgAggregateDefinition.class;,                         break;, ,                   case COUNT:,                     retval = CountAggregateDefinition.class;,                         break;, ,                   default:,                         if (SanityManager.DEBUG),                         {,                                 SanityManager.THROWASSERT("Unexpected token type in aggClass: ",                                                                                         + token.kind);,                         },                         break;,                 }, ,                 return retval;,         }, ,         /**, 	 * Determine whether the next sequence of tokens can be the beginning, 	 * of another element in a PROPERTY list. These elements are of the, 	 * form:, 	 *, 	 *		COMMA dot.separated.list = ..., 	 *, 	 * Look for the COMMA, the dots in the dot-separated list, and the =, 	 *, 	 * @return	TRUE iff the next set of tokens is the beginning of a, 	 *			another element in a PROPERTY list., 	 */,         private boolean anotherPropertyFollows(),         {,                 boolean retval = false;, ,                 // Element must start with COMMA,                 if (getToken(1).kind == COMMA),                 {,                         // Rest of element is dot-separated list with = at end,                         int i = 3;,                         int tokKind;,                         do,                         {,                                 tokKind = getToken(i).kind;, ,                                 // If we've found nothing but PERIODs until the EQUALS_OPERATOR,                                 // it is the beginning of another property list element.,                                 if (tokKind == EQUALS_OPERATOR),                                 {,                                         retval = true;,                                         break;,                                 }, ,                                 i += 2;,                         } while (tokKind == PERIOD);,                 }, ,                 return retval;,         }, ,         /**, 	 * Get one of the several types of create alias nodes., 	 *, 	 * @param aliasName	The name of the alias, 	 * @param targetName TableName for target, or the full path/method name, 	 * @param aliasSpecificInfo	 Information specific to the type of alias being created., 	 * @param aliasType	The type of alias to create,          * @return      A CreateAliasNode matching the given parameters, 	 *, 	 * @exception StandardException		Thrown on error, 	 */,         StatementNode,         getCreateAliasNode(,         TableName aliasName,,                 Object targetName,,                 Object aliasSpecificInfo,,                 char aliasType),                 throws StandardException,         {,         String methodName = null;, ,         if (,             (aliasType != AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR) &&,             (aliasType != AliasInfo.ALIAS_TYPE_UDT_AS_CHAR) &&,             (aliasType != AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR),             ),         {,             int lastPeriod;,             String fullStaticMethodName = (String) targetName;,             int paren = fullStaticMethodName.indexOf('(');,             if (paren == -1) {,                 // not a Java signature - split based on last period,                 lastPeriod = fullStaticMethodName.lastIndexOf('.');,             } else {,                 // a Java signature - split on last period before the '(',                 lastPeriod = fullStaticMethodName.substring(0, paren).lastIndexOf('.');,             },             if (lastPeriod == -1 || lastPeriod == fullStaticMethodName.length()-1) {,                 throw StandardException.newException(SQLState.LANG_INVALID_FULL_STATIC_METHOD_NAME, fullStaticMethodName);,             },             String javaClassName = fullStaticMethodName.substring(0, lastPeriod);,             methodName = fullStaticMethodName.substring(lastPeriod + 1);,             targetName = javaClassName;,         }, ,         return new CreateAliasNode(,             aliasName,,             targetName,,             methodName,,             aliasSpecificInfo,,             aliasType,,             cm );,         }, ,         /**, 		Create a node for the drop alias/procedure call., 	*/,         StatementNode,     dropAliasNode(TableName aliasName, char type) throws StandardException,         {,         return new DropAliasNode(aliasName, type, getContextManager());,         }, ,     /**,      * Get a substring node from,      *      - the string,      *      - the start position,      *      - the length,      * @exception StandardException  Thrown on error,      */,     ValueNode getSubstringNode( ValueNode stringValue, ValueNode startPosition,,                          ValueNode length) throws StandardException,     {,         return new TernaryOperatorNode(,                                                 stringValue,,                                                 startPosition,,                                                 length,,                             TernaryOperatorNode.K_SUBSTRING,,                             -1,,                                                     getContextManager());,     }, ,     private void initStatement( String statementSQLText, Object[] paramDefaults),         throws StandardException,     {,         /* Do per-statement initialization here */,         parameterNumber = 0;,        this.statementSQLText = statementSQLText;,         this.paramDefaults = paramDefaults;,         optimizerFactory = getOptimizerFactory();,         initUnnamedParameterList();,     } // End of initStatement, ,     private ValueNode getJdbcIntervalNode( int intervalType) throws StandardException,     {,         return new NumericConstantNode(,             TypeId.getBuiltInTypeId(Types.INTEGER),,             ReuseFactory.getInteger(intervalType),,             getContextManager());,     }, ,     /**,         Check to see if the required claues have been added,         to a procedure or function defintion.,         ,         @param required int array of require clauses,         @param  clauses the array of declared clauses.,     */,     void checkRequiredRoutineClause(int[] required, Object[] clauses),         throws StandardException,     {,         for (int i = 0; i < required.length; i++),         {,             int re = required[i];,             if (clauses[re] == null),             {,                 throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,,                                  ROUTINE_CLAUSE_NAMES[re]);,                     },                 },     }, ,         boolean isPrivilegeKeywordExceptTrigger(int tokenKind) {,                 return (tokenKind == SELECT ||,                                 tokenKind == DELETE ||,                                 tokenKind == INSERT ||,                                 tokenKind == UPDATE ||,                                 tokenKind == REFERENCES ||,                                 tokenKind == EXECUTE ||,                                 tokenKind == USAGE ||,                                 tokenKind == ALL);,         }, , ,         /**, 	 * Construct a TableElementNode of type, 	 * C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE., 	 *, 	 * @param defaultNode the new default value node, 	 * @param columnName  the name of the column to be altered, 	 * @param autoIncrementInfo autoincrement information collected, if any., 	 *, 	 * @return the new node constructed, 	 * @exception StandardException standard error policy, 	 */,         TableElementNode wrapAlterColumnDefaultValue(,                 ValueNode defaultNode,,                 String columnName,,                 long[] autoIncrementInfo) throws StandardException {, ,                 if (autoIncrementInfo,                                 [QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] == 0) {,                         autoIncrementInfo = null;,                 }, ,         return,             new ModifyColumnNode(ModifyColumnNode.K_MODIFY_COLUMN_DEFAULT,,                                  columnName,,                                  defaultNode,,                                  null,,                                  autoIncrementInfo,,                                  getContextManager());,         }, ,         private boolean,                 isTableValueConstructor(ResultSetNode expression),                         throws StandardException {, ,                 return expression instanceof RowResultSetNode ||,                         (expression instanceof UnionNode &&,                          ((UnionNode)expression).tableConstructor());,         }, ,     /**,      * Construct a new join node.,      *,      * @param leftRSN the left side of the join,      * @param rightRSN the right side of the join,      * @param onClause the ON clause, or null if there is no ON clause,      * @param usingClause the USING clause, or null if there is no USING clause,      * @param joinType the type of the join (one of the constants INNERJOIN,,      *                 LEFTOUTERJOIN or RIGHTOUTERJOIN in JoinNode),      * @return a new join node,      */,     private JoinNode newJoinNode(ResultSetNode leftRSN, ResultSetNode rightRSN,,                          ValueNode onClause, ResultColumnList usingClause,,                          int joinType),     throws StandardException,     {,         switch(joinType),         {,             case JoinNode.INNERJOIN:,                 return new JoinNode(leftRSN,,                                     rightRSN,,                                     onClause,,                                     usingClause,,                                     null,,                                     null,,                                     null,,                                     getContextManager());, ,             case JoinNode.LEFTOUTERJOIN:,                 return new HalfOuterJoinNode(leftRSN,,                                              rightRSN,,                                              onClause,,                                              usingClause,,                                              false,,                                              null,,                                              getContextManager());, ,             case JoinNode.RIGHTOUTERJOIN:,                 return new HalfOuterJoinNode(leftRSN,,                                              rightRSN,,                                              onClause,,                                              usingClause,,                                              true,,                                              null,,                                              getContextManager());, ,             default:,                 if (SanityManager.DEBUG),                 {,                     SanityManager.THROWASSERT("Unexpected joinType: " + joinType);,                 },                 return null;,         },     }, ,     private static boolean hasQueryExpressionSuffix(,         OrderByList orderBy, ValueNode[] offsetClauses),     {,         return,             orderBy != null ||,             offsetClauses[OFFSET_CLAUSE] != null ||,             offsetClauses[FETCH_FIRST_CLAUSE] != null;,     }, , /*,  * <A NAME="Statement">Statement</A>,  */,   final public StatementNode Statement(String statementSQLText, Object[] paramDefaults) throws ParseException, StandardException {,         StatementNode   statementNode;, ,         initStatement(statementSQLText, paramDefaults);,     statementNode = StatementPart(null);,     jj_consume_token(0);,                 {if (true) return statementNode;},     throw new Error("Missing return statement in function");,   }, , /**,  * Parse a search condition.,  *,  * @param sqlFragment a fragment of an SQL statement, representing a,  *                    search condition,  * @return a {@code ValueNode} representing the search condition,  */,   final public ValueNode SearchCondition(String sqlFragment) throws ParseException, StandardException {,     ValueNode valueNode;,     initStatement(sqlFragment, null);,     valueNode = valueExpression();,     jj_consume_token(0);,         {if (true) return valueNode;},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode proceduralStatement(Token[] tokenHolder) throws ParseException, StandardException {,         StatementNode statementNode;,         tokenHolder[0] = getToken(1);,     switch (jj_nt.kind) {,     case INSERT:,       statementNode = insertStatement();,       break;,     case UPDATE:,       statementNode = preparableUpdateStatement();,       break;,     case DELETE:,       statementNode = preparableDeleteStatement();,       break;,     case SELECT:,     case VALUES:,     case LEFT_PAREN:,       statementNode = preparableSelectStatement(true);,       break;,     case MERGE:,       statementNode = mergeStatement();,       break;,     case CALL:,     case LEFT_BRACE:,     case QUESTION_MARK:,       statementNode = callStatement();,       break;,     default:,       jj_la1[0] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return statementNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="StatementPart">StatementPart</A>,  * ,  * @param tokenHolder returns the token that starts,  * the statement.  If null, ignored.,  */,   final public StatementNode StatementPart(Token[] tokenHolder) throws ParseException, StandardException {,         StatementNode   statementNode;, ,         /*, 	** Grab the token preceding this production, 	*/,         if (tokenHolder != null),         {,                 tokenHolder[0] = getToken(1);,         },     switch (jj_nt.kind) {,     case LOCK:,     case RENAME:,       switch (jj_nt.kind) {,       case RENAME:,         statementNode = spsRenameStatement();,         break;,       case LOCK:,         // statementNode = SQLTransactionStatement() |,                 statementNode = lockStatement();,         break;,       default:,         jj_la1[1] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },         {if (true) return statementNode;},       break;,     default:,       jj_la1[5] = jj_gen;,       if (jj_2_4(1)) {,         switch (jj_nt.kind) {,         case CREATE:,           statementNode = createStatements();,           break;,         case DROP:,           statementNode = dropStatements();,           break;,         case ALTER:,           statementNode = spsAlterStatement();,           break;,         case DECLARE:,           statementNode = globalTemporaryTableDeclaration();,           break;,         case DELETE:,         case INSERT:,         case ROLLBACK:,         case SELECT:,         case UPDATE:,         case VALUES:,         case MERGE:,         case RELEASE:,         case SAVEPOINT:,         case CALL:,         case LEFT_BRACE:,         case LEFT_PAREN:,         case QUESTION_MARK:,           statementNode = preparableSQLDataStatement();,           break;,         default:,           jj_la1[2] = jj_gen;,           if (jj_2_1(1)) {,             statementNode = spsSetStatement();,           } else {,             switch (jj_nt.kind) {,             case TRUNCATE:,               statementNode = truncateTableStatement();,               break;,             default:,               jj_la1[3] = jj_gen;,               if (jj_2_2(1)) {,                 statementNode = grantStatement();,               } else if (jj_2_3(1)) {,                 statementNode = revokeStatement();,               } else {,                 switch (jj_nt.kind) {,                 case EXECUTE:,                   statementNode = execStatement();,                   break;,                 default:,                   jj_la1[4] = jj_gen;,                   jj_consume_token(-1);,                   throw new ParseException();,                 },               },             },           },         },         {if (true) return statementNode;},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="createStatements">spsCreateStatement</A>,  */,   final public StatementNode createStatements() throws ParseException, StandardException {,         StatementNode statementNode;,         Token beginToken;,         int tokKind;,     beginToken = jj_consume_token(CREATE);,     switch (jj_nt.kind) {,     case SCHEMA:,     case VIEW:,     case SYNONYM:,     case ROLE:,     case SEQUENCE:,     case TRIGGER:,       switch (jj_nt.kind) {,       case SCHEMA:,         statementNode = schemaDefinition();,         break;,       case VIEW:,         statementNode = viewDefinition(beginToken);,         break;,       case TRIGGER:,         statementNode = triggerDefinition();,         break;,       case SYNONYM:,         statementNode = synonymDefinition();,         break;,       case ROLE:,         statementNode = roleDefinition();,         break;,       case SEQUENCE:,         statementNode = sequenceDefinition();,         break;,       default:,         jj_la1[6] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       }, ,       break;,     case TABLE:,       statementNode = tableDefinition();, ,       break;,     case PROCEDURE:,       statementNode = procedureDefinition();,       break;,     case FUNCTION:,       statementNode = functionDefinition();,       break;,     case DERBY:,       statementNode = aggregateDefinition();,       break;,     case TYPE:,       statementNode = udtDefinition();,       break;,     case UNIQUE:,     case INDEX:,       statementNode = indexDefinition();, ,       break;,     default:,       jj_la1[7] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return statementNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dropStatements">spsDropStatement</A>,  */,   final public StatementNode dropStatements() throws ParseException, StandardException {,         StatementNode statementNode;,     jj_consume_token(DROP);,     switch (jj_nt.kind) {,     case SCHEMA:,       statementNode = dropSchemaStatement();,       break;,     case TABLE:,       statementNode = dropTableStatement();,       break;,     case INDEX:,       statementNode = dropIndexStatement();,       break;,     case FUNCTION:,     case PROCEDURE:,     case SYNONYM:,     case TYPE:,     case DERBY:,       statementNode = dropAliasStatement();,       break;,     case VIEW:,       statementNode = dropViewStatement();,       break;,     case TRIGGER:,       statementNode = dropTriggerStatement();,       break;,     case ROLE:,       statementNode = dropRoleStatement();,       break;,     case SEQUENCE:,       statementNode = dropSequenceStatement();,       break;,     default:,       jj_la1[8] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return statementNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="spsAlterStatement">spsAlterStatement</A>,  */,   final public StatementNode spsAlterStatement() throws ParseException, StandardException {,         StatementNode statementNode;,     jj_consume_token(ALTER);,     statementNode = alterTableStatement();,                 {if (true) return statementNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="spsSetStatement">spsSetStatement</A>,  */,   final public StatementNode spsSetStatement() throws ParseException, StandardException {,         StatementNode statementNode;,     if (getToken(1).kind == SET && getToken(2).kind != CURRENT) {,       jj_consume_token(SET);,       if (jj_2_5(1)) {,         statementNode = setIsolationStatement();,       } else if (jj_2_6(1)) {,         statementNode = setSchemaStatement();,       } else {,         switch (jj_nt.kind) {,         case MESSAGE_LOCALE:,           statementNode = setMessageLocaleStatement();,           break;,         case ROLE:,           statementNode = setRoleStatement();,           break;,         case CONSTRAINTS:,           statementNode = setConstraintsStatement();,           break;,         default:,           jj_la1[9] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },                 {if (true) return statementNode;},     } else if (getToken(1).kind == SET && getToken(2).kind == CURRENT) {,       jj_consume_token(SET);,       if (jj_2_7(1)) {,         statementNode = setSchemaStatement();,       } else if (jj_2_8(1)) {,         statementNode = setIsolationStatement();,       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },                 {if (true) return statementNode;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /**,  * <A NAME="constraintsReference">constraintsReference</A>,  */,   final public void constraintsReference(List<TableName> constraints) throws ParseException, StandardException {,     TableName constraint;,     constraint = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         constraints.add(constraint);,   }, , /**,  * <A NAME="setConstraintsStatement">setConstraintsStatement</A>,  */,   final public StatementNode setConstraintsStatement() throws ParseException, StandardException {,     List<TableName> constraints = new ArrayList<TableName>();,     boolean initiallyDeferred;,     jj_consume_token(CONSTRAINTS);,     if (jj_2_9(1)) {,       constraintsReference(constraints);,       label_1:,       while (true) {,         switch (jj_nt.kind) {,         case COMMA:,           ;,           break;,         default:,           jj_la1[10] = jj_gen;,           break label_1;,         },         jj_consume_token(COMMA);,         constraintsReference(constraints);,       },     } else {,       switch (jj_nt.kind) {,       case ALL:,         jj_consume_token(ALL);,             constraints = null;,         break;,       default:,         jj_la1[11] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     switch (jj_nt.kind) {,     case DEFERRED:,       jj_consume_token(DEFERRED);,             initiallyDeferred = true;,       break;,     case IMMEDIATE:,       jj_consume_token(IMMEDIATE);,             initiallyDeferred = false;,       break;,     default:,       jj_la1[12] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },         checkVersion(,             DataDictionary.DD_VERSION_DERBY_10_11, "DEFERRED CONSTRAINTS");,         {if (true) return new SetConstraintsNode(constraints, initiallyDeferred, cm);},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="preparableSQLDataStatement">preparableSQLDataStatement</A>,  *,  * preparableSQLDataStatement differs from,  * directSQLDataStatement in that it,  * supports positioned update and delete,  * and a preparable select (with FOR UPDATE),  * instead of a direct select (without FOR UPDATE),  */,   final public StatementNode preparableSQLDataStatement() throws ParseException, StandardException {,         StatementNode   dmlStatement;,     switch (jj_nt.kind) {,     case DELETE:,       /*,       	** RESOLVE: Ignoring temporary table declarations for now.,       	*/,               dmlStatement = preparableDeleteStatement();,                 {if (true) return dmlStatement;},       break;,     case SELECT:,     case VALUES:,     case LEFT_PAREN:,       dmlStatement = preparableSelectStatement(true);,                 {if (true) return dmlStatement;},       break;,     case INSERT:,       dmlStatement = insertStatement();,                 {if (true) return dmlStatement;},       break;,     case MERGE:,       dmlStatement = mergeStatement();,                 {if (true) return dmlStatement;},       break;,     case UPDATE:,       dmlStatement = preparableUpdateStatement();,                 {if (true) return dmlStatement;},       break;,     case CALL:,     case LEFT_BRACE:,     case QUESTION_MARK:,       dmlStatement = callStatement();,                 {if (true) return dmlStatement;},       break;,     case ROLLBACK:,     case RELEASE:,     case SAVEPOINT:,       dmlStatement = savepointStatement();,                 {if (true) return dmlStatement;},       break;,     default:,       jj_la1[13] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="preparableDeleteStatement">preparableDeleteStatement</A>,  *,  *	This may be a search or positioned delete statement.,  */,   final public StatementNode preparableDeleteStatement() throws ParseException, StandardException {,         StatementNode qtn;,     jj_consume_token(DELETE);,     qtn = deleteBody();,                 {if (true) return qtn;},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode deleteBody() throws ParseException, StandardException {,         JavaToSQLValueNode      javaToSQLNode = null;,         String                          correlationName = null;,         TableName  tableName = null;,         ValueNode  whereClause = null;,         FromTable  fromTable = null;,         QueryTreeNode retval;,         Properties targetProperties = null;,         Token      whereToken = null;,     if (fromNewInvocationFollows()) {,       jj_consume_token(FROM);,       javaToSQLNode = newInvocation();,       switch (jj_nt.kind) {,       case WHERE:,         whereToken = jj_consume_token(WHERE);,         whereClause = whereClause(whereToken);,         break;,       default:,         jj_la1[14] = jj_gen;,         ;,       },         fromTable =,             new FromVTI((MethodCallNode)javaToSQLNode.getJavaValueNode(),,                         (String)null,,                         null,,                         (Properties)null,,                         getContextManager());, ,                 {if (true) return getDeleteNode(fromTable, tableName, whereClause);},     } else {,       switch (jj_nt.kind) {,       case FROM:,         jj_consume_token(FROM);,         tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         if ((getToken(1).kind != EOF) && (getToken(1).kind != WHERE) && !derbyPropertiesListFollows()) {,           switch (jj_nt.kind) {,           case AS:,             jj_consume_token(AS);,             break;,           default:,             jj_la1[15] = jj_gen;,             ;,           },           correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         } else {,           ;,         },         switch (jj_nt.kind) {,         case DERBYDASHPROPERTIES:,           targetProperties = propertyList(false);,           jj_consume_token(CHECK_PROPERTIES);,           break;,         default:,           jj_la1[16] = jj_gen;,           ;,         },         switch (jj_nt.kind) {,         case WHERE:,           whereToken = jj_consume_token(WHERE);,           if ((getToken(1).kind == CURRENT) &&,                                                    (getToken(2).kind == OF)) {,             fromTable = currentOfClause(correlationName);,           } else if (jj_2_10(1)) {,             whereClause = whereClause(whereToken);,           } else {,             jj_consume_token(-1);,             throw new ParseException();,           },           break;,         default:,           jj_la1[17] = jj_gen;,           ;,         },                 /* Fabricate a ResultSetNode (SelectNode) under the DeleteNode., 		 * For a searched delete,, 		 * The FromList is simply the table that we are deleting from., 		 * (NOTE - we mark the table as the one that we are deleting from.), 		 * For a positioned delete,, 		 * the FromList is a CurrentOfNode holding the cursor name., 		 * The select list will be null for now.  We will generate it at, 	 	 * bind time, in keeping with the design decision that the parser's, 	  	 * output should look like the language., 		 */,                 if (fromTable == null),             fromTable = new FromBaseTable(tableName,,                                           correlationName,,                                           FromBaseTable.DELETE,,                                           null,,                                           getContextManager());, ,                 /* Update the FromTable with any properties, if non-null */,                 if (targetProperties != null),                 {,                         if (SanityManager.DEBUG),                         {,                                 if (((FromBaseTable) fromTable).getProperties() != null),                                 {,                                         SanityManager.THROWASSERT(,                                                 "Overwriting existing properties");,                                 },                         },                         ((FromBaseTable) fromTable).setTableProperties(targetProperties);,                 }, ,                 {if (true) return getDeleteNode(fromTable, tableName, whereClause);},         break;,       default:,         jj_la1[18] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="currentOfClause">currentOfClause</A>,  */,   final public FromTable currentOfClause(String correlationName) throws ParseException, StandardException {,         String cursorName = null;,     jj_consume_token(CURRENT);,     jj_consume_token(OF);,     cursorName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         {if (true) return new CurrentOfNode(,             correlationName, cursorName, null, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="preparableSelectStatement">preparableSelectStatement</A>,  *,  *,  *	The preparable select statement is a superset of,  *	the directSelectStatementMultipleRows in that it,  *	allows both the preparable single row select statement,  *	(a query expression that returns one row, although it,  *	is also handled like a cursor) and the preparable,  *	multiple row select statement, which allows not only,  *	an order by clause but also a for update clause.,  */,   final public CursorNode preparableSelectStatement(boolean checkParams) throws ParseException, StandardException {,         ResultSetNode     queryExpression;,         ArrayList<String> updateColumns = new ArrayList<String>();,         int               forUpdateState = CursorNode.UNSPECIFIED;,         int                               isolationLevel = TransactionControl.UNSPECIFIED_ISOLATION_LEVEL;,         CursorNode                retval;,         OrderByList orderCols = null;,     ValueNode[] offsetClauses = new ValueNode[ OFFSET_CLAUSE_COUNT ];,     boolean     hasJDBClimitClause = false;,     queryExpression = queryExpression(null, NO_SET_OP);,     switch (jj_nt.kind) {,     case ORDER:,       orderCols = orderByClause(queryExpression);,       break;,     default:,       jj_la1[19] = jj_gen;,       ;,     },     hasJDBClimitClause = offsetFetchFirstClause(offsetClauses);,     switch (jj_nt.kind) {,     case FOR:,       jj_consume_token(FOR);,       forUpdateState = forUpdateClause(updateColumns);,       break;,     default:,       jj_la1[20] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case WITH:,       isolationLevel = atIsolationLevel();,       break;,     default:,       jj_la1[21] = jj_gen;,       ;,     },                 // Note: if order by is specified, the for update clause,                 // must be READ ONLY or empty, and the cursor,                 // is implicitly READ_ONLY., ,         retval = new CursorNode(,                                 "SELECT",,                                 queryExpression,,                                 null,,                                 orderCols,,                                 offsetClauses[ OFFSET_CLAUSE ],,                                 offsetClauses[ FETCH_FIRST_CLAUSE ],,                 hasJDBClimitClause,,                 forUpdateState,,                 forUpdateState == CursorNode.READ_ONLY ?,                     null :,                     updateColumns.toArray(new String[updateColumns.size()]),,                 false,,                                 getContextManager());, ,                 if (checkParams),                 {,                         setUpAndLinkParameters();,                 }, ,                 /* Set the isolation levels for the scans if specified */,                 if (isolationLevel != TransactionControl.UNSPECIFIED_ISOLATION_LEVEL),                 {,                         getCompilerContext().setScanIsolationLevel(isolationLevel);,                 }, ,                 {if (true) return retval;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="insertStatement">insertStatement</A>,  */,   final public StatementNode insertStatement() throws ParseException, StandardException {,         StatementNode   insertNode;,         QueryTreeNode   targetTable;,     jj_consume_token(INSERT);,     jj_consume_token(INTO);,     targetTable = targetTable();,     insertNode = insertColumnsAndSource(targetTable);,                 setUpAndLinkParameters();, ,                 {if (true) return insertNode;},     throw new Error("Missing return statement in function");,   }, ,   final public QueryTreeNode targetTable() throws ParseException, StandardException {,         JavaToSQLValueNode      javaToSQLNode = null;,         String                          correlationName = null;,         TableName                       tableName;,     if (newInvocationFollows(1)) {,       javaToSQLNode = newInvocation();,         {if (true) return new FromVTI((MethodCallNode)javaToSQLNode.getJavaValueNode(),,                            correlationName,,                            null,,                            (Properties) null,,                            getContextManager());},     } else if (jj_2_11(1)) {,       tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,                 {if (true) return tableName;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="preparableUpdateStatement">preparableUpdateStatement</A>,  */,   final public StatementNode preparableUpdateStatement() throws ParseException, StandardException {,         StatementNode qtn;,     jj_consume_token(UPDATE);,     qtn = updateBody();,                 {if (true) return qtn;},     throw new Error("Missing return statement in function");,   }, ,   final public boolean tableOrIndex() throws ParseException {,     switch (jj_nt.kind) {,     case TABLE:,       jj_consume_token(TABLE);,                 {if (true) return true;},       break;,     case INDEX:,       jj_consume_token(INDEX);,                 {if (true) return false;},       break;,     default:,       jj_la1[22] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode updateBody() throws ParseException, StandardException {,         ResultColumnList        columnList;,         String                          correlationName = null;,         JavaToSQLValueNode      javaToSQLNode = null;,         TableName  tableName = null;,         ValueNode  whereClause = null;,         FromTable  fromTable = null;,         Properties targetProperties = null;,         Token      whereToken = null;,     if (newInvocationFollows(1)) {,       javaToSQLNode = newInvocation();,       jj_consume_token(SET);,       columnList = setClauseList();,       switch (jj_nt.kind) {,       case WHERE:,         whereToken = jj_consume_token(WHERE);,         whereClause = whereClause(whereToken);,         break;,       default:,         jj_la1[23] = jj_gen;,         ;,       },         fromTable =,             new FromVTI((MethodCallNode)javaToSQLNode.getJavaValueNode(),,                         (String)null,,                         null,,                         (Properties)null,,                         getContextManager());, ,                 {if (true) return getUpdateNode(fromTable, tableName, columnList, whereClause);},     } else if (jj_2_13(1)) {,       tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,       if ((getToken(1).kind != SET) && !derbyPropertiesListFollows()) {,         switch (jj_nt.kind) {,         case AS:,           jj_consume_token(AS);,           break;,         default:,           jj_la1[24] = jj_gen;,           ;,         },         correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,       } else {,         ;,       },       switch (jj_nt.kind) {,       case DERBYDASHPROPERTIES:,         targetProperties = propertyList(false);,         jj_consume_token(CHECK_PROPERTIES);,         break;,       default:,         jj_la1[25] = jj_gen;,         ;,       },       jj_consume_token(SET);,       columnList = setClauseList();,       switch (jj_nt.kind) {,       case WHERE:,         whereToken = jj_consume_token(WHERE);,         if (jj_2_12(1)) {,           whereClause = whereClause(whereToken);,         } else {,           switch (jj_nt.kind) {,           case CURRENT:,             fromTable = currentOfClause(correlationName);,             break;,           default:,             jj_la1[26] = jj_gen;,             jj_consume_token(-1);,             throw new ParseException();,           },         },         break;,       default:,         jj_la1[27] = jj_gen;,         ;,       },                 /* Fabricate a ResultSetNode (SelectNode) under the UpdateNode., 		 * For a searched update,, 		 * The FromList is simply the table that we are updating., 		 * For a positioned update,, 		 * the FromList is a CurrentOfNode holding the cursor name., 		 * (NOTE - we mark the table as the one that we are updating.), 		 * The select list is the columns in the SET clause.  At bind time,, 	 	 * we will prepend the CurrentRowLocation() in keeping with the design , 		 * decision that the parser's output should look like the language., 		 */,                 if (fromTable == null),             fromTable = new FromBaseTable(tableName,,                                           correlationName,,                                           FromBaseTable.UPDATE,,                                           null,,                                           getContextManager());, ,                 /* Update the FromTable with any properties, if non-null */,                 if (targetProperties != null),                 {,                         if (SanityManager.DEBUG),                         {,                                 if (((FromBaseTable) fromTable).getProperties() != null),                                 {,                                         SanityManager.THROWASSERT(,                                                 "Overwriting existing properties");,                                 },                         },                         ((FromBaseTable) fromTable).setTableProperties(targetProperties);,                 },                 {if (true) return getUpdateNode(fromTable, tableName, columnList, whereClause);},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="callStatement">callStatement</A>,  */,   final public StatementNode callStatement() throws ParseException, StandardException {,         StatementNode retval;,     switch (jj_nt.kind) {,     case CALL:,     case QUESTION_MARK:,       retval = bareCallStatement();,       break;,     case LEFT_BRACE:,       jj_consume_token(LEFT_BRACE);,       retval = bareCallStatement();,       jj_consume_token(RIGHT_BRACE);,       break;,     default:,       jj_la1[28] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return retval;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="bareCallStatement">baseCallStatement</A>,  */,   final public StatementNode bareCallStatement() throws ParseException, StandardException {,         ParameterNode           returnParam;, ,         ValueNode                       value;, ,         ResultSetNode           resultSetNode;,     switch (jj_nt.kind) {,     case CALL:,       jj_consume_token(CALL);,       value = primaryExpression();,                 if (! (value instanceof JavaToSQLValueNode) ||,                         ! (((JavaToSQLValueNode) value).getJavaValueNode() instanceof MethodCallNode)),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_INVALID_CALL_STATEMENT);},                 }, ,                 StatementNode callStatement =,         new CallStatementNode((JavaToSQLValueNode)value, getContextManager());, ,                 setUpAndLinkParameters();, ,                 {if (true) return callStatement;},       break;,     case QUESTION_MARK:,       returnParam = dynamicParameterSpecification();,                 getCompilerContext().setReturnParameterFlag(); //bug4450, ,       jj_consume_token(EQUALS_OPERATOR);,       jj_consume_token(CALL);,       resultSetNode = rowValueConstructor(null);,                 // validate that we have something that is an appropriate call statement,                 ResultColumnList rcl = resultSetNode.getResultColumns();, ,                 // we can have only 1 return value/column,                 if (rcl == null || rcl.size() > 1),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_INVALID_CALL_STATEMENT);},                 }, ,                 // we must have a method call node,                 value = ((ResultColumn) rcl.elementAt(0)).getExpression();,                 if (! (value instanceof JavaToSQLValueNode) ||,                         ! (((JavaToSQLValueNode) value).getJavaValueNode() instanceof MethodCallNode)),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_INVALID_CALL_STATEMENT);},                 }, ,                 // wrap the row result set in a cursor node,         StatementNode cursorNode = new CursorNode("SELECT",,                                                   resultSetNode,,                                                   null,,                                                   null,,                                                   null,,                                                   null,,                                                   false,,                                                   CursorNode.READ_ONLY,,                                                   null,,                                                   false,,                                                   getContextManager());, ,                 // set the 0th param to be a RETURN param,                 returnParam.setReturnOutputParam(value);, ,                 setUpAndLinkParameters();, ,                 {if (true) return cursorNode;},       break;,     default:,       jj_la1[29] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="mergeStatement">mergeStatement</A>,  */,   final public StatementNode mergeStatement() throws ParseException, StandardException {,         FromTable   targetTable;,     FromTable       sourceTable;,     ValueNode       searchCondition;,     ArrayList<MatchingClauseNode>   matchingClauses;,     jj_consume_token(MERGE);,     jj_consume_token(INTO);,     targetTable = tableFactor();,     jj_consume_token(USING);,     sourceTable = tableFactor();,     searchCondition = joinCondition();,     matchingClauses = matchingClauseList();,         checkVersion( DataDictionary.DD_VERSION_DERBY_10_11, "MERGE" );, ,                 setUpAndLinkParameters();, ,         {if (true) return new MergeNode,         (,             targetTable,,             sourceTable,,             searchCondition,,             matchingClauses,,             getContextManager(),         );},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="matchingClauseList">matchingClauseList</A>,  */,   final public ArrayList<MatchingClauseNode> matchingClauseList() throws ParseException, StandardException {,     ArrayList<MatchingClauseNode>   matchingClauses = new ArrayList<MatchingClauseNode>();,     matchingClause(matchingClauses);,     label_2:,     while (true) {,       if (jj_2_14(1)) {,         ;,       } else {,         break label_2;,       },       matchingClause(matchingClauses);,     },         {if (true) return matchingClauses;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="matchingClause">matchingClause</A>,  */,   final public void matchingClause(ArrayList<MatchingClauseNode> matchingClauses) throws ParseException, StandardException {,     ValueNode   matchingRefinement = null;,     ResultColumnList               updateColumns = null;,     ResultColumnList               insertColumns = null;,         ResultColumnList               insertValues = new ResultColumnList( getContextManager() );,     MatchingClauseNode             matchingClause;,     if (getToken(1).kind == WHEN && getToken(2).kind != NOT) {,       jj_consume_token(WHEN);,       jj_consume_token(MATCHED);,       switch (jj_nt.kind) {,       case AND:,         jj_consume_token(AND);,         matchingRefinement = valueExpression();,         break;,       default:,         jj_la1[30] = jj_gen;,         ;,       },       jj_consume_token(THEN);,       switch (jj_nt.kind) {,       case DELETE:,         jj_consume_token(DELETE);,         break;,       case UPDATE:,         jj_consume_token(UPDATE);,         jj_consume_token(SET);,         updateColumns = setClauseList();,         break;,       default:,         jj_la1[31] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },         if ( updateColumns != null ),         {,             matchingClause = MatchingClauseNode.makeUpdateClause,             ( matchingRefinement, updateColumns, getContextManager() );,         },         else,         {,             matchingClause = MatchingClauseNode.makeDeleteClause,             ( matchingRefinement, getContextManager() );,         }, ,         matchingClauses.add( matchingClause );,     } else if (getToken(1).kind == WHEN && getToken(2).kind == NOT) {,       jj_consume_token(WHEN);,       jj_consume_token(NOT);,       jj_consume_token(MATCHED);,       switch (jj_nt.kind) {,       case AND:,         jj_consume_token(AND);,         matchingRefinement = valueExpression();,         break;,       default:,         jj_la1[32] = jj_gen;,         ;,       },       jj_consume_token(THEN);,       jj_consume_token(INSERT);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         jj_consume_token(LEFT_PAREN);,         insertColumns = insertColumnList();,         jj_consume_token(RIGHT_PAREN);,         break;,       default:,         jj_la1[33] = jj_gen;,         ;,       },       jj_consume_token(VALUES);,       jj_consume_token(LEFT_PAREN);,       rowValueConstructorList(insertValues);,       jj_consume_token(RIGHT_PAREN);,         matchingClause = MatchingClauseNode.makeInsertClause,         ( matchingRefinement, insertColumns, insertValues, getContextManager() );, ,         matchingClauses.add( matchingClause );,     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },   }, , /*,  * <A NAME="primaryExpression">primaryExpression</A>,  */,   final public ValueNode primaryExpression() throws ParseException, StandardException {,         ValueNode                       value = null;,     if (getToken(2).kind == PERIOD &&,                     getToken(4).kind == LEFT_PAREN) {,       value = routineInvocation();,                 {if (true) return value;},     } else if (jj_2_15(1)) {,       value = primaryExpressionXX();,                 {if (true) return value;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /* ,  * <A NAME="savepointStatement">savepointStatement</A>, , 	savepointStatementClauses contains the UNIQUE, ON ROLLBACK RETAIN LOCKS, ON ROLLBACK RETAIN CURSORS clauses., , 	0 - Boolean - UNIQUE clause, 	1 - Boolean - ON ROLLBACK RETAIN LOCKS clause, 	2 - Boolean - ON ROLLBACK RETAIN CURSORS clause,  */,   final public StatementNode savepointStatement() throws ParseException, StandardException {,         String                  savepointName = null;,         int                     savepointStatementType;,         Object[] savepointStatementClauses = new Object[3];,     switch (jj_nt.kind) {,     case SAVEPOINT:,       jj_consume_token(SAVEPOINT);,       savepointName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,       label_3:,       while (true) {,         savepointStatementClause(savepointStatementClauses);,         switch (jj_nt.kind) {,         case ON:,         case UNIQUE:,           ;,           break;,         default:,           jj_la1[34] = jj_gen;,           break label_3;,         },       },                 //ON ROLLBACK RETAIN CURSORS is mandatory,                 if (savepointStatementClauses[2] == null),                                 {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MISSING ON ROLLBACK RETAIN CURSORS");},                 savepointStatementType = 1;,       break;,     case ROLLBACK:,       jj_consume_token(ROLLBACK);,       switch (jj_nt.kind) {,       case WORK:,         jj_consume_token(WORK);,         break;,       default:,         jj_la1[35] = jj_gen;,         ;,       },       jj_consume_token(TO);,       jj_consume_token(SAVEPOINT);,       if (jj_2_16(1)) {,         savepointName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,       } else {,         ;,       },                 savepointStatementType = 2;,       break;,     case RELEASE:,       jj_consume_token(RELEASE);,       switch (jj_nt.kind) {,       case TO:,         jj_consume_token(TO);,         break;,       default:,         jj_la1[36] = jj_gen;,         ;,       },       jj_consume_token(SAVEPOINT);,       savepointName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 savepointStatementType = 3;,       break;,     default:,       jj_la1[37] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },         {if (true) return new SavepointNode(,             savepointName, savepointStatementType, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public void savepointStatementClause(Object[] savepointStatementClauses) throws ParseException, StandardException {,         int clausePosition = -1;,     switch (jj_nt.kind) {,     case UNIQUE:,       jj_consume_token(UNIQUE);,                           clausePosition = 0;,       break;,     case ON:,       jj_consume_token(ON);,       jj_consume_token(ROLLBACK);,       jj_consume_token(RETAIN);,       clausePosition = LocksOrCursors();,       break;,     default:,       jj_la1[38] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 if (clausePosition != -1) {,                         // check for repeated clause,                         if (savepointStatementClauses[clausePosition] != null) {, ,                                 String which = SAVEPOINT_CLAUSE_NAMES[clausePosition];,                                 {if (true) throw StandardException.newException(SQLState.LANG_DB2_MULTIPLE_ELEMENTS, which);},                         }, ,                         savepointStatementClauses[clausePosition] = Boolean.TRUE;,                 },   }, , /*,  * <A NAME="LocksOrCursors">LocksOrCursors</A>,  */,   final public int LocksOrCursors() throws ParseException {,     switch (jj_nt.kind) {,     case LOCKS:,       jj_consume_token(LOCKS);,                 {if (true) return (1);},       break;,     case CURSORS:,       jj_consume_token(CURSORS);,                 {if (true) return (2);},       break;,     default:,       jj_la1[39] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /* ,  * <A NAME="globalTemporaryTableDeclaration">globalTemporaryTableDeclaration</A>, , 	declareTableClauses contains the NOT LOGGED, on commit and on rollback clauses., , 	0 - Boolean - NOT LOGGED clause, 	1 - Boolean - on commit behavior, 	2 - Boolean - on rollback behavior,  */,   final public StatementNode globalTemporaryTableDeclaration() throws ParseException, StandardException {,         TableName                       tableName;,         TableElementList tableElementList;,         Object[] declareTableClauses = new Object[3];,     jj_consume_token(DECLARE);,     jj_consume_token(GLOBAL);,     jj_consume_token(TEMPORARY);,     jj_consume_token(TABLE);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     tableElementList = tableElementList();,     label_4:,     while (true) {,       declareTableClause(declareTableClauses);,       if (jj_2_17(1)) {,         ;,       } else {,         break label_4;,       },     },                 // NOT LOGGED is mandatory,                 if (declareTableClauses[0] == null),                                 {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MISSING NOT LOGGED");},                 // if ON COMMIT behavior not explicitly specified in DECLARE command, resort to default ON COMMIT DELETE ROWS,                 if (declareTableClauses[1] == null),                                 declareTableClauses[1] = Boolean.TRUE;,                 // if ON ROLLBACK behavior not explicitly specified in DECLARE command, resort to default ON ROLLBACK DELETE ROWS,                 if (declareTableClauses[2] == null),                                 declareTableClauses[2] = Boolean.TRUE;,         {if (true) return new CreateTableNode(,             tableName,,             tableElementList,,             (Properties)null,,             ((Boolean) declareTableClauses[1]).booleanValue(),,             ((Boolean) declareTableClauses[2]).booleanValue(),,             getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public void declareTableClause(Object[] declareTableClauses) throws ParseException, StandardException {,         int clausePosition = -1;,         Object clauseValue = null;,     switch (jj_nt.kind) {,     case NOT:,       jj_consume_token(NOT);,       jj_consume_token(LOGGED);,                                 clauseValue = Boolean.TRUE; clausePosition = 0;,       break;,     default:,       jj_la1[40] = jj_gen;,       if (getToken(1).kind == ON && getToken(2).kind == COMMIT) {,         jj_consume_token(ON);,         jj_consume_token(COMMIT);,         clauseValue = onCommit();,         jj_consume_token(ROWS);,                                                                     clausePosition = 1;,       } else if (getToken(1).kind == ON && getToken(2).kind == ROLLBACK) {,         jj_consume_token(ON);,         jj_consume_token(ROLLBACK);,         jj_consume_token(DELETE);,         jj_consume_token(ROWS);,                                                   clauseValue = Boolean.TRUE; clausePosition = 2;,       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },                 if (clausePosition != -1) {,                         // check for repeated clause,                         if (declareTableClauses[clausePosition] != null) {, ,                                 String which = TEMPORARY_TABLE_CLAUSE_NAMES[clausePosition];,                                 {if (true) throw StandardException.newException(SQLState.LANG_DB2_MULTIPLE_ELEMENTS, which);},                         }, ,                         declareTableClauses[clausePosition] = clauseValue;,                 },   }, , /*,  * <A NAME="onCommit">onCommit</A>,  */,   final public Boolean onCommit() throws ParseException {,     switch (jj_nt.kind) {,     case PRESERVE:,       jj_consume_token(PRESERVE);,                 {if (true) return (Boolean.FALSE);},       break;,     case DELETE:,       jj_consume_token(DELETE);,                 {if (true) return (Boolean.TRUE);},       break;,     default:,       jj_la1[41] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="tableElementList">tableElementList</A>,  */,   final public TableElementList tableElementList() throws ParseException, StandardException {,     TableElementList tableElementList =,         new TableElementList(getContextManager());,     jj_consume_token(LEFT_PAREN);,     tableElement(tableElementList);,     label_5:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[42] = jj_gen;,         break label_5;,       },       jj_consume_token(COMMA);,       tableElement(tableElementList);,     },     jj_consume_token(RIGHT_PAREN);,                 {if (true) return tableElementList;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="tableElement">tableElement</A>,  */,   final public void tableElement(TableElementList tableElementList) throws ParseException, StandardException {,         TableElementNode        tableElement;,     if (jj_2_18(1)) {,       tableElement = columnDefinition(tableElementList);,                 tableElementList.addTableElement(tableElement);,     } else {,       switch (jj_nt.kind) {,       case CHECK:,       case CONSTRAINT:,       case FOREIGN:,       case PRIMARY:,       case UNIQUE:,         tableElement = tableConstraintDefinition();,                 tableElementList.addTableElement(tableElement);,         break;,       default:,         jj_la1[43] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },   }, , /*,  * <A NAME="columnDefinition">columnDefinition</A>,  */,   final public TableElementNode columnDefinition(TableElementList tableElementList) throws ParseException, StandardException {,         DataTypeDescriptor[]    typeDescriptor = new DataTypeDescriptor[1];,         ValueNode                       defaultNode = null;,         String                          columnName;,         long[]                          autoIncrementInfo = new long[4];,     /*,     	** RESOLVE: We are ignoring domains and collation.,     	*/,     ,             /* identifier() used to be columnName() */,             columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     if (jj_2_19(1)) {,       typeDescriptor[0] = dataTypeDDL();,     } else {,       ;,     },     switch (jj_nt.kind) {,     case CHECK:,     case CONSTRAINT:,     case _DEFAULT:,     case NOT:,     case PRIMARY:,     case REFERENCES:,     case UNIQUE:,     case WITH:,     case GENERATED:,       defaultNode = defaultAndConstraints(typeDescriptor, tableElementList, columnName, autoIncrementInfo);,       break;,     default:,       jj_la1[44] = jj_gen;,       ;,     },                 // Only pass autoincrement info for autoincrement columns,                 if (autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] == 0),                 {,                         autoIncrementInfo = null;,                 }, ,         {if (true) return new ColumnDefinitionNode(,                                                                 columnName,,                                                                 defaultNode,,                                                                 typeDescriptor[0],,                                                                 autoIncrementInfo,,                                                                 getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="defaultAndConstraints">defaultAndConstraints</A>,  */,   final public ValueNode defaultAndConstraints(DataTypeDescriptor[] typeDescriptor,,                                           TableElementList tableElementList,,                                           String columnName,,                                           long[] autoIncrementInfo) throws ParseException, StandardException {,         ValueNode               defaultNode = null;,     switch (jj_nt.kind) {,     case CHECK:,     case CONSTRAINT:,     case NOT:,     case PRIMARY:,     case REFERENCES:,     case UNIQUE:,       columnConstraintDefinition(typeDescriptor, tableElementList, columnName);,       label_6:,       while (true) {,         switch (jj_nt.kind) {,         case CHECK:,         case CONSTRAINT:,         case NOT:,         case PRIMARY:,         case REFERENCES:,         case UNIQUE:,           ;,           break;,         default:,           jj_la1[45] = jj_gen;,           break label_6;,         },         columnConstraintDefinition(typeDescriptor, tableElementList, columnName);,       },       switch (jj_nt.kind) {,       case _DEFAULT:,       case WITH:,       case GENERATED:,         defaultNode = defaultClause(autoIncrementInfo, columnName);,         label_7:,         while (true) {,           switch (jj_nt.kind) {,           case CHECK:,           case CONSTRAINT:,           case NOT:,           case PRIMARY:,           case REFERENCES:,           case UNIQUE:,             ;,             break;,           default:,             jj_la1[46] = jj_gen;,             break label_7;,           },           columnConstraintDefinition(typeDescriptor, tableElementList, columnName);,         },         break;,       default:,         jj_la1[47] = jj_gen;,         ;,       },                 {if (true) return defaultNode;},       break;,     case _DEFAULT:,     case WITH:,     case GENERATED:,       defaultNode = defaultClause(autoIncrementInfo, columnName);,       label_8:,       while (true) {,         switch (jj_nt.kind) {,         case CHECK:,         case CONSTRAINT:,         case NOT:,         case PRIMARY:,         case REFERENCES:,         case UNIQUE:,           ;,           break;,         default:,           jj_la1[48] = jj_gen;,           break label_8;,         },         columnConstraintDefinition(typeDescriptor, tableElementList, columnName);,       },                 {if (true) return defaultNode;},       break;,     default:,       jj_la1[49] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dataTypeDDL">dataTypeDDL</A>,  */,   final public DataTypeDescriptor dataTypeDDL() throws ParseException, StandardException {,         DataTypeDescriptor      typeDescriptor;,     if (commonDatatypeName(false)) {,       typeDescriptor = dataTypeCommon();,                 {if (true) return typeDescriptor;},     } else if (getToken(1).kind != GENERATED) {,       typeDescriptor = javaType(new TableName[1]);,                 {if (true) return typeDescriptor;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /**,    Returns  a dataTypeDDL() as a catalog type, ie.,    the Java interface TypeDescriptor., */,   final public TypeDescriptor catalogType() throws ParseException, StandardException {,         DataTypeDescriptor      typeDescriptor;,     typeDescriptor = dataTypeDDL();,                 {if (true) return typeDescriptor.getCatalogType();},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dataTypeCast">dataTypeCast</A>,  */,   final public DataTypeDescriptor dataTypeCast(TableName[] udtName) throws ParseException, StandardException {,         DataTypeDescriptor      typeDescriptor;,     if (commonDatatypeName(true)) {,       typeDescriptor = dataTypeCommon();,                 {if (true) return typeDescriptor;},     } else if (jj_2_20(1)) {,       typeDescriptor = javaType(udtName);,                 {if (true) return typeDescriptor;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dataTypeCommon">dataTypeCommon</A>,  */,   final public DataTypeDescriptor dataTypeCommon() throws ParseException, StandardException {,         DataTypeDescriptor      typeDescriptor;,         boolean checkCS = false;,     if (jj_2_21(1)) {,       if (getToken(2).kind != LARGE) {, ,       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },       typeDescriptor = characterStringType();,     } else if (jj_2_22(1)) {,       if (getToken(3).kind != LARGE) {, ,       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },       typeDescriptor = nationalCharacterStringType();,     } else if (jj_2_23(1)) {,       typeDescriptor = numericType();,     } else {,       switch (jj_nt.kind) {,       case DATE:,       case TIME:,       case TIMESTAMP:,         typeDescriptor = datetimeType();,         break;,       case BOOLEAN:,         jj_consume_token(BOOLEAN);,         if ((getCompilerContext().getReliability() & CompilerContext.INTERNAL_SQL_ILLEGAL) != 0),     {,         checkVersion(DataDictionary.DD_VERSION_DERBY_10_7, "BOOLEAN");,     },         typeDescriptor = new DataTypeDescriptor(TypeId.BOOLEAN_ID, true);,         break;,       case LONG:,         typeDescriptor = longType();,         break;,       case BINARY:,       case CHAR:,       case CHARACTER:,       case NATIONAL:,       case BLOB:,       case CLOB:,       case NCLOB:,         typeDescriptor = LOBType();,         break;,       case XML:,         typeDescriptor = XMLType();,         break;,       default:,         jj_la1[50] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },                 {if (true) return typeDescriptor;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="characterStringType">characterStringType</A>,  */,   final public DataTypeDescriptor characterStringType() throws ParseException, StandardException {,         int                                     length = DEFAULT_STRING_COLUMN_LENGTH;,         Token                           varyingToken = null;,         int type;,     switch (jj_nt.kind) {,     case VARCHAR:,       jj_consume_token(VARCHAR);,       length = charLength();,                 type = Types.VARCHAR;,       break;,     case CHAR:,     case CHARACTER:,       charOrCharacter();,       switch (jj_nt.kind) {,       case VARYING:,         // Length is optional for CHARACTER, not for plain CHARACTER VARYING,                         varyingToken = jj_consume_token(VARYING);,         length = charLength();,         break;,       default:,         jj_la1[52] = jj_gen;,         switch (jj_nt.kind) {,         case LEFT_PAREN:,           length = charLength();,           break;,         default:,           jj_la1[51] = jj_gen;,           ;,         },       },                 // If the user says CHARACTER VARYING, it's really VARCHAR,                 type = (varyingToken == null ? Types.CHAR : Types.VARCHAR);,       break;,     default:,       jj_la1[53] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     switch (jj_nt.kind) {,     case FOR:,       type = forBitData(type);,       break;,     default:,       jj_la1[54] = jj_gen;,       ;,     },                 checkTypeLimits(type,length);,                 DataTypeDescriptor charDTD = DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);,                 {if (true) return charDTD;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="charOrCharacter">charOrCharacter</A>,  */,   final public void charOrCharacter() throws ParseException {,     switch (jj_nt.kind) {,     case CHAR:,       jj_consume_token(CHAR);,       break;,     case CHARACTER:,       jj_consume_token(CHARACTER);,       break;,     default:,       jj_la1[55] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },   }, , /*,  * <A NAME="charType">charType</A>,  */,   final public int charLength() throws ParseException, StandardException {,         int length;,     jj_consume_token(LEFT_PAREN);,     length = length();,     jj_consume_token(RIGHT_PAREN);,                 {if (true) return length;},     throw new Error("Missing return statement in function");,   }, , /*, ** <A NAME="forBitData">forBitData</A>, */,   final public int forBitData(int charType) throws ParseException {,     jj_consume_token(FOR);,     jj_consume_token(BIT);,     jj_consume_token(DATA);,                 if (charType == Types.CHAR),                         charType = Types.BINARY;,                 else if (charType == Types.VARCHAR),                         charType = Types.VARBINARY;,                 else if (charType == Types.LONGVARCHAR),                         charType = Types.LONGVARBINARY;, ,                 {if (true) return charType;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="nationalCharacterStringType">nationalCharacterStringType</A>,  */,   final public DataTypeDescriptor nationalCharacterStringType() throws ParseException, StandardException {,         DataTypeDescriptor      dataTypeDescriptor;,         int                                     length = DEFAULT_STRING_COLUMN_LENGTH;,         String                          type = null;,         Token                           varyingToken = null;,     switch (jj_nt.kind) {,     case NATIONAL:,       jj_consume_token(NATIONAL);,       charOrCharacter();,       switch (jj_nt.kind) {,       case VARYING:,         // Length is optional for NATIONAL CHARACTER , not for NATIONAL CHARACTER VARYING,                         varyingToken = jj_consume_token(VARYING);,         length = charLength();,         break;,       default:,         jj_la1[57] = jj_gen;,         switch (jj_nt.kind) {,         case LEFT_PAREN:,           length = charLength();,           break;,         default:,           jj_la1[56] = jj_gen;,           ;,         },       },                 // If the user says NATIONAL CHARACTER VARYING, it's really NATIONALVARCHAR,                 type = (varyingToken == null ? TypeId.NATIONAL_CHAR_NAME :,                                 TypeId.NATIONAL_VARCHAR_NAME);,       break;,     case NCHAR:,       jj_consume_token(NCHAR);,       switch (jj_nt.kind) {,       case VARYING:,         // Length is optional for NCHAR, not for NCHAR VARYING,                         varyingToken = jj_consume_token(VARYING);,         length = charLength();,         break;,       default:,         jj_la1[59] = jj_gen;,         switch (jj_nt.kind) {,         case LEFT_PAREN:,           length = charLength();,           break;,         default:,           jj_la1[58] = jj_gen;,           ;,         },       },                 // If the user says NCHAR VARYING, it's really NATIONALVARCHAR,                 type = (varyingToken == null ? TypeId.NATIONAL_CHAR_NAME :,                                 TypeId.NATIONAL_VARCHAR_NAME);,       break;,     case NVARCHAR:,       jj_consume_token(NVARCHAR);,       length = charLength();,                 type = TypeId.NATIONAL_VARCHAR_NAME;,       break;,     default:,       jj_la1[60] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 // need to re-enable according to SQL standard,                 {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, type);},                 // return DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);, ,     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="LOBType">lobType</A>,  */,   final public DataTypeDescriptor LOBType() throws ParseException, StandardException {,         int     length = 2147483647; // default to 2GB-1 if no length specified,         String  type;,     switch (jj_nt.kind) {,     case BLOB:,       jj_consume_token(BLOB);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         length = lengthAndModifier();,         break;,       default:,         jj_la1[61] = jj_gen;,         ;,       },                         type = TypeId.BLOB_NAME;,       break;,     case CLOB:,       jj_consume_token(CLOB);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         length = lengthAndModifier();,         break;,       default:,         jj_la1[62] = jj_gen;,         ;,       },                         type = TypeId.CLOB_NAME;,       break;,     case NCLOB:,       jj_consume_token(NCLOB);,       length = lengthAndModifier();,                         type = TypeId.NCLOB_NAME;,                         // need to re-enable according to SQL standard,                         {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, type);},       break;,     case BINARY:,       jj_consume_token(BINARY);,       jj_consume_token(LARGE);,       jj_consume_token(OBJECT);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         length = lengthAndModifier();,         break;,       default:,         jj_la1[63] = jj_gen;,         ;,       },                         type = TypeId.BLOB_NAME;,       break;,     case CHAR:,     case CHARACTER:,       charOrCharacter();,       jj_consume_token(LARGE);,       jj_consume_token(OBJECT);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         length = lengthAndModifier();,         break;,       default:,         jj_la1[64] = jj_gen;,         ;,       },                         type = TypeId.CLOB_NAME;,       break;,     case NATIONAL:,       jj_consume_token(NATIONAL);,       jj_consume_token(CHARACTER);,       jj_consume_token(LARGE);,       jj_consume_token(OBJECT);,       length = lengthAndModifier();,                         type = TypeId.NCLOB_NAME;,                         // need to re-enable according to SQL standard,                         {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, type);},       break;,     default:,       jj_la1[65] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);, ,                 {if (true) return dtd;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="numericType">numericType</A>,  */,   final public DataTypeDescriptor numericType() throws ParseException, StandardException {,         DataTypeDescriptor      typeDescriptor;,     switch (jj_nt.kind) {,     case DEC:,     case DECIMAL:,     case INT:,     case INTEGER:,     case NUMERIC:,     case SMALLINT:,     case BIGINT:,       typeDescriptor = exactNumericType();,                 {if (true) return typeDescriptor;},       break;,     default:,       jj_la1[66] = jj_gen;,       if (jj_2_24(1)) {,         typeDescriptor = approximateNumericType();,                 {if (true) return typeDescriptor;},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="exactNumericType">exactNumericType</A>,  */,   final public DataTypeDescriptor exactNumericType() throws ParseException, StandardException {,         int precision = TypeCompiler.DEFAULT_DECIMAL_PRECISION;,         int scale = TypeCompiler.DEFAULT_DECIMAL_SCALE;,         int type = Types.DECIMAL;,         String typeStr = "DECIMAL";,         int maxWidth;,         DataTypeDescriptor dtd =  null;,     switch (jj_nt.kind) {,     case DEC:,     case DECIMAL:,     case NUMERIC:,       switch (jj_nt.kind) {,       case NUMERIC:,         jj_consume_token(NUMERIC);,                 type = Types.NUMERIC;,                 typeStr = "NUMERIC";,         break;,       case DECIMAL:,         jj_consume_token(DECIMAL);,         break;,       case DEC:,         jj_consume_token(DEC);,         break;,       default:,         jj_la1[67] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch (jj_nt.kind) {,       case LEFT_PAREN:,         jj_consume_token(LEFT_PAREN);,         precision = precision();,         switch (jj_nt.kind) {,         case COMMA:,           jj_consume_token(COMMA);,           scale = scale();,           break;,         default:,           jj_la1[68] = jj_gen;,           ;,         },         jj_consume_token(RIGHT_PAREN);,         break;,       default:,         jj_la1[69] = jj_gen;,         ;,       },                 if ((precision <= 0) ||,                         (precision > TypeCompiler.MAX_DECIMAL_PRECISION_SCALE)),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_INVALID_PRECISION,,                                 typeStr, String.valueOf(precision));},                 },                 else if ((scale < 0) ||,                                  (scale > TypeCompiler.MAX_DECIMAL_PRECISION_SCALE)),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_INVALID_DECIMAL_SCALE,,                                 typeStr, String.valueOf(scale));},                 },                 else if (scale > precision),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_INVALID_DECIMAL_PRECISION_SCALE,,                                 String.valueOf(scale),,                                 String.valueOf(precision));},                 },                 /*, 		** If we have a decimal point, need to count it, 		** towards maxwidth.  Max width needs to account, 		** for the possible leading '0' and '-' and the, 		** decimal point.  e.g., DEC(1,1) has a maxwidth, 		** of 4 (to handle "-0.1")., 		*/,                 maxWidth = DataTypeUtilities.computeMaxWidth( precision, scale);,                 {if (true) return getDataTypeServices(type, precision, scale, maxWidth);},       break;,     case INT:,     case INTEGER:,     case SMALLINT:,     case BIGINT:,       dtd = exactIntegerType();,                         {if (true) return dtd;},       break;,     default:,       jj_la1[70] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="exactNumericType">exactNumericType</A>,  */,   final public DataTypeDescriptor exactIntegerType() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case INT:,     case INTEGER:,       switch (jj_nt.kind) {,       case INTEGER:,         jj_consume_token(INTEGER);,         break;,       case INT:,         jj_consume_token(INT);,         break;,       default:,         jj_la1[71] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },                 {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER);},       break;,     case SMALLINT:,       jj_consume_token(SMALLINT);,                 {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.SMALLINT);},       break;,     case BIGINT:,       jj_consume_token(BIGINT);,                 {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT);},       break;,     default:,       jj_la1[72] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="approximateNumericType">approximateNumericType</A>,  */,   final public DataTypeDescriptor approximateNumericType() throws ParseException, StandardException {,         int type = 0, scale = 0, width = 0;,         int prec = -1;,         DataTypeDescriptor dts = null;,     switch (jj_nt.kind) {,     case FLOAT:,       jj_consume_token(FLOAT);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         jj_consume_token(LEFT_PAREN);,         prec = precision();,         jj_consume_token(RIGHT_PAREN);,         break;,       default:,         jj_la1[73] = jj_gen;,         ;,       },                 /*, 			When not specified, default is DOUBLE_PRECISION, 		 */,                 if (prec == -1),                         prec = TypeId.DOUBLE_PRECISION;, ,                 if (prec > 0 && prec <= TypeId.REAL_PRECISION),                 {,                         type = Types.REAL;,                         prec = TypeId.REAL_PRECISION;,                         scale = TypeId.REAL_SCALE;,                         width = TypeId.REAL_MAXWIDTH;,                 },                 else if (prec > TypeId.REAL_PRECISION &&,                                  prec <= TypeId.DOUBLE_PRECISION),                 {,                         type = Types.DOUBLE;,                         prec = TypeId.DOUBLE_PRECISION;,                         scale = TypeId.DOUBLE_SCALE;,                         width = TypeId.DOUBLE_MAXWIDTH;,                 },                 else,                         {if (true) throw StandardException.newException(SQLState.LANG_INVALID_PRECISION, "FLOAT", String.valueOf(prec));}, ,                 /*, 			REMIND: this is a slight hack, in that exacting reading of, 			the InformationSchema requires that the type the user typed, 			in be visible to them in the InformationSchema views. But, 			most implementations use synonyms or mappings at some point,, 			and this is one of those places, for us., 		 */,                 {if (true) return getDataTypeServices(type, prec, scale, width);},       break;,     case REAL:,       jj_consume_token(REAL);,                 {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.REAL);},       break;,     default:,       jj_la1[74] = jj_gen;,       if (jj_2_25(1)) {,         dts = doubleType();,                 {if (true) return dts;},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="doubleType">doubleType</A>,  */,   final public DataTypeDescriptor doubleType() throws ParseException, StandardException {,     if (getToken(2).kind == PRECISION) {,       jj_consume_token(DOUBLE);,       jj_consume_token(PRECISION);,     } else {,       switch (jj_nt.kind) {,       case DOUBLE:,         jj_consume_token(DOUBLE);,         break;,       default:,         jj_la1[75] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },                 {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE);},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="longType">longType</A>,  */,   final public DataTypeDescriptor longType() throws ParseException, StandardException {,         DataTypeDescriptor      dataTypeDescriptor;,     jj_consume_token(LONG);,     dataTypeDescriptor = longSubType();,                 {if (true) return dataTypeDescriptor;},     throw new Error("Missing return statement in function");,   }, ,   final public DataTypeDescriptor longSubType() throws ParseException, StandardException {,         int lvcType = Types.LONGVARCHAR;,     switch (jj_nt.kind) {,     case VARCHAR:,       jj_consume_token(VARCHAR);,       switch (jj_nt.kind) {,       case FOR:,         lvcType = forBitData(lvcType);,         break;,       default:,         jj_la1[76] = jj_gen;,         ;,       },                 {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(lvcType);},       break;,     case NVARCHAR:,       jj_consume_token(NVARCHAR);,                 // need to re-enable according to SQL standard,                 {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, TypeId.NATIONAL_LONGVARCHAR_NAME);},                 // return DataTypeDescriptor.getBuiltInDataTypeDescriptor(TypeId.NATIONAL_LONGVARCHAR_NAME);, ,       break;,     default:,       jj_la1[77] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="XMLType">XMLType</A>,  */,   final public DataTypeDescriptor XMLType() throws ParseException, StandardException {,         DataTypeDescriptor value;,     jj_consume_token(XML);,                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "XML");,         {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.SQLXML);},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="xmlDocOrContent">xmlDocOrContent</A>,  *,  * Parse the XML keywords DOCUMENT and CONTENT.  We don't,  * support CONTENT yet, so we throw an appropriate error,  * if we see it.,  *,  */,   final public void xmlDocOrContent() throws ParseException, StandardException {,     if ((getToken(1).kind != DOCUMENT) &&,                     (getToken(1).kind != CONTENT)) {,                 {if (true) throw StandardException.newException(,                         SQLState.LANG_XML_KEYWORD_MISSING, "DOCUMENT",,                         ReuseFactory.getInteger(getToken(1).beginLine),,                         ReuseFactory.getInteger(getToken(1).beginColumn));},     } else if (getToken(1).kind == CONTENT) {,       jj_consume_token(CONTENT);,                 {if (true) throw StandardException.newException(,                         SQLState.LANG_UNSUPPORTED_XML_FEATURE, "CONTENT");},     } else if (getToken(1).kind == DOCUMENT) {,       jj_consume_token(DOCUMENT);,                 {if (true) return;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },   }, , /*,  * <A NAME="javaType">javaType</A>,  */,   final public DataTypeDescriptor javaType(TableName[] udtName) throws ParseException, StandardException {,         TableName       typeName;,     typeName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         udtName[0] = typeName;,                 {if (true) return getJavaClassDataTypeDescriptor(typeName);},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME = "javaDSL">javaDSL</A>,  *,  * A Java dot-separated list.,  */,   final public String javaDSL() throws ParseException {,         String dotSeparatedList;,     dotSeparatedList = caseSensitiveIdentifierPlusReservedWords();,     label_9:,     while (true) {,       switch (jj_nt.kind) {,       case PERIOD:,         ;,         break;,       default:,         jj_la1[78] = jj_gen;,         break label_9;,       },       dotSeparatedList = javaDSLNameExtender(dotSeparatedList);,     },                 {if (true) return dotSeparatedList;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="javaClassName">javaClassName</A>,  */,   final public String javaClassName() throws ParseException {,         String javaClassName;,     javaClassName = javaDSL();,                 {if (true) return javaClassName;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="javaDSLNameExtender">javaDSLNameExtender</A>,  */,   final public String javaDSLNameExtender(String dotSeparatedList) throws ParseException {,         String  extender;,     jj_consume_token(PERIOD);,     extender = caseSensitiveIdentifierPlusReservedWords();,                 {if (true) return dotSeparatedList + "." + extender;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="length">lengthAndModifier</A>,  */,   final public int lengthAndModifier() throws ParseException, StandardException {,         Token   tok;,         Token   tokmod = null;,     jj_consume_token(LEFT_PAREN);,     switch (jj_nt.kind) {,     case LENGTH_MODIFIER:,       tok = jj_consume_token(LENGTH_MODIFIER);,       break;,     case EXACT_NUMERIC:,       tok = jj_consume_token(EXACT_NUMERIC);,       switch (jj_nt.kind) {,       case IDENTIFIER:,         tokmod = jj_consume_token(IDENTIFIER);,         break;,       default:,         jj_la1[79] = jj_gen;,         ;,       },       break;,     default:,       jj_la1[80] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     jj_consume_token(RIGHT_PAREN);,                 String s = tok.image + (tokmod==null ? "" : tokmod.image); // colapse cases;,                 try,                 {,                         char modifier = s.charAt(s.length()-1);,                         String number = s.substring(0, s.length()-1); // in case of ending w. letter,                         long mul;,                         switch (modifier) {,                         case 'G':,                         case 'g':,                                 mul =1073741824L;       //1 Giga,                                 break;,                         case 'M':,                         case 'm':,                                 mul=1048576L;           // 1 Mega,                                 break;,                         case 'K':,                         case 'k':,                                 mul=1024L;              // 1 Kilo,                                 break;,                         default:,                                 mul=1;,                                 number = s; // no letter in end, need whole string,                                 break;,                         },                         long    specifiedLength = Long.parseLong(number) * mul;, ,                         // match DB2 limits of 1 to 2147483647,                         if ((specifiedLength > 0L) &&,                 (specifiedLength <= Limits.DB2_LOB_MAXWIDTH)),             {,                                 {if (true) return (int)specifiedLength;},             }, ,                         // DB2 allows 2G or 2048M or 2097152k that calculate out to ,             // 2147483648, but sets the length to be one less.,                         if (mul != 1 && specifiedLength == 2147483648L),                                 {if (true) return Limits.DB2_LOB_MAXWIDTH;}, ,                 },                 catch (NumberFormatException nfe),                 {,                 }, ,                 {if (true) throw StandardException.newException(,             SQLState.LANG_INVALID_COLUMN_LENGTH, s);},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="length">length</A>,  */,   final public int length() throws ParseException, StandardException {,         Token   tok;,         int     retval;,     tok = jj_consume_token(EXACT_NUMERIC);,                 try,                 {,                         retval = Integer.parseInt(tok.image);, ,                         if (retval > 0),                                 {if (true) return retval;},                 },                 catch (NumberFormatException nfe),                 {,                 },                 {if (true) throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH, tok.image);},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="exactNumber">exactNumber</A>, */,   final public long exactNumber() throws ParseException, StandardException {,         Token longToken;,         String sign = "";,     switch (jj_nt.kind) {,     case PLUS_SIGN:,     case MINUS_SIGN:,       sign = sign();,       break;,     default:,       jj_la1[81] = jj_gen;,       ;,     },     longToken = jj_consume_token(EXACT_NUMERIC);,                 try,                 {,                         /*, 			 * Note that it's important to re-concatenate, 			 * the - sign (if present) into the number, 			 * before converting it to a long value so, 			 * that we can successfully handle any value, 			 * in the range Long.MIN_VALUE ... Long.MAX_VALUE., 			 * Unfortunately, we can't simply do:, 			 *     return Long.parseLong(sign+longToken.image);, 			 * because Long.parseLong() doesn't accept a, 			 * leading + sign., 			 */, ,                         if (sign.equals("-")),                         {,                                 {if (true) return Long.parseLong("-"+longToken.image);},                         },                         else,                         {,                                 {if (true) return Long.parseLong(longToken.image);},                         },                 },                 catch (NumberFormatException nfe),                 {,                         {if (true) throw,                         StandardException.newException(,                                    SQLState.LANG_INVALID_INTEGER_LITERAL, longToken.image);},                 },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="precision">precision</A>,  */,   final public int precision() throws ParseException, StandardException {,         int uintValue;,     uintValue = uint_value();,                 {if (true) return uintValue;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="uint_value">uint_value</A>,  */,   final public int uint_value() throws ParseException, StandardException {,         Token uintToken;,     /*,     		because the parser won't match to UINT, we use EXACT_NUMERIC.,     	 */,             uintToken = jj_consume_token(EXACT_NUMERIC);,                 try {,                         {if (true) return Integer.parseInt(uintToken.image);},                 } catch (NumberFormatException nfe) {,                         {if (true) throw StandardException.newException(SQLState.LANG_INVALID_INTEGER_LITERAL, uintToken.image);},                 },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="scale">scale</A>,  */,   final public int scale() throws ParseException, StandardException {,         int uintValue;,     uintValue = uint_value();,                 {if (true) return uintValue;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="datetimeType">datetimeType</A>,  */,   final public DataTypeDescriptor datetimeType() throws ParseException, StandardException {,         Token tzTok = null;,         int prec = -1;,     switch (jj_nt.kind) {,     case DATE:,       jj_consume_token(DATE);,                 {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DATE);},       break;,     case TIME:,       jj_consume_token(TIME);,                 /*, 			We do not try to set up a precision for time/timestamp, 			values because this field gets mapped to the precision, 			field in the JDBC driver that is for the number of, 			decimal digits in the value.  Precision for time is, 			actually the scale of the seconds value., , 			If/when precision for times is supported, we may need, 			to migrate the system catalog information to fill in, 			the default values appropriately (the default for, 			time is 0, fortunately; but for timestamp it is, 			actually 9 due to java.sql.Timestamp's precision)., 		 */,                 {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIME);},       break;,     case TIMESTAMP:,       jj_consume_token(TIMESTAMP);,                 {if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIMESTAMP);},       break;,     default:,       jj_la1[82] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="qualifiedName">qualifiedName</A>,  */,   final public TableName qualifiedName(int id_length_limit) throws ParseException, StandardException {,         //String	catalogName = null;,         String  schemaName = null;,         String  qualifiedId;,         String  firstName = null;,         String  secondName = null;,     Token firstNameToken = null;,     firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);,     if (getToken(1).kind == PERIOD &&,                                                                     getToken(2).kind != ASTERISK) {,       jj_consume_token(PERIOD);,       secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);,     } else {,       ;,     },                 if (secondName == null),                 {,                         qualifiedId = firstName;,             firstNameToken = lastIdentifierToken;,                 },                 else,                 {,                         schemaName = firstName;,                         qualifiedId = secondName;,             firstNameToken = nextToLastIdentifierToken;,                 }, ,                 //limit the qualifiedId to the id length limit passed to this method,                 IdUtil.checkIdentifierLengthLimit(qualifiedId, id_length_limit);,                 if (schemaName != null),                         IdUtil.checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);, ,         {if (true) return new TableName(,             schemaName,,             qualifiedId,,             firstNameToken.beginOffset,,             lastIdentifierToken.endOffset,,             getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="queryExpression">queryExpression</A>,  *,  * We have to be carefull to get the associativity correct. According to the SQL spec,  *   <non-join query expression> ::=,  *     <non-join query term>,  *    | <query expression body> UNION [ ALL ] <query term>,  *    | <query expression body> EXCEPT [ ALL ] <query term>,  * Meaning that,  *   t1 UNION ALL t2 UNION t3,  * is equivalent to,  *   (t1 UNION ALL t2) UNION t3,  * However recursive descent parsers want recursion to be on the right, so this kind of associativity is unnatural,  * for our parser. The queryExpression method must know whether it is being called as the right hand side of a,  * set operator to produce a query tree with the correct associativity.,  */,   final public ResultSetNode queryExpression(ResultSetNode leftSide, int operatorType) throws ParseException, StandardException {,         ResultSetNode   term;,     term = nonJoinQueryTerm(leftSide, operatorType);,     switch (jj_nt.kind) {,     case EXCEPT:,     case UNION:,       term = unionOrExcept(term);,       break;,     default:,       jj_la1[83] = jj_gen;,       ;,     },                 {if (true) return term;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="unionOrExcept">unionOrExcept</A>,  */,   final public ResultSetNode unionOrExcept(ResultSetNode term) throws ParseException, StandardException {,         ResultSetNode   expression;,         Token                   tok = null;,     switch (jj_nt.kind) {,     case UNION:,       jj_consume_token(UNION);,       switch (jj_nt.kind) {,       case ALL:,       case DISTINCT:,         switch (jj_nt.kind) {,         case ALL:,           tok = jj_consume_token(ALL);,           break;,         case DISTINCT:,           jj_consume_token(DISTINCT);,           break;,         default:,           jj_la1[84] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         break;,       default:,         jj_la1[85] = jj_gen;,         ;,       },       expression = queryExpression(term,,                                                                       (tok != null) ? UNION_ALL_OP : UNION_OP);,         if ( (tok != null) && (tok.kind == DISTINCT) ) { forbidNextValueFor(); }, ,                 {if (true) return expression;},       break;,     case EXCEPT:,       jj_consume_token(EXCEPT);,       switch (jj_nt.kind) {,       case ALL:,       case DISTINCT:,         switch (jj_nt.kind) {,         case ALL:,           tok = jj_consume_token(ALL);,           break;,         case DISTINCT:,           jj_consume_token(DISTINCT);,           break;,         default:,           jj_la1[86] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         break;,       default:,         jj_la1[87] = jj_gen;,         ;,       },       expression = queryExpression(term,,                                                                       (tok != null) ? EXCEPT_ALL_OP : EXCEPT_OP);,         if ( (tok != null) && (tok.kind == DISTINCT) ) { forbidNextValueFor(); }, ,                 {if (true) return expression;},       break;,     default:,       jj_la1[88] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="nonJoinQueryTerm">nonJoinQueryTerm</A>,  *,  * Be careful with the associativity of INTERSECT. According to the SQL spec,  *   t1 INTERSECT t2 INTERSECT ALL t3,  * is equivalent to,  *   (t1 INTERSECT t2) INTERSECT ALL t3,  * which is not the same as,  *   t1 INTERSECT (t2 INTERSECT ALL t3),  * See the comment on queryExpression.,  */,   final public ResultSetNode nonJoinQueryTerm(ResultSetNode leftSide, int operatorType) throws ParseException, StandardException {,         ResultSetNode   term;,     term = nonJoinQueryPrimary();,     switch (jj_nt.kind) {,     case INTERSECT:,       term = intersect(term);,       break;,     default:,       jj_la1[89] = jj_gen;,       ;,     },         switch( operatorType),         {,         case NO_SET_OP:,             {if (true) return term;}, ,         case UNION_OP:,             {if (true) return new UnionNode(,                 leftSide, term, false, false, null, getContextManager());}, ,         case UNION_ALL_OP:,             {if (true) return new UnionNode(,                 leftSide, term, true, false, null, getContextManager());}, ,         case EXCEPT_OP:,             {if (true) return new IntersectOrExceptNode(,                 IntersectOrExceptNode.EXCEPT_OP,,                 leftSide,,                 term,,                 false,,                 null,,                 getContextManager());}, ,         case EXCEPT_ALL_OP:,             {if (true) return new IntersectOrExceptNode(,                 IntersectOrExceptNode.EXCEPT_OP,,                 leftSide,,                 term,,                 true,,                 null,,                 getContextManager());}, ,         case INTERSECT_OP:,             {if (true) return new IntersectOrExceptNode(,                 IntersectOrExceptNode.INTERSECT_OP,,                 leftSide,,                 term,,                 false,,                 null,,                 getContextManager());}, ,         case INTERSECT_ALL_OP:,             {if (true) return new IntersectOrExceptNode(,                 IntersectOrExceptNode.INTERSECT_OP,,                 leftSide,,                 term,,                 true,,                 null,,                 getContextManager());}, , ,         default:,             if (SanityManager.DEBUG),             {,                 SanityManager.THROWASSERT( "Invalid set operator type: " + operatorType);,             },             {if (true) return null;},         },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="intersect">intersect</A>,  */,   final public ResultSetNode intersect(ResultSetNode term) throws ParseException, StandardException {,         ResultSetNode   expression;,         Token                   tok = null;,     jj_consume_token(INTERSECT);,     switch (jj_nt.kind) {,     case ALL:,     case DISTINCT:,       switch (jj_nt.kind) {,       case ALL:,         tok = jj_consume_token(ALL);,         break;,       case DISTINCT:,         jj_consume_token(DISTINCT);,         break;,       default:,         jj_la1[90] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[91] = jj_gen;,       ;,     },     expression = nonJoinQueryTerm(term, (tok != null) ? INTERSECT_ALL_OP : INTERSECT_OP);,         if ( (tok != null) && (tok.kind == DISTINCT) ) { forbidNextValueFor(); }, ,                 {if (true) return expression;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="nonJoinQueryPrimary">nonJoinQueryPrimary</A>,  */,   final public ResultSetNode nonJoinQueryPrimary() throws ParseException, StandardException {,         ResultSetNode   primary;,     boolean     hasJDBClimitClause = false;,     OrderByList orderCols = null;,     ValueNode[] offsetClauses = new ValueNode[OFFSET_CLAUSE_COUNT];,     switch (jj_nt.kind) {,     case SELECT:,     case VALUES:,       primary = simpleTable();,                 {if (true) return primary;},       break;,     case LEFT_PAREN:,       jj_consume_token(LEFT_PAREN);,       primary = queryExpression(null, NO_SET_OP);,       switch (jj_nt.kind) {,       case ORDER:,         orderCols = orderByClause(primary);,         break;,       default:,         jj_la1[92] = jj_gen;,         ;,       },       hasJDBClimitClause = offsetFetchFirstClause(offsetClauses);,       jj_consume_token(RIGHT_PAREN);,         if (hasQueryExpressionSuffix(orderCols, offsetClauses)) {,             if (primary instanceof SelectNode ||,                 primary instanceof UnionNode || // table value constructor,                 primary instanceof RowResultSetNode) {, ,                 primary.pushQueryExpressionSuffix();,                 primary.pushOrderByList(orderCols);,                 primary.pushOffsetFetchFirst(,                     offsetClauses[OFFSET_CLAUSE],,                     offsetClauses[FETCH_FIRST_CLAUSE],,                     hasJDBClimitClause);,             } else {,                 // shouldn't happen,                 String tokenName;, ,                 if (orderCols != null) {,                     tokenName = "ORDER BY";,                 } else if (hasJDBClimitClause)  {,                     tokenName = "LIMIT";,                 } else if (offsetClauses[OFFSET_CLAUSE] != null) {,                     tokenName = "OFFSET";,                 } else {,                     tokenName = "FETCH";,                 }, ,                 {if (true) throw StandardException.newException(,                     SQLState.LANG_SYNTAX_ERROR, tokenName);},             },         }, ,         {if (true) return primary;},       break;,     default:,       jj_la1[93] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="simpleTable">simpleTable</A>,  */,   final public ResultSetNode simpleTable() throws ParseException, StandardException {,         ResultSetNode   resultSetNode;,     switch (jj_nt.kind) {,     case SELECT:,       resultSetNode = querySpecification();,                 {if (true) return resultSetNode;},       break;,     case VALUES:,       resultSetNode = tableValueConstructor();,                 {if (true) return resultSetNode;},       break;,     default:,       jj_la1[94] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="querySpecification">querySpecification</A>,  */,   final public ResultSetNode querySpecification() throws ParseException, StandardException {,         ResultColumnList        selectList;,         SelectNode                      selectNode;,         boolean isDistinct = false;,     jj_consume_token(SELECT);,     if (jj_2_26(1)) {,       isDistinct = setQuantifier();,     } else {,       ;,     },     selectList = selectList();,     selectNode = tableExpression(selectList);,                 if (isDistinct) selectNode.makeDistinct();,                 {if (true) return selectNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="setQuantifier">setQuantifier</A>,  */,   final public boolean setQuantifier() throws ParseException {,     if (getToken(1).kind == DISTINCT &&,                             !(,                                     getToken(2).kind == PERIOD ||,                                     getToken(2).kind == DOUBLE_COLON,                             )) {,       jj_consume_token(DISTINCT);,         forbidNextValueFor();, ,                 {if (true) return true;},     } else if (getToken(1).kind == ALL &&,                             !(,                                     getToken(2).kind == PERIOD ||,                                     getToken(2).kind == DOUBLE_COLON,                             )) {,       jj_consume_token(ALL);,                 {if (true) return false;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="selectList">selectList</A>,  */,   final public ResultColumnList selectList() throws ParseException, StandardException {,         ResultColumn    allResultColumn;,     ResultColumnList resultColumns = new ResultColumnList(getContextManager());,     switch (jj_nt.kind) {,     case ASTERISK:,       jj_consume_token(ASTERISK);,        allResultColumn = new AllResultColumn(null, getContextManager());, ,                 /* Add the new AllResultColumn to the end of the list */,                 resultColumns.addResultColumn(allResultColumn);,                 {if (true) return resultColumns;},       break;,     default:,       jj_la1[95] = jj_gen;,       if (jj_2_27(1)) {,         selectColumnList(resultColumns);,                 {if (true) return resultColumns;},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, ,   final public void selectColumnList(ResultColumnList resultColumns) throws ParseException, StandardException {,     selectSublist(resultColumns);,     label_10:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[96] = jj_gen;,         break label_10;,       },       jj_consume_token(COMMA);,       selectSublist(resultColumns);,     },   }, , /*,  * <A NAME="selectSublist">selectSublist</A>,  */,   final public void selectSublist(ResultColumnList resultColumns) throws ParseException, StandardException {,         ResultColumn    resultColumn;,         ResultColumn    allResultColumn;,         TableName       tableName;,     if (getToken(2).kind == PERIOD &&,                             (,                                     getToken(3).kind == ASTERISK ||,                                     (getToken(4).kind == PERIOD && getToken(5).kind == ASTERISK),                             )) {,       tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,       jj_consume_token(PERIOD);,       jj_consume_token(ASTERISK);,        allResultColumn = new AllResultColumn(tableName, getContextManager());,                 /* Add the new AllResultColumn to the end of the list */,                 resultColumns.addResultColumn(allResultColumn);,     } else if (jj_2_28(1)) {,       resultColumn = derivedColumn(resultColumns);,                 /* Add the new ResultColumn to the end of the list */,                 resultColumns.addResultColumn(resultColumn);,     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },   }, , /*,  * <A NAME="derivedColumn">derivedColumn</A>,  */,   final public ResultColumn derivedColumn(ResultColumnList resultColumns) throws ParseException, StandardException {,         ValueNode       columnExpression;,         String          columnName = null;,     columnExpression = valueExpression();,     if (jj_2_29(1)) {,       columnName = asClause();,     } else {,       ;,     },                 /*, 		** If there is no AS clause, and the expression is a simple, 		** column, use the name of the column as the result column, 		** name., 		*/,                 if ((columnName == null) && (columnExpression instanceof ColumnReference)),                 {,                         columnName = ((ColumnReference) columnExpression).getColumnName();,                 }, ,        {if (true) return new ResultColumn(,                                                 columnName,,                                                 columnExpression,,                                                 getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="asClause">asClause</A>,  */,   final public String asClause() throws ParseException, StandardException {,         String  columnName;,     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       break;,     default:,       jj_la1[97] = jj_gen;,       ;,     },     columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 {if (true) return columnName;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="valueExpression">valueExpression</A>,  */,   final public ValueNode valueExpression() throws ParseException, StandardException {,         ValueNode       leftOperand;,     leftOperand = orExpression(null);,     label_11:,     while (true) {,       switch (jj_nt.kind) {,       case OR:,         ;,         break;,       default:,         jj_la1[98] = jj_gen;,         break label_11;,       },       jj_consume_token(OR);,       leftOperand = orExpression(leftOperand);,     },                 {if (true) return leftOperand;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="orExpression">orExpression</A>,  */,   final public ValueNode orExpression(ValueNode farLeftOperand) throws ParseException, StandardException {,         ValueNode       leftOperand;,     leftOperand = andExpression(null);,     label_12:,     while (true) {,       switch (jj_nt.kind) {,       case AND:,         ;,         break;,       default:,         jj_la1[99] = jj_gen;,         break label_12;,       },       jj_consume_token(AND);,       leftOperand = andExpression(leftOperand);,     },                 if (farLeftOperand == null),                 {,                         {if (true) return leftOperand;},                 },                 else,                 {,             {if (true) return new OrNode(farLeftOperand, leftOperand, getContextManager());},                 },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="andExpression">andExpression</A>,  */,   final public ValueNode andExpression(ValueNode farLeftOperand) throws ParseException, StandardException {,         Token           tok = null;,         ValueNode       test;,     if (getToken(1).kind == NOT && !(getToken(2).kind == PERIOD ||,                             getToken(2).kind == DOUBLE_COLON)) {,       tok = jj_consume_token(NOT);,     } else {,       ;,     },     test = isSearchCondition();,                 /* Put the NOT on top of test */,                 if (tok != null),                 {,            test = new NotNode(test, getContextManager());,                 }, ,                 if (farLeftOperand != null),                 {,            test = new AndNode(farLeftOperand, test, getContextManager());,                 },                 {if (true) return test;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="isSearchCondition">isSearchCondition</A>,  */,   final public ValueNode isSearchCondition() throws ParseException, StandardException {,         ValueNode       result;,         ValueNode       booleanPrimary;,         Token           isToken = null;,         Token           notToken = null;,         Token           truthValue = null;,     booleanPrimary = booleanPrimary();,     switch (jj_nt.kind) {,     case IS:,       isToken = jj_consume_token(IS);,       switch (jj_nt.kind) {,       case NOT:,         notToken = jj_consume_token(NOT);,         break;,       default:,         jj_la1[100] = jj_gen;,         ;,       },       jj_consume_token(NULL);,       break;,     default:,       jj_la1[101] = jj_gen;,       ;,     },                 if ( isToken != null ),                 {,             result = new IsNullNode(booleanPrimary,,                                     false,,                                     getContextManager());, ,             /* Put the NOT on top of the tree */,                                 if (notToken != null),                                 {,                 result = new NotNode(result, getContextManager());,             },         },                 else { result = booleanPrimary; }, ,                 {if (true) return result;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="booleanPrimary">booleanPrimary</A>,  */,   final public ValueNode booleanPrimary() throws ParseException, StandardException {,         ValueNode       primary;,         ValueNode       searchCondition;,     primary = predicate();,                 {if (true) return  primary;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="predicate">predicate</A>,  */,   final public ValueNode predicate() throws ParseException, StandardException {,         ValueNode       value;,     if (jj_2_30(1)) {,       value = additiveExpression(null, 0);,     } else {,       switch (jj_nt.kind) {,       case EXISTS:,         value = existsExpression();,         break;,       default:,         jj_la1[102] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     label_13:,     while (true) {,       if (remainingPredicateFollows()) {,         ;,       } else {,         break label_13;,       },       value = remainingPredicate(value);,     },                 {if (true) return value;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="remainingPredicates">remainingPredicates</A>,  */,   final public ValueNode remainingPredicate(ValueNode value) throws ParseException, StandardException {,         Token tok = null;,     switch (jj_nt.kind) {,     case LESS_THAN_OPERATOR:,     case LESS_THAN_OR_EQUALS_OPERATOR:,     case EQUALS_OPERATOR:,     case NOT_EQUALS_OPERATOR:,     case NOT_EQUALS_OPERATOR2:,     case GREATER_THAN_OPERATOR:,     case GREATER_THAN_OR_EQUALS_OPERATOR:,       value = remainingNonNegatablePredicate(value);,                 {if (true) return value;},       break;,     case BETWEEN:,     case IN:,     case LIKE:,     case NOT:,       switch (jj_nt.kind) {,       case NOT:,         tok = jj_consume_token(NOT);,         break;,       default:,         jj_la1[103] = jj_gen;,         ;,       },       value = remainingNegatablePredicate(value);,                 /* Put the NOT on top of the tree */,                 if (tok != null),                 {,            value = new NotNode(value, getContextManager());,                 }, ,                 {if (true) return value;},       break;,     default:,       jj_la1[104] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="remainingNonNegatablePredicate">remainingNonNegatablePredicate</A>,  */,   final public ValueNode remainingNonNegatablePredicate(ValueNode leftOperand) throws ParseException, StandardException {,         int                     operator;,         String          javaClassName;,         Token           tok = null;,         ValueNode       tree = null;,         ValueNode       likePattern;,         ValueNode       betweenLeft;,         ValueNode       betweenRight;,     operator = compOp();,     if ((getToken(1).kind == ALL || getToken(1).kind == ANY ||,                             getToken(1).kind == SOME) && getToken(2).kind == LEFT_PAREN) {,       operator = quantifier(operator);,       jj_consume_token(LEFT_PAREN);,       leftOperand = tableSubquery(operator, leftOperand);,       jj_consume_token(RIGHT_PAREN);,     } else if (jj_2_31(1)) {,       leftOperand = additiveExpression(leftOperand, operator);,     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return leftOperand;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="remainingNegatablePredicate">remainingNegatablePredicate</A>,  */,   final public ValueNode remainingNegatablePredicate(ValueNode leftOperand) throws ParseException, StandardException {,         ValueNode       tree = null;,         ValueNode       likePattern;,         ValueNode       betweenLeft;,         ValueNode       betweenRight;,         ValueNode       escapeValue = null;,     switch (jj_nt.kind) {,     case IN:,       jj_consume_token(IN);,       tree = inPredicateValue(leftOperand);,                 {if (true) return tree;},       break;,     case LIKE:,       jj_consume_token(LIKE);,       likePattern = additiveExpression(null, 0);,       if (jj_2_32(1)) {,         switch (jj_nt.kind) {,         case ESCAPE:,           jj_consume_token(ESCAPE);,           escapeValue = additiveExpression(null, 0);,           break;,         default:,           jj_la1[105] = jj_gen;,           if (getToken(1).kind == LEFT_BRACE && getToken(2).kind != LIMIT) {,             jj_consume_token(LEFT_BRACE);,             jj_consume_token(ESCAPE);,             escapeValue = additiveExpression(null, 0);,             jj_consume_token(RIGHT_BRACE);,           } else {,             jj_consume_token(-1);,             throw new ParseException();,           },         },       } else {,         ;,       },         tree = new LikeEscapeOperatorNode(,                                                                 leftOperand,,                                                                 likePattern,,                                                                 escapeValue,,                                                                 getContextManager());, ,                 {if (true) return tree;},       break;,     case BETWEEN:,       jj_consume_token(BETWEEN);,       betweenLeft = additiveExpression(null, 0);,       jj_consume_token(AND);,       betweenRight = additiveExpression(null, 0);,         ValueNodeList betweenList = new ValueNodeList(getContextManager());,                 betweenList.addElement(betweenLeft);,                 betweenList.addElement(betweenRight);,         tree = new BetweenOperatorNode(,                                                                 leftOperand,,                                                                 betweenList,,                                                                 getContextManager());, ,                 {if (true) return tree;},       break;,     default:,       jj_la1[106] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="compOp">compOp</A>,  */,   final public int compOp() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case EQUALS_OPERATOR:,       jj_consume_token(EQUALS_OPERATOR);,                 {if (true) return BinaryOperatorNode.EQ;},       break;,     case NOT_EQUALS_OPERATOR:,       jj_consume_token(NOT_EQUALS_OPERATOR);,                 {if (true) return BinaryOperatorNode.NE;},       break;,     case NOT_EQUALS_OPERATOR2:,       jj_consume_token(NOT_EQUALS_OPERATOR2);,                 {if (true) return BinaryOperatorNode.NE;},       break;,     case LESS_THAN_OPERATOR:,       jj_consume_token(LESS_THAN_OPERATOR);,                 {if (true) return BinaryOperatorNode.LT;},       break;,     case GREATER_THAN_OPERATOR:,       jj_consume_token(GREATER_THAN_OPERATOR);,                 {if (true) return BinaryOperatorNode.GT;},       break;,     case LESS_THAN_OR_EQUALS_OPERATOR:,       jj_consume_token(LESS_THAN_OR_EQUALS_OPERATOR);,                 {if (true) return BinaryOperatorNode.LE;},       break;,     case GREATER_THAN_OR_EQUALS_OPERATOR:,       jj_consume_token(GREATER_THAN_OR_EQUALS_OPERATOR);,                 {if (true) return BinaryOperatorNode.GE;},       break;,     default:,       jj_la1[107] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="additiveExpression">additiveExpression</A>,  */,   final public ValueNode additiveExpression(ValueNode farLeftOperand, int compOp) throws ParseException, StandardException {,         ValueNode       leftOperand;,         int                     operator;,     int         kind;,     leftOperand = multiplicativeExpression(null, 0);,     label_14:,     while (true) {,       switch (jj_nt.kind) {,       case PLUS_SIGN:,       case MINUS_SIGN:,         ;,         break;,       default:,         jj_la1[108] = jj_gen;,         break label_14;,       },       operator = additiveOperator();,       leftOperand = multiplicativeExpression(leftOperand, operator);,     },                 if (farLeftOperand == null),                         {if (true) return leftOperand;}, ,                 switch (compOp),                 {,                   case BinaryOperatorNode.EQ:,             kind = BinaryRelationalOperatorNode.K_EQUALS;,                         break;, ,                   case BinaryOperatorNode.NE:,             kind = BinaryRelationalOperatorNode.K_NOT_EQUALS;,                         break;, ,                   case BinaryOperatorNode.LT:,             kind = BinaryRelationalOperatorNode.K_LESS_THAN;,                         break;, ,                   case BinaryOperatorNode.GT:,             kind = BinaryRelationalOperatorNode.K_GREATER_THAN;,                         break;, ,                   case BinaryOperatorNode.LE:,             kind = BinaryRelationalOperatorNode.K_LESS_EQUALS;,                         break;, ,                   case BinaryOperatorNode.GE:,             kind = BinaryRelationalOperatorNode.K_GREATER_EQUALS;,                         break;, ,                   default:,                         if (SanityManager.DEBUG),                         SanityManager.THROWASSERT("Unknown comparison operator " + compOp);,             kind = -1;,                         break;,                 }, ,         {if (true) return new BinaryRelationalOperatorNode(,                             kind,,                                                         farLeftOperand,,                                                         leftOperand,,                             false,,                                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="additiveOperator">additiveOperator</A>,  */,   final public int additiveOperator() throws ParseException, StandardException {,         Token tok;,     switch (jj_nt.kind) {,     case PLUS_SIGN:,       tok = jj_consume_token(PLUS_SIGN);,                 {if (true) return BinaryOperatorNode.PLUS;},       break;,     case MINUS_SIGN:,       tok = jj_consume_token(MINUS_SIGN);,                 {if (true) return BinaryOperatorNode.MINUS;},       break;,     default:,       jj_la1[109] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="multiplicativeExpression">multiplicativeExpression</A>,  */,   final public ValueNode multiplicativeExpression(ValueNode farLeftOperand, int additiveOperator) throws ParseException, StandardException {,         ValueNode       leftOperand;,         int                     multOp;,     leftOperand = unaryExpression(null, 0);,     label_15:,     while (true) {,       switch (jj_nt.kind) {,       case ASTERISK:,       case SOLIDUS:,       case CONCATENATION_OPERATOR:,         ;,         break;,       default:,         jj_la1[110] = jj_gen;,         break label_15;,       },       multOp = multiplicativeOperator();,       leftOperand = unaryExpression(leftOperand, multOp);,     },                 if (farLeftOperand == null),                         {if (true) return leftOperand;}, ,                 switch (additiveOperator),                 {,                   case BinaryOperatorNode.PLUS:,             {if (true) return new BinaryArithmeticOperatorNode(,                 BinaryArithmeticOperatorNode.K_PLUS,,                 farLeftOperand,,                 leftOperand,,                 getContextManager());}, ,                   case BinaryOperatorNode.MINUS:,               {if (true) return new BinaryArithmeticOperatorNode(,                   BinaryArithmeticOperatorNode.K_MINUS,,                   farLeftOperand,,                   leftOperand,,                   getContextManager());}, ,                   default:,                         if (SanityManager.DEBUG),                         SanityManager.THROWASSERT(,                                         "Unexpected operator value of " + additiveOperator);,                         {if (true) return null;},                 },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="multiplicativeOperator">multiplicativeOperator</A>,  */,   final public int multiplicativeOperator() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case ASTERISK:,       jj_consume_token(ASTERISK);,                 {if (true) return BinaryOperatorNode.TIMES;},       break;,     case SOLIDUS:,       jj_consume_token(SOLIDUS);,                 {if (true) return BinaryOperatorNode.DIVIDE;},       break;,     case CONCATENATION_OPERATOR:,       jj_consume_token(CONCATENATION_OPERATOR);,                 {if (true) return BinaryOperatorNode.CONCATENATE;},       break;,     default:,       jj_la1[111] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="unaryExpression">unaryExpression</A>,  */,   final public ValueNode unaryExpression(ValueNode farLeftOperand, int multiplicativeOperator) throws ParseException, StandardException {,         ValueNode       value;,         String          sign = null;,         int                     tokKind1;,         int                     tokKind2;,     if (( (tokKind1 = getToken(1).kind) == PLUS_SIGN ||,                                                tokKind1 == MINUS_SIGN ),                                             &&,                                             ( (tokKind2 = getToken(2).kind) != EXACT_NUMERIC &&,                                                tokKind2 != APPROXIMATE_NUMERIC)) {,       sign = sign();,     } else {,       ;,     },     value = primaryExpression();,                 if ("-".equals(sign)),                 {,            value = new UnaryArithmeticOperatorNode(,                value,,                UnaryArithmeticOperatorNode.K_MINUS,,                getContextManager());,                 },                 else if ("+".equals(sign)),                 {,            value = new UnaryArithmeticOperatorNode(,                value,,                UnaryArithmeticOperatorNode.K_PLUS,,                getContextManager());,                 },                 else if (SanityManager.DEBUG),                 {,                         if (sign != null),                         {,                                 SanityManager.THROWASSERT("Unknown unary operator '",                                                                                         + sign,                                                                                         + "'");,                         },                 }, ,                 {if (true) return multOp(farLeftOperand, value, multiplicativeOperator);},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="sign">sign</A>,  */,   final public String sign() throws ParseException {,         Token   s;,     switch (jj_nt.kind) {,     case PLUS_SIGN:,       s = jj_consume_token(PLUS_SIGN);,                 {if (true) return s.image;},       break;,     case MINUS_SIGN:,       s = jj_consume_token(MINUS_SIGN);,                 {if (true) return s.image;},       break;,     default:,       jj_la1[112] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="primaryExpressionXX">primaryExpressionXX</A>,  */,   final public ValueNode primaryExpressionXX() throws ParseException, StandardException {,         ValueNode       value;,     value = primary();,     label_16:,     while (true) {,       if (jj_2_33(1)) {,         ;,       } else {,         break label_16;,       },       value = nonStaticMethodCallOrFieldAccess(value);,     },                 {if (true) return value;},     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode nonStaticMethodCallOrFieldAccess(ValueNode receiver) throws ParseException, StandardException {,         ValueNode value;,     value = nonStaticMethodInvocation(receiver);,                 {if (true) return value;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="nonStaticMethodInvocation">nonStaticMethodInvocation</A>,  */,   final public ValueNode nonStaticMethodInvocation(ValueNode receiver) throws ParseException, StandardException {,         ArrayList<ValueNode>    parameterList = new ArrayList<ValueNode>();,         MethodCallNode                  methodNode;,     if (getToken(3).kind == LEFT_PAREN) {,       switch (jj_nt.kind) {,       case FIELD_REFERENCE:,         jj_consume_token(FIELD_REFERENCE);,         break;,       case PERIOD:,         jj_consume_token(PERIOD);,         break;,       default:,         jj_la1[113] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       methodNode = methodName(receiver);,       methodCallParameterList(parameterList);,                 /*, 		** ? parameters are not allowed for the receiver --, 		** unless the receiver is standing in for a named parameter,, 		** whose type is therefore known., 		*/,                 if (receiver instanceof ParameterNode),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER,,                                                                                                 methodNode.getMethodName());},                 }, ,                 methodNode.addParms(parameterList);, ,                 /*, 		** Assume this is being returned to the SQL domain.  If it turns, 		** out that this is being returned to the Java domain, we will, 		** get rid of this node., 		*/,         {if (true) return new JavaToSQLValueNode(methodNode, getContextManager());},     } else {,       switch (jj_nt.kind) {,       case PERIOD:,         jj_consume_token(PERIOD);,         methodNode = methodName(receiver);,                 /*, 		** ? parameters are not allowed for the receiver --, 		** unless the receiver is standing in for a named parameter,, 		** whose type is therefore known., 		*/,                 if (receiver instanceof ParameterNode),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER,,                                                                                                 methodNode.getMethodName());},                 }, ,                 methodNode.addParms(parameterList);, ,                 /*, 		** Assume this is being returned to the SQL domain.  If it turns, 		** out that this is being returned to the Java domain, we will, 		** get rid of this node., 		*/,         {if (true) return new JavaToSQLValueNode(methodNode, getContextManager());},         break;,       default:,         jj_la1[114] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="methodName">methodName</A>,  */,   final public MethodCallNode methodName(ValueNode receiver) throws ParseException, StandardException {,         String  methodName;,     /*,     	** NOTE: allowing a delimited identifier as a method name is necessary,,     	** because Java is case-sensitive.  But this also allows identifiers that,     	** do not match Java syntax.  This will probably not cause a problem,     	** in later phases, like binding and code generation.,     	*/,             methodName = caseSensitiveIdentifierPlusReservedWords();,         {if (true) return new NonStaticMethodCallNode(,             methodName, receiver, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="staticMethodName">staticMethodName</A>,  */,   final public MethodCallNode staticMethodName(String javaClassName) throws ParseException, StandardException {,         String  methodName;,     /*,     	** NOTE: allowing a delimited identifier as a method name is necessary,,     	** because Java is case-sensitive.  But this also allows identifiers that,     	** do not match Java syntax.  This will probably not cause a problem,     	** in later phases, like binding and code generation.,     	*/,             methodName = caseSensitiveIdentifierPlusReservedWords();,         {if (true) return new StaticMethodCallNode(,             methodName, javaClassName, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="methodParameter">methodParameter</A>,  */,   final public void methodParameter(List<ValueNode> parameterList) throws ParseException, StandardException {,         ValueNode       parameter;,     if (jj_2_34(1)) {,       parameter = valueExpression();,                 parameterList.add(parameter);,     } else {,       switch (jj_nt.kind) {,       case NULL:,         parameter = nullSpecification();,                 parameterList.add(parameter);,         break;,       default:,         jj_la1[115] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },   }, , /*,  * <A NAME="primary">primary</A>,  */,   final public ValueNode primary() throws ParseException, StandardException {,         String          javaClassName;,         ValueNode       value;,     if (javaClassFollows()) {,       value = staticClassReference();,                 {if (true) return value;},     } else if (jj_2_35(1)) {,       value = valueExpressionPrimary();,                 {if (true) return value;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="staticClassReference">staticClassReference</A>,  */,   final public ValueNode staticClassReference() throws ParseException, StandardException {,         String          javaClassName;,         ValueNode value;,     javaClassName = javaClass();,     jj_consume_token(DOUBLE_COLON);,     value = staticClassReferenceType(javaClassName);,                 {if (true) return value;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="staticClassReferenceType">staticClassReferenceType</A>,  */,   final public ValueNode staticClassReferenceType(String javaClassName) throws ParseException, StandardException {,         ValueNode value;,     if ((getToken(2).kind == LEFT_PAREN)) {,       value = staticMethodInvocation(javaClassName);,                 {if (true) return value;},     } else if (jj_2_36(1)) {,       value = staticClassFieldReference(javaClassName);,                 {if (true) return value;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="staticClassFieldReference">staticClassFieldReference</A>,  */,   final public ValueNode staticClassFieldReference(String javaClassName) throws ParseException, StandardException {,         String          fieldName = null;,     fieldName = caseSensitiveIdentifierPlusReservedWords();,         {if (true) return  new JavaToSQLValueNode(,             new StaticClassFieldReferenceNode(,                 javaClassName,,                 fieldName,,                 nextToLastTokenDelimitedIdentifier,,                 getContextManager()),,             getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="nonSecondDatetimeField">nonSecondDatetimeField</A>,  */,   final public int nonSecondDatetimeField() throws ParseException {,     switch (jj_nt.kind) {,     case YEAR:,       jj_consume_token(YEAR);,                 {if (true) return DateTimeDataValue.YEAR_FIELD;},       break;,     case MONTH:,       jj_consume_token(MONTH);,                 {if (true) return DateTimeDataValue.MONTH_FIELD;},       break;,     case DAY:,       jj_consume_token(DAY);,                 {if (true) return DateTimeDataValue.DAY_FIELD;},       break;,     case HOUR:,       jj_consume_token(HOUR);,                 {if (true) return DateTimeDataValue.HOUR_FIELD;},       break;,     case MINUTE:,       jj_consume_token(MINUTE);,                 {if (true) return DateTimeDataValue.MINUTE_FIELD;},       break;,     default:,       jj_la1[116] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode escapedValueFunction() throws ParseException, StandardException {,         ValueNode       value;,     ValueNode   str1;,     ValueNode   str2;,         ValueNode       startPosition;,     ValueNode   length = null;,     if (jj_2_37(1)) {,       value = miscBuiltinsCore(true /* is JDBC escape */);,                 {if (true) return value;},     } else {,       switch (jj_nt.kind) {,       case SUBSTRING:,         jj_consume_token(SUBSTRING);,         jj_consume_token(LEFT_PAREN);,         value = additiveExpression(null, 0);,         jj_consume_token(COMMA);,         startPosition = additiveExpression(null, 0);,         switch (jj_nt.kind) {,         case COMMA:,           jj_consume_token(COMMA);,           length = additiveExpression(null, 0);,           break;,         default:,           jj_la1[117] = jj_gen;,           ;,         },         jj_consume_token(RIGHT_PAREN);,         {if (true) return getSubstringNode(value, startPosition, length);},         break;,       case CURDATE:,         jj_consume_token(CURDATE);,         jj_consume_token(LEFT_PAREN);,         jj_consume_token(RIGHT_PAREN);,         {if (true) return new CurrentDatetimeOperatorNode(,             CurrentDatetimeOperatorNode.CURRENT_DATE,,             getContextManager());},         break;,       case CURTIME:,         jj_consume_token(CURTIME);,         jj_consume_token(LEFT_PAREN);,         jj_consume_token(RIGHT_PAREN);,         {if (true) return new CurrentDatetimeOperatorNode(,             CurrentDatetimeOperatorNode.CURRENT_TIME,,             getContextManager());},         break;,       case CONCAT:,         jj_consume_token(CONCAT);,         jj_consume_token(LEFT_PAREN);,         str1 = additiveExpression(null,0);,         jj_consume_token(COMMA);,         str2 = additiveExpression(null,0);,         jj_consume_token(RIGHT_PAREN);,         {if (true) return new ConcatenationOperatorNode(,                             str1,,                             str2,,                             getContextManager());},         break;,       case CURRENT_USER:,       case SESSION_USER:,       case USER:,         /* Method versions of USER special registers,         	 * are ODBC remnants.  Only supported,         	 * when escaped.,         	 */,                 value = userNode();,         jj_consume_token(LEFT_PAREN);,         jj_consume_token(RIGHT_PAREN);,                 {if (true) return value;},         break;,       case TIMESTAMPADD:,       case TIMESTAMPDIFF:,         value = timestampArithmeticFuncion();,         {if (true) return value;},         break;,       default:,         jj_la1[118] = jj_gen;,         if (getEscapedSYSFUN(getToken(1).image) != null) {,           value = escapedSYSFUNFunction();,         {if (true) return value;},         } else {,           jj_consume_token(-1);,           throw new ParseException();,         },       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="numericValueFunction">numericValueFunction</A>,  */,   final public ValueNode escapedSYSFUNFunction() throws ParseException, StandardException {,     ArrayList<ValueNode> parameterList = new ArrayList<ValueNode>();,         Token tok;,     tok = jj_consume_token(IDENTIFIER);,     methodCallParameterList(parameterList);,             String sysFunName = getEscapedSYSFUN(tok.image);, ,         TableName functionName = new TableName(,                                 SchemaDescriptor.IBM_SYSTEM_FUN_SCHEMA_NAME,,                                                                 sysFunName,,                                                                 getContextManager());, ,         MethodCallNode methodNode = new StaticMethodCallNode(,             functionName, null, getContextManager());, ,                 methodNode.addParms(parameterList);, ,                 /*, 		** Assume this is being returned to the SQL domain.  If it turns, 		** out that this is being returned to the Java domain, we will, 		** get rid of this node., 		*/,         {if (true) return new JavaToSQLValueNode(methodNode, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="timestampArithmeticFuncion">timestampArithmeticFuncion</A>,  */,   final public ValueNode timestampArithmeticFuncion() throws ParseException, StandardException {,     ValueNode intervalType;,     ValueNode tstamp1;,     ValueNode tstamp2;,     ValueNode count;,     switch (jj_nt.kind) {,     case TIMESTAMPADD:,       jj_consume_token(TIMESTAMPADD);,       jj_consume_token(LEFT_PAREN);,       intervalType = jdbcIntervalType();,       jj_consume_token(COMMA);,       count = additiveExpression(null,0);,       jj_consume_token(COMMA);,       tstamp1 = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,         {if (true) return new TernaryOperatorNode(tstamp1,,                                        intervalType,,                                        count,,                                        TernaryOperatorNode.K_TIMESTAMPADD,,                                        -1,,                                        getContextManager());},       break;,     case TIMESTAMPDIFF:,       jj_consume_token(TIMESTAMPDIFF);,       jj_consume_token(LEFT_PAREN);,       intervalType = jdbcIntervalType();,       jj_consume_token(COMMA);,       tstamp1 = additiveExpression(null,0);,       jj_consume_token(COMMA);,       tstamp2 = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,         {if (true) return new TernaryOperatorNode(tstamp2,,                                        intervalType,,                                        tstamp1,,                                        TernaryOperatorNode.K_TIMESTAMPDIFF,,                                        -1,,                                        getContextManager());},       break;,     default:,       jj_la1[119] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="jdbcIntervalType">jdbcIntervalType</A>,  */,   final public ValueNode jdbcIntervalType() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case SQL_TSI_FRAC_SECOND:,       jj_consume_token(SQL_TSI_FRAC_SECOND);,         {if (true) return getJdbcIntervalNode( DateTimeDataValue.FRAC_SECOND_INTERVAL);},       break;,     case SQL_TSI_SECOND:,       jj_consume_token(SQL_TSI_SECOND);,         {if (true) return getJdbcIntervalNode( DateTimeDataValue.SECOND_INTERVAL);},       break;,     case SQL_TSI_MINUTE:,       jj_consume_token(SQL_TSI_MINUTE);,         {if (true) return getJdbcIntervalNode( DateTimeDataValue.MINUTE_INTERVAL);},       break;,     case SQL_TSI_HOUR:,       jj_consume_token(SQL_TSI_HOUR);,         {if (true) return getJdbcIntervalNode( DateTimeDataValue.HOUR_INTERVAL);},       break;,     case SQL_TSI_DAY:,       jj_consume_token(SQL_TSI_DAY);,         {if (true) return getJdbcIntervalNode( DateTimeDataValue.DAY_INTERVAL);},       break;,     case SQL_TSI_WEEK:,       jj_consume_token(SQL_TSI_WEEK);,         {if (true) return getJdbcIntervalNode( DateTimeDataValue.WEEK_INTERVAL);},       break;,     case SQL_TSI_MONTH:,       jj_consume_token(SQL_TSI_MONTH);,         {if (true) return getJdbcIntervalNode( DateTimeDataValue.MONTH_INTERVAL);},       break;,     case SQL_TSI_QUARTER:,       jj_consume_token(SQL_TSI_QUARTER);,         {if (true) return getJdbcIntervalNode( DateTimeDataValue.QUARTER_INTERVAL);},       break;,     case SQL_TSI_YEAR:,       jj_consume_token(SQL_TSI_YEAR);,         {if (true) return getJdbcIntervalNode( DateTimeDataValue.YEAR_INTERVAL);},       break;,     default:,       jj_la1[120] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="numericValueFunction">numericValueFunction</A>,  */,   final public ValueNode numericValueFunction() throws ParseException, StandardException {,         ValueNode       value;,         int                     field;,     switch (jj_nt.kind) {,     case ABS:,       jj_consume_token(ABS);,       value = absFunction();,                 {if (true) return value;},       break;,     case ABSVAL:,       jj_consume_token(ABSVAL);,       value = absFunction();,                 {if (true) return value;},       break;,     case SQRT:,       jj_consume_token(SQRT);,       jj_consume_token(LEFT_PAREN);,       value = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,         {if (true) return new UnaryArithmeticOperatorNode(,                 value,,                 UnaryArithmeticOperatorNode.K_SQRT,,                 getContextManager());},       break;,     case MOD:,       jj_consume_token(MOD);,       value = modFunction();,                 {if (true) return value;},       break;,     case IDENTITY_VAL_LOCAL:,       jj_consume_token(IDENTITY_VAL_LOCAL);,       jj_consume_token(LEFT_PAREN);,       jj_consume_token(RIGHT_PAREN);,         {if (true) return new SpecialFunctionNode(,             SpecialFunctionNode.K_IDENTITY_VAL,,             getContextManager());},       break;,     default:,       jj_la1[121] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="coalesceFunction">coalesceFunction</A>,  */,   final public ValueNode coalesceFunction(String coalesceOrValue) throws ParseException, StandardException {,     ValueNodeList expressionList = new ValueNodeList(getContextManager());,     jj_consume_token(LEFT_PAREN);,     coalesceExpression(expressionList);,     label_17:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[122] = jj_gen;,         break label_17;,       },       jj_consume_token(COMMA);,       coalesceExpression(expressionList);,     },     jj_consume_token(RIGHT_PAREN);,         {if (true) return new CoalesceFunctionNode(,                 coalesceOrValue,,                 expressionList,,                 getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="coalesceExpression">coalesceExpression</A>,  */,   final public void coalesceExpression(ValueNodeList expressionList) throws ParseException, StandardException {,         ValueNode       expression;,     expression = additiveExpression(null,0);,                 expressionList.addElement(expression);,   }, , /*,  * <A NAME="absFunction">absFunction</A>,  */,   final public ValueNode absFunction() throws ParseException, StandardException {,     ValueNode value;,     jj_consume_token(LEFT_PAREN);,     value = additiveExpression(null,0);,     jj_consume_token(RIGHT_PAREN);,         {if (true) return new UnaryArithmeticOperatorNode(,                 value,,                 UnaryArithmeticOperatorNode.K_ABS,,                 getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="modFunction">modFunction</A>,  */,   final public ValueNode modFunction() throws ParseException, StandardException {,     ValueNode int1;,         ValueNode int2;,     jj_consume_token(LEFT_PAREN);,     int1 = additiveExpression(null,0);,     jj_consume_token(COMMA);,     int2 = additiveExpression(null,0);,     jj_consume_token(RIGHT_PAREN);,         {if (true) return new BinaryArithmeticOperatorNode(,                 BinaryArithmeticOperatorNode.K_MOD,,                 int1,,                 int2,,                 getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="datetimeField">datetimeField</A>,  */,   final public int datetimeField() throws ParseException {,         int field;,     switch (jj_nt.kind) {,     case HOUR:,     case MINUTE:,     case YEAR:,     case DAY:,     case MONTH:,       field = nonSecondDatetimeField();,                 {if (true) return field;},       break;,     case SECOND:,       jj_consume_token(SECOND);,                 {if (true) return DateTimeDataValue.SECOND_FIELD;},       break;,     default:,       jj_la1[123] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode characterValueFunction() throws ParseException, StandardException {,         ValueNode       value = null;,         ValueNode       str1;,         ValueNode       str2;,         Token           upperTok = null;,         Token           lowerTok = null;,         ValueNode       startPosition;,     ValueNode   length = null;,     switch (jj_nt.kind) {,     case SUBSTR:,       jj_consume_token(SUBSTR);,       jj_consume_token(LEFT_PAREN);,       value = additiveExpression(null,0);,       jj_consume_token(COMMA);,       startPosition = additiveExpression(null,0);,       switch (jj_nt.kind) {,       case COMMA:,         jj_consume_token(COMMA);,         length = additiveExpression(null,0);,         break;,       default:,         jj_la1[124] = jj_gen;,         ;,       },       jj_consume_token(RIGHT_PAREN);,         {if (true) return getSubstringNode( value, startPosition, length);},       break;,     case LOWER:,     case UPPER:,       switch (jj_nt.kind) {,       case UPPER:,         upperTok = jj_consume_token(UPPER);,         break;,       case LOWER:,         lowerTok = jj_consume_token(LOWER);,         break;,       default:,         jj_la1[125] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       jj_consume_token(LEFT_PAREN);,       value = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,        {if (true) return new SimpleStringOperatorNode(,                                         value,,                                         (upperTok != null) ? "upper" : "lower",,                                         getContextManager());},       break;,     case LCASE:,     case UCASE:,       switch (jj_nt.kind) {,       case UCASE:,         upperTok = jj_consume_token(UCASE);,         break;,       case LCASE:,         lowerTok = jj_consume_token(LCASE);,         break;,       default:,         jj_la1[126] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       jj_consume_token(LEFT_PAREN);,       value = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,        {if (true) return new SimpleStringOperatorNode(,                                         value,,                                         (upperTok != null) ? "upper" : "lower",,                                         getContextManager());},       break;,     case TRIM:,     case LTRIM:,     case RTRIM:,       value = trimFunction();,                 {if (true) return value;},       break;,     case LOCATE:,       jj_consume_token(LOCATE);,       jj_consume_token(LEFT_PAREN);,       str1 = additiveExpression(null,0);,       jj_consume_token(COMMA);,       str2 = additiveExpression(null,0);,       switch (jj_nt.kind) {,       case COMMA:,         jj_consume_token(COMMA);,         value = additiveExpression(null,0);,         break;,       default:,         jj_la1[127] = jj_gen;,         ;,       },       jj_consume_token(RIGHT_PAREN);,                 // if start is missing, start is equal to 1,         {if (true) return new TernaryOperatorNode(,                             str1,,                             str2,,                             (value == null) ?,                                 new NumericConstantNode(,                                     TypeId.getBuiltInTypeId(Types.INTEGER),,                                     ReuseFactory.getInteger(1),,                                     getContextManager() ) :,                                 value,,                             TernaryOperatorNode.K_LOCATE,,                             -1,,                             getContextManager());},       break;,     default:,       jj_la1[128] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode trimFunction() throws ParseException, StandardException {,         ValueNode       source;,         Integer         trimType;,         ValueNode       ansiTrimNode;,     switch (jj_nt.kind) {,     case LTRIM:,     case RTRIM:,       trimType = trimType();,       jj_consume_token(LEFT_PAREN);,       source = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,                 {if (true) return getTrimOperatorNode(trimType, null, source, null);},       break;,     case TRIM:,       jj_consume_token(TRIM);,       ansiTrimNode = ansiTrim();,                 {if (true) return ansiTrimNode;},       break;,     default:,       jj_la1[129] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode ansiTrim() throws ParseException, StandardException {,     Integer trimSpec = ReuseFactory.getInteger(StringDataValue.BOTH);,     ValueNode trimChar = null;,     ValueNode trimSource = null;,     if (ansiTrimSpecFollows()) {,       jj_consume_token(LEFT_PAREN);,       trimSpec = ansiTrimSpec();,       if (jj_2_38(2147483647)) {,         jj_consume_token(FROM);,         trimSource = additiveExpression(null,0);,         jj_consume_token(RIGHT_PAREN);,              {if (true) return getTrimOperatorNode(trimSpec, trimChar, trimSource, null);},       } else if (jj_2_39(1)) {,         // LEADING <char> FROM <source>,                  trimChar = additiveExpression(null,0);,         jj_consume_token(FROM);,         trimSource = additiveExpression(null,0);,         jj_consume_token(RIGHT_PAREN);,              {if (true) return getTrimOperatorNode(trimSpec, trimChar, trimSource, null);},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     } else if (!ansiTrimSpecFollows()) {,       jj_consume_token(LEFT_PAREN);,       trimChar = additiveExpression(null,0);,       switch (jj_nt.kind) {,       case FROM:,         jj_consume_token(FROM);,         trimSource = additiveExpression(null,0);,         jj_consume_token(RIGHT_PAREN);,             {if (true) return getTrimOperatorNode(trimSpec, trimChar, trimSource, null);},         break;,       case RIGHT_PAREN:,         jj_consume_token(RIGHT_PAREN);,             // expr was trim(e)-- we assigned e to trimChar but it is really the trimSource,             {if (true) return getTrimOperatorNode(trimSpec, null, trimChar, null);},         break;,       default:,         jj_la1[130] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public Integer ansiTrimSpec() throws ParseException {,     switch (jj_nt.kind) {,     case TRAILING:,       jj_consume_token(TRAILING);,                 {if (true) return ReuseFactory.getInteger(StringDataValue.TRAILING);},       break;,     case LEADING:,       jj_consume_token(LEADING);,                 {if (true) return ReuseFactory.getInteger(StringDataValue.LEADING);},       break;,     case BOTH:,       jj_consume_token(BOTH);,                 {if (true) return ReuseFactory.getInteger(StringDataValue.BOTH);},       break;,     default:,       jj_la1[131] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public Integer trimType() throws ParseException {,     switch (jj_nt.kind) {,     case RTRIM:,       jj_consume_token(RTRIM);,                 {if (true) return ReuseFactory.getInteger(StringDataValue.TRAILING);},       break;,     case LTRIM:,       jj_consume_token(LTRIM);,                 {if (true) return ReuseFactory.getInteger(StringDataValue.LEADING);},       break;,     default:,       jj_la1[132] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="valueExpressionPrimary">valueExpressionPrimary</A>,  */,   final public ValueNode valueExpressionPrimary() throws ParseException, StandardException {,         ValueNode       value;,         int                     tokKind;,     if (escapedValueFunctionFollows()) {,       jj_consume_token(LEFT_BRACE);,       jj_consume_token(FN);,       value = escapedValueFunction();,       jj_consume_token(RIGHT_BRACE);,                 {if (true) return value;},     } else if (getToken(2).kind == SCHEMA || getToken(2).kind == SQLID) {,       jj_consume_token(CURRENT);,       switch (jj_nt.kind) {,       case SCHEMA:,         jj_consume_token(SCHEMA);,         break;,       case SQLID:,         jj_consume_token(SQLID);,         break;,       default:,         jj_la1[133] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },         {if (true) return new SpecialFunctionNode(,             SpecialFunctionNode.K_CURRENT_SCHEMA, getContextManager());},     } else if (getToken(2).kind == ISOLATION) {,       jj_consume_token(CURRENT);,       jj_consume_token(ISOLATION);,         {if (true) return new SpecialFunctionNode(,             SpecialFunctionNode.K_CURRENT_ISOLATION, getContextManager());},     } else {,       switch (jj_nt.kind) {,       case CASE:,       case CURRENT_USER:,       case FALSE:,       case NULLIF:,       case SESSION_USER:,       case TRUE:,       case USER:,       case CURRENT_ROLE:,       case LEFT_BRACE:,       case PLUS_SIGN:,       case MINUS_SIGN:,       case QUESTION_MARK:,       case EXACT_NUMERIC:,       case STRING:,       case HEX_STRING:,       case APPROXIMATE_NUMERIC:,         /* Omitted "case_expression" */,                 value = valueSpecification();,                 {if (true) return value;},         break;,       default:,         jj_la1[134] = jj_gen;,         if (newInvocationFollows(1)) {,           value = newInvocation();,                 {if (true) return value;},         } else if (windowOrAggregateFunctionFollows()) {,           value = windowOrAggregateFunctionNode();,                 {if (true) return value;},         } else if (miscBuiltinFollows()) {,           value = miscBuiltins();,                 {if (true) return value;},         } else if (jj_2_41(1)) {,           value = columnReference();,                 {if (true) return value;},         } else {,           switch (jj_nt.kind) {,           case LEFT_PAREN:,             jj_consume_token(LEFT_PAREN);,             if (getToken(1).kind == SELECT || getToken(1).kind == VALUES) {,               value = subquery(SubqueryNode.EXPRESSION_SUBQUERY, null);,             } else if (jj_2_40(1)) {,               /*,               		** NOTE: The optional intervalQualfier() here makes sense only for,               		** the MINUS operator.  We will have to add a semantic check that the,               		** valueExpression() here is a MINUS operator if the intervalQualifier,               		** is supplied.,               		*/,                               value = valueExpression();,             } else {,               jj_consume_token(-1);,               throw new ParseException();,             },             jj_consume_token(RIGHT_PAREN);,                 {if (true) return value;},             break;,           case CAST:,             value = castSpecification();,                 {if (true) return value;},             break;,           case NEXT:,             value = nextValueExpression();,                 {if (true) return value;},             break;,           default:,             jj_la1[135] = jj_gen;,             jj_consume_token(-1);,             throw new ParseException();,           },         },       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="miscBuiltins">miscBuiltins</A>,  */,   final public ValueNode miscBuiltins() throws ParseException, StandardException {,         ValueNode value;,     if (( (getToken(1).kind == GET_CURRENT_CONNECTION ||,                     getToken(1).kind == ABS ||,                     getToken(1).kind == ABSVAL ||,                     getToken(1).kind == SQRT ||,                     getToken(1).kind == MOD ||,                     getToken(1).kind == COALESCE ||,                     getToken(1).kind == VALUE ||,                     getToken(1).kind == IDENTITY_VAL_LOCAL ||,                     getToken(1).kind == SUBSTRING ||,                     getToken(1).kind == SUBSTR ||,                     getToken(1).kind == UPPER ||,                     getToken(1).kind == LOWER ||,                     getToken(1).kind == UCASE ||,                     getToken(1).kind == LCASE ||,                     getToken(1).kind == LTRIM ||,                     getToken(1).kind == RTRIM ||,                     getToken(1).kind == TRIM ||,                     getToken(1).kind == DATE ||,                     getToken(1).kind == TIME ||,                     getToken(1).kind == TIMESTAMP ||,                     getToken(1).kind == DOUBLE ||,                     getToken(1).kind == CHAR ||,                     getToken(1).kind == VARCHAR ||,                     getToken(1).kind == INTEGER ||,                     getToken(1).kind == INT ||,                     getToken(1).kind == SMALLINT ||,             getToken(1).kind == BIGINT ||,                     getToken(1).kind == YEAR ||,                     getToken(1).kind == MONTH ||,                     getToken(1).kind == DAY ||,                     getToken(1).kind == HOUR ||,                     getToken(1).kind == MINUTE ||,                     getToken(1).kind == SECOND ||,                     getToken(1).kind == LENGTH ||,                     getToken(1).kind == LOCATE ||,                     getToken(1).kind == XMLPARSE ||,                     getToken(1).kind == XMLSERIALIZE ||,                     getToken(1).kind == XMLEXISTS ||,                     getToken(1).kind == XMLQUERY ) &&,                   getToken(2).kind == LEFT_PAREN,                   )) {,       /* miscBuiltins() are composed of the core,       	 * system, string and numeric functions,,       	 * date functions,       	 * and static method calls.,       	 */,               value = miscBuiltinsCore(false /* not JDBC escape */);,                 {if (true) return value;},     } else if (jj_2_42(1)) {,       value = datetimeValueFunction();,                 {if (true) return value;},     } else if (jj_2_43(1)) {,       /* This is where we build a node for static method aliases */,               value = routineInvocation();,                 {if (true) return value;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode miscBuiltinsCore(boolean isJDBCEscape) throws ParseException, StandardException {,         ValueNode value;,     switch (jj_nt.kind) {,     case GET_CURRENT_CONNECTION:,       jj_consume_token(GET_CURRENT_CONNECTION);,       jj_consume_token(LEFT_PAREN);,       jj_consume_token(RIGHT_PAREN);,         ContextManager cm = getContextManager();,                 checkInternalFeature("GETCURRENTCONNECTION()");,         {if (true) return new JavaToSQLValueNode(new GetCurrentConnectionNode(cm), cm);},       break;,     case ABS:,     case ABSVAL:,     case IDENTITY_VAL_LOCAL:,     case MOD:,     case SQRT:,       value = numericValueFunction();,                 {if (true) return value;},       break;,     case LOWER:,     case TRIM:,     case UPPER:,     case LTRIM:,     case RTRIM:,     case SUBSTR:,     case LCASE:,     case LOCATE:,     case UCASE:,       value = characterValueFunction();,                 {if (true) return value;},       break;,     default:,       jj_la1[136] = jj_gen;,       if (jj_2_44(1)) {,         value = dataTypeScalarFunction();,                 {if (true) return value;},       } else {,         switch (jj_nt.kind) {,         case COALESCE:,           jj_consume_token(COALESCE);,           value = coalesceFunction("COALESCE");,                 {if (true) return value;},           break;,         case VALUE:,           jj_consume_token(VALUE);,           value = coalesceFunction("VALUE");,                 {if (true) return value;},           break;,         case LENGTH:,           jj_consume_token(LENGTH);,           jj_consume_token(LEFT_PAREN);,           value = additiveExpression(null,0);,           jj_consume_token(RIGHT_PAREN);,                 ContextManager  localCM = getContextManager();,                 if( isJDBCEscape),                     {if (true) return new LengthOperatorNode(,                                                                 getTrimOperatorNode(,                                                                         ReuseFactory.getInteger(StringDataValue.TRAILING),,                                                                         null,,                                                                         value,,                                                                         localCM),,                                                                 localCM);},        {if (true) return new DB2LengthOperatorNode(value, localCM);},           break;,         case XMLEXISTS:,         case XMLPARSE:,         case XMLQUERY:,         case XMLSERIALIZE:,           value = xmlFunction();,                 {if (true) return value;},           break;,         default:,           jj_la1[137] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dataTypeScalarFunction">dataTypeScalarFunction</A>,  */,   final public ValueNode dataTypeScalarFunction() throws ParseException, StandardException {,         DataTypeDescriptor dts;,         ValueNode value;           //converted result,         ValueNode operand;,         int charType;,         int length = -1;,     switch (jj_nt.kind) {,     case HOUR:,     case MINUTE:,     case SECOND:,     case YEAR:,     case DATE:,     case DAY:,     case MONTH:,     case TIME:,     case TIMESTAMP:,       //Note: When you add a new data type function, in addition to adding it ,               // here, you need to add it to miscBuiltins(),               value = dateTimeScalarFunction();,                 {if (true) return value;},       break;,     default:,       jj_la1[139] = jj_gen;,       if (jj_2_45(1)) {,         dts = numericFunctionType();,         jj_consume_token(LEFT_PAREN);,         operand = additiveExpression(null,0);,         jj_consume_token(RIGHT_PAREN);,         value = new CastNode(operand, dts, getContextManager());,         ((CastNode) value).setForDataTypeFunction(true);,         ((CastNode) value).setForExternallyGeneratedCASTnode();, ,         {if (true) return value;},       } else {,         switch (jj_nt.kind) {,         case CHAR:,         case VARCHAR:,           charType = charOrVarchar();,           jj_consume_token(LEFT_PAREN);,           operand = additiveExpression(null,0);,           switch (jj_nt.kind) {,           case COMMA:,             jj_consume_token(COMMA);,             length = length();,             break;,           default:,             jj_la1[138] = jj_gen;,             ;,           },           jj_consume_token(RIGHT_PAREN);,                 // Always check db2 limits for this function. It's new,                 checkTypeLimits(charType,length);,         value = new CastNode(operand, charType, length, getContextManager());, ,                 ((CastNode) value).setForDataTypeFunction(true);,                 ((CastNode) value).setForExternallyGeneratedCASTnode();,                 {if (true) return value;},           break;,         default:,           jj_la1[140] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="xmlFunction">xmlFunction</A>,  *,  * This method parses the built-in functions used with,  * the XML datatype.,  *,  */,   final public ValueNode xmlFunction() throws ParseException, StandardException {,         ValueNode value;,         checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "XML");, ,         // We only allow XML operations if the classpath has all,         // of the required external classes (namley, JAXP and Xalan).,         org.apache.derby.iapi.types.XML.checkXMLRequirements();,     switch (jj_nt.kind) {,     case XMLPARSE:,       jj_consume_token(XMLPARSE);,       jj_consume_token(LEFT_PAREN);,       xmlDocOrContent();,       value = xmlParseValue();,       jj_consume_token(RIGHT_PAREN);,                 {if (true) return value;},       break;,     case XMLSERIALIZE:,       jj_consume_token(XMLSERIALIZE);,       jj_consume_token(LEFT_PAREN);,       value = xmlSerializeValue();,       jj_consume_token(RIGHT_PAREN);,                 {if (true) return value;},       break;,     case XMLEXISTS:,       jj_consume_token(XMLEXISTS);,       jj_consume_token(LEFT_PAREN);,       value = xmlQueryValue(true);,       jj_consume_token(RIGHT_PAREN);,                 {if (true) return value;},       break;,     case XMLQUERY:,       jj_consume_token(XMLQUERY);,       jj_consume_token(LEFT_PAREN);,       value = xmlQueryValue(false);,       jj_consume_token(RIGHT_PAREN);,                 {if (true) return value;},       break;,     default:,       jj_la1[141] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="xmlParseValue">xmlParseValue</A>,  *,  * Syntax is as follows:,  *,  *     XMLPARSE( DOCUMENT <string-value-expression> PRESERVE WHITESPACE ),  *,  * The result of this operation will be an XML value, which can either,  * be used transiently or else can be stored persistently in a table that,  * has an XML column.  For example:,  *,  * ij> CREATE TABLE x_table (id INT, xdoc XML);,  * 0 rows inserted/updated/deleted,  * ij> INSERT INTO x_table VALUES (1, XMLPARSE(DOCUMENT '<simp> doc </simp>',  * PRESERVE WHITESPACE));,  * 1 row inserted/updated/deleted,  *,  * We only allow XML documents (as opposed to XML content) to be,  * parsed into XML values.  Note that we require the "PRESERVE WHITESPACE",  * keyword to be explicit; this is because the SQL/XML (2003) spec says that,  * if no whitespace option is given, the default is "STRIP WHITESPACE", which,  * we don't support (yet).,  *,  * By the time we get to this method, the "DOCUMENT" keyword has already,  * been parsed.,  *,  */,   final public ValueNode xmlParseValue() throws ParseException, StandardException {,         ValueNode value;,         boolean wsOption;,     value = additiveExpression(null,0);,     wsOption = xmlPreserveWhitespace();,         {if (true) return new UnaryOperatorNode(,                                         value,,                     UnaryOperatorNode.K_XMLPARSE,,                     null, /* N/A for PARSE */,                     wsOption,,                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="xmlPreserveWhitespace">xmlPreserveWhitespace</A>,  *,  * For now, we only support the PRESERVE WHITESPACE option.,  *,  */,   final public boolean xmlPreserveWhitespace() throws ParseException, StandardException {,     if ((getToken(1).kind != STRIP) &&,                     (getToken(1).kind != PRESERVE)) {,                 {if (true) throw StandardException.newException(,                         SQLState.LANG_XML_KEYWORD_MISSING, "PRESERVE WHITESPACE",,                         ReuseFactory.getInteger(getToken(1).beginLine),,                         ReuseFactory.getInteger(getToken(1).beginColumn));},     } else {,       switch (jj_nt.kind) {,       case STRIP:,         jj_consume_token(STRIP);,         jj_consume_token(WHITESPACE);,           // don't preserve whitespace.,                 {if (true) throw StandardException.newException(,                         SQLState.LANG_UNSUPPORTED_XML_FEATURE, "STRIP WHITESPACE");},         break;,       case PRESERVE:,         jj_consume_token(PRESERVE);,         jj_consume_token(WHITESPACE);,           // must preserve whitespace.,                 {if (true) return true;},         break;,       default:,         jj_la1[142] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="xmlSerializeValue">xmlSerializeValue</A>,  *,  * Syntax is as follows:,  *,  *   XMLSERIALIZE( <xml-value-expression> AS <string-data-type> ),  *,  * The result of this operation will be a string value with the type specified,  * by the user.  For example:,  *,  * ij> SELECT id, XMLSERIALIZE(xdoc AS varchar(30)) FROM x_table;,  * ID         |2,  * ------------------------------------------,  * 1          |<simp> doc </simp>,  *,  */,   final public ValueNode xmlSerializeValue() throws ParseException, StandardException {,         ValueNode value;,         DataTypeDescriptor targetType;,     value = additiveExpression(null,0);,     targetType = xmlSerializeTargetType();,         {if (true) return new UnaryOperatorNode(,                                         value,,                     UnaryOperatorNode.K_XMLSERIALIZE,,                                         targetType,,                     false, /* N/A for SERIALIZE */,                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="xmlSerializeTargetType">xmlSerializeTargetType</A>,  *,  * Parse the target type of an XMLSERIALIZE operation.,  *,  */,   final public DataTypeDescriptor xmlSerializeTargetType() throws ParseException, StandardException {,         DataTypeDescriptor targetType;,     if ((getToken(1).kind != AS)) {,                 {if (true) throw StandardException.newException(,                         SQLState.LANG_XML_KEYWORD_MISSING, "AS",,                         ReuseFactory.getInteger(getToken(1).beginLine),,                         ReuseFactory.getInteger(getToken(1).beginColumn));},     } else {,       switch (jj_nt.kind) {,       case AS:,         jj_consume_token(AS);,         targetType = dataTypeDDL();,                 {if (true) return targetType;},         break;,       default:,         jj_la1[143] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="xmlQueryValue">xmlQueryValue</A>,  *,  * This method is used for parsing the XMLEXISTS and XMLQUERY operators,  * (which operator depends on the received boolean parameter).,  *,  * For XMLEXISTS, the syntax is as follows:,  *,  *   XMLEXISTS( <xpath-expression> PASSING BY REF <xml-value-expression> ),  *,  * The result of this operation will be a boolean true/false/unknown value:,  *   -- Unknown if either <xquery-expression> or <xml-value-expression> is null;,  *   -- True if evaluation of the given query expression against the,  *      given xml-value returns at least one node.,  *   -- False otherwise.,  *,  * For example:,  *,  * ij> SELECT id FROM x_table WHERE XMLEXISTS('/simple' PASSING BY REF xdoc);,  * ID,  * -----------,  * 1,  *,  * ====,  *,  * For XMLQUERY, the syntax is as follows:,  *,  *   XMLQUERY( <xquery-expression>,  *      PASSING BY REF <xml-value-expression>,  *      [ RETURNING SEQUENCE [ BY REF ] ],  *      EMPTY ON EMPTY,  *   ),  *,  * The result of this operation will be an XMLDataValue.,  *,  * For example:,  *,  * ij> SELECT XMLSERIALIZE(,  *       XMLQUERY('/simple' PASSING BY REF xdoc EMPTY ON EMPTY) AS CHAR(100));,  * ID,  * -----------,  * <simp> doc </simp>,  *,  */,   final public ValueNode xmlQueryValue(boolean existsOnly) throws ParseException, StandardException {,         // The query expression (currently must be an expression,         // supported by Xalan--i.e. XPath only).,         ValueNode xqueryExpr = null;, ,         // Context item for the query; not required by SQL/XML spec,,         // but required by Derby for now.,         ValueNode xmlValue = null;, ,         // User-specified default passing mechanism.  Since Derby only,         // supports one type of passing mechanism--BY REF--this value,         // isn't currently used.,         short defaultPassingMech = -1;,     xqueryExpr = additiveExpression(null, 0);,     jj_consume_token(PASSING);,     defaultPassingMech = xmlPassingMechanism();,     xmlValue = xqVarList();,     if (!existsOnly) {,       if (jj_2_47(1)) {,         xqReturningClause();,         if (jj_2_46(1)) {,           xmlPassingMechanism();,         } else {,           ;,         },       } else {,         ;,       },       xqEmptyHandlingClause();, ,     } else if (existsOnly) {, ,     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },         ValueNode vNode = new BinaryOperatorNode(,                         xqueryExpr,,                         xmlValue,,                         (existsOnly,                 ? BinaryOperatorNode.K_XMLEXISTS,                 : BinaryOperatorNode.K_XMLQUERY),,                         getContextManager());, ,                 {if (true) return vNode;},     throw new Error("Missing return statement in function");,   }, , /**,  * <A NAME="xqVarList">xqVarList</A>,  *,  * Parse a list of XML query variables, which can include at most one,  * XML value to be used as the "context item" for the query.  If,  * such a context item was found, return that item; for all other,  * variable declarations we currently throw a "not supported" error,  * because Xalan doesn't allowing binding of variables.,  */,   final public ValueNode xqVarList() throws ParseException, StandardException {,         // Placeholder for the XML context item as we parse the,         // argument list.,         ValueNode [] xmlValue = new ValueNode [] { (ValueNode)null };,     xqVariable(xmlValue);,     label_18:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[144] = jj_gen;,         break label_18;,       },       jj_consume_token(COMMA);,       xqVariable(xmlValue);,     },                 {if (true) return xmlValue[0];},     throw new Error("Missing return statement in function");,   }, , /**,  * <A NAME="xqVariable">xqVariable</A>,  *,  * Parse an XML query variable.  If the argument is an XML value,  * to be used as the "context item" for a query, then store the,  * value in the first slot of the received ValueNode array;,  * otherwise, throw a "not supported" errror (for now).,  */,   final public void xqVariable(ValueNode [] xmlVal) throws ParseException, StandardException {,         ValueNode curVal;,         String varName = null;,         short passingMech = -1;,     curVal = additiveExpression(null,0);,     if (getToken(1).kind == AS) {,       jj_consume_token(AS);,       varName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                         /* From XQuery 1.0: "The <identifier> I contained in XQV, 			 * shall be an XML 1.1 NCName."  From XML 1.1:, 			 *, 			 *   [4] NCName ::= (Letter | '_') (NCNameChar)*, 			 *   [5] NCNameChar ::= Letter | Digit | '.' | '-' | '_' |, 			 *                    CombiningChar | Extender, 			 *, 			 * Since Derby's definition of an "identifier" is a subset, 			 * of NCName, we just use Derby's definition.  This means, 			 * that some valid NCNames won't be recognized by Derby--, 			 * but since the ones we _do_ recognize are all still valid, 			 * NCNames, we're not breaking any rules., 			 */, ,                         /* All of that said, since we use Xalan as the underlying, 			 * query engine and Xalan doesn't support variable binding,, 			 * there's no point in letting the user specify variables, 			 * right now.  So we disallow it.  In the future we'll have, 			 * to add logic here to store the variables and pass them, 			 * to the correct operator for binding/execution., 			 */,                         {if (true) throw StandardException.newException(,                                 SQLState.LANG_UNSUPPORTED_XML_FEATURE, "PASSING ... AS");},     } else {,       ;,     },     if (jj_2_48(1)) {,       passingMech = xmlPassingMechanism();,     } else {,       ;,     },                         if (varName == null),                         {,                                 /* We get here if we just parsed an XML context item., 				 * That said, if we already have one (xmlVal[0] is not, 				 * null) then we can't allow second one, per SQL/XML[2006], 				 * (6.17: Syntax Rules:5.b.i): "XMQ shall contain exactly, 				 * one <XML query context item> XQCI.", 				 */,                                 if (xmlVal[0] != null),                                 {,                                         {if (true) throw StandardException.newException(,                                                 SQLState.LANG_MULTIPLE_XML_CONTEXT_ITEMS);},                                 }, ,                                 xmlVal[0] = curVal;, ,                                 /* Note: It's possible that a passing mechanism was, 				 * specified for the context item; if so its value is, 				 * stored in passingMech.  However, we don't actually, 			 	 * store that passing mechanism anywhere because we, 				 * (currently) only support BY REF, so we know what, 			 	 * it has to be.  If we add support for other passing, 			 	 * mechanisms (namely, BY VALUE) in the future, we'll, 			 	 * have to store the passing mechanism provided by, 			 	 * the user and process it at compilation/execution, 				 * time., 				 */,                         }, ,   }, , /*,  * <A NAME="xmlPassingMechanism">xmlPassingMechanism</A>,  *,  * For now, we only support the BY REF option because,  * that gives us better performance (allows us to avoid,  * performing potentially deep copies of XML nodes).  This,  * means that if the same XML value is passed BY REF into,  * two different XML arguments for a single operator, then,  * every node in the first XML argument must have an,  * identical node in the second XML argument, and the,  * ids for both nodes must be the same.  That said,,  * since we don't support variable binding yet, this,  * becomes a non-issue because we can't pass XML values.,  * In the future, though, we may choose to support the,  * passing/binding of variables (the only reason we,  * don't now is because Xalan doesn't support it) and,  * if we do, BY REF should provide better performance,  * due to lack of deep copying.,  */,   final public short xmlPassingMechanism() throws ParseException, StandardException {,     if (getToken(2).kind == REF) {,       jj_consume_token(BY);,       jj_consume_token(REF);,           // pass the XML value by reference,                 {if (true) return org.apache.derby.iapi.types.XML.XQ_PASS_BY_REF;},     } else {,       switch (jj_nt.kind) {,       case BY:,         jj_consume_token(BY);,         jj_consume_token(VALUE);,           // pass a 'copy' of the XML value.,                 {if (true) throw StandardException.newException(,                         SQLState.LANG_UNSUPPORTED_XML_FEATURE, "BY VALUE");},         break;,       default:,         jj_la1[145] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="xqReturningClause">xqReturningClause</A>,  *,  * For now we only support "RETURNING SEQUENCE".  The reason,  * is that this applies to the XMLQUERY operator and the,  * results of evaluating a query expression in Xalan against,  * an XML value can be an arbritary sequence of items--including,  * atomic values.  For simplicity we just return the values,  * as they are, without doing any further work.  SQL/XML[2006],  * says that if we supported RETURNING CONTENT then we'd have,  * to construct an XQuery document from the results--but we don't,  * do that extra work for now, so we just say that we return,  * SEQUENCE.,  *,  * NOTE: This means that we may not be able to store the results,  * of an XMLQUERY operation into a Derby XML column.  Right now,  * an XML column can only hold valid DOCUMENT nodes, which we,  * we define as an XML value whose serialized form can be parsed,  * by a JAXP DocumentBuilder (because that's what Derby's XMLPARSE,  * operator uses and the result is always a Document node).,  * Internally this means that we can only store a sequence if it,  * contains exactly one org.w3c.dom.Node that is an instance of,  * org.w3c.dom.Document.  If the result of an XMLQUERY operation,  * does not fit this criteria then it will *not* be storable into,  * Derby XML columns.,  */,   final public short xqReturningClause() throws ParseException, StandardException {,     if (getToken(2).kind == SEQUENCE) {,       jj_consume_token(RETURNING);,       jj_consume_token(SEQUENCE);,           // XMLQUERY should return result as a sequence.,           // NOTE: since Derby XML columns only allow DOCUMENT(UNTYPED),,           // the result of an XMLQUERY operator that returns SEQUENCE,           // might not be storable into an XML column.,                 {if (true) return org.apache.derby.iapi.types.XML.XQ_RETURN_SEQUENCE;},     } else {,       switch (jj_nt.kind) {,       case RETURNING:,         jj_consume_token(RETURNING);,         jj_consume_token(CONTENT);,           // XMLQUERY should return 'content'.,                 {if (true) throw StandardException.newException(,                         SQLState.LANG_UNSUPPORTED_XML_FEATURE, "RETURNING CONTENT");},         break;,       default:,         jj_la1[146] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="xqEmptyHandlingClause">xqEmptyHandlingClause</A>,  *,  * Defines what the behavior should be when an XMLQUERY operator,  * results in an empty sequence.  For now we just return the,  * empty sequence.,  */,   final public short xqEmptyHandlingClause() throws ParseException, StandardException {,     if (getToken(1).kind == EMPTY) {,       jj_consume_token(EMPTY);,       jj_consume_token(ON);,       jj_consume_token(EMPTY);,           // XMLQUERY should return an empty sequence when result of,           // the query is an empty sequence (i.e. when there are no,           // results).,                 {if (true) return org.apache.derby.iapi.types.XML.XQ_EMPTY_ON_EMPTY;},     } else {,       switch (jj_nt.kind) {,       case NULL:,         jj_consume_token(NULL);,         jj_consume_token(ON);,         jj_consume_token(EMPTY);,           // XMLQUERY should return a null XML value when result of,           // the query is an empty sequence (i.e. when there are no,           // results).,                 {if (true) throw StandardException.newException(,                         SQLState.LANG_UNSUPPORTED_XML_FEATURE, "NULL ON EMPTY");},         break;,       default:,         jj_la1[147] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="numericFunctionType">numericFunctionType</A>,  */,   final public DataTypeDescriptor numericFunctionType() throws ParseException, StandardException {,         DataTypeDescriptor dts;,     if (jj_2_49(1)) {,       dts = doubleType();,                 {if (true) return dts;},     } else {,       switch (jj_nt.kind) {,       case INT:,       case INTEGER:,       case SMALLINT:,       case BIGINT:,         dts = exactIntegerType();,                 {if (true) return dts;},         break;,       default:,         jj_la1[148] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dateTimeScalarFunction">dateTimeScalarFunction</A>,  */,   final public ValueNode dateTimeScalarFunction() throws ParseException, StandardException {,         ValueNode       value;,         ValueNode       timestampNode;,         int             field;,     switch (jj_nt.kind) {,     case TIME:,       jj_consume_token(TIME);,       jj_consume_token(LEFT_PAREN);,       value = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,         ValueNode castValue = new CastNode(,             value,,             DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIME),,             getContextManager());,                 ((CastNode) castValue).setForExternallyGeneratedCASTnode();,                 {if (true) return castValue;},       break;,     case DATE:,       jj_consume_token(DATE);,       jj_consume_token(LEFT_PAREN);,       value = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,        {if (true) return new UnaryDateTimestampOperatorNode(,             value,,             UnaryDateTimestampOperatorNode.K_DATE,,             getContextManager());},       break;,     case TIMESTAMP:,       jj_consume_token(TIMESTAMP);,       jj_consume_token(LEFT_PAREN);,       value = additiveExpression(null,0);,       timestampNode = timestampFunctionCompletion(value);,                 {if (true) return timestampNode;},       break;,     case HOUR:,     case MINUTE:,     case SECOND:,     case YEAR:,     case DAY:,     case MONTH:,       field = datetimeField();,       jj_consume_token(LEFT_PAREN);,       value = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,        {if (true) return new ExtractOperatorNode(,                                                                 ReuseFactory.getInteger(field),,                                                                 value,,                                                                 getContextManager());},       break;,     default:,       jj_la1[149] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="timestampFunctionCompletion">timestampFunctionCompletion</A>,  */,   final public ValueNode timestampFunctionCompletion(ValueNode firstArg) throws ParseException, StandardException {,         ValueNode timeValue;,     switch (jj_nt.kind) {,     case RIGHT_PAREN:,       jj_consume_token(RIGHT_PAREN);,        {if (true) return new UnaryDateTimestampOperatorNode(,             firstArg,,             UnaryDateTimestampOperatorNode.K_TIMESTAMP,,             getContextManager());},       break;,     case COMMA:,       jj_consume_token(COMMA);,       timeValue = additiveExpression(null,0);,       jj_consume_token(RIGHT_PAREN);,         {if (true) return,             new TimestampOperatorNode(firstArg, timeValue, getContextManager());},       break;,     default:,       jj_la1[150] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="booleanLiteral">booleanLiteral</A>,  */,   final public Token booleanLiteral() throws ParseException {,         Token tok;,     switch (jj_nt.kind) {,     case TRUE:,       tok = jj_consume_token(TRUE);,                 {if (true) return tok;},       break;,     case FALSE:,       tok = jj_consume_token(FALSE);,                 {if (true) return tok;},       break;,     default:,       jj_la1[151] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="generalValueSpecification">generalValueSpecification</A>,  */,   final public ValueNode generalValueSpecification() throws ParseException, StandardException {,                 ValueNode       parm;,     switch (jj_nt.kind) {,     case QUESTION_MARK:,       parm = dynamicParameterSpecification();,                 {if (true) return parm;},       break;,     case CURRENT_USER:,     case SESSION_USER:,     case USER:,       parm = userNode();,                 {if (true) return parm;},       break;,     case CURRENT_ROLE:,       parm = currentRoleNode();,                 {if (true) return parm;},       break;,     default:,       jj_la1[152] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode userNode() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case USER:,       jj_consume_token(USER);,         {if (true) return new SpecialFunctionNode(,             SpecialFunctionNode.K_USER, getContextManager());},       break;,     case CURRENT_USER:,       jj_consume_token(CURRENT_USER);,         {if (true) return new SpecialFunctionNode(,             SpecialFunctionNode.K_CURRENT_USER, getContextManager());},       break;,     case SESSION_USER:,       jj_consume_token(SESSION_USER);,         {if (true) return new SpecialFunctionNode(,             SpecialFunctionNode.K_SESSION_USER, getContextManager());},       break;,     default:,       jj_la1[153] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="currentRoleNode">currentRoleNode</A>,  */,   final public ValueNode currentRoleNode() throws ParseException, StandardException {,     jj_consume_token(CURRENT_ROLE);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_5, "ROLES");,                 checkSqlStandardAccess("CURRENT_ROLE");,         {if (true) return new SpecialFunctionNode(,             SpecialFunctionNode.K_CURRENT_ROLE, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="newInvocation">newInvocation</A>,  */,   final public JavaToSQLValueNode newInvocation() throws ParseException, StandardException {,     NewInvocationNode   newNode;,         ArrayList<ValueNode> parameterList = new ArrayList<ValueNode>();,         String  javaClassName;,     jj_consume_token(NEW);,     javaClassName = javaClassName();,     methodCallParameterList(parameterList);,                 if (!javaClassName.startsWith("org.apache.derby.diag.") && !javaClassName.startsWith("org.apache.derby.catalog.") && !javaClassName.startsWith("com.ibm.db2j.")),                 {,                         checkInternalFeature(javaClassName);,                 },         newNode = new NewInvocationNode(javaClassName,,                                                                            parameterList,,                                                                            lastTokenDelimitedIdentifier,,                                                                            getContextManager());, ,                 /*, 		** Assume this is being returned to the SQL domain.  If it turns, 		** out that this is being returned to the Java domain, we will, 		** get rid of this node., 		*/,         {if (true) return new JavaToSQLValueNode(newNode, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="vtiTableConstruct">vtiTableConstruct</A>,  *,  * Parse a TABLE() constructor that corresponds to an internal,  * VTI invocation.  For example:,  *,  *    TABLE ( <qualifiedName> (arg1, arg2, ...) ),  *,  * where <qualifiedName> is a table name that Derby will map internally,  * to a VTI (ex. "SYSCS_DIAG.SPACE_TABLE").  The list of arguments,  * will then be passed to the VTI when it is invoked (DERBY-2152).,  *,  * An example query where this might occur is as follows:,  *,  *   SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'T1')) x,  *,  * in which case SYSCS_DIAG.SPACE_TABLE will be mapped (internally),  * to the "org.apache.derby.diag.SpaceTable" diagnostic VTI.  Thus,  * the equivalent call prior to DERBY-2152 would have been:,  *,  *   SELECT * FROM NEW org.apache.derby.diag.SpaceTable('APP', 'T1')) x,  *,  * Note that this latter syntax is still supported.,  */,   final public JavaToSQLValueNode vtiTableConstruct() throws ParseException, StandardException {,     NewInvocationNode newNode = null;,     MethodCallNode invocationNode = null;,     ArrayList<ValueNode> parameterList = new ArrayList<ValueNode>();,     TableName vtiTableName = null;,     TableDescriptor td;,     MethodCallNode      methodNode;,     jj_consume_token(TABLE);,     jj_consume_token(LEFT_PAREN);,     vtiTableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     methodCallParameterList(parameterList);,     jj_consume_token(RIGHT_PAREN);,         /* The fact that we pass a NULL table descriptor to the,         * following call is an indication that we are mapping to a,         * VTI table function (i.e. one that accepts arguments).,         * Since we have the table name we do not need to pass in a,         * TableDescriptor--we'll just create one from the table,         * name. See NewInvocationNode for more.,         */,         newNode = new NewInvocationNode(,             vtiTableName,  // TableName,             null,          // TableDescriptor,             parameterList,,             lastTokenDelimitedIdentifier,,             getContextManager());, ,         if ( newNode.isBuiltinVTI() ) { invocationNode = newNode; },         else,         {,             methodNode = new StaticMethodCallNode(,                 vtiTableName, null, getContextManager());,             methodNode.addParms(parameterList);, ,             invocationNode = methodNode;,         }, , ,         /*,         ** Assume this is being returned to the SQL domain.  If it turns,         ** out that this is being returned to the Java domain, we will,         ** get rid of this node.,         */,         {if (true) return new JavaToSQLValueNode(invocationNode, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="staticMethodInvocation">staticMethodInvocation</A>,  */,   final public ValueNode staticMethodInvocation(String javaClassName) throws ParseException, StandardException {,         ArrayList<ValueNode> parameterList = new ArrayList<ValueNode>();,         MethodCallNode  methodNode;,     methodNode = staticMethodName(javaClassName);,     methodCallParameterList(parameterList);,                 methodNode.addParms(parameterList);, ,                 /*, 		** Assume this is being returned to the SQL domain.  If it turns, 		** out that this is being returned to the Java domain, we will, 		** get rid of this node., 		*/,         {if (true) return new JavaToSQLValueNode(methodNode, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /**,  * <A NAME="methodCallParameterList">methodCallParameterList</A>, */,   final public void methodCallParameterList(List<ValueNode> parameterList) throws ParseException, StandardException {,     jj_consume_token(LEFT_PAREN);,     if (jj_2_50(1)) {,       methodParameter(parameterList);,       label_19:,       while (true) {,         switch (jj_nt.kind) {,         case COMMA:,           ;,           break;,         default:,           jj_la1[154] = jj_gen;,           break label_19;,         },         jj_consume_token(COMMA);,         methodParameter(parameterList);,       },     } else {,       ;,     },     jj_consume_token(RIGHT_PAREN);,   }, , /*,  * <A NAME="routineInvocation">routineInvocation</A>,  */,   final public ValueNode routineInvocation() throws ParseException, StandardException {,         ValueNode       valueNode;,     if (!distinctUDAFollows()) {,       valueNode = routineExpression();,         {if (true) return valueNode;},     } else if (distinctUDAFollows()) {,       valueNode = distinctUDA();,         {if (true) return valueNode;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="routineExpression">routineExpression</A>,  */,   final public ValueNode routineExpression() throws ParseException, StandardException {,         ArrayList<ValueNode> parameterList = new ArrayList<ValueNode>();,         TableName       routineName;,         MethodCallNode  methodNode;,     routineName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     methodCallParameterList(parameterList);,         methodNode = new StaticMethodCallNode(,             routineName, null,getContextManager());, ,                 methodNode.addParms(parameterList);, ,                 /*, 		** Assume this is being returned to the SQL domain.  If it turns, 		** out that this is being returned to the Java domain, we will, 		** get rid of this node., 		*/,         {if (true) return new JavaToSQLValueNode(methodNode, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="distinctUDA">distinctUDA</A>,  */,   final public ValueNode distinctUDA() throws ParseException, StandardException {,         ValueNode               value;,         TableName  aggName;,     aggName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(LEFT_PAREN);,     jj_consume_token(DISTINCT);,     value = additiveExpression(null, 0);,     jj_consume_token(RIGHT_PAREN);,         //,         // The parser can't distinguish one-arg function calls from,         // non-distinct aggregates. That has to be figured out at,         // bind() time.,         //,        {if (true) return new AggregateNode(value,,                                  aggName,,                                  true,,                                  "",,                                  getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="javaClass">javaClass</A>,  */,   final public String javaClass() throws ParseException, StandardException {,         String javaClassName;,     javaClassName = javaClassName();,                 {if (true) return javaClassName;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="columnMethodInvocation">columnMethodInvocation</A>,  */,   final public ValueNode columnMethodInvocation() throws ParseException, StandardException {,         ValueNode       columnReference;,         ValueNode       methodNode;,     columnReference = columnNameForInvocation();,     methodNode = nonStaticMethodInvocation(columnReference);,                 {if (true) return methodNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="columnNameForInvocation">columnNameForInvocation</A>,  */,   final public ValueNode columnNameForInvocation() throws ParseException, StandardException {,         String firstName;,         String secondName = null;,         String thirdName = null;,         String          columnName = null;,         String          tableName = null;,         String          schemaName = null;,         TableName       tabName = null;,         ValueNode       retval;,     firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     if (getToken(1).kind == PERIOD &&,                                             getToken(3).kind == PERIOD) {,       jj_consume_token(PERIOD);,       secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,       if (getToken(1).kind == PERIOD &&,                                                       getToken(3).kind == PERIOD) {,         jj_consume_token(PERIOD);,         thirdName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,       } else {,         ;,       },     } else {,       ;,     },                 // Figure out what each identifier stands for,                 if (thirdName == null),                 {,                         if (secondName == null),                         {,                                 // There's only one identifier, so it must be a column name,                                 columnName = firstName;,                         },                         else,                         {,                                 // There are two identifiers, so they are table and column names,                                 tableName = firstName;,                                 columnName = secondName;,                         },                 },                 else,                 {,                         // There are three identifiers,,                         // so they are schema, table, and column names,                         schemaName = firstName;,                         tableName = secondName;,                         columnName = thirdName;,                 }, ,                 if (tableName != null),                 {,                         // There is a table name, so get a TableName node,             tabName = new TableName(,                     schemaName,,                     tableName,,                     (thirdName == null,                          ? nextToLastIdentifierToken,                          : thirdToLastIdentifierToken).beginOffset,,                     nextToLastIdentifierToken.endOffset,,                     getContextManager());,                 }, ,                 // Get the column reference,         retval = new ColumnReference(,             columnName,,             tabName,,             Integer.valueOf(lastIdentifierToken.beginOffset),,             Integer.valueOf(lastIdentifierToken.endOffset),,             getContextManager());, ,                 {if (true) return retval;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="columnReference">columnReference</A>,  */,   final public ColumnReference columnReference() throws ParseException, StandardException {,         String          firstName;,         String          secondName = null;,         String          thirdName = null;,         String          columnName = null;,         String          tableName = null;,         String          schemaName = null;,         TableName       tabName = null;,     firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);,     if (getToken(1).kind == PERIOD &&,                                             getToken(3).kind != LEFT_PAREN) {,       jj_consume_token(PERIOD);,       secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);,       if (getToken(1).kind == PERIOD &&,                                                       getToken(3).kind != LEFT_PAREN) {,         jj_consume_token(PERIOD);,         thirdName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);,       } else {,         ;,       },     } else {,       ;,     },                 // Figure out what each name stands for,                 if (thirdName == null),                 {,                         if (secondName == null),                         {,                                 // Only one name, must be column name,                                 columnName = firstName;,                         },                         else,                         {,                                 // Two names: table.column,                                 tableName = firstName;,                                 columnName = secondName;,                         },                 },                 else,                 {,                         // Three names: schema.table.column,                         schemaName = firstName;,                         tableName = secondName;,                         columnName = thirdName;,                 }, ,                 IdUtil.checkIdentifierLengthLimit(columnName, Limits.MAX_IDENTIFIER_LENGTH);,                 if (schemaName != null),                         IdUtil.checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);,                 if (tableName != null),                         IdUtil.checkIdentifierLengthLimit(tableName, Limits.MAX_IDENTIFIER_LENGTH);, ,                 if (tableName != null),                 {,             tabName = new TableName(,                 schemaName,,                 tableName,,                 (thirdName == null,                      ? nextToLastIdentifierToken,                      : thirdToLastIdentifierToken).beginOffset,,                 nextToLastIdentifierToken.endOffset,,                 getContextManager());,                 }, ,         {if (true) return new ColumnReference(,             columnName,,             tabName,,             Integer.valueOf(lastIdentifierToken.beginOffset),,             Integer.valueOf(lastIdentifierToken.endOffset),,             getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*, void, columnReference() throws StandardException :, {}, {, 	/*, 	**, 	** I re-wrote the above rule because it caused a grammar ambiguitity., 	** The problem is that we are parsing a dot-separated list of identifiers,, 	** and the grammar doesn't know what the identifiers stand for, but the, 	** syntax assumed that it did.  For example, in schema.table.column,, 	** the grammar doesn't know when it parses the first identifier whether, 	** it will be a catalog name, schema name, table name, or column name., 	**, 	** I think this problem could be solved by increasing the lookahead., 	** I will try that solution next.  I like that solution better because,, 	** if it works, it will be easier for the grammar to figure out what, 	** each identifier stands for., 	**, , 	[ <MODULE> <PERIOD> <IDENTIFIER> |, 	  [ [ [ <IDENTIFIER> <PERIOD> ] <IDENTIFIER> <PERIOD> ] <IDENTIFIER> <PERIOD> ], 	], 	<IDENTIFIER>, }, */,   final public OrderByList orderByClause(ResultSetNode rs) throws ParseException, StandardException {,         OrderByList orderCols;,     jj_consume_token(ORDER);,     jj_consume_token(BY);,     orderCols = sortSpecificationList(rs);,         forbidNextValueFor();, ,                 {if (true) return orderCols;},     throw new Error("Missing return statement in function");,   }, ,   final public int atIsolationLevel() throws ParseException, StandardException {,         int isolationLevel;,     jj_consume_token(WITH);,     isolationLevel = isolationLevelDB2Abbrev();,                 {if (true) return isolationLevel;},     throw new Error("Missing return statement in function");,   }, ,   final public OrderByList sortSpecificationList(ResultSetNode rs) throws ParseException, StandardException {,     OrderByList orderCols = new OrderByList(rs, getContextManager());,     sortSpecification(orderCols);,     label_20:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[155] = jj_gen;,         break label_20;,       },       jj_consume_token(COMMA);,       sortSpecification(orderCols);,     },                 {if (true) return orderCols;},     throw new Error("Missing return statement in function");,   }, ,   final public void sortSpecification(OrderByList orderCols) throws ParseException, StandardException {,         OrderByColumn orderCol;,     orderCol = sortKey();,     switch (jj_nt.kind) {,     case ASC:,     case DESC:,       orderingSpecification(orderCol);,       break;,     default:,       jj_la1[156] = jj_gen;,       ;,     },     if (jj_2_51(1)) {,       nullOrdering(orderCol);,     } else {,       ;,     },                 orderCols.addOrderByColumn(orderCol);,   }, ,   final public OrderByColumn sortKey() throws ParseException, StandardException {,         ValueNode columnExpression;,     columnExpression = additiveExpression(null,0);,         {if (true) return new OrderByColumn(columnExpression, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public void orderingSpecification(OrderByColumn orderCol) throws ParseException {,     switch (jj_nt.kind) {,     case ASC:,       jj_consume_token(ASC);,       break;,     case DESC:,       jj_consume_token(DESC);,                 orderCol.setDescending();,       break;,     default:,       jj_la1[157] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },   }, , /*,  * The data type comparison functions need to know whether NULL values,  * should sort higher than non-NULL values, or lower. The answer to this,  * depends on whether the user specified ASCending or DESCending, and on,  * whether the user specified NULLS FIRST, or NULLS LAST, as follows:,  *,  * +===============+========+========+,  * | ORDER BY says | ASC    | DESC   |,  * +===============+========+========+,  * | NULLS FIRST   | less   | greater|,  * +===============+========+========+,  * | NULLS LAST    | greater| less   |,  * +===============+========+========+,  */,   final public void nullOrdering(OrderByColumn orderCol) throws ParseException {,     if (getToken(2).kind == LAST) {,       jj_consume_token(NULLS);,       jj_consume_token(LAST);,             if (! orderCol.isAscending()),                 orderCol.setNullsOrderedLow();,     } else {,       switch (jj_nt.kind) {,       case NULLS:,         jj_consume_token(NULLS);,         jj_consume_token(FIRST);,             if (orderCol.isAscending()),                 orderCol.setNullsOrderedLow();,         break;,       default:,         jj_la1[158] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },   }, , /*,  * <A NAME="offsetFetchFirstClause">offsetFetchFirstClause</A>,  */,   final public boolean offsetFetchFirstClause(ValueNode[] clauses) throws ParseException, StandardException {,     boolean result = false;,     if (getToken(1).kind == OFFSET || getToken(1).kind == FETCH) {,       sqlStandardOffsetFetchFirst(clauses);,         {if (true) return false;},     } else {,       if (getToken(1).kind == LEFT_BRACE) {,         jdbcLimitOffset(clauses);,             result = true;,       } else {,         ;,       },         {if (true) return result;},     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="sqlStandardOffsetFetchFirst">sqlStandardOffsetFetchFirst</A>,  */,   final public void sqlStandardOffsetFetchFirst(ValueNode[] clauses) throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case OFFSET:,       clauses[ OFFSET_CLAUSE ] = offsetClause();,       break;,     default:,       jj_la1[159] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case FETCH:,       clauses[ FETCH_FIRST_CLAUSE ] = fetchFirstClause();,       break;,     default:,       jj_la1[160] = jj_gen;,       ;,     },   }, , /*,  * <A NAME="jdbcLimitOffset">jdbcLimitOffset</A>,  */,   final public void jdbcLimitOffset(ValueNode[] clauses) throws ParseException, StandardException {,     ValueNode rowCount = null;,     ValueNode startRow = null;,     jj_consume_token(LEFT_BRACE);,     jj_consume_token(LIMIT);,     switch (jj_nt.kind) {,     case PLUS_SIGN:,     case MINUS_SIGN:,     case EXACT_NUMERIC:,       rowCount = intLiteral();,       break;,     case QUESTION_MARK:,       rowCount = dynamicParameterSpecification();,       break;,     default:,       jj_la1[161] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     switch (jj_nt.kind) {,     case OFFSET:,       jj_consume_token(OFFSET);,       switch (jj_nt.kind) {,       case PLUS_SIGN:,       case MINUS_SIGN:,       case EXACT_NUMERIC:,         startRow = intLiteral();,         break;,       case QUESTION_MARK:,         startRow = dynamicParameterSpecification();,         break;,       default:,         jj_la1[162] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[163] = jj_gen;,       ;,     },     jj_consume_token(RIGHT_BRACE);,         // LIMIT of 0 means omit the FETCH/FIRST CLAUSE,         if (,              (rowCount instanceof NumericConstantNode) &&,              ((NumericConstantNode) rowCount).getValue().getInt() == 0,            ),         {,             rowCount = null;,         }, ,         // default OFFSET is 0,         if ( startRow == null ),         {,             startRow = getNumericNode( "0", true );,         }, ,         clauses[ FETCH_FIRST_CLAUSE ] = rowCount;,         clauses[ OFFSET_CLAUSE ] = startRow;,         {if (true) return;},   }, , /*,  * <A NAME="offsetClause">offsetClause</A>,  */,   final public ValueNode offsetClause() throws ParseException, StandardException {,         ValueNode result = null;,     jj_consume_token(OFFSET);,     switch (jj_nt.kind) {,     case PLUS_SIGN:,     case MINUS_SIGN:,     case EXACT_NUMERIC:,       result = intLiteral();,       break;,     case QUESTION_MARK:,       result = dynamicParameterSpecification();,       break;,     default:,       jj_la1[164] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     switch (jj_nt.kind) {,     case ROW:,       jj_consume_token(ROW);,       break;,     case ROWS:,       jj_consume_token(ROWS);,       break;,     default:,       jj_la1[165] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return result;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="fetchFirstClause">fetchFirstClause</A>,  */,   final public ValueNode fetchFirstClause() throws ParseException, StandardException {,         // The default number of rows to fetch if the literal is omitted is 1:,         ValueNode result = getNumericNode("1", true);,     jj_consume_token(FETCH);,     switch (jj_nt.kind) {,     case FIRST:,       jj_consume_token(FIRST);,       break;,     case NEXT:,       jj_consume_token(NEXT);,       break;,     default:,       jj_la1[166] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     switch (jj_nt.kind) {,     case PLUS_SIGN:,     case MINUS_SIGN:,     case QUESTION_MARK:,     case EXACT_NUMERIC:,       switch (jj_nt.kind) {,       case PLUS_SIGN:,       case MINUS_SIGN:,       case EXACT_NUMERIC:,         result = intLiteral();,         break;,       case QUESTION_MARK:,         result = dynamicParameterSpecification();,         break;,       default:,         jj_la1[167] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[168] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case ROW:,       jj_consume_token(ROW);,       break;,     case ROWS:,       jj_consume_token(ROWS);,       break;,     default:,       jj_la1[169] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     jj_consume_token(ONLY);,                 {if (true) return result;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="forUpdateClause">forUpdateClause</A>,  */,   final public int forUpdateClause(List<String> columnList) throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case UPDATE:,       jj_consume_token(UPDATE);,       switch (jj_nt.kind) {,       case OF:,         jj_consume_token(OF);,         forUpdateColumnList(columnList);,         break;,       default:,         jj_la1[170] = jj_gen;,         ;,       },                 {if (true) return CursorNode.UPDATE;},       break;,     case READ:,       jj_consume_token(READ);,       jj_consume_token(ONLY);,                 {if (true) return CursorNode.READ_ONLY;},       break;,     case FETCH:,       jj_consume_token(FETCH);,       jj_consume_token(ONLY);,                 {if (true) return CursorNode.READ_ONLY;},       break;,     default:,       jj_la1[171] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="forUpdateColumnList">forUpdateColumnList</A>,  */,   final public void forUpdateColumnList(List<String> columnList) throws ParseException, StandardException {,     forUpdateColumn(columnList);,     label_21:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[172] = jj_gen;,         break label_21;,       },       jj_consume_token(COMMA);,       forUpdateColumn(columnList);,     },   }, , /*,  * <A NAME="forUpdateColumn">forUpdateColumn</A>,  */,   final public void forUpdateColumn(List<String> columnList) throws ParseException, StandardException {,         String           columnName;,     /* identifier() used to be columnName() */,             columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 columnList.add(columnName);,   }, , /*,  * <A NAME="setClauseList">setClauseList</A>,  */,   final public ResultColumnList setClauseList() throws ParseException, StandardException {,     ResultColumnList columnList = new ResultColumnList(getContextManager());,     setClause(columnList);,     label_22:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[173] = jj_gen;,         break label_22;,       },       jj_consume_token(COMMA);,       setClause(columnList);,     },                 {if (true) return columnList;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="setClause">setClause</A>,  */,   final public void setClause(ResultColumnList columnList) throws ParseException, StandardException {,         ResultColumn resultColumn;,         ColumnReference  columnName;,         ValueNode        valueNode;,     /* identifier() used to be objectColumn() */,             /*,     		SQL92 only wants identifiers here (column names),     		but JBuilder expects table.column, so we allow the,     		general form.,     	 */,             columnName = columnReference();,     jj_consume_token(EQUALS_OPERATOR);,     valueNode = updateSource(columnName.getColumnName());,        resultColumn = new ResultColumn(columnName,,                                                                                 valueNode,,                                                                                 getContextManager());,                 columnList.addResultColumn(resultColumn);,   }, , /*,  * <A NAME="updateSource">updateSource</A>,  */,   final public ValueNode updateSource(String columnName) throws ParseException, StandardException {,         ValueNode       valueNode;,     if (jj_2_52(1)) {,       valueNode = valueExpression();,                 {if (true) return valueNode;},     } else {,       switch (jj_nt.kind) {,       case NULL:,         valueNode = nullSpecification();,                 {if (true) return valueNode;},         break;,       case _DEFAULT:,         jj_consume_token(_DEFAULT);,         {if (true) return new DefaultNode(columnName, getContextManager());},         break;,       default:,         jj_la1[174] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="nullSpecification">nullSpecification</A>,  */,   final public ValueNode nullSpecification() throws ParseException, StandardException {,     jj_consume_token(NULL);,        {if (true) return new UntypedNullConstantNode(getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="insertColumnsAndSource">insertColumnsAndSource</A>,  */,   final public StatementNode insertColumnsAndSource(QueryTreeNode targetTable) throws ParseException, StandardException {,         Properties                      targetProperties = null;,         ResultSetNode   queryExpression;,         ResultColumnList        columnList = null;,         OrderByList orderCols = null;,     ValueNode[] offsetClauses = new ValueNode[ OFFSET_CLAUSE_COUNT ];,     boolean     hasJDBClimitClause = false;,     if (getToken(1).kind == LEFT_PAREN && ! subqueryFollows()) {,       jj_consume_token(LEFT_PAREN);,       columnList = insertColumnList();,       jj_consume_token(RIGHT_PAREN);,     } else {,       ;,     },     switch (jj_nt.kind) {,     case DERBYDASHPROPERTIES:,       targetProperties = propertyList(false);,       jj_consume_token(CHECK_PROPERTIES);,       break;,     default:,       jj_la1[175] = jj_gen;,       ;,     },     queryExpression = queryExpression(null, NO_SET_OP);,     switch (jj_nt.kind) {,     case ORDER:,       orderCols = orderByClause(queryExpression);,       break;,     default:,       jj_la1[176] = jj_gen;,       ;,     },     hasJDBClimitClause = offsetFetchFirstClause(offsetClauses);,                 if (orderCols != null && isTableValueConstructor(queryExpression)) {,                         // Not allowed by the standard since this is a <contextually typed,                         // table value constructor> according SQL 2008, vol2, section 14.11,                         // "<insert statement>, SR 17. (I.e. it is not a <subquery> and,                         // can't have an ORDER BY)., ,                         {if (true) throw StandardException.newException(,                                 SQLState.LANG_SYNTAX_ERROR, "ORDER BY");},                 }, ,         if ((offsetClauses[ OFFSET_CLAUSE ] != null || offsetClauses[ FETCH_FIRST_CLAUSE ] != null) &&,                 isTableValueConstructor(queryExpression)),         {,             String tokenName;,             if ( hasJDBClimitClause ) { tokenName = "LIMIT"; },             else if ( offsetClauses[ OFFSET_CLAUSE ] != null ) { tokenName = "OFFSET"; },             else { tokenName = "FETCH"; }, ,             {if (true) throw StandardException.newException( SQLState.LANG_SYNTAX_ERROR, tokenName );},         }, ,         {if (true) return new InsertNode(,                                                         targetTable,,                                                         columnList,,                                                         queryExpression,,                                                         null,,                                                         targetProperties,,                                                         orderCols,,                             offsetClauses[ OFFSET_CLAUSE ],,                             offsetClauses[ FETCH_FIRST_CLAUSE ],,                             hasJDBClimitClause,,                                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="insertColumnList">insertColumnList</A>,  */,   final public ResultColumnList insertColumnList() throws ParseException, StandardException {,     ResultColumnList columnList = new ResultColumnList(getContextManager());,     columnQualifiedNameList(columnList);,                 {if (true) return columnList;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="columnQualifiedNameList">columnQualifiedNameList</A>,  */,   final public void columnQualifiedNameList(ResultColumnList columnList) throws ParseException, StandardException {,     columnQualifiedNameItem(columnList);,     label_23:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[177] = jj_gen;,         break label_23;,       },       jj_consume_token(COMMA);,       columnQualifiedNameItem(columnList);,     },   }, , /*,  * <A NAME="columnQualifiedNameItem">columnQualifiedNameItem</A>,  */,   final public void columnQualifiedNameItem(ResultColumnList columnList) throws ParseException, StandardException {,         ColumnReference         columnRef;,         ResultColumn    resultColumn;,     /*,     		SQL92 only wants identifiers here (column names),     		but JBuilder expects table.column, so we allow the,     		general form.,     	 */,             columnRef = columnReference();,                 /*, 		** Store the column names for the result columns in the, 		** result column list.  We don't know yet what valueNodes, 		** should be hooked up to each result column, so set that, 		** to null for now., 		*/,        resultColumn = new ResultColumn(columnRef,,                                                                                 null,,                                                                                 getContextManager());,                 columnList.addResultColumn(resultColumn);,   }, , /*,  * <A NAME="rowValueConstructor">rowValueConstructor</A>,  */,   final public ResultSetNode rowValueConstructor(ResultSetNode leftRSN) throws ParseException, StandardException {,     ResultColumnList resultColumns = new ResultColumnList(getContextManager());,         ResultSetNode           newRSN;,     if (rowValueConstructorListFollows()) {,       jj_consume_token(LEFT_PAREN);,       rowValueConstructorList(resultColumns);,       jj_consume_token(RIGHT_PAREN);,                 /* If leftRSN is null, simply return the newRSN, else generate and, 		 * return a UNION ALL above the 2 RSNs, after verifying that the size(), 		 * of both RSNs RCLs is the same., 		 */,         newRSN = new RowResultSetNode(resultColumns, null, getContextManager());, ,                 if (leftRSN != null),                 {,                         if (leftRSN.getResultColumns().size() !=,                                 newRSN.getResultColumns().size()),                         {,                                 {if (true) throw StandardException.newException(SQLState.LANG_ROW_VALUE_CONSTRUCTOR_UNMATCHED_COLUMNS);},                         }, ,             newRSN = new UnionNode(,                 leftRSN, newRSN, true, true, null, getContextManager());,                 },                 {if (true) return newRSN;},     } else {,       rowValueConstructorElement(resultColumns);,                 /* If leftRSN is null, simply return the newRSN, else generate and, 		 * return a UNION ALL above the 2 RSNs, after verifying that the size(), 		 * of both RSNs RCLs is the same., 		 */,         newRSN = new RowResultSetNode(resultColumns, null, getContextManager());, ,                 if (leftRSN != null),                 {,                         if (leftRSN.getResultColumns().size() !=,                                 newRSN.getResultColumns().size()),                         {,                                 {if (true) throw StandardException.newException(SQLState.LANG_ROW_VALUE_CONSTRUCTOR_UNMATCHED_COLUMNS);},                         }, ,             newRSN = new UnionNode(,                 leftRSN, newRSN, true, true, null, getContextManager());,                 },                 {if (true) return newRSN;},     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="rowValueConstructorElement">rowValueConstructorElement</A>,  */,   final public void rowValueConstructorElement(ResultColumnList resultColumns) throws ParseException, StandardException {,         ValueNode       value;,     if (jj_2_53(1)) {,       value = valueExpression();,        resultColumns.addResultColumn(new ResultColumn((String)null,,                                                        value,,                                                        getContextManager()));,     } else {,       switch (jj_nt.kind) {,       case NULL:,         value = nullSpecification();,        resultColumns.addResultColumn(new ResultColumn((String)null,,                                                        value,,                                                        getContextManager()));,         break;,       case _DEFAULT:,         jj_consume_token(_DEFAULT);,                 resultColumns.addResultColumn(,             new ResultColumn((String)null,,                              new DefaultNode( null, getContextManager()),,                              getContextManager()));,         break;,       default:,         jj_la1[178] = jj_gen;,                 {if (true) throw StandardException.newException(SQLState.LANG_EMPTY_VALUES_CLAUSE);},       },     },   }, , /*,  * <A NAME="rowValueConstructorList">rowValueConstructorList</A>,  */,   final public void rowValueConstructorList(ResultColumnList resultColumns) throws ParseException, StandardException {,     rowValueConstructorElement(resultColumns);,     label_24:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[179] = jj_gen;,         break label_24;,       },       jj_consume_token(COMMA);,       rowValueConstructorElement(resultColumns);,     },   }, , /*,  * <A NAME="tableSubquery">tableSubquery</A>,  */,   final public SubqueryNode tableSubquery(int subqueryType, ValueNode leftOperand) throws ParseException, StandardException {,         SubqueryNode    subqueryNode;,     subqueryNode = subquery(subqueryType, leftOperand);,                 {if (true) return subqueryNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="subquery">subquery</A>,  */,   final public SubqueryNode subquery(int subqueryType, ValueNode leftOperand) throws ParseException, StandardException {,         ResultSetNode   queryExpression;,         SubqueryNode    subqueryNode;,         OrderByList orderCols = null;,     ValueNode[] offsetClauses = new ValueNode[ OFFSET_CLAUSE_COUNT ];,     boolean     hasJDBClimitClause = false;,     queryExpression = queryExpression(null, NO_SET_OP);,     switch (jj_nt.kind) {,     case ORDER:,       orderCols = orderByClause(queryExpression);,       break;,     default:,       jj_la1[180] = jj_gen;,       ;,     },     hasJDBClimitClause = offsetFetchFirstClause(offsetClauses);,         subqueryNode = new SubqueryNode(queryExpression,,                                         subqueryType,,                                                                                 leftOperand,,                                                                                 orderCols,,                                         offsetClauses[ OFFSET_CLAUSE ],,                                         offsetClauses[ FETCH_FIRST_CLAUSE ],,                                         hasJDBClimitClause,,                                                                                 getContextManager());,                 {if (true) return subqueryNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="inPredicateValue">inPredicateValue</A>,  */,   final public ValueNode inPredicateValue(ValueNode leftOperand) throws ParseException, StandardException {,         ValueNode               retval;,         int                             tokKind;,     jj_consume_token(LEFT_PAREN);,     if (subqueryFollows()) {,       retval = tableSubquery(SubqueryNode.IN_SUBQUERY, leftOperand);,     } else if (jj_2_54(1)) {,       retval = inValueList(leftOperand);,     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     jj_consume_token(RIGHT_PAREN);,                 {if (true) return retval;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="inValueList">inValueList</A>,  */,   final public ValueNode inValueList(ValueNode leftOperand) throws ParseException, StandardException {,     ValueNodeList inList = new ValueNodeList(getContextManager());,     inElement(inList);,     label_25:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[181] = jj_gen;,         break label_25;,       },       jj_consume_token(COMMA);,       inElement(inList);,     },         {if (true) return new InListOperatorNode(leftOperand, inList, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="inElement">inElement</A>,  */,   final public void inElement(ValueNodeList inList) throws ParseException, StandardException {,         ValueNode valueNode;,     valueNode = additiveExpression(null, 0);,                 inList.addElement(valueNode);,   }, , /*,  * <A NAME="quantifier">quantifier</A>,  */,   final public int quantifier(int opType) throws ParseException, StandardException {,         int retval = 0;,     switch (jj_nt.kind) {,     case ALL:,       jj_consume_token(ALL);,                 switch (opType),                 {,                         case BinaryOperatorNode.EQ:,                                 retval = SubqueryNode.EQ_ALL_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.NE:,                                 retval = SubqueryNode.NE_ALL_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.LE:,                                 retval = SubqueryNode.LE_ALL_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.LT:,                                 retval = SubqueryNode.LT_ALL_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.GE:,                                 retval = SubqueryNode.GE_ALL_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.GT:,                                 retval = SubqueryNode.GT_ALL_SUBQUERY;,                                 break;, ,                         default:,                                 if (SanityManager.DEBUG),                                 SanityManager.THROWASSERT(,                                                 "Invalid value for opType (" + opType +,                                                 ") passed to quantifier()");,                 },                 {if (true) return retval;},       break;,     case ANY:,     case SOME:,       some();,                 switch (opType),                 {,                         case BinaryOperatorNode.EQ:,                                 retval = SubqueryNode.EQ_ANY_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.NE:,                                 retval = SubqueryNode.NE_ANY_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.LE:,                                 retval = SubqueryNode.LE_ANY_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.LT:,                                 retval = SubqueryNode.LT_ANY_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.GE:,                                 retval = SubqueryNode.GE_ANY_SUBQUERY;,                                 break;, ,                         case BinaryOperatorNode.GT:,                                 retval = SubqueryNode.GT_ANY_SUBQUERY;,                                 break;, ,                         default:,                                 if (SanityManager.DEBUG),                                 SanityManager.THROWASSERT(,                                                 "Invalid value for opType (" + opType +,                                                 ") passed to quantifier()");,                 },                 {if (true) return retval;},       break;,     default:,       jj_la1[182] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="some">some</A>,  */,   final public void some() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case SOME:,       jj_consume_token(SOME);,       break;,     case ANY:,       jj_consume_token(ANY);,       break;,     default:,       jj_la1[183] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },   }, , /*,  * <A NAME="existsExpression">existsExpression</A>,  */,   final public SubqueryNode existsExpression() throws ParseException, StandardException {,         SubqueryNode    subqueryNode;,     jj_consume_token(EXISTS);,     jj_consume_token(LEFT_PAREN);,     subqueryNode = tableSubquery(SubqueryNode.EXISTS_SUBQUERY, null);,     jj_consume_token(RIGHT_PAREN);,                 {if (true) return subqueryNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="tableExpression">tableExpression</A>,  */,   final public SelectNode tableExpression(ResultColumnList selectList) throws ParseException, StandardException {,         SelectNode      selectNode;,         FromList        fromList;,         ValueNode       whereClause = null;,         GroupByList     groupByList = null;,         ValueNode       havingClause = null;,         Token           whereToken;,         WindowList  windows = null;,     OptimizerPlan       optimizerOverridePlan = null;,     fromList = fromClause();,     switch (jj_nt.kind) {,     case WHERE:,       whereToken = jj_consume_token(WHERE);,       whereClause = whereClause(whereToken);,       break;,     default:,       jj_la1[184] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case GROUP:,       groupByList = groupByClause();,       break;,     default:,       jj_la1[185] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case HAVING:,       havingClause = havingClause();,       break;,     default:,       jj_la1[186] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case WINDOW:,       windows = windowClause();,       break;,     default:,       jj_la1[187] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case DERBYPLAN:,       optimizerOverridePlan = optimizerOverridePlan();,       break;,     default:,       jj_la1[188] = jj_gen;,       ;,     },                 // fix for HAVING without GROUP BY, makes sure we get one,                 // aggregate operator by adding a count(*), this fixes beetle 5853, 5890,                 if (havingClause != null && groupByList == null) {,            AggregateNode n = new AggregateNode(,                                                                 null,,                                                                 org.apache.derby.impl.sql.compile.CountAggregateDefinition.class,,                                false, // distinct true?,                                                                 "COUNT(*)",,                                                                 getContextManager());,                         n.replaceAggregatesWithColumnReferences(selectList, 0);,                 }, ,         selectNode = new SelectNode(selectList,,                                     fromList,,                                     whereClause,,                                     groupByList,,                                     havingClause,,                                     windows,,                                     optimizerOverridePlan,,                                     getContextManager());, ,                 {if (true) return selectNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="fromClause">fromClause</A>,  */,   final public FromList fromClause() throws ParseException, StandardException {,     FromList fromList = new FromList(,         getOptimizerFactory().doJoinOrderOptimization(),,         getContextManager());, ,         int     tokKind;,     Token   beginToken;,     Token   endToken;,     jj_consume_token(FROM);,                 beginToken = getToken(1);,     switch (jj_nt.kind) {,     case DERBYDASHPROPERTIES:,       fromListProperties(fromList);,       break;,     default:,       jj_la1[189] = jj_gen;,       ;,     },     dummyTableReferenceRule(fromList);,     label_26:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[190] = jj_gen;,         break label_26;,       },       jj_consume_token(COMMA);,       dummyTableReferenceRule(fromList);,     },                                                                          endToken = getToken(0);,                 fromList.setBeginOffset( beginToken.beginOffset);,                 fromList.setEndOffset( endToken.endOffset);,                 {if (true) return fromList;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="fromListProperties">fromListProperties</A>,  */,   final public void fromListProperties(FromList fromList) throws ParseException, StandardException {,         Properties properties;,     properties = propertyList(true);,     jj_consume_token(CHECK_PROPERTIES);,                 fromList.setProperties(properties);,   }, , /* This rule created simply as a way to add the result of tableReference(),  * to the fromList.,  */,   final public void dummyTableReferenceRule(FromList fromList) throws ParseException, StandardException {,         FromTable tableReference;,     if (getToken(1).kind == TABLE &&,                                     getToken(2).kind == LEFT_PAREN &&,                                     (,                                             getToken(3).kind == SELECT ||,                                             getToken(3).kind == VALUES,                                     )) {,       jj_consume_token(TABLE);,       tableReference = tableReferenceTypes(false);,                 fromList.addFromTable(tableReference);,     } else if (jj_2_55(1)) {,       tableReference = tableReferenceTypes(false);,                 fromList.addFromTable(tableReference);,     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },   }, ,   final public FromTable tableReferenceTypes(boolean nestedInParens) throws ParseException, StandardException {,         FromTable tableReference;,     if (jj_2_56(1)) {,       tableReference = tableReference(nestedInParens);,                 {if (true) return tableReference ;},     } else {,       switch (jj_nt.kind) {,       case LEFT_BRACE:,         jj_consume_token(LEFT_BRACE);,         jj_consume_token(OJ);,         tableReference = tableReference(nestedInParens);,         jj_consume_token(RIGHT_BRACE);,                 {if (true) return tableReference;},         break;,       default:,         jj_la1[191] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, ,   final public Object[] optionalTableClauses() throws ParseException, StandardException {,         Object[]                         otc = null;,         Properties                      tableProperties = null;,         ResultColumnList        derivedRCL = null;,         String                          correlationName = null;,     switch (jj_nt.kind) {,     case DERBYDASHPROPERTIES:,       otc = optionalTableProperties();,                 otc[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL] = derivedRCL;,                 otc[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME] = correlationName;,                 {if (true) return otc;},       break;,     default:,       jj_la1[195] = jj_gen;,       if (jj_2_57(1)) {,         switch (jj_nt.kind) {,         case AS:,           jj_consume_token(AS);,           break;,         default:,           jj_la1[192] = jj_gen;,           ;,         },         correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         switch (jj_nt.kind) {,         case LEFT_PAREN:,           jj_consume_token(LEFT_PAREN);,           derivedRCL = derivedColumnList();,           jj_consume_token(RIGHT_PAREN);,           break;,         default:,           jj_la1[193] = jj_gen;,           ;,         },         switch (jj_nt.kind) {,         case DERBYDASHPROPERTIES:,           tableProperties = propertyList(true);,           jj_consume_token(CHECK_PROPERTIES);,           break;,         default:,           jj_la1[194] = jj_gen;,           ;,         },       } else {,         ;,       },                 otc = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];,                 otc[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] = tableProperties;,                 otc[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL] = derivedRCL;,                 otc[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME] = correlationName;,                 {if (true) return otc;},     },     throw new Error("Missing return statement in function");,   }, ,   final public Object[] optionalTableProperties() throws ParseException, StandardException {,         Object[]                        otc = null;,         Properties                      tableProperties = null;,     tableProperties = propertyList(true);,     jj_consume_token(CHECK_PROPERTIES);,                 otc = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];,                 otc[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] = tableProperties;,                 {if (true) return otc;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="tableReference">tableReference</A>,  */,   final public FromTable tableReference(boolean nestedInParens) throws ParseException, StandardException {,     FromTable fromTable;,     TableOperatorNode joinTable = null;,     fromTable = tableFactor();,     label_27:,     while (true) {,       if (joinedTableExpressionFollows()) {,         ;,       } else {,         break label_27;,       },       joinTable = joinedTableExpression((joinTable == null) ? fromTable : joinTable,,                       nestedInParens);,     },         {if (true) return joinTable == null ? fromTable : joinTable;},     throw new Error("Missing return statement in function");,   }, ,   final public FromTable tableFactor() throws ParseException, StandardException {,         JavaToSQLValueNode      javaToSQLNode = null;,         TableName                       tableName;,         String                          correlationName = null;,         ResultColumnList        derivedRCL = null;,         FromTable                       fromTable;,         FromTable                       tableReference;,         Object[]                        optionalTableClauses = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];,         Properties                      tableProperties = null;,         SubqueryNode            derivedTable;,     if (jj_2_58(1)) {,       if (newInvocationFollows(1)) {,         javaToSQLNode = newInvocation();,       } else {,         switch (jj_nt.kind) {,         case TABLE:,           javaToSQLNode = vtiTableConstruct();,           break;,         default:,           jj_la1[196] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },       switch (jj_nt.kind) {,       case AS:,         jj_consume_token(AS);,         break;,       default:,         jj_la1[197] = jj_gen;,         ;,       },       correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         jj_consume_token(LEFT_PAREN);,         derivedRCL = derivedColumnList();,         jj_consume_token(RIGHT_PAREN);,         break;,       default:,         jj_la1[198] = jj_gen;,         ;,       },       switch (jj_nt.kind) {,       case DERBYDASHPROPERTIES:,         optionalTableClauses = optionalTableProperties();,         break;,       default:,         jj_la1[199] = jj_gen;,         ;,       },         fromTable = new FromVTI(,             (MethodCallNode)javaToSQLNode.getJavaValueNode(),,             correlationName,,             derivedRCL,,             ((optionalTableClauses != null) ?,                  (Properties)optionalTableClauses[,                      OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :,                  (Properties)null),,             getContextManager());,                 {if (true) return fromTable;},     } else if (jj_2_59(1)) {,       /* identifier() used to be correlationName() */,               tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,       optionalTableClauses = optionalTableClauses();,         fromTable = new FromBaseTable(,             tableName,,             (String) optionalTableClauses[,                 OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME],,             (ResultColumnList) optionalTableClauses[,                 OPTIONAL_TABLE_CLAUSES_DERIVED_RCL],,             (Properties) optionalTableClauses[,                 OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES],,             getContextManager());,                 {if (true) return fromTable;},     } else if (getToken(1).kind == LEFT_PAREN &&,                                     (,                                             getToken(2).kind == SELECT ||,                                             getToken(2).kind == VALUES,                                     )) {,       derivedTable = derivedTable();,       switch (jj_nt.kind) {,       case AS:,         jj_consume_token(AS);,         break;,       default:,         jj_la1[200] = jj_gen;,         ;,       },       correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         jj_consume_token(LEFT_PAREN);,         derivedRCL = derivedColumnList();,         jj_consume_token(RIGHT_PAREN);,         break;,       default:,         jj_la1[201] = jj_gen;,         ;,       },       switch (jj_nt.kind) {,       case DERBYDASHPROPERTIES:,         optionalTableClauses = optionalTableProperties();,         break;,       default:,         jj_la1[202] = jj_gen;,         ;,       },         fromTable = new FromSubquery(,             derivedTable.getResultSet(),,             derivedTable.getOrderByList(),,             derivedTable.getOffset(),,             derivedTable.getFetchFirst(),,             derivedTable.hasJDBClimitClause(),,             correlationName,,             derivedRCL,,             ((optionalTableClauses != null) ?,              (Properties) optionalTableClauses[,                  OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :,              (Properties) null),,             getContextManager());, ,                 {if (true) return fromTable;},     } else {,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         jj_consume_token(LEFT_PAREN);,         tableReference = tableReferenceTypes(true);,         jj_consume_token(RIGHT_PAREN);,                 fromTable = tableReference;, ,                 {if (true) return fromTable;},         break;,       default:,         jj_la1[203] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="derivedColumnList">derivedColumnList</A>,  */,   final public ResultColumnList derivedColumnList() throws ParseException, StandardException {,     ResultColumnList resultColumns = new ResultColumnList(getContextManager());,     columnNameList(resultColumns);,                 {if (true) return resultColumns;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="columnNameList">columnNameList</A>,  */,   final public void columnNameList(ResultColumnList columnList) throws ParseException, StandardException {,     columnNameItem(columnList);,     label_28:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[204] = jj_gen;,         break label_28;,       },       jj_consume_token(COMMA);,       columnNameItem(columnList);,     },   }, , /*,  * <A NAME="columnNameItem">columnNameItem</A>,  */,   final public void columnNameItem(ResultColumnList columnList) throws ParseException, StandardException {,         String          columnName;,         ResultColumn    resultColumn;,     /* identifier() used to be columnName() */,             columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 /*, 		** Store the column names for the result columns in the, 		** result column list.  We don't know yet what valueNodes, 		** should be hooked up to each result column, so set that, 		** to null for now., 		*/,        resultColumn = new ResultColumn(columnName,,                                         null,,                                         getContextManager());,                 columnList.addResultColumn(resultColumn);,   }, , /*,  * <A NAME="indexColumnList">indexColumnList</A>,  */,   final public void indexColumnList(List<String> columnList) throws ParseException, StandardException {,     indexColumnItem(columnList);,     label_29:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[205] = jj_gen;,         break label_29;,       },       jj_consume_token(COMMA);,       indexColumnItem(columnList);,     },   }, , /*,  * <A NAME="indexColumnItem">indexColumnItem</A>,  */,   final public void indexColumnItem(List<String> columnList) throws ParseException, StandardException {,         String          columnName;,     /* identifier never ends with a space; appending a space meaning desc */,             columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     switch (jj_nt.kind) {,     case ASC:,     case DESC:,       switch (jj_nt.kind) {,       case ASC:,         jj_consume_token(ASC);,         break;,       case DESC:,         jj_consume_token(DESC);,                                                                                      columnName = columnName + ' ';,         break;,       default:,         jj_la1[206] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[207] = jj_gen;,       ;,     },                 /*, 		** Store the column names for the index columns in the, 		** index column list., 		*/,                 columnList.add(columnName);,   }, , /*,  * <A NAME="derivedTable">derivedTable</A>,  */,   final public SubqueryNode derivedTable() throws ParseException, StandardException {,         SubqueryNode tableSubquery;,     jj_consume_token(LEFT_PAREN);,     tableSubquery = tableSubquery(SubqueryNode.FROM_SUBQUERY, null);,     jj_consume_token(RIGHT_PAREN);,                 {if (true) return tableSubquery;},     throw new Error("Missing return statement in function");,   }, ,   final public TableOperatorNode joinedTableExpression(ResultSetNode leftRSN, boolean nestedInParens) throws ParseException, StandardException {,         TableOperatorNode joinNode;,     switch (jj_nt.kind) {,     case CROSS:,       joinNode = crossJoin(leftRSN, nestedInParens);,                 {if (true) return joinNode;},       break;,     case INNER:,     case JOIN:,     case LEFT:,     case RIGHT:,       joinNode = qualifiedJoin(leftRSN, nestedInParens);,                 {if (true) return joinNode;},       break;,     case NATURAL:,       joinNode = naturalJoin(leftRSN, nestedInParens);,                 {if (true) return joinNode;},       break;,     default:,       jj_la1[208] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public TableOperatorNode crossJoin(ResultSetNode leftRSN, boolean nestedInParens) throws ParseException, StandardException {,     ResultSetNode rightRSN;,     jj_consume_token(CROSS);,     jj_consume_token(JOIN);,     rightRSN = tableFactor();,         TableOperatorNode ton = newJoinNode(,                 leftRSN,,                 rightRSN,,                 null, // no ON clause in CROSS JOIN,                 null, // no USING clause in CROSS JOIN,                 JoinNode.INNERJOIN);,         ton.setNestedInParens(nestedInParens);,         {if (true) return ton;},     throw new Error("Missing return statement in function");,   }, ,   final public TableOperatorNode qualifiedJoin(ResultSetNode leftRSN, boolean nestedInParens) throws ParseException, StandardException {,         int                                     joinType = JoinNode.INNERJOIN;,         ResultSetNode           rightRSN;,         TableOperatorNode       ton = null;,         Object[]                        onOrUsingClause = null;,         ResultColumnList        usingClause = null;,         ValueNode                       onClause;,     switch (jj_nt.kind) {,     case INNER:,     case LEFT:,     case RIGHT:,       joinType = joinType();,       break;,     default:,       jj_la1[209] = jj_gen;,       ;,     },     jj_consume_token(JOIN);,     rightRSN = tableReferenceTypes(nestedInParens);,     onOrUsingClause = joinSpecification(leftRSN, rightRSN);,                 /* If NATURAL or CROSS is specified, then no joinSpecification(), 		 * is required, otherwise it is required. NATURAL and CROSS should, 		 * be handled by other rules, so this rule should always see a, 		 * joinSpecification()., 		 */, ,                 /* Figure out whether an ON or USING clause was used */,                 onClause = (ValueNode) onOrUsingClause[ON_CLAUSE];,                 usingClause = (ResultColumnList) onOrUsingClause[USING_CLAUSE];, ,                 if (onClause == null && usingClause == null),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_MISSING_JOIN_SPECIFICATION,,                                                         JoinNode.joinTypeToString(joinType));},                 }, ,                 ton = newJoinNode(leftRSN, rightRSN, onClause, usingClause, joinType);, ,                 /* Mark whether or not we are nested within parens */,                 ton.setNestedInParens(nestedInParens);,                 {if (true) return ton;},     throw new Error("Missing return statement in function");,   }, ,   final public TableOperatorNode naturalJoin(ResultSetNode leftRSN, boolean nestedInParens) throws ParseException, StandardException {,     int joinType = JoinNode.INNERJOIN;,     ResultSetNode rightRSN;,     jj_consume_token(NATURAL);,     switch (jj_nt.kind) {,     case INNER:,     case LEFT:,     case RIGHT:,       joinType = joinType();,       break;,     default:,       jj_la1[210] = jj_gen;,       ;,     },     jj_consume_token(JOIN);,     rightRSN = tableFactor();,         JoinNode node = newJoinNode(leftRSN, rightRSN, null, null, joinType);,         node.setNestedInParens(nestedInParens);,         node.setNaturalJoin();,         {if (true) return node;},     throw new Error("Missing return statement in function");,   }, ,   final public int joinType() throws ParseException, StandardException {,         int joinType;,     switch (jj_nt.kind) {,     case INNER:,       jj_consume_token(INNER);,                 {if (true) return JoinNode.INNERJOIN;},       break;,     case LEFT:,     case RIGHT:,       joinType = outerJoinType();,       switch (jj_nt.kind) {,       case OUTER:,         jj_consume_token(OUTER);,         break;,       default:,         jj_la1[211] = jj_gen;,         ;,       },                 {if (true) return joinType;},       break;,     default:,       jj_la1[212] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public int outerJoinType() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case LEFT:,       jj_consume_token(LEFT);,                 {if (true) return JoinNode.LEFTOUTERJOIN;},       break;,     case RIGHT:,       jj_consume_token(RIGHT);,                 {if (true) return JoinNode.RIGHTOUTERJOIN;},       break;,     default:,       jj_la1[213] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public Object[] joinSpecification(ResultSetNode leftRSN, ResultSetNode rightRSN) throws ParseException, StandardException {,         Object[]                        onOrUsingClause = new Object[ON_OR_USING_CLAUSE_SIZE];,         ResultColumnList        usingClause = null;,         ValueNode                       joinClause = null;,     switch (jj_nt.kind) {,     case ON:,       joinClause = joinCondition();,                 onOrUsingClause[ON_CLAUSE] = joinClause;,                 onOrUsingClause[USING_CLAUSE] = usingClause;,                 {if (true) return onOrUsingClause;},       break;,     case USING:,       usingClause = namedColumnsJoin();,         onOrUsingClause[ON_CLAUSE] = joinClause;,         onOrUsingClause[USING_CLAUSE] = usingClause;,         {if (true) return onOrUsingClause;},       break;,     default:,       jj_la1[214] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode joinCondition() throws ParseException, StandardException {,         ValueNode joinClause;,     jj_consume_token(ON);,     joinClause = valueExpression();,                 {if (true) return joinClause;},     throw new Error("Missing return statement in function");,   }, ,   final public ResultColumnList namedColumnsJoin() throws ParseException, StandardException {,     ResultColumnList usingClause = new ResultColumnList(getContextManager());,     jj_consume_token(USING);,     jj_consume_token(LEFT_PAREN);,     columnNameList(usingClause);,     jj_consume_token(RIGHT_PAREN);,         {if (true) return usingClause;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="tableValueConstructor">tableValueConstructor</A>,  */,   final public ResultSetNode tableValueConstructor() throws ParseException, StandardException {,         ResultSetNode   resultSetNode;,     jj_consume_token(VALUES);,     resultSetNode = tableValueConstructorList();,                 {if (true) return resultSetNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="tableValueConstructorList">tableValueConstructorList</A>,  */,   final public ResultSetNode tableValueConstructorList() throws ParseException, StandardException {,         ResultSetNode   resultSetNode;,     resultSetNode = rowValueConstructor(null);,     label_30:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[215] = jj_gen;,         break label_30;,       },       jj_consume_token(COMMA);,       resultSetNode = rowValueConstructor(resultSetNode);,     },                 if (resultSetNode instanceof UnionNode),                 {,                         ((UnionNode) resultSetNode).markTopTableConstructor();,                 }, ,                 {if (true) return resultSetNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="explicitTable">explicitTable</A>,  */, , /*,  * <A NAME="datetimeValueFunction">datetimeValueFunction</A>,  */,   final public ValueNode datetimeValueFunction() throws ParseException, StandardException {,         int prec = -1;,     if ((getToken(1).kind == CURRENT && getToken(2).kind == DATE)) {,       jj_consume_token(CURRENT);,       jj_consume_token(DATE);,         {if (true) return new CurrentDatetimeOperatorNode(,             CurrentDatetimeOperatorNode.CURRENT_DATE,,             getContextManager());},     } else {,       switch (jj_nt.kind) {,       case CURRENT_DATE:,         jj_consume_token(CURRENT_DATE);,         {if (true) return new CurrentDatetimeOperatorNode(,             CurrentDatetimeOperatorNode.CURRENT_DATE,,             getContextManager());},         break;,       default:,         jj_la1[216] = jj_gen;,         if ((getToken(1).kind == CURRENT && getToken(2).kind == TIME)) {,           jj_consume_token(CURRENT);,           jj_consume_token(TIME);,         {if (true) return new CurrentDatetimeOperatorNode(,             CurrentDatetimeOperatorNode.CURRENT_TIME,,             getContextManager());},         } else {,           switch (jj_nt.kind) {,           case CURRENT_TIME:,             jj_consume_token(CURRENT_TIME);,         {if (true) return new CurrentDatetimeOperatorNode(,             CurrentDatetimeOperatorNode.CURRENT_TIME,,             getContextManager());},             break;,           default:,             jj_la1[217] = jj_gen;,             if ((getToken(1).kind == CURRENT && getToken(2).kind == TIMESTAMP)) {,               jj_consume_token(CURRENT);,               jj_consume_token(TIMESTAMP);,         {if (true) return new CurrentDatetimeOperatorNode(,             CurrentDatetimeOperatorNode.CURRENT_TIMESTAMP,,             getContextManager());},             } else {,               switch (jj_nt.kind) {,               case CURRENT_TIMESTAMP:,                 jj_consume_token(CURRENT_TIMESTAMP);,         {if (true) return new CurrentDatetimeOperatorNode(,             CurrentDatetimeOperatorNode.CURRENT_TIMESTAMP,,             getContextManager());},                 break;,               default:,                 jj_la1[218] = jj_gen;,                 jj_consume_token(-1);,                 throw new ParseException();,               },             },           },         },       },     },     throw new Error("Missing return statement in function");,   }, , /*, ** Note that set function and aggregate are used, ** interchangeably in the parser.  The tree has, ** aggregate nodes., */,   final public ValueNode windowOrAggregateFunctionNode() throws ParseException, StandardException {,    WindowNode window = null;,     AggregateNode agg = null;,     switch (jj_nt.kind) {,     case COUNT:,       jj_consume_token(COUNT);,       jj_consume_token(LEFT_PAREN);,       switch (jj_nt.kind) {,       case ASTERISK:,         jj_consume_token(ASTERISK);,         agg = new AggregateNode(null,,                                                                 CountAggregateDefinition.class,,                                false,,                                                                 "COUNT(*)",,                                                                 getContextManager());,         break;,       default:,         jj_la1[219] = jj_gen;,         if (jj_2_60(1)) {,           agg = aggregateExpression("COUNT", CountAggregateDefinition.class);,         } else {,           jj_consume_token(-1);,           throw new ParseException();,         },       },       jj_consume_token(RIGHT_PAREN);,       if (jj_2_61(1)) {,         window = overClause();,       } else {,         ;,       },                 if (window != null) {,            {if (true) return new AggregateWindowFunctionNode(,                 window, agg, getContextManager());},        } else {,             {if (true) return agg;},         },       break;,     case AVG:,     case MAX:,     case MIN:,     case SUM:,       agg = generalAggregate();,       if (jj_2_62(1)) {,         window = overClause();,       } else {,         ;,       },                 if (window != null) {,            {if (true) return new AggregateWindowFunctionNode(,                window, agg, getContextManager());},        } else {,             {if (true) return agg;},         },       break;,     case ROWNUMBER:,       jj_consume_token(ROWNUMBER);,       jj_consume_token(LEFT_PAREN);,       jj_consume_token(RIGHT_PAREN);,       window = overClause();,        {if (true) return new RowNumberFunctionNode(null, window, getContextManager());},       break;,     default:,       jj_la1[220] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public WindowNode overClause() throws ParseException, StandardException {,         String windowRef;,         OrderByList orderCols = null;,     if (getToken(2).kind == LEFT_PAREN ||,                               getToken(2).kind == IDENTIFIER) {, ,     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     jj_consume_token(OVER);,     switch (jj_nt.kind) {,     case LEFT_PAREN:,       jj_consume_token(LEFT_PAREN);,       switch (jj_nt.kind) {,       case ORDER:,         orderCols = orderByClause(null);,         break;,       default:,         jj_la1[221] = jj_gen;,         ;,       },       jj_consume_token(RIGHT_PAREN);,         {if (true) return new WindowDefinitionNode(null, orderCols, getContextManager());},       break;,     default:,       jj_la1[222] = jj_gen;,       if (jj_2_63(1)) {,         windowRef = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,        {if (true) return new WindowReferenceNode(windowRef, getContextManager());},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, ,   final public AggregateNode aggregateExpression(String aggName, Class aggClass) throws ParseException, StandardException {,         boolean         distinct = false;,         ValueNode       value;,     if (jj_2_64(1)) {,       distinct = setQuantifier();,     } else {,       ;,     },     value = additiveExpression(null, 0);,        {if (true) return new AggregateNode(value,,                                  aggClass,,                                  distinct,,                                  aggName,,                                  getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public AggregateNode generalAggregate() throws ParseException, StandardException {,         Token                   aggToken;,         String                  methodAliasString;,    AggregateNode   aggExpr;,         ValueNode               value;,     aggToken = builtInAggregateType();,     jj_consume_token(LEFT_PAREN);,     aggExpr = aggregateExpression(aggName(aggToken), aggClass(aggToken));,     jj_consume_token(RIGHT_PAREN);,                 {if (true) return aggExpr;},     throw new Error("Missing return statement in function");,   }, , /*, ** All built in aggregates are pretty similar to user, ** defined aggregates, except we know what to map to, ** without looking up the class name., **, ** NOTE: COUNT is omitted here because the COUNT aggregate is, ** factored into a different rule, to distinguish between, ** COUNT(*) and COUNT(<expression>)., */,   final public Token builtInAggregateType() throws ParseException, StandardException {,         Token   retval;,     switch (jj_nt.kind) {,     case MAX:,       retval = jj_consume_token(MAX);,       break;,     case AVG:,       retval = jj_consume_token(AVG);,       break;,     case MIN:,       retval = jj_consume_token(MIN);,       break;,     case SUM:,       retval = jj_consume_token(SUM);,       break;,     default:,       jj_la1[223] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return retval;},     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode castSpecification() throws ParseException, StandardException {,         DataTypeDescriptor dts;,         ValueNode                value;,         int                              charType;,         int                              length = -1;,     TableName[]      udtName = new TableName[1];,     jj_consume_token(CAST);,     jj_consume_token(LEFT_PAREN);,     value = castOperand();,     jj_consume_token(AS);,     dts = dataTypeCast(udtName);,     jj_consume_token(RIGHT_PAREN);,         CastNode castNode = new CastNode(value, dts, getContextManager());,         castNode.setForExternallyGeneratedCASTnode();, ,         // Register the name token if it's a UDT in case we need to,         // rewrite the original statement text later (for example when,         // storing a CHECK constraint).,         castNode.setTargetUDTName(udtName[0]);, ,                 /* We need to generate a SQL->Java conversion tree above us if, 		 * the dataTypeCast is a user type., 		 */,         ValueNode treeTop = castNode;,                 if (dts.getTypeId().userType()),                 {,             treeTop = new JavaToSQLValueNode(,                             new SQLToJavaValueNode(,                                                                                         treeTop,,                                                                                         getContextManager()),,                                                         getContextManager());,                 }, ,                 {if (true) return treeTop;},     throw new Error("Missing return statement in function");,   }, , /**,  * Next value from a sequence object,  */,   final public ValueNode nextValueExpression() throws ParseException, StandardException {,         TableName sequenceName;,     jj_consume_token(NEXT);,     jj_consume_token(VALUE);,     jj_consume_token(FOR);,     sequenceName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         checkVersion(DataDictionary.DD_VERSION_DERBY_10_6, "NEXT VALUE");,         {if (true) return new NextSequenceNode(sequenceName, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="charOrVarchar">charOrVarchar</A>,  */,   final public int charOrVarchar() throws ParseException {,     switch (jj_nt.kind) {,     case CHAR:,       jj_consume_token(CHAR);,                 {if (true) return Types.CHAR;},       break;,     case VARCHAR:,       jj_consume_token(VARCHAR);,                 {if (true) return Types.VARCHAR;},       break;,     default:,       jj_la1[224] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ValueNode castOperand() throws ParseException, StandardException {,         ValueNode value;,     if (jj_2_65(1)) {,       value = additiveExpression(null, 0);,                 {if (true) return value;},     } else {,       switch (jj_nt.kind) {,       case NULL:,         jj_consume_token(NULL);,        {if (true) return new UntypedNullConstantNode(getContextManager());},         break;,       default:,         jj_la1[225] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dynamicParameterSpecification">dynamicParameterSpecification</A>,  */,   final public ParameterNode dynamicParameterSpecification() throws ParseException, StandardException {,     jj_consume_token(QUESTION_MARK);,                 {if (true) return makeParameterNode( );},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="whereClause">whereClause</A>,  */,   final public ValueNode whereClause(Token beginToken) throws ParseException, StandardException {,         ValueNode       value;,         Token           endToken;,     /* valueExpression() was searchCondition() */,             value = valueExpression();,                 endToken = getToken(0);, ,                 value.setBeginOffset( beginToken.endOffset + 1 );,                 value.setEndOffset( endToken.endOffset );, ,                 {if (true) return value;},     throw new Error("Missing return statement in function");,   }, ,   final public GroupByList groupByClause() throws ParseException, StandardException {,         GroupByList groupingCols;,     jj_consume_token(GROUP);,     jj_consume_token(BY);,     if (getToken(1).kind == ROLLUP &&,                             getToken(2).kind == LEFT_PAREN) {,       jj_consume_token(ROLLUP);,       jj_consume_token(LEFT_PAREN);,       groupingCols = groupingColumnReferenceList();,       jj_consume_token(RIGHT_PAREN);,                 groupingCols.setRollup();,                 {if (true) return groupingCols;},     } else if (jj_2_66(1)) {,       groupingCols = groupingColumnReferenceList();,                 {if (true) return groupingCols;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public GroupByList groupingColumnReferenceList() throws ParseException, StandardException {,     GroupByList groupingCols = new GroupByList(getContextManager());,     groupingColumnReference(groupingCols);,     label_31:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[226] = jj_gen;,         break label_31;,       },       jj_consume_token(COMMA);,       groupingColumnReference(groupingCols);,     },                 {if (true) return groupingCols;},     throw new Error("Missing return statement in function");,   }, ,   final public void groupingColumnReference(GroupByList groupingCols) throws ParseException, StandardException {,         ValueNode columnExpression;,     columnExpression = additiveExpression(null, 0);,                 /* Aggregates not allowed in group by */,                 HasNodeVisitor visitor =,                         new HasNodeVisitor(AggregateNode.class);,                 columnExpression.accept(visitor);,                 if (visitor.hasNode()),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_AGGREGATE_IN_GROUPBY_LIST);},                 }, ,         // Look for user-defined aggregates too. At the parsing stage,,         // they appear as function calls. Look for function calls,         // inside the expression and mark them so that at bind() time,         // we can reject them if they turn out to be user-defined aggregates,         // rather than ordinary function calls.,         CollectNodesVisitor<StaticMethodCallNode> functionSniffer =,             new CollectNodesVisitor<StaticMethodCallNode>(StaticMethodCallNode.class);,         columnExpression.accept( functionSniffer );,         for (StaticMethodCallNode node : functionSniffer.getList()),         {,             node.setAppearsInGroupBy();,         }, ,                 if (columnExpression.isParameterNode()),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "?");},                 },                 groupingCols.addGroupByColumn(,             new GroupByColumn(columnExpression, getContextManager()));,   }, ,   final public ValueNode havingClause() throws ParseException, StandardException {,         ValueNode value;,     jj_consume_token(HAVING);,     value = valueExpression();,                 {if (true) return value;},     throw new Error("Missing return statement in function");,   }, ,   final public WindowList windowClause() throws ParseException, StandardException {,     WindowList windows = new WindowList(getContextManager());,     jj_consume_token(WINDOW);,     windows = windowDefinition(windows);,     label_32:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[227] = jj_gen;,         break label_32;,       },       jj_consume_token(COMMA);,       windows = windowDefinition(windows);,     },                 {if (true) return windows;},     throw new Error("Missing return statement in function");,   }, ,   final public WindowList windowDefinition(WindowList wl) throws ParseException, StandardException {,         String windowName;,         OrderByList orderCols = null;,     windowName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     jj_consume_token(AS);,     jj_consume_token(LEFT_PAREN);,     switch (jj_nt.kind) {,     case ORDER:,       orderCols = orderByClause(null);,       break;,     default:,       jj_la1[228] = jj_gen;,       ;,     },     jj_consume_token(RIGHT_PAREN);,         wl.addWindow(new WindowDefinitionNode(,                          windowName, orderCols, getContextManager()));, ,                 {if (true) return wl;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="optimizerOverridePlan">optimizerOverridePlan</A>,  */,   final public OptimizerPlan optimizerOverridePlan() throws ParseException, StandardException {,     OptimizerPlan       optimizerOverridePlan;,     jj_consume_token(DERBYPLAN);,     optimizerOverridePlan = optimizerPlan();,         {if (true) return  optimizerOverridePlan;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="optimizerPlan">optimizerPlan</A>,  */,   final public OptimizerPlan optimizerPlan() throws ParseException, StandardException {,     OptimizerPlan       plan;,     if (getToken(1).kind == LEFT_PAREN) {,       plan = optimizerJoin();,         {if (true) return  plan;},     } else if (jj_2_67(1)) {,       plan = optimizerRowSource();,         {if (true) return plan;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="optimizerJoin">optimizerJoin</A>,  */,   final public OptimizerPlan optimizerJoin() throws ParseException, StandardException {,     JoinStrategy        strategy;,     OptimizerPlan       leftPlan;,     OptimizerPlan       rightPlan;,     jj_consume_token(LEFT_PAREN);,     leftPlan = optimizerPlan();,     strategy = joinStrategy();,     rightPlan = optimizerPlan();,     jj_consume_token(RIGHT_PAREN);,         {if (true) return new OptimizerPlan.Join( strategy, leftPlan, rightPlan );},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="joinStrategy">joinStrategy</A>,  */,   final public JoinStrategy joinStrategy() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case ASTERISK:,       jj_consume_token(ASTERISK);,         {if (true) return new NestedLoopJoinStrategy();},       break;,     case HASH:,       jj_consume_token(HASH);,         {if (true) return new HashJoinStrategy();},       break;,     default:,       jj_la1[229] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="optimizerRowSource">optimizerRowSource</A>,  */,   final public OptimizerPlan optimizerRowSource() throws ParseException, StandardException {,     TableName       sourceName = null;,         Token              leftParenToken = null;,     sourceName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     switch (jj_nt.kind) {,     case LEFT_PAREN:,       leftParenToken = jj_consume_token(LEFT_PAREN);,       jj_consume_token(RIGHT_PAREN);,       break;,     default:,       jj_la1[230] = jj_gen;,       ;,     },         if ( leftParenToken != null ),         {,             {if (true) return new OptimizerPlan.TableFunctionRS( sourceName.getSchemaName(), sourceName.getTableName() );},         },         else,         {,             {if (true) return new OptimizerPlan.ConglomerateRS( sourceName.getSchemaName(), sourceName.getTableName() );},         },     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode schemaDefinition() throws ParseException, StandardException {,         String  schemaName = null;,         String  authName = null;,     jj_consume_token(SCHEMA);,     if (jj_2_68(1)) {,       schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,       switch (jj_nt.kind) {,       case AUTHORIZATION:,         jj_consume_token(AUTHORIZATION);,         authName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         break;,       default:,         jj_la1[231] = jj_gen;,         ;,       },                         if (authName != null),                                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_2, "AUTHORIZATION");, ,                         if (schemaName.startsWith("SYS")),                                 {if (true) throw StandardException.newException(SQLState.INVALID_SCHEMA_SYS, schemaName);}, ,             {if (true) return new CreateSchemaNode(,                                         schemaName,,                                         authName,,                                         getContextManager(),                                         );},     } else {,       switch (jj_nt.kind) {,       case AUTHORIZATION:,         jj_consume_token(AUTHORIZATION);,         authName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                         checkVersion( DataDictionary.DD_VERSION_DERBY_10_2, "AUTHORIZATION");,                         if (authName.startsWith("SYS")),                                 {if (true) throw StandardException.newException(SQLState.INVALID_SCHEMA_SYS, authName);}, ,             {if (true) return new CreateSchemaNode(,                                         authName,,                                         authName,,                                         getContextManager(),                                         );},         break;,       default:,         jj_la1[232] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="roleDefinition">roleDefinition</A>,  */,   final public StatementNode roleDefinition() throws ParseException, StandardException {,         String  roleName = null;,     jj_consume_token(ROLE);,     roleName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_5, "ROLES");,                 checkSqlStandardAccess("CREATE ROLE");, ,                 // Reserve namespace for system roles,                 if (roleName.startsWith("SYS")) {,                         {if (true) throw StandardException.newException,                             (SQLState.INVALID_ROLE_SYS, roleName);},                 }, ,         {if (true) return new CreateRoleNode(roleName, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="sequenceDefinition">sequenceDefinition</A>,  */,   final public StatementNode sequenceDefinition() throws ParseException, StandardException {,         TableName qualifiedSequenceName = null;,         DataTypeDescriptor dtd =  null;,         Long initialValue = null;,         Long stepValue = null;,         Long maxValue = null;,         Long minValue = null;,     Boolean cycle = Boolean.FALSE;,     Object[] optionalClauses = new Object[ IDX_OPTION_COUNT ];,     jj_consume_token(SEQUENCE);,     qualifiedSequenceName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     label_33:,     while (true) {,       if (jj_2_69(1)) {,         ;,       } else {,         break label_33;,       },       sequenceGeneratorOption(optionalClauses);,     },                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_6, "SEQUENCES");, ,         if ( optionalClauses[ IDX_DATA_TYPE ] != null ),         { dtd = (DataTypeDescriptor) optionalClauses[ IDX_DATA_TYPE ]; }, ,         if ( optionalClauses[ IDX_START_WITH_OPTION ] != null ),         { initialValue = (Long) optionalClauses[ IDX_START_WITH_OPTION ]; }, ,         if ( optionalClauses[ IDX_INCREMENT_BY_OPTION ] != null ),         { stepValue = (Long) optionalClauses[ IDX_INCREMENT_BY_OPTION ]; }, ,         if (,                 (optionalClauses[ IDX_MAX_VALUE_OPTION ] != null) &&,                 ( !( optionalClauses[ IDX_MAX_VALUE_OPTION ] instanceof Boolean ) ),             ),         { maxValue = (Long) optionalClauses[ IDX_MAX_VALUE_OPTION ]; }, ,         if (,                 (optionalClauses[ IDX_MIN_VALUE_OPTION ] != null) &&,                 ( !( optionalClauses[ IDX_MIN_VALUE_OPTION ] instanceof Boolean ) ),             ),         { minValue = (Long) optionalClauses[ IDX_MIN_VALUE_OPTION ]; }, ,         if ( optionalClauses[ IDX_CYCLE_OPTION ] != null ),         { cycle = (Boolean) optionalClauses[ IDX_CYCLE_OPTION ]; }, ,         {if (true) return new CreateSequenceNode(,                         qualifiedSequenceName,,             dtd,,             initialValue,,             stepValue,,             maxValue,,             minValue,,             cycle.booleanValue(),,                         getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="sequenceGeneratorOption">sequenceGeneratorOption</A>,  */,   final public void sequenceGeneratorOption(Object[] optionalClauses) throws ParseException, StandardException {,     Object option =  null;,     int  optionIndex = -1;,     Boolean[] cycleOption = new Boolean[ 1 ];,     String optionName = null;,     Token optionToken = null;,     switch (jj_nt.kind) {,     case AS:,       optionToken = jj_consume_token(AS);,       option = exactIntegerType();,           optionIndex = IDX_DATA_TYPE;,       break;,     case START:,       optionToken = jj_consume_token(START);,       jj_consume_token(WITH);,       option = exactIntegerObject();,           optionIndex = IDX_START_WITH_OPTION;,       break;,     case INCREMENT:,       optionToken = jj_consume_token(INCREMENT);,       jj_consume_token(BY);,       option = exactIntegerObject();,           optionIndex = IDX_INCREMENT_BY_OPTION;,       break;,     default:,       jj_la1[235] = jj_gen;,       if (jj_2_70(1)) {,         switch (jj_nt.kind) {,         case MAXVALUE:,           optionToken = jj_consume_token(MAXVALUE);,           option = exactIntegerObject();,           break;,         default:,           jj_la1[233] = jj_gen;,           if (getToken( 2 ).kind == MAXVALUE) {,             jj_consume_token(NO);,             optionToken = jj_consume_token(MAXVALUE);,                                                 option = Boolean.FALSE;,           } else {,             jj_consume_token(-1);,             throw new ParseException();,           },         },           optionIndex = IDX_MAX_VALUE_OPTION;,       } else if (jj_2_71(1)) {,         switch (jj_nt.kind) {,         case MINVALUE:,           optionToken = jj_consume_token(MINVALUE);,           option = exactIntegerObject();,           break;,         default:,           jj_la1[234] = jj_gen;,           if (getToken( 2 ).kind == MINVALUE) {,             jj_consume_token(NO);,             optionToken = jj_consume_token(MINVALUE);,                                                 option = Boolean.FALSE;,           } else {,             jj_consume_token(-1);,             throw new ParseException();,           },         },           optionIndex = IDX_MIN_VALUE_OPTION;,       } else {,         switch (jj_nt.kind) {,         case NO:,         case CYCLE:,           optionToken = cycleClause(cycleOption);,             option = cycleOption[ 0 ];,             optionIndex = IDX_CYCLE_OPTION;,           break;,         default:,           jj_la1[236] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },     },         if ( optionIndex != -1 ),         {,             if ( optionalClauses[ optionIndex ] != null ),             {,                 {if (true) throw StandardException.newException( SQLState.LANG_DUPLICATE_CS_CLAUSE, optionToken.image );},             }, ,             optionalClauses[ optionIndex ] = option;,         },   }, , /*,  * <A NAME="cycleClause">cycleClause</A>,  */,   final public Token cycleClause(Boolean[] cycleOption) throws ParseException, StandardException {,     Token token = null;,     switch (jj_nt.kind) {,     case CYCLE:,       token = jj_consume_token(CYCLE);,         cycleOption[0] = Boolean.TRUE;,         {if (true) return token;},       break;,     case NO:,       jj_consume_token(NO);,       token = jj_consume_token(CYCLE);,         cycleOption[0] = Boolean.FALSE;,         {if (true) return token;},       break;,     default:,       jj_la1[237] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="exactIntegerObject">exactNumberObject</A>,  */,   final public Long exactIntegerObject() throws ParseException, StandardException {,         long exactNumeric;,     exactNumeric = exactNumber();,         {if (true) return Long.valueOf( exactNumeric );},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="stepValue">stepValue</A>,  */,   final public Long stepValue() throws ParseException, StandardException {,         long stepValue;,     jj_consume_token(INCREMENT);,     jj_consume_token(BY);,     stepValue = exactNumber();,         {if (true) return Long.valueOf( stepValue );},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dropSequenceStatement">dropSequenceStatement</A>,  */,   final public StatementNode dropSequenceStatement() throws ParseException, StandardException {,         TableName sequenceName;,     jj_consume_token(SEQUENCE);,     sequenceName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(RESTRICT);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_6, "SEQUENCES");, ,         {if (true) return new DropSequenceNode(sequenceName, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="tableDefinition">tableDefinition</A>,  */,   final public StatementNode tableDefinition() throws ParseException, StandardException {,         char                            lockGranularity = TableDescriptor.DEFAULT_LOCK_GRANULARITY;,         Properties                      properties = null;,         TableName                       tableName;,         TableElementList        tableElementList;,         ResultColumnList        resultColumns = null;,         ResultSetNode           queryExpression;,         boolean                         withData = true;,     jj_consume_token(TABLE);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     if (getToken(1).kind == LEFT_PAREN &&,                                getToken(3).kind != COMMA &&,                                getToken(3).kind != RIGHT_PAREN) {,       tableElementList = tableElementList();,       switch (jj_nt.kind) {,       case DERBYDASHPROPERTIES:,         properties = propertyList(false);,         jj_consume_token(CHECK_PROPERTIES);,         break;,       default:,         jj_la1[238] = jj_gen;,         ;,       },                 {if (true) return new CreateTableNode(,                                                                                 tableName,,                                                                                 tableElementList,,                                                                                 properties,,                                         lockGranularity,,                                                                                 getContextManager());},     } else {,       switch (jj_nt.kind) {,       case AS:,       case LEFT_PAREN:,         switch (jj_nt.kind) {,         case LEFT_PAREN:,           jj_consume_token(LEFT_PAREN);,           resultColumns = tableColumnList();,           jj_consume_token(RIGHT_PAREN);,           break;,         default:,           jj_la1[239] = jj_gen;,           ;,         },         jj_consume_token(AS);,         queryExpression = queryExpression(null, NO_SET_OP);,         jj_consume_token(WITH);,         switch (jj_nt.kind) {,         case NO:,           jj_consume_token(NO);,                                         withData = false;,           break;,         default:,           jj_la1[240] = jj_gen;,           ;,         },         jj_consume_token(DATA);,                                 // Raise error if WITH DATA is specified,                                 // (until it is implemented),                                 if (withData) {,                                         {if (true) throw StandardException.newException(,                                                 SQLState.NOT_IMPLEMENTED, "WITH DATA");},                                 },                                 /* Parameters not allowed in create table */,                                 HasNodeVisitor visitor =,                                         new HasNodeVisitor(ParameterNode.class);,                                 queryExpression.accept(visitor);,                                 if (visitor.hasNode()),                                 {,                                         {if (true) throw StandardException.newException(,                                                 SQLState.LANG_NO_PARAMS_IN_TABLES);},                                 }, ,                 {if (true) return new CreateTableNode(,                                                                                 tableName,,                                                                                 resultColumns,,                                                                                 queryExpression,,                                                                                 getContextManager());},         break;,       default:,         jj_la1[241] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, ,   final public ResultColumnList tableColumnList() throws ParseException, StandardException {,     ResultColumnList resultColumns = new ResultColumnList(getContextManager());,     columnNameList(resultColumns);,                 {if (true) return resultColumns;},     throw new Error("Missing return statement in function");,   }, , /*,  * This method is called when a comment starting with "--derby-properties" is,  * found.  Such a comment is a special directive to Derby and allows an SQL,  * statement to pass optimizer overrides. Derby looks for,  *,  *     propertyName = value* [, propertyName = value]*,  *,  * after "--derby-properties" and returns these properties in a Properties,  * object as a return value of this method.  If the parameter,  * "propertiesUseAllowed" is true, it indicates that users are allowed to,  * specify optimizer overrides in the given context.  False means optimizer,  * overrides in the given context are allowed internally only, e.g. by the,  * class org.apache.derby.impl.load.Import specifies the property,  * "insertMode=replace/bulkInsert" in the INSERT statement. This same property,  * will not be acceptable from an INSERT statement from a user SQL statement.,  */,   final public Properties propertyList(boolean propertiesUseAllowed) throws ParseException, StandardException {,         Properties properties = new FormatableProperties();,         StringTokenizer commaSeparatedProperties;,     jj_consume_token(DERBYDASHPROPERTIES);,         // First use StringTokenizer to get tokens which are delimited by,         // commas,         commaSeparatedProperties = new StringTokenizer(getToken(1).image, ",");, ,         while (commaSeparatedProperties.hasMoreTokens()) {, ,             // Now verify that tokens delimited by commas follow,             // "propertyName=value" pattern,             String currentProperty = commaSeparatedProperties.nextToken();, ,             // Use a new tokenizer to parse "propertyName=value". Let it,             // return the '=' delimiter as well.,             StringTokenizer equalOperatorSeparatedProperty =,                 new StringTokenizer(currentProperty, "=", true);, ,             if (equalOperatorSeparatedProperty.countTokens() != 3) {,                 // should see exactly three tokens: propertyName, '=' and,                 // value.,                 {if (true) throw StandardException.newException(,                     SQLState.PROPERTY_SYNTAX_INVALID);},             } else {,                 // ignore blanks around key,                 String key = equalOperatorSeparatedProperty.nextToken().trim();, ,                 if (!equalOperatorSeparatedProperty.nextToken().equals("=")) {,                     {if (true) throw StandardException.newException(,                         SQLState.PROPERTY_SYNTAX_INVALID);},                 }, ,                 // Also ignore blanks around value, canonize to upper case,                 // unless we have surrounding quotes.,                 String value =,                     equalOperatorSeparatedProperty.nextToken().trim();, ,                 verifyImageLength(value);, ,                 if (value.startsWith("'") && value.endsWith("'")) {,                     // Trim off the leading and trailing ', and compress all,                     // '' to ',                     value = StringUtil.compressQuotes(,                         value.substring(1, value.length() - 1), SINGLEQUOTES);,                 } else if (value.startsWith("\"") && value.endsWith("\"")) {,                     // Trim off the leading and trailing ", and compress all,                     // "" to ",                     value = StringUtil.compressQuotes(,                         value.substring(1, value.length() - 1), DOUBLEQUOTES);, ,                 } else {,                     value = value.toUpperCase();,                 }, ,                 // Do not allow user to specify multiple values for the same,                 // key.,                 if (properties.put(key, value) != null) {,                     {if (true) throw StandardException.newException(,                         SQLState.LANG_DUPLICATE_PROPERTY, key);},                 },             },         }, ,         // If this property override is supported in internal mode only, then,         // do that verification here.,         if (!propertiesUseAllowed) {,             checkInternalFeature("DERBY-PROPERTIES");,         }, ,         {if (true) return properties;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="DB2lockGranularityClause">DB2lockGranularityClause</A>,  */,   final public char DB2lockGranularityClause() throws ParseException, StandardException {,         char lockGranularity;,     jj_consume_token(LOCKSIZE);,     lockGranularity = lockGranularity();,                 {if (true) return lockGranularity;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="lockGranularity">lockGranularity</A>,  */,   final public char lockGranularity() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case TABLE:,       jj_consume_token(TABLE);,                 {if (true) return TableDescriptor.TABLE_LOCK_GRANULARITY;},       break;,     case ROW:,       jj_consume_token(ROW);,                 {if (true) return TableDescriptor.ROW_LOCK_GRANULARITY;},       break;,     default:,       jj_la1[242] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="indexDefinition">indexDefinition</A>,  */,   final public StatementNode indexDefinition() throws ParseException, StandardException {,         Boolean         unique = Boolean.FALSE;,         Properties      properties = null;,         TableName       indexName;,         TableName       tableName;,         ArrayList<String> indexColumnList = new ArrayList<String>();,     switch (jj_nt.kind) {,     case UNIQUE:,       unique = unique();,       break;,     default:,       jj_la1[243] = jj_gen;,       ;,     },     jj_consume_token(INDEX);,     indexName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(ON);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(LEFT_PAREN);,     indexColumnList(indexColumnList);,     jj_consume_token(RIGHT_PAREN);,     switch (jj_nt.kind) {,     case DERBYDASHPROPERTIES:,       properties = propertyList(false);,       jj_consume_token(CHECK_PROPERTIES);,       break;,     default:,       jj_la1[244] = jj_gen;,       ;,     },                 /* User allowed to specify schema name on table and index., 		 * If no schema name specified for index, then it "inherits" , 		 * its schema name from the table., 		 * If index has a schema name and table does not, then, 		 * table "inherits" its schema name from the index., 		 * If schema names are specified for both objects, then the, 		 * schema names must be the same., 		 */,                 if (indexName.getSchemaName() == null),                 {,                         indexName.setSchemaName(tableName.getSchemaName());,                 },                 else if (tableName.getSchemaName() == null),                 {,                         tableName.setSchemaName(indexName.getSchemaName());,                 },                 else,                 {,                         /* schema name specified for both */,                         if (! (indexName.getSchemaName().equals(,                                                 tableName.getSchemaName()))),                         {,                                 {if (true) throw StandardException.newException(SQLState.LANG_INDEX_AND_TABLE_IN_DIFFERENT_SCHEMAS,,                                                         indexName,,                                                         tableName);},                         },                 },         {if (true) return new CreateIndexNode(,                                 unique.booleanValue(),,                                                                 DEFAULT_INDEX_TYPE,,                                                                 indexName,,                                                                 tableName,,                                                                 indexColumnList,,                                                                 properties,,                                                                 getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="unique">unique</A>,  */,   final public Boolean unique() throws ParseException, StandardException {,     jj_consume_token(UNIQUE);,                 {if (true) return Boolean.TRUE;},     throw new Error("Missing return statement in function");,   }, , /**, 	CREATE PROCEDURE, , 	procedureElements contains the description of the procedure., 	(CREATE FUNCTIONS shares this lyout), see functionDefinition, , 	0 - Object[] 3 element array for parameters, 	1 - TableName - specific name, 	2 - Integer - dynamic result set count, 	3 - String language (always java) - ignore, 	4 - String external name (also passed directly to create alias node - ignore, 	5 - Short parameter style (always java) - ignore , 	6 - Short - SQL allowed., 	7 - Boolean - CALLED ON NULL INPUT (always TRUE for procedures), 	8 - TypeDescriptor - return type (always NULL for procedures), */,   final public StatementNode procedureDefinition() throws ParseException, StandardException {,         TableName procedureName;,         Object[] procedureElements = new Object[CreateAliasNode.ROUTINE_ELEMENT_COUNT];,     jj_consume_token(PROCEDURE);,     procedureName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     procedureElements[0] = procedureParameterList(procedureElements);,     label_34:,     while (true) {,       routineElement(true, false, procedureElements);,       switch (jj_nt.kind) {,       case EXTERNAL:,       case NO:,       case NOT:,       case CALLED:,       case CONTAINS:,       case DETERMINISTIC:,       case DYNAMIC:,       case LANGUAGE:,       case MODIFIES:,       case RETURNS:,       case PARAMETER:,       case READS:,       case RESULT:,       case SPECIFIC:,         ;,         break;,       default:,         jj_la1[245] = jj_gen;,         break label_34;,       },     },                     checkRequiredRoutineClause(JAVA_ROUTINE_CLAUSES, procedureElements);, ,                         {if (true) return getCreateAliasNode(,                                                         procedureName,,                                                         (String) procedureElements[ CreateAliasNode.EXTERNAL_NAME ],,                                                         procedureElements,,                             AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR);},     throw new Error("Missing return statement in function");,   }, ,   final public void routineElement(boolean isProcedure, boolean isTableFunction, Object[] routineElements) throws ParseException, StandardException {,         int drs;,         int clausePosition = -1;,         Object clauseValue = null;,     switch (jj_nt.kind) {,     case SPECIFIC:,       jj_consume_token(SPECIFIC);,       clauseValue = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,                           clausePosition = CreateAliasNode.TABLE_NAME; {if (true) throw StandardException.newException(SQLState.NOT_IMPLEMENTED, "SPECIFIC identifier");},       break;,     case DYNAMIC:,     case RESULT:,       switch (jj_nt.kind) {,       case DYNAMIC:,         jj_consume_token(DYNAMIC);,         break;,       default:,         jj_la1[246] = jj_gen;,         ;,       },       jj_consume_token(RESULT);,       jj_consume_token(SETS);,       drs = uint_value();,                         if (!isProcedure),                                 {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "RESULT SETS");},                         clauseValue = ReuseFactory.getInteger(drs); clausePosition = CreateAliasNode.DYNAMIC_RESULT_SET_COUNT;,       break;,     case LANGUAGE:,       jj_consume_token(LANGUAGE);,       jj_consume_token(JAVA);,                                      clauseValue = "JAVA"; clausePosition = CreateAliasNode.LANGUAGE;,       break;,     case DETERMINISTIC:,       jj_consume_token(DETERMINISTIC);,             clauseValue = Boolean.TRUE;,             clausePosition = CreateAliasNode.DETERMINISTIC;,             checkVersion(DataDictionary.DD_VERSION_DERBY_10_5, "DETERMINISTIC");,       break;,     case NOT:,       jj_consume_token(NOT);,       jj_consume_token(DETERMINISTIC);,             clauseValue = Boolean.FALSE;,             clausePosition = CreateAliasNode.DETERMINISTIC;,             checkVersion(DataDictionary.DD_VERSION_DERBY_10_5, "DETERMINISTIC");,       break;,     case EXTERNAL:,       jj_consume_token(EXTERNAL);,       switch (jj_nt.kind) {,       case NAME:,         jj_consume_token(NAME);,         clauseValue = string();,               clausePosition = CreateAliasNode.EXTERNAL_NAME;,         break;,       case SECURITY:,         jj_consume_token(SECURITY);,                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_7,,                             "EXTERNAL SECURITY");,                 checkSqlStandardAccess("EXTERNAL SECURITY");,                 clauseValue = new Boolean(routineSecurityClause());,                 clausePosition = CreateAliasNode.ROUTINE_SECURITY_DEFINER;,         break;,       default:,         jj_la1[247] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     case PARAMETER:,       jj_consume_token(PARAMETER);,       jj_consume_token(STYLE);,       clauseValue = parameterStyle(isTableFunction);,                                                                                       clausePosition = CreateAliasNode.PARAMETER_STYLE;,       break;,     case NO:,       jj_consume_token(NO);,       jj_consume_token(SQL);,                                                           clauseValue = ReuseFactory.getShort(RoutineAliasInfo.NO_SQL); clausePosition = CreateAliasNode.SQL_CONTROL;,       break;,     case CONTAINS:,       jj_consume_token(CONTAINS);,       jj_consume_token(SQL);,                                                   clauseValue = ReuseFactory.getShort(RoutineAliasInfo.CONTAINS_SQL); clausePosition = CreateAliasNode.SQL_CONTROL;,       break;,     case READS:,       jj_consume_token(READS);,       jj_consume_token(SQL);,       jj_consume_token(DATA);,                                           clauseValue = ReuseFactory.getShort(RoutineAliasInfo.READS_SQL_DATA); clausePosition = CreateAliasNode.SQL_CONTROL;,       break;,     case MODIFIES:,       jj_consume_token(MODIFIES);,       jj_consume_token(SQL);,       jj_consume_token(DATA);,                         if (!isProcedure),                                 {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MODIFIES SQL DATA");},                         clauseValue = ReuseFactory.getShort(RoutineAliasInfo.MODIFIES_SQL_DATA); clausePosition = CreateAliasNode.SQL_CONTROL;,       break;,     case CALLED:,     case RETURNS:,       clauseValue = calledOnNullInput(isProcedure);,                                                            clausePosition = CreateAliasNode.NULL_ON_NULL_INPUT;,       break;,     default:,       jj_la1[248] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 if (clausePosition != -1) {,                         // check for repeated clause,                         if (routineElements[clausePosition] != null) {, ,                                 String which = ROUTINE_CLAUSE_NAMES[clausePosition];,                                 {if (true) throw StandardException.newException(SQLState.LANG_DB2_MULTIPLE_ELEMENTS, which);},                         }, ,                         routineElements[clausePosition] = clauseValue;,                 },   }, ,   final public Boolean calledOnNullInput(boolean isProcedure) throws ParseException, StandardException {,         Boolean calledOnNull;,     switch (jj_nt.kind) {,     case CALLED:,       jj_consume_token(CALLED);,                            calledOnNull = Boolean.TRUE;,       break;,     case RETURNS:,       jj_consume_token(RETURNS);,       jj_consume_token(NULL);,                    if (isProcedure),                      {if (true) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,,                              "RETURNS NULL ON NULL INPUT");}, ,                    calledOnNull = Boolean.FALSE;,       break;,     default:,       jj_la1[249] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     jj_consume_token(ON);,     jj_consume_token(NULL);,     jj_consume_token(INPUT);,                 {if (true) return calledOnNull;},     throw new Error("Missing return statement in function");,   }, ,   final public boolean routineSecurityClause() throws ParseException, StandardException {,     boolean result = false;,     switch (jj_nt.kind) {,     case INVOKER:,       jj_consume_token(INVOKER);,                     result = false;,       break;,     case DEFINER:,       jj_consume_token(DEFINER);,                     result = true;,       break;,     default:,       jj_la1[250] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },         {if (true) return result;},     throw new Error("Missing return statement in function");,   }, ,   final public Short parameterStyle(boolean isTableFunction) throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case JAVA:,       jj_consume_token(JAVA);,               if ( isTableFunction ),               { {if (true) throw StandardException.newException( SQLState.LANG_MUST_BE_DJRS );} }, ,               {if (true) return ReuseFactory.getShort(RoutineAliasInfo.PS_JAVA);},       break;,     case DERBY_JDBC_RESULT_SET:,       jj_consume_token(DERBY_JDBC_RESULT_SET);,               if ( !isTableFunction ),               { {if (true) throw StandardException.newException( SQLState.LANG_NO_DJRS );} }, ,               {if (true) return ReuseFactory.getShort(RoutineAliasInfo.PS_DERBY_JDBC_RESULT_SET);},       break;,     case DERBY:,       jj_consume_token(DERBY);,           checkVersion(DataDictionary.DD_VERSION_DERBY_10_10, "DERBY");, ,               if ( isTableFunction ),               { {if (true) throw StandardException.newException( SQLState.LANG_MUST_BE_DJRS );} }, ,               {if (true) return ReuseFactory.getShort( RoutineAliasInfo.PS_DERBY );},       break;,     default:,       jj_la1[251] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public Object[] procedureParameterList(Object[] procedureElements) throws ParseException, StandardException {,     List<String>    names = new ArrayList<String>();,     List<TypeDescriptor>    types = new ArrayList<TypeDescriptor>();,     List<Integer>    inOut = new ArrayList<Integer>();,     Object[]         result = new Object[ 3 ];,     Boolean ellipsis = null;,     jj_consume_token(LEFT_PAREN);,     if (jj_2_72(1)) {,       procedureParameterDefinition(names, types, inOut);,       label_35:,       while (true) {,         switch (jj_nt.kind) {,         case COMMA:,           ;,           break;,         default:,           jj_la1[252] = jj_gen;,           break label_35;,         },         jj_consume_token(COMMA);,         procedureParameterDefinition(names, types, inOut);,       },       switch (jj_nt.kind) {,       case ELLIPSIS:,         ellipsis = ellipsis();,         break;,       default:,         jj_la1[253] = jj_gen;,         ;,       },     } else {,       ;,     },     jj_consume_token(RIGHT_PAREN);,         procedureElements[ CreateAliasNode.VARARGS ] = ellipsis;, ,         result[ 0 ] = names;,         result[ 1 ] = types;,         result[ 2 ] = inOut;, ,                 {if (true) return result;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="Definition">procedureParameterDefinition</A>,  */,   final public void procedureParameterDefinition(List<String> names,,     List<TypeDescriptor>    types,,     List<Integer>    inOut) throws ParseException, StandardException {,         DataTypeDescriptor      typeDescriptor;,         String                          parameterName = "";,         Integer                         inout;,     inout = inoutParameter();,     if (dataTypeCheck(2)) {,       parameterName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     } else {,       ;,     },     typeDescriptor = dataTypeDDL();,                 names.add(parameterName);,                 types.add(typeDescriptor.getCatalogType());,                 inOut.add(inout);,   }, ,   final public Integer inoutParameter() throws ParseException {,     int mode = ParameterMetaData.parameterModeIn;,     switch (jj_nt.kind) {,     case IN:,     case INOUT:,     case OUT:,       switch (jj_nt.kind) {,       case IN:,         jj_consume_token(IN);, ,         break;,       case OUT:,         jj_consume_token(OUT);,                   mode = ParameterMetaData.parameterModeOut;,         break;,       case INOUT:,         jj_consume_token(INOUT);,                     mode = ParameterMetaData.parameterModeInOut;,         break;,       default:,         jj_la1[254] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[255] = jj_gen;,       ;,     },           {if (true) return ReuseFactory.getInteger(mode);},     throw new Error("Missing return statement in function");,   }, , /**, 	CREATE FUNCTION, , 	functionElements contains the description of the function., , 	0 - Object[] 3 element array for parameters, 	1 - TableName - specific name, 	2 - Integer - dynamic result set count - always 0, 	3 - String language (always java) - required to be set, 	4 - String external name (also passed directly to create alias node - ignore, 	5 - Short parameter style (always java) - required to be set , 	6 - Short - SQL allowed., 	7 - Boolean - CALLED ON NULL INPUT, 	8 - TypeDescriptor - return type, */,   final public StatementNode functionDefinition() throws ParseException, StandardException {,         TableName functionName;,         TypeDescriptor  returnType;,         Object[] functionElements = new Object[CreateAliasNode.ROUTINE_ELEMENT_COUNT];,     jj_consume_token(FUNCTION);,     functionName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     functionElements[0] = functionParameterList(functionElements);,     jj_consume_token(RETURNS);,     returnType = functionReturnDataType();,     label_36:,     while (true) {,       routineElement(false, returnType.isRowMultiSet(), functionElements);,       switch (jj_nt.kind) {,       case EXTERNAL:,       case NO:,       case NOT:,       case CALLED:,       case CONTAINS:,       case DETERMINISTIC:,       case DYNAMIC:,       case LANGUAGE:,       case MODIFIES:,       case RETURNS:,       case PARAMETER:,       case READS:,       case RESULT:,       case SPECIFIC:,         ;,         break;,       default:,         jj_la1[256] = jj_gen;,         break label_36;,       },     },                     functionElements[CreateAliasNode.RETURN_TYPE] = returnType;,                     checkRequiredRoutineClause(JAVA_ROUTINE_CLAUSES, functionElements);, ,                         {if (true) return getCreateAliasNode(,                                                         functionName,,                                                         (String) functionElements[CreateAliasNode.EXTERNAL_NAME],,                                                         functionElements,,                             AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR);},     throw new Error("Missing return statement in function");,   }, ,   final public Object[] functionParameterList(Object[] functionElements) throws ParseException, StandardException {,     List<String>    names = new ArrayList<String>();,     List<TypeDescriptor>    types = new ArrayList<TypeDescriptor>();,     List<Integer>    inOut = new ArrayList<Integer>(); // in/out - ALWAYS IN,     Object[]         result = new Object[ 3 ];,     Boolean ellipsis = null;,     jj_consume_token(LEFT_PAREN);,     if (jj_2_73(1)) {,       functionParameterDefinition(names, types,inOut);,       label_37:,       while (true) {,         switch (jj_nt.kind) {,         case COMMA:,           ;,           break;,         default:,           jj_la1[257] = jj_gen;,           break label_37;,         },         jj_consume_token(COMMA);,         functionParameterDefinition(names, types,inOut);,       },       switch (jj_nt.kind) {,       case ELLIPSIS:,         ellipsis = ellipsis();,         break;,       default:,         jj_la1[258] = jj_gen;,         ;,       },     } else {,       ;,     },     jj_consume_token(RIGHT_PAREN);,         functionElements[ CreateAliasNode.VARARGS ] = ellipsis;, ,         result[ 0 ] = names;,         result[ 1 ] = types;,         result[ 2 ] = inOut;, ,                 {if (true) return result;},     throw new Error("Missing return statement in function");,   }, ,   final public Boolean ellipsis() throws ParseException, StandardException {,     jj_consume_token(ELLIPSIS);,         checkVersion( DataDictionary.DD_VERSION_DERBY_10_10, "..." );,         {if (true) return Boolean.TRUE;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="Definition">functionParameterDefinition</A>,  */,   final public void functionParameterDefinition(List<String>    names,,     List<TypeDescriptor>    types,,     List<Integer>    inOut) throws ParseException, StandardException {,         DataTypeDescriptor      typeDescriptor;,         String                          parameterName = "";,     if (dataTypeCheck(2)) {,       parameterName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     } else {,       ;,     },     typeDescriptor = dataTypeDDL();,                 names.add(parameterName);,                 types.add(typeDescriptor.getCatalogType());,         inOut.add(ReuseFactory.getInteger(ParameterMetaData.parameterModeIn));,   }, , /*,  * <A NAME="functionReturnDataType">functionReturnDataType</A>,  */,   final public TypeDescriptor functionReturnDataType() throws ParseException, StandardException {,     TypeDescriptor      typeDescriptor;,     if (jj_2_74(1)) {,       typeDescriptor = catalogType();,     } else {,       switch (jj_nt.kind) {,       case TABLE:,         typeDescriptor = functionTableType();,         break;,       default:,         jj_la1[259] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },         {if (true) return typeDescriptor;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="functionTableType">functionTableType</A>,  */,   final public TypeDescriptor functionTableType() throws ParseException, StandardException {,         ArrayList<String>                       names = new ArrayList<String>();,         ArrayList<TypeDescriptor>          types = new ArrayList<TypeDescriptor>();,         String[]                          nameArray;,         TypeDescriptor[]        typeArray;,         int                                     columnCount;,     jj_consume_token(TABLE);,     jj_consume_token(LEFT_PAREN);,     functionTableReturnColumn(names, types);,     label_38:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[260] = jj_gen;,         break label_38;,       },       jj_consume_token(COMMA);,       functionTableReturnColumn(names, types);,     },     jj_consume_token(RIGHT_PAREN);,         checkVersion( DataDictionary.DD_VERSION_DERBY_10_4, "CREATE FUNCTION...RETURNS TABLE");, ,                 columnCount = names.size();,                 nameArray = new String[ columnCount ];,                 names.toArray( nameArray );,                 typeArray = new TypeDescriptor[ columnCount ];,                 types.toArray( typeArray );, ,                 //,                 // We do not allow XML as a column datatype because,                 // Derby does not yet support the streaming JDBC4,                 // interfaces to XML values.,                 //,                 for ( int i = 0; i < columnCount; i++ ),                 {,             if ( typeArray[ i ].getJDBCTypeId() == Types.SQLXML ),                     { {if (true) throw StandardException.newException( SQLState.LANG_XML_NOT_ALLOWED_DJRS );} },                 }, ,                 {if (true) return DataTypeDescriptor.getRowMultiSet( nameArray, typeArray );},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="functionTableReturnColumn">functionTableReturnColumn</A>,  */,   final public void functionTableReturnColumn(ArrayList<String> names,,     ArrayList<TypeDescriptor> types) throws ParseException, StandardException {,         String                          name;,         DataTypeDescriptor      typeDescriptor;,     name = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     typeDescriptor = dataTypeDDL();,                 names.add( name );,                 types.add( typeDescriptor.getCatalogType() );,   }, , /**, 	CREATE TYPE, */,   final public StatementNode udtDefinition() throws ParseException, StandardException {,         TableName udtName;,         String externalName;,     jj_consume_token(TYPE);,     udtName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(EXTERNAL);,     jj_consume_token(NAME);,     externalName = string();,     jj_consume_token(LANGUAGE);,     jj_consume_token(JAVA);,                         checkVersion(DataDictionary.DD_VERSION_DERBY_10_6, "CREATE TYPE");,                         {if (true) return getCreateAliasNode(,                                                         udtName,,                                                         externalName,,                                                         null,,                             AliasInfo.ALIAS_TYPE_UDT_AS_CHAR);},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode aggregateDefinition() throws ParseException, StandardException {,         TableName aggregateName;,     DataTypeDescriptor  forType;,     DataTypeDescriptor  returnType = null;,         Object[] aggElements = new Object[CreateAliasNode.AGG_ELEMENT_COUNT];,         String externalName;,     jj_consume_token(DERBY);,     jj_consume_token(AGGREGATE);,     aggregateName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(FOR);,     forType = dataTypeDDL();,     switch (jj_nt.kind) {,     case RETURNS:,       jj_consume_token(RETURNS);,       returnType = dataTypeDDL();,       break;,     default:,       jj_la1[261] = jj_gen;,       ;,     },     jj_consume_token(EXTERNAL);,     jj_consume_token(NAME);,     externalName = string();,             checkVersion(DataDictionary.DD_VERSION_DERBY_10_10, "CREATE DERBY AGGREGATE");, ,             if ( returnType == null ) { returnType = forType; },             aggElements[ CreateAliasNode.AGG_FOR_TYPE ] = forType.getCatalogType();,             aggElements[ CreateAliasNode.AGG_RETURN_TYPE ] = returnType.getCatalogType();, ,             {if (true) return getCreateAliasNode,             (,                 aggregateName,,                 externalName,,                 aggElements,,                 AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR,             );},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode viewDefinition(Token beginToken) throws ParseException, StandardException {,         int                                     checkOptionType;,         ResultColumnList        resultColumns = null;,         ResultSetNode           queryExpression;,         TableName                       tableName;,         Token                           checkTok = null;,         Token                           endToken;,         OrderByList         orderCols = null;,     ValueNode[] offsetClauses = new ValueNode[ OFFSET_CLAUSE_COUNT ];,     boolean     hasJDBClimitClause = false;,     jj_consume_token(VIEW);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     switch (jj_nt.kind) {,     case LEFT_PAREN:,       jj_consume_token(LEFT_PAREN);,       resultColumns = viewColumnList();,       jj_consume_token(RIGHT_PAREN);,       break;,     default:,       jj_la1[262] = jj_gen;,       ;,     },     jj_consume_token(AS);,     queryExpression = queryExpression(null, NO_SET_OP);,     switch (jj_nt.kind) {,     case ORDER:,       orderCols = orderByClause(queryExpression);,       break;,     default:,       jj_la1[263] = jj_gen;,       ;,     },     hasJDBClimitClause = offsetFetchFirstClause(offsetClauses);,                 checkOptionType = ViewDescriptor.NO_CHECK_OPTION;,                 endToken = getToken(0);,                 /* Parameters not allowed in create view */,                 HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);,                 queryExpression.accept(visitor);,                 if (visitor.hasNode()),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_NO_PARAMS_IN_VIEWS);},                 }, ,         {if (true) return new CreateViewNode(,                                                                 tableName,,                                                                 resultColumns,,                                                                 queryExpression,,                                 checkOptionType,,                                                                 StringUtil.slice(statementSQLText,,                                                                                                 beginToken.beginOffset,,                                                                                                 endToken.endOffset,false),,                                                                 orderCols,,                                 offsetClauses[ OFFSET_CLAUSE ],,                                 offsetClauses[ FETCH_FIRST_CLAUSE ],,                                 hasJDBClimitClause,,                                                                 getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public ResultColumnList viewColumnList() throws ParseException, StandardException {,     ResultColumnList resultColumns = new ResultColumnList(getContextManager());,     columnNameList(resultColumns);,                 {if (true) return resultColumns;},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode triggerDefinition() throws ParseException, StandardException {,         Boolean                         isBefore;,         Boolean                         isRow = Boolean.FALSE;  // STATEMENT implicit by default,         TableName                       tableName;,         TableName                       triggerName;,         Token[]                         tokenHolder = new Token[1];,         Token                           beginToken;,         Token                           checkTok = null;,         Token                           endToken;,         int                                     actionBegin;,         int                                     actionEnd;,         int                                     triggerEvent;,     StatementNode       actionNode;,     ResultColumnList    triggerColumns =,                         new ResultColumnList(getContextManager());,     List<TriggerReferencingStruct> refClause = null;,     ValueNode whenClause = null;,     Token whenOpen = null;,     Token whenClose = null;,     jj_consume_token(TRIGGER);,     triggerName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     isBefore = beforeOrAfter();,     triggerEvent = triggerEvent(triggerColumns);,     jj_consume_token(ON);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     switch (jj_nt.kind) {,     case REFERENCING:,       refClause = triggerReferencingClause();,       break;,     default:,       jj_la1[264] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case FOR:,       jj_consume_token(FOR);,       jj_consume_token(EACH);,       isRow = rowOrStatement();,       break;,     default:,       jj_la1[265] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case MODE:,       jj_consume_token(MODE);,       jj_consume_token(DB2SQL);,       break;,     default:,       jj_la1[266] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case WHEN:,       jj_consume_token(WHEN);,       whenOpen = jj_consume_token(LEFT_PAREN);,       whenClause = valueExpression();,       whenClose = jj_consume_token(RIGHT_PAREN);,       break;,     default:,       jj_la1[267] = jj_gen;,       ;,     },     //we are not top level statement,                     actionNode = proceduralStatement(tokenHolder);,                 actionEnd = getToken(0).endOffset;,                 actionBegin = tokenHolder[0].beginOffset;, ,                 // No DML in action node for BEFORE triggers.,                 if (isBefore.booleanValue() && (actionNode instanceof DMLModStatementNode)) {,                                 {if (true) throw StandardException.newException(,                                         SQLState.LANG_UNSUPPORTED_TRIGGER_STMT,,                                         ((StatementNode) actionNode).statementToString(), "BEFORE");},                                         }, , ,                 // no params in trigger action,                 HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);,                 actionNode.accept(visitor);,         if (whenClause != null) {,             whenClause.accept(visitor);,         },                 if (visitor.hasNode()),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_NO_PARAMS_IN_TRIGGER_ACTION);},                 }, ,         String actionText = StringUtil.slice(,                 statementSQLText, actionBegin, actionEnd, false);, ,         String whenText = null;,         int whenOffset = 0;,         if (whenClause != null) {,             // The WHEN clause is only supported if the dictionary version is,             // 10.11 or higher.,             checkVersion(DataDictionary.DD_VERSION_DERBY_10_11, "WHEN");,             whenOffset = whenOpen.endOffset + 1;,             whenText = StringUtil.slice(statementSQLText,,                     whenOffset, whenClose.beginOffset - 1, false);,         }, ,         {if (true) return new CreateTriggerNode(,                                                                 triggerName,,                                                                 tableName,,                                 triggerEvent,,                                                                 triggerColumns,,                                 isBefore.booleanValue(),,                                 isRow.booleanValue(),,                                 true,        // enabled,                                 refClause,   // referencing clause,                                 whenClause,  // when clause node,                                 whenText,    // when clause text,                                 whenOffset,,                                                                 actionNode,,                                 actionText,,                                 actionBegin,,                                                                 getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode synonymDefinition() throws ParseException, StandardException {,         TableName synonymName;,         TableName targetName;,     jj_consume_token(SYNONYM);,     synonymName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(FOR);,     targetName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_1,,                              "CREATE SYNONYM");, ,                 {if (true) return getCreateAliasNode,                         (,                                 synonymName,,                                 targetName,,                                 null,,                 AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR,                         );},     throw new Error("Missing return statement in function");,   }, ,   final public Boolean beforeOrAfter() throws ParseException {,     switch (jj_nt.kind) {,     case NO:,       jj_consume_token(NO);,       jj_consume_token(CASCADE);,       jj_consume_token(BEFORE);,                 {if (true) return Boolean.TRUE;},       break;,     case AFTER:,       jj_consume_token(AFTER);,                 {if (true) return Boolean.FALSE;},       break;,     default:,       jj_la1[268] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public int triggerEvent(ResultColumnList rcl) throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case INSERT:,       jj_consume_token(INSERT);,                 {if (true) return TriggerDescriptor.TRIGGER_EVENT_INSERT;},       break;,     case DELETE:,       jj_consume_token(DELETE);,                 {if (true) return TriggerDescriptor.TRIGGER_EVENT_DELETE;},       break;,     case UPDATE:,       jj_consume_token(UPDATE);,       switch (jj_nt.kind) {,       case OF:,         jj_consume_token(OF);,         columnNameList(rcl);,         break;,       default:,         jj_la1[269] = jj_gen;,         ;,       },                 {if (true) return TriggerDescriptor.TRIGGER_EVENT_UPDATE;},       break;,     default:,       jj_la1[270] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public Boolean rowOrStatement() throws ParseException {,     switch (jj_nt.kind) {,     case ROW:,       token = jj_consume_token(ROW);,                 {if (true) return Boolean.TRUE;},       break;,     case STATEMENT:,       token = jj_consume_token(STATEMENT);,                 {if (true) return Boolean.FALSE;},       break;,     default:,       jj_la1[271] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public List<TriggerReferencingStruct> triggerReferencingClause() throws ParseException, StandardException {,         ArrayList<TriggerReferencingStruct> expressions = new ArrayList<TriggerReferencingStruct>();,     jj_consume_token(REFERENCING);,     triggerReferencingExpression(expressions);,     label_39:,     while (true) {,       switch (jj_nt.kind) {,       case NEW:,       case NEW_TABLE:,       case OLD:,       case OLD_TABLE:,         ;,         break;,       default:,         jj_la1[272] = jj_gen;,         break label_39;,       },       triggerReferencingExpression(expressions);,     },                 {if (true) return expressions;},     throw new Error("Missing return statement in function");,   }, ,   final public void triggerReferencingExpression(List<TriggerReferencingStruct> expressions) throws ParseException, StandardException {,         String  identifier;,         boolean isNew = true;,         boolean isRow = true;,     switch (jj_nt.kind) {,     case NEW:,       jj_consume_token(NEW);,       switch (jj_nt.kind) {,       case TABLE:,       case ROW:,         switch (jj_nt.kind) {,         case ROW:,           jj_consume_token(ROW);,           break;,         case TABLE:,           jj_consume_token(TABLE);,                                     isRow = false;,           break;,         default:,           jj_la1[273] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         break;,       default:,         jj_la1[274] = jj_gen;,         ;,       },       break;,     case OLD:,       jj_consume_token(OLD);,                  isNew = false;,       switch (jj_nt.kind) {,       case TABLE:,       case ROW:,         switch (jj_nt.kind) {,         case ROW:,           jj_consume_token(ROW);,           break;,         case TABLE:,           jj_consume_token(TABLE);,                                                      isRow = false;,           break;,         default:,           jj_la1[275] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         break;,       default:,         jj_la1[276] = jj_gen;,         ;,       },       break;,     case NEW_TABLE:,       jj_consume_token(NEW_TABLE);,                         isRow = false;,       break;,     case OLD_TABLE:,       jj_consume_token(OLD_TABLE);,                         isNew = false; isRow = false;,       break;,     default:,       jj_la1[277] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     jj_consume_token(AS);,     identifier = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 expressions.add(new TriggerReferencingStruct(isRow, isNew, identifier));,   }, , /*,  * <A NAME="defaultClause">defaultClause</A>,  */,   final public ValueNode defaultClause(long[] autoIncrementInfo, String columnName) throws ParseException, StandardException {,         ValueNode       value;,         Token           beginToken;,         Token           endToken;,     switch (jj_nt.kind) {,     case _DEFAULT:,     case WITH:,       switch (jj_nt.kind) {,       case WITH:,         jj_consume_token(WITH);,         break;,       default:,         jj_la1[278] = jj_gen;,         ;,       },       beginToken = jj_consume_token(_DEFAULT);,       value = defaultOption(beginToken, autoIncrementInfo, columnName);,                 {if (true) return value;},       break;,     case GENERATED:,       value = generatedColumnOption(autoIncrementInfo);,                 {if (true) return value;},       break;,     default:,       jj_la1[279] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="defaultNullOnlyClause">defaultNullOnlyClause</A>,  */,   final public ValueNode defaultNullOnlyClause() throws ParseException, StandardException {,     jj_consume_token(_DEFAULT);,     jj_consume_token(NULL);,        {if (true) return new UntypedNullConstantNode(getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="generatedColumnOption">generatedColumnOption</A>,  */, , //ToCleanUp, //A specific class not such long[] should exists for autoIncrementInfo ...,   final public ValueNode generatedColumnOption(long[] autoIncrementInfo) throws ParseException, StandardException {,         ValueNode       value = null;,         autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = 1;,         autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = 1;,         autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] = 1;,         autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;,     jj_consume_token(GENERATED);,     switch (jj_nt.kind) {,     case ALWAYS:,       value = generatedAlways(autoIncrementInfo);,             {if (true) return value;},       break;,     case BY:,       value = generatedByDefault(autoIncrementInfo);,             {if (true) return value;},       break;,     default:,       jj_la1[280] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="generatedAlways">generatedAlways</A>,  */,   final public ValueNode generatedAlways(long[] autoIncrementInfo) throws ParseException, StandardException {,         ValueNode       value = null;,     jj_consume_token(ALWAYS);,     if (getToken(1).kind == AS && getToken(2).kind == IDENTITY) {,       asIdentity(autoIncrementInfo);,             {if (true) return value;},     } else if (getToken(1).kind == AS && getToken(2).kind == LEFT_PAREN) {,       value = generationClause();,             {if (true) return value;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="generatedByDefault">generatedByDefault</A>,  */,   final public ValueNode generatedByDefault(long[] autoIncrementInfo) throws ParseException, StandardException {,         ValueNode       value = null;,     jj_consume_token(BY);,     jj_consume_token(_DEFAULT);,     asIdentity(autoIncrementInfo);,                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_1,,                              "GENERATED BY DEFAULT");, ,         value = new DefaultNode(getContextManager()) ;, ,                 {if (true) return value;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="asIdentity">asIdentity</A>,  */,   final public void asIdentity(long[] autoIncrementInfo) throws ParseException, StandardException {,     jj_consume_token(AS);,     jj_consume_token(IDENTITY);,     switch (jj_nt.kind) {,     case LEFT_PAREN:,       jj_consume_token(LEFT_PAREN);,       autoIncrementBeginEnd(autoIncrementInfo);,       jj_consume_token(RIGHT_PAREN);,       break;,     default:,       jj_la1[281] = jj_gen;,       ;,     },                 {if (true) return;},   }, , /*,  * <A NAME="generationClause">generationClause</A>,  */,   final public ValueNode generationClause() throws ParseException, StandardException {,         ValueNode       value = null;,         Token beginToken = null;,         Token endToken = null;,     jj_consume_token(AS);,     beginToken = jj_consume_token(LEFT_PAREN);,     value = valueExpression();,     endToken = jj_consume_token(RIGHT_PAREN);,                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_5, "GENERATED COLUMN");, ,         {if (true) return new GenerationClauseNode(value,,                                         StringUtil.slice,                                         (,                                             statementSQLText,,                                             beginToken.endOffset + 1,,                                             endToken.beginOffset - 1,,                                             true,                                          ),,                                         getContextManager(),                                         );},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="autoIncrementBeginEnd">autoIncrementBeginEnd</A>,  */,   final public void autoIncrementBeginEnd(long[] autoIncrementInfo) throws ParseException, StandardException {,         long            autoIncrementInitial = 1;,         long            autoIncrementIncrement = 1;,     switch (jj_nt.kind) {,     case INCREMENT:,       jj_consume_token(INCREMENT);,       jj_consume_token(BY);,       autoIncrementIncrement = exactNumber();,                 autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;,                 autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;,                 {if (true) return;},       break;,     case START:,       jj_consume_token(START);,       jj_consume_token(WITH);,       autoIncrementInitial = exactNumber();,       switch (jj_nt.kind) {,       case COMMA:,         jj_consume_token(COMMA);,         jj_consume_token(INCREMENT);,         jj_consume_token(BY);,         autoIncrementIncrement = exactNumber();,         break;,       default:,         jj_la1[282] = jj_gen;,         ;,       },                 autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = autoIncrementInitial;,                 autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;,                 autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;,                 {if (true) return;},       break;,     default:,       jj_la1[283] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },   }, , /*,  * <A NAME="defaultOption">defaultOption</A>,  */,   final public ValueNode defaultOption(Token beginToken, long[] autoIncrementInfo,,         String columnName) throws ParseException, StandardException {,         Token           endToken;,         Token           errorTok = null;,         Token           initialTok = null;,         ValueNode       value;,     if (getToken(1).kind == NULL && !(getToken(2).kind == PERIOD ||,                             getToken(2).kind == DOUBLE_COLON)) {,       jj_consume_token(NULL);,        {if (true) return new UntypedNullConstantNode(getContextManager());},     } else if (jj_2_75(1)) {,       value = DB2DefaultOption(columnName);,                 endToken = getToken(0);,                 value.setBeginOffset( beginToken.beginOffset );,                 value.setEndOffset( endToken.endOffset );,         value = new DefaultNode(value,,                                                                 StringUtil.slice(statementSQLText,,                                                                         beginToken.beginOffset + 7,,                                                                         endToken.endOffset,true),,                                 getContextManager());,                 {if (true) return value;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="DB2DefaultOption">DB2DefaultOption</A>,  */,   final public ValueNode DB2DefaultOption(String columnName) throws ParseException, StandardException {,         ValueNode       value;,     if (getToken(2).kind == SCHEMA || getToken(2).kind == SQLID) {,       jj_consume_token(CURRENT);,       switch (jj_nt.kind) {,       case SCHEMA:,         jj_consume_token(SCHEMA);,         break;,       case SQLID:,         jj_consume_token(SQLID);,         break;,       default:,         jj_la1[284] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },         {if (true) return new SpecialFunctionNode(,             SpecialFunctionNode.K_CURRENT_SCHEMA, getContextManager());},     } else {,       switch (jj_nt.kind) {,       case CURRENT_USER:,       case SESSION_USER:,       case USER:,         /* Revert DB2 restriction: DERBY-3013. Accept standard SQL CURRENT_USER,,         	 * SESSION_USER in addition to USER.,         	 */,                 value = userNode();,                 {if (true) return value;},         break;,       case CURRENT_ROLE:,         value = currentRoleNode();,                 {if (true) return value;},         break;,       default:,         jj_la1[285] = jj_gen;,         if (getToken(1).kind == DATE ||,                         getToken(1).kind == TIME ||,                         getToken(1).kind == TIMESTAMP) {,           value = miscBuiltins();,           // these functions are allowed as valid <cast-function> defaults.,           // Once "BLOB" is allowed as a cast-function (5281), a case should be,           // added for that, as well.,                 {if (true) return value;},         } else if (getToken(2).kind == LEFT_PAREN ||,                                (getToken(4).kind == LEFT_PAREN &&,                                 getToken(2).kind != COMMA)) {,           // Check against comma: see Derby-331 ,                           // Before adding this, the following was erroneously,                           // flagged as invalid: ,                           //	   create table foo(.., b int default 0, unique (a)),                   value = miscBuiltins();,                 // If we have a function (as indicated by an open paren,,                 // which can be either the 2nd token (w/ normal function name),                 // or the 4th token (w/ qualified function name)), then,                 // it's not valid.  Catch it here and throw an "invalid,                 // default" error (42894) instead of letting it go as,                 // a syntax error (this matches DB2 UDB behavior).,                 {if (true) throw StandardException.newException(,                         SQLState.LANG_DB2_INVALID_DEFAULT_VALUE,,                         columnName);},         } else if (jj_2_76(1)) {,           value = datetimeValueFunction();,                 {if (true) return value;},         } else {,           switch (jj_nt.kind) {,           case FALSE:,           case TRUE:,           case LEFT_BRACE:,           case PLUS_SIGN:,           case MINUS_SIGN:,           case EXACT_NUMERIC:,           case STRING:,           case HEX_STRING:,           case APPROXIMATE_NUMERIC:,             // Only (valid) thing left is literals (i.e. actual constants).,                     value = literal();,                 {if (true) return value;},             break;,           default:,             jj_la1[286] = jj_gen;,             jj_consume_token(-1);,             throw new ParseException();,           },         },       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="literal">literal</A>,  */,   final public ValueNode literal() throws ParseException, StandardException {,         String  sign = "";,         Token   tok;,         String  datetimeString;,         String  bitString;,         ValueNode               constantNode;,     switch (jj_nt.kind) {,     case PLUS_SIGN:,     case MINUS_SIGN:,     case EXACT_NUMERIC:,     case APPROXIMATE_NUMERIC:,       switch (jj_nt.kind) {,       case PLUS_SIGN:,       case MINUS_SIGN:,         sign = sign();,         break;,       default:,         jj_la1[287] = jj_gen;,         ;,       },       constantNode = numericLiteral(sign);,                 {if (true) return constantNode;},       break;,     case STRING:,       constantNode = stringLiteral();,                 {if (true) return  constantNode;},       break;,     case HEX_STRING:,       constantNode = hexLiteral();,                 {if (true) return  constantNode;},       break;,     case LEFT_BRACE:,       constantNode = dateTimeLiteral();,                 {if (true) return constantNode;},       break;,     case FALSE:,     case TRUE:,       tok = booleanLiteral();,        {if (true) return new BooleanConstantNode(,            StringUtil.SQLEqualsIgnoreCase(tok.image, "true"),,            getContextManager());},       break;,     default:,       jj_la1[288] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="int">intLiteral</A>,  */,   final public NumericConstantNode intLiteral() throws ParseException, StandardException {,         Token   tok;,         String sign = null;,         NumericConstantNode result;,     switch (jj_nt.kind) {,     case PLUS_SIGN:,     case MINUS_SIGN:,       sign = sign();,       break;,     default:,       jj_la1[289] = jj_gen;,       ;,     },     tok = jj_consume_token(EXACT_NUMERIC);,                 /*, 		** The various java parse utilities can't handle leading +,, 		** so only concatenate leading -., 		*/, ,                 String num = tok.image;, ,                 if (sign != null && sign.equals("-")),                         num = sign.concat(num);, ,                 try {,                         result = getNumericNode(num, true);,                 } catch (NumberFormatException e) {,                         {if (true) throw StandardException.newException(,                                 SQLState.LANG_INTEGER_LITERAL_EXPECTED);},                 }, ,                 {if (true) return result;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="numericLiteral">numericLiteral</A>,  */,   final public ValueNode numericLiteral(String sign) throws ParseException, StandardException {,         Token   tok;,     switch (jj_nt.kind) {,     case EXACT_NUMERIC:,       tok = jj_consume_token(EXACT_NUMERIC);,                 /*, 		** The various java parse utilities can't handle leading +,, 		** so only concatenate leading -., 		*/, ,                 String num = tok.image;, ,                 if (sign.equals("-")),                         num = sign.concat(num);, ,                 {if (true) return getNumericNode(num, false);},       break;,     case APPROXIMATE_NUMERIC:,       tok = jj_consume_token(APPROXIMATE_NUMERIC);,                 StringBuffer doubleImage;,                 String doubleString;,                 int ePosn, dotPosn; // Position of letter e and '.' in value,                 Double          doubleValue;, ,                 doubleImage = new StringBuffer(sign);,                 doubleImage.append(tok.image);,                 doubleString = doubleImage.toString();, ,                 ePosn = doubleString.indexOf('E');,                 if (ePosn == -1),                         ePosn = doubleString.indexOf('e');,                 if (SanityManager.DEBUG),                         SanityManager.ASSERT(ePosn != -1, "no E or e in approximate numeric");, ,                 // there is a limit on the length of a floatingpoint literal in DB2,                 if (doubleString.length() > Limits.DB2_MAX_FLOATINGPOINT_LITERAL_LENGTH),                         {if (true) throw StandardException.newException(SQLState.LANG_DB2_TOO_LONG_FLOATING_POINT_LITERAL, doubleString, TypeId.DOUBLE_NAME);},                 // if there is no '.' before the e, put one in,                 dotPosn = doubleString.substring(0,ePosn).indexOf('.');,                 if (dotPosn == -1) {,                         doubleImage.insert(ePosn,'.');,                         doubleString = doubleImage.toString();,                         ePosn++;,                 }, ,                 try,                 {,                         doubleValue = Double.valueOf(doubleString);, ,                 },                 catch (NumberFormatException nfe),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, TypeId.DOUBLE_NAME);},                 }, ,                 double dv = doubleValue.doubleValue();, ,                 // When the value is 0 it's possible rounded, try to detect it by checking if the mantissa is 0.0,                 //   "proof of correctness": any nonzero value (mantissa) with less than 30 characters will not be,                 //                           rounded to 0.0 by a float/real. This correctly detects the case when,                 //                           the radix/exponent being "too small" (1e-900) giving a value rounded to zero.,                 if ( (dv == 0.0d) && (Double.parseDouble(doubleString.substring(0, ePosn-1)) != 0.0d) ),                 {,                         {if (true) throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);},                 }, ,                 if (Double.isNaN(dv) || Double.isInfinite(dv)),                         {if (true) throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);}, ,        {if (true) return new NumericConstantNode(,            TypeId.getBuiltInTypeId(Types.DOUBLE),,            doubleValue,,            getContextManager());},       break;,     default:,       jj_la1[290] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dateTimeLiteral">dateTimeLiteral</A>,  */,   final public ValueNode dateTimeLiteral() throws ParseException, StandardException {,         ValueNode       constantNode;,     jj_consume_token(LEFT_BRACE);,     constantNode = escapedDateTimeLiteral();,     jj_consume_token(RIGHT_BRACE);,                 {if (true) return constantNode;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="escapedDateTimeLiteral">escapedDateTimeLiteral</A>,  */,   final public ValueNode escapedDateTimeLiteral() throws ParseException, StandardException {,         ValueNode constantNode;,     switch (jj_nt.kind) {,     case D:,       jj_consume_token(D);,       constantNode = bareDateLiteral();,                 {if (true) return constantNode;},       break;,     case T:,       jj_consume_token(T);,       constantNode = bareTimeLiteral();,                 {if (true) return constantNode;},       break;,     case TS:,       jj_consume_token(TS);,       constantNode = bareTimestampLiteral();,                 {if (true) return constantNode;},       break;,     default:,       jj_la1[291] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="bareDateLiteral">bareDateLiteral</A>,  */,   final public ValueNode bareDateLiteral() throws ParseException, StandardException {,         String dateString;,     dateString = string();,        {if (true) return new UserTypeConstantNode(,             getLanguageConnectionContext().getDataValueFactory().,                 getDateValue(dateString, true),,             getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="bareTimeLiteral">bareTimeLiteral</A>,  */,   final public ValueNode bareTimeLiteral() throws ParseException, StandardException {,         String timeString;,     timeString = string();,        {if (true) return new UserTypeConstantNode(,             getLanguageConnectionContext().getDataValueFactory().,                 getTimeValue(timeString, true),,             getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="bareTimestampLiteral">bareTimestampLiteral</A>,  */,   final public ValueNode bareTimestampLiteral() throws ParseException, StandardException {,         String timestampString;,     timestampString = string();,        {if (true) return new UserTypeConstantNode(,             getLanguageConnectionContext().getDataValueFactory().,                 getTimestampValue(timestampString, true),,             getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="string">string</A>,  */,   final public String string() throws ParseException, StandardException {,         Token   tok;,     tok = jj_consume_token(STRING);,                 verifyImageLength(tok.image);,                 /* Trim off the leading and trailing ', and compress all '' to ' */,                 {if (true) return StringUtil.compressQuotes(tok.image.substring(1, tok.image.length() - 1),,                                                           SINGLEQUOTES);},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="stringLiteral">stringLiteral</A>,  */,   final public CharConstantNode stringLiteral() throws ParseException, StandardException {,         Token   tok;,         String  string;,     tok = jj_consume_token(STRING);,                 //there is a maximum limit on the length of the string,                 if (tok.image.length()-2 > Limits.DB2_MAX_CHARACTER_LITERAL_LENGTH)//-2 is for the beginning and ending quote,                         {if (true) throw StandardException.newException(SQLState.LANG_DB2_STRING_CONSTANT_TOO_LONG, StringUtil.formatForPrint(tok.image));},                 string = StringUtil.compressQuotes(tok.image.substring(1, tok.image.length() - 1), SINGLEQUOTES);,                 /* Trim quotes from string. */,        {if (true) return new CharConstantNode(string, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="hexLiteral">hexLiteral</A>,  */,   final public ValueNode hexLiteral() throws ParseException, StandardException {,         Token   tok;,     tok = jj_consume_token(HEX_STRING);,                 String hexLiteral = tok.image;, ,                 //there is a maximum limit on the length of the hex constant,                 if (hexLiteral.length()-3 > Limits.DB2_MAX_HEX_LITERAL_LENGTH)//-3 is for X' at the beginning and ' at the end,                         {if (true) throw StandardException.newException(SQLState.LANG_DB2_STRING_CONSTANT_TOO_LONG, StringUtil.formatForPrint(hexLiteral));},                 if ((hexLiteral.length()-3)%2 == 1),                         {if (true) throw StandardException.newException(SQLState.LANG_DB2_INVALID_HEXADECIMAL_CONSTANT, StringUtil.formatForPrint(hexLiteral));}, ,                 int bitLength = ((hexLiteral.length() - 3) / 2);,        {if (true) return new VarbitConstantNode(,             hexLiteral.substring(2, hexLiteral.length() - 1),,             bitLength,,             getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public TableName constraintNameDefinition() throws ParseException, StandardException {,         TableName constraintName;,     jj_consume_token(CONSTRAINT);,     constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,                 {if (true) return constraintName;},     throw new Error("Missing return statement in function");,   }, , /*,  * DB2 requires column check constraints to refer to only that column. Derby,  * doesn't care if check constraints are column level or table level. For DB2 compatibility,  * check that column check constraints only refer to that column.,  */,   final public ConstraintDefinitionNode checkConstraintDefinition(TableName constraintName, String columnName) throws ParseException, StandardException {,         Token           beginToken;,         Token           endToken;,         ValueNode       value;,         ResultColumnList rclList = null;,     jj_consume_token(CHECK);,     beginToken = jj_consume_token(LEFT_PAREN);,     value = valueExpression();,     endToken = jj_consume_token(RIGHT_PAREN);,                 if (columnName != null),                 {,                         /* Column check constraint */,             rclList = new ResultColumnList(getContextManager());,             rclList.addElement(new ResultColumn(columnName,,                                                 null,,                                                 getContextManager()));,                 }, ,                 value.setBeginOffset( beginToken.beginOffset );,                 value.setEndOffset( endToken.endOffset );,         {if (true) return new ConstraintDefinitionNode(,                                         constraintName,,                     DataDictionary.CHECK_CONSTRAINT,,                                         rclList,,                                         null,,                                         value,,                                         StringUtil.slice(statementSQLText,,                                                 beginToken.beginOffset,,                                                 endToken.endOffset,true),,                     StatementType.DROP_DEFAULT,,                     DataDictionary.DROP_CONSTRAINT,,                                         getContextManager(),                                         );},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="spsRenameStatement">spsRenameStatement</A>,  */,   final public StatementNode spsRenameStatement() throws ParseException, StandardException {,         StatementNode qtn;,     jj_consume_token(RENAME);,     switch (jj_nt.kind) {,     case TABLE:,       qtn = renameTableStatement();,       break;,     case INDEX:,       qtn = renameIndexStatement();,       break;,     case COLUMN:,       qtn = renameColumnStatement();,       break;,     default:,       jj_la1[292] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return qtn;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="renameTableStatement">renameTableStatement</A>,  */,   final public StatementNode renameTableStatement() throws ParseException, StandardException {,         StatementNode qtn;,         TableName tableName;,         String newTableName;,     jj_consume_token(TABLE);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(TO);,     newTableName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         {if (true) return new RenameNode(tableName,,                               null,,                               newTableName,,                               false,,                               StatementType.RENAME_TABLE,,                               getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="renameIndexStatement">renameIndexStatement</A>,  */,   final public StatementNode renameIndexStatement() throws ParseException, StandardException {,         String oldIndexName;,         String newIndexName;,     jj_consume_token(INDEX);,     oldIndexName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     jj_consume_token(TO);,     newIndexName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         {if (true) return new RenameNode(null,,                               oldIndexName,,                               newIndexName,,                               false,,                               StatementType.RENAME_INDEX,,                               getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode renameColumnStatement() throws ParseException, StandardException {,         String newColumnName;,         ColumnReference oldColumnReference;,     jj_consume_token(COLUMN);,     oldColumnReference = columnReference();,     jj_consume_token(TO);,     newColumnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         if (oldColumnReference.getQualifiedTableName() == null) {,                         {if (true) throw StandardException.newException(,                                 SQLState.LANG_OBJECT_DOES_NOT_EXIST,,                                 "RENAME COLUMN",,                                 oldColumnReference.getColumnName());},         }, ,         {if (true) return new RenameNode(,                         oldColumnReference.getQualifiedTableName(),,                         oldColumnReference.getColumnName(),,                         newColumnName,,             false,,             StatementType.RENAME_COLUMN,,             getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode lockStatement() throws ParseException, StandardException {,     boolean                     exclusiveMode;,         TableName                                       tableName;,     jj_consume_token(LOCK);,     jj_consume_token(TABLE);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(IN);,     exclusiveMode = lockMode();,     jj_consume_token(MODE);,         {if (true) return new LockTableNode(tableName, exclusiveMode, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public boolean lockMode() throws ParseException {,     switch (jj_nt.kind) {,     case EXCLUSIVE:,       jj_consume_token(EXCLUSIVE);,         {if (true) return true;},       break;,     case SHARE:,       jj_consume_token(SHARE);,         {if (true) return false;},       break;,     default:,       jj_la1[293] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode execStatement() throws ParseException, StandardException {,         TableName       stmtName;,     jj_consume_token(EXECUTE);,     jj_consume_token(STATEMENT);,     stmtName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new ExecSPSNode(stmtName, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public TransactionStatementNode setIsolationStatement() throws ParseException, StandardException {,         TransactionStatementNode tranNode;,     setIsolationHeader();,     switch (jj_nt.kind) {,     case TO:,     case EQUALS_OPERATOR:,       switch (jj_nt.kind) {,       case EQUALS_OPERATOR:,         jj_consume_token(EQUALS_OPERATOR);,         break;,       case TO:,         jj_consume_token(TO);,         break;,       default:,         jj_la1[294] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[295] = jj_gen;,       ;,     },     tranNode = transactionMode();,                 {if (true) return tranNode;},     throw new Error("Missing return statement in function");,   }, ,   final public void setIsolationHeader() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case ISOLATION:,       jj_consume_token(ISOLATION);,       break;,     default:,       jj_la1[296] = jj_gen;,       if (getToken(1).kind == CURRENT && getToken(2).kind == ISOLATION) {,         jj_consume_token(CURRENT);,         jj_consume_token(ISOLATION);,       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },   }, ,   final public TransactionStatementNode transactionMode() throws ParseException, StandardException {,         int isolationLevel;,     isolationLevel = isolationLevelDB2OrReset();,         {if (true) return new SetTransactionIsolationNode(isolationLevel,,                                                getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public int isolationLevelDB2OrReset() throws ParseException {,         int isolationLevel;,     switch (jj_nt.kind) {,     case RESET:,       jj_consume_token(RESET);,                           {if (true) return TransactionControl.UNSPECIFIED_ISOLATION_LEVEL;},       break;,     default:,       jj_la1[297] = jj_gen;,       if (jj_2_77(1)) {,         isolationLevel = isolationLevelDB2();,                                                          {if (true) return isolationLevel;},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, ,   final public int isolationLevelDB2() throws ParseException {,         int isolationLevel;,     switch (jj_nt.kind) {,     case CS:,     case RR:,     case RS:,     case UR:,       isolationLevel = isolationLevelDB2Abbrev();,                                                              {if (true) return isolationLevel;},       break;,     case REPEATABLE:,     case SERIALIZABLE:,       switch (jj_nt.kind) {,       case REPEATABLE:,         jj_consume_token(REPEATABLE);,         jj_consume_token(READ);,         break;,       case SERIALIZABLE:,         jj_consume_token(SERIALIZABLE);,         break;,       default:,         jj_la1[298] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },                           {if (true) return TransactionControl.SERIALIZABLE_ISOLATION_LEVEL;},       break;,     case CURSOR:,       jj_consume_token(CURSOR);,       jj_consume_token(STABILITY);,                           {if (true) return TransactionControl.READ_COMMITTED_ISOLATION_LEVEL;},       break;,     case DIRTY:,       jj_consume_token(DIRTY);,       jj_consume_token(READ);,                           {if (true) return TransactionControl.READ_UNCOMMITTED_ISOLATION_LEVEL;},       break;,     default:,       jj_la1[299] = jj_gen;,       if (getToken(1).kind == READ && getToken(2).kind == COMMITTED) {,         jj_consume_token(READ);,         jj_consume_token(COMMITTED);,                           {if (true) return TransactionControl.READ_COMMITTED_ISOLATION_LEVEL;},       } else if (getToken(1).kind == READ && getToken(2).kind == UNCOMMITTED) {,         jj_consume_token(READ);,         jj_consume_token(UNCOMMITTED);,                           {if (true) return TransactionControl.READ_UNCOMMITTED_ISOLATION_LEVEL;},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, ,   final public int isolationLevelDB2Abbrev() throws ParseException {,     switch (jj_nt.kind) {,     case RR:,       jj_consume_token(RR);,                           {if (true) return TransactionControl.SERIALIZABLE_ISOLATION_LEVEL;},       break;,     case RS:,       jj_consume_token(RS);,                          {if (true) return TransactionControl.REPEATABLE_READ_ISOLATION_LEVEL;},       break;,     case CS:,       jj_consume_token(CS);,                           {if (true) return TransactionControl.READ_COMMITTED_ISOLATION_LEVEL;},       break;,     case UR:,       jj_consume_token(UR);,                           {if (true) return TransactionControl.READ_UNCOMMITTED_ISOLATION_LEVEL;},       break;,     default:,       jj_la1[300] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public int isolationLevel() throws ParseException {,         int isolationLevel;,     jj_consume_token(ISOLATION);,     jj_consume_token(LEVEL);,     isolationLevel = levelOfIsolation();,                 {if (true) return isolationLevel;},     throw new Error("Missing return statement in function");,   }, ,   final public int levelOfIsolation() throws ParseException {,     switch (jj_nt.kind) {,     case READ:,       jj_consume_token(READ);,                 {if (true) return levelOfIsolationRead();},       break;,     case REPEATABLE:,       jj_consume_token(REPEATABLE);,       jj_consume_token(READ);,                 {if (true) return TransactionControl.REPEATABLE_READ_ISOLATION_LEVEL;},       break;,     case SERIALIZABLE:,       jj_consume_token(SERIALIZABLE);,                 {if (true) return TransactionControl.SERIALIZABLE_ISOLATION_LEVEL;},       break;,     default:,       jj_la1[301] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public int levelOfIsolationRead() throws ParseException {,     switch (jj_nt.kind) {,     case UNCOMMITTED:,       jj_consume_token(UNCOMMITTED);,                 {if (true) return TransactionControl.READ_UNCOMMITTED_ISOLATION_LEVEL;},       break;,     case COMMITTED:,       jj_consume_token(COMMITTED);,                 {if (true) return TransactionControl.READ_COMMITTED_ISOLATION_LEVEL;},       break;,     default:,       jj_la1[302] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="simpleValueSpecification">simpleValueSpecification</A>,  */,   final public ValueNode simpleValueSpecification() throws ParseException, StandardException {,         ValueNode       value;,     value = literal();,                 {if (true) return value;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="setRoleStatement">setRoleStatement</A>,  */,   final public StatementNode setRoleStatement() throws ParseException, StandardException {,         StatementNode role;,     jj_consume_token(ROLE);,     role = setRoleSpecification();,                 if (parameterList != null && parameterList.size() > 0),                 {,                         setUpAndLinkParameters();,                         // set the type of parameter node, it should be a varchar,                         // max Limits.MAX_IDENTIFIER_LENGTH - non nullable,                         ParameterNode p = (ParameterNode) parameterList.get(0);,                         p.setType(new DataTypeDescriptor,                                           (TypeId.getBuiltInTypeId(Types.VARCHAR),,                                            false,,                                            Limits.MAX_IDENTIFIER_LENGTH));,                 },                 {if (true) return role;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="setRoleSpecification">setRoleSpecification</A>,  */,   final public StatementNode setRoleSpecification() throws ParseException, StandardException {,         String roleName = null;,         checkVersion( DataDictionary.DD_VERSION_DERBY_10_5, "ROLES");,         checkSqlStandardAccess("SET ROLE");,     switch (jj_nt.kind) {,     case NONE:,       jj_consume_token(NONE);,         {if (true) return new SetRoleNode(,             roleName,,             StatementType.UNKNOWN,,             getContextManager());},       break;,     default:,       jj_la1[303] = jj_gen;,       if (jj_2_78(1)) {,         roleName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         {if (true) return new SetRoleNode(,                          roleName,,              StatementType.UNKNOWN,,                          getContextManager());},       } else {,         switch (jj_nt.kind) {,         case QUESTION_MARK:,           dynamicParameterSpecification();,         {if (true) return new SetRoleNode(,                          null,,              StatementType.SET_ROLE_DYNAMIC,,                          getContextManager());},           break;,         case STRING:,           roleName = string();,                 roleName = IdUtil.parseRoleId(roleName);, ,         {if (true) return new SetRoleNode(,                         roleName,,             StatementType.UNKNOWN,,                         getContextManager());},           break;,         default:,           jj_la1[304] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },     },     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode setSchemaStatement() throws ParseException, StandardException {,         StatementNode setSchema;,     setSchemaHeader();,     switch (jj_nt.kind) {,     case EQUALS_OPERATOR:,       jj_consume_token(EQUALS_OPERATOR);,       break;,     default:,       jj_la1[305] = jj_gen;,       ;,     },     setSchema = setSchemaValues();,                 if (parameterList != null && parameterList.size() > 0),                 {,                         setUpAndLinkParameters();,                         // set the type of parameter node, it should be a varchar max Limits.MAX_IDENTIFIER_LENGTH - non nullable,                         ParameterNode p = (ParameterNode) parameterList.get(0);,                         p.setType(new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), false, Limits.MAX_IDENTIFIER_LENGTH));,                 },                 {if (true) return setSchema;},     throw new Error("Missing return statement in function");,   }, ,   final public void setSchemaHeader() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case SCHEMA:,       jj_consume_token(SCHEMA);,       break;,     default:,       jj_la1[307] = jj_gen;,       if (getToken(1).kind == CURRENT && ( getToken(2).kind == SCHEMA ||  getToken(2).kind == SQLID )) {,         jj_consume_token(CURRENT);,         switch (jj_nt.kind) {,         case SCHEMA:,           jj_consume_token(SCHEMA);,           break;,         case SQLID:,           jj_consume_token(SQLID);,           break;,         default:,           jj_la1[306] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },   }, ,   final public StatementNode setSchemaValues() throws ParseException, StandardException {,         String schemaName;,     if (jj_2_79(1)) {,       schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         {if (true) return new SetSchemaNode(,             schemaName, StatementType.UNKNOWN, getContextManager());},     } else {,       switch (jj_nt.kind) {,       case USER:,         jj_consume_token(USER);,         {if (true) return new SetSchemaNode(,             null, StatementType.SET_SCHEMA_USER, getContextManager());},         break;,       case QUESTION_MARK:,         dynamicParameterSpecification();,         {if (true) return new SetSchemaNode(,             null, StatementType.SET_SCHEMA_DYNAMIC, getContextManager());},         break;,       case STRING:,         schemaName = string();,                 /* Max length for schema name is Limits.MAX_IDENTIFIER_LENGTH */,                 IdUtil.checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new SetSchemaNode(,             schemaName, StatementType.UNKNOWN, getContextManager());},         break;,       default:,         jj_la1[308] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , // Set the locale for messages coming from the database system. This, // is for support only, so we can get messages in our preferred language, // (usually English). I didn't want to create all the execution wiring, // to do this, so this command executes in the parser,   final public StatementNode setMessageLocaleStatement() throws ParseException, StandardException {,         String messageLocale;,     jj_consume_token(MESSAGE_LOCALE);,     messageLocale = string();,                 getContextManager().setMessageLocale(messageLocale);, ,         {if (true) return new NOPStatementNode(getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="valueSpecification">valueSpecification</A>,  */,   final public ValueNode valueSpecification() throws ParseException, StandardException {,         ValueNode          value;,         ValueNode          leftExpression;,         ValueNode          rightExpression;,     switch (jj_nt.kind) {,     case FALSE:,     case TRUE:,     case LEFT_BRACE:,     case PLUS_SIGN:,     case MINUS_SIGN:,     case EXACT_NUMERIC:,     case STRING:,     case HEX_STRING:,     case APPROXIMATE_NUMERIC:,       value = literal();,                 {if (true) return value;},       break;,     case CURRENT_USER:,     case SESSION_USER:,     case USER:,     case CURRENT_ROLE:,     case QUESTION_MARK:,       value = generalValueSpecification();,                 {if (true) return value;},       break;,     case NULLIF:,       jj_consume_token(NULLIF);,       jj_consume_token(LEFT_PAREN);,       leftExpression = additiveExpression(null, 0);,       jj_consume_token(COMMA);,       rightExpression = additiveExpression(null, 0);,       jj_consume_token(RIGHT_PAREN);,                 // "NULLIF(L, R)" is the same as "L=R ? untyped NULL : L",                 // An impl assumption here is that Derby can promote CHAR to any comparable datatypes such as numeric,                 ContextManager cm = getContextManager();,         ValueNodeList thenElseList = new ValueNodeList(cm);, ,                 //Use untyped null for then clause at this point. At the bind time, we will cast it to the datatype of L ,        thenElseList.addElement(new UntypedNullConstantNode(cm));,                 thenElseList.addElement(leftExpression);, ,         {if (true) return new ConditionalNode(,                    new BinaryRelationalOperatorNode(,                        BinaryRelationalOperatorNode.K_EQUALS,,                        leftExpression,,                        rightExpression,,                        false,,                        cm),,                    thenElseList,,                    true, // this node is for nullif,                    cm);},       break;,     case CASE:,       jj_consume_token(CASE);,       value = whenThenExpression();,                 {if (true) return value;},       break;,     default:,       jj_la1[309] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="caseExpression">caseExpression</A>,  */,   final public ValueNode caseExpression() throws ParseException, StandardException {,         ValueNode          expr;,     switch (jj_nt.kind) {,     case END:,       jj_consume_token(END);,         ValueNode value = new CastNode(,             new UntypedNullConstantNode(getContextManager()),,             DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 1),,             getContextManager());,                 ((CastNode) value).setForExternallyGeneratedCASTnode();,                 {if (true) return value;},       break;,     case ELSE:,       jj_consume_token(ELSE);,       expr = thenElseExpression();,       jj_consume_token(END);,                 {if (true) return expr;},       break;,     case WHEN:,       expr = whenThenExpression();,                 {if (true) return expr;},       break;,     default:,       jj_la1[310] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="whenThenExpression">whenThenExpression</A>,  */,   final public ValueNode whenThenExpression() throws ParseException, StandardException {,         ValueNode          expr;,         ValueNode          thenExpr;,         ValueNode          elseExpr;,     jj_consume_token(WHEN);,     expr = valueExpression();,     jj_consume_token(THEN);,     thenExpr = thenElseExpression();,     elseExpr = caseExpression();,                 ContextManager cm = getContextManager();,         ValueNodeList thenElseList = new ValueNodeList(cm);,                 thenElseList.addElement(thenExpr); // then,                 thenElseList.addElement(elseExpr); // else, ,         {if (true) return new ConditionalNode(expr, thenElseList, false, cm);},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="thenElseExpression">thenElseExpression</A>,  */,   final public ValueNode thenElseExpression() throws ParseException, StandardException {,         ValueNode          expr;,     if (getToken(1).kind == NULL) {,       jj_consume_token(NULL);,         ValueNode value = new CastNode(,             new UntypedNullConstantNode(getContextManager()),,             DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 1),,             getContextManager());,                 ((CastNode) value).setForExternallyGeneratedCASTnode();,                 {if (true) return value;},     } else if (jj_2_80(1)) {,       expr = additiveExpression(null, 0);,                 {if (true) return expr;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public TableElementNode tableConstraintDefinition() throws ParseException, StandardException {,         Properties properties = null;,         ConstraintDefinitionNode tcdn;,         TableName               constraintName = null;,     switch (jj_nt.kind) {,     case CONSTRAINT:,       constraintName = constraintNameDefinition();,       break;,     default:,       jj_la1[311] = jj_gen;,       ;,     },     tcdn = tableConstraint(constraintName);,     switch (jj_nt.kind) {,     case DERBYDASHPROPERTIES:,       properties = propertyList(false);,       jj_consume_token(CHECK_PROPERTIES);,       break;,     default:,       jj_la1[312] = jj_gen;,       ;,     },                 if (properties != null),                 {,                         tcdn.setProperties(properties);,                 },                 {if (true) return tcdn;},     throw new Error("Missing return statement in function");,   }, ,   final public ConstraintDefinitionNode tableConstraint(TableName constraintName) throws ParseException, StandardException {,         ConstraintDefinitionNode tcdn;,     boolean[] cc = null;,     switch (jj_nt.kind) {,     case PRIMARY:,     case UNIQUE:,       tcdn = uniqueConstraintDefinition(constraintName);,       break;,     case FOREIGN:,       tcdn = referentialConstraintDefinition(constraintName);,       break;,     case CHECK:,       tcdn = checkConstraintDefinition(constraintName, null);,       break;,     default:,       jj_la1[313] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     if (jj_2_81(1)) {,       cc = constraintCharacteristics();,     } else {,       ;,     },         if (cc != null) {,             tcdn.setCharacteristics(cc);,         }, ,         {if (true) return tcdn;},     throw new Error("Missing return statement in function");,   }, ,   final public ConstraintDefinitionNode uniqueConstraintDefinition(TableName constraintName) throws ParseException, StandardException {,         int constraintType;,         ResultColumnList uniqueColumnList;,     //for table level constraint, parameter will be null,             constraintType = uniqueSpecification(null);,     jj_consume_token(LEFT_PAREN);,     uniqueColumnList = uniqueColumnList();,     jj_consume_token(RIGHT_PAREN);,         {if (true) return new ConstraintDefinitionNode(,                         constraintName,,                                                 ReuseFactory.getInteger(constraintType),,                                                 uniqueColumnList,,                                                 null,,                                                 null,,                                                 null,,                         StatementType.DROP_DEFAULT,,                         DataDictionary.DROP_CONSTRAINT,,                                                 getContextManager(),                                                 );},     throw new Error("Missing return statement in function");,   }, , //the second parameter to the following method will always be null for a table level, //constraint but not for a column level constraint,   final public int uniqueSpecification(String columnName) throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case UNIQUE:,       jj_consume_token(UNIQUE);,                 {if (true) return DataDictionary.UNIQUE_CONSTRAINT;},       break;,     case PRIMARY:,       jj_consume_token(PRIMARY);,       jj_consume_token(KEY);,                 {if (true) return DataDictionary.PRIMARYKEY_CONSTRAINT;},       break;,     default:,       jj_la1[314] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ResultColumnList uniqueColumnList() throws ParseException, StandardException {,     ResultColumnList resultColumns = new ResultColumnList(getContextManager());,     columnNameList(resultColumns);,                 {if (true) return resultColumns;},     throw new Error("Missing return statement in function");,   }, ,   final public ConstraintDefinitionNode referentialConstraintDefinition(TableName constraintName) throws ParseException, StandardException {,     ResultColumnList fkRcl = new ResultColumnList(getContextManager());,     ResultColumnList refRcl = new ResultColumnList(getContextManager());,         TableName referencedTable;,         int[] refActions = {StatementType.RA_NOACTION,,                             StatementType.RA_NOACTION};,     jj_consume_token(FOREIGN);,     jj_consume_token(KEY);,     jj_consume_token(LEFT_PAREN);,     columnNameList(fkRcl);,     jj_consume_token(RIGHT_PAREN);,     referencedTable = referencesSpecification(refRcl, refActions);,         {if (true) return new FKConstraintDefinitionNode(,                         constraintName,,                                                 referencedTable,,                                                 fkRcl,,                                                 refRcl,,                                                 refActions,,                                                 getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public TableName referencesSpecification(ResultColumnList rcl, int[] refActions) throws ParseException, StandardException {,         TableName tableName = null;,     jj_consume_token(REFERENCES);,     tableName = referencedTableAndColumns(rcl);,     switch (jj_nt.kind) {,     case ON:,       jj_consume_token(ON);,       referentialTriggeredAction(refActions);,       break;,     default:,       jj_la1[315] = jj_gen;,       ;,     },                 {if (true) return tableName;},     throw new Error("Missing return statement in function");,   }, ,   final public TableName referencedTableAndColumns(ResultColumnList rcl) throws ParseException, StandardException {,         TableName       tableName = null;,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     switch (jj_nt.kind) {,     case LEFT_PAREN:,       jj_consume_token(LEFT_PAREN);,       columnNameList(rcl);,       jj_consume_token(RIGHT_PAREN);,       break;,     default:,       jj_la1[316] = jj_gen;,       ;,     },                 {if (true) return tableName;},     throw new Error("Missing return statement in function");,   }, ,   final public void referentialTriggeredAction(int [] refActions) throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case UPDATE:,       refActions[1] = updateRule();,       switch (jj_nt.kind) {,       case ON:,         jj_consume_token(ON);,         refActions[0] = deleteRule();,         break;,       default:,         jj_la1[317] = jj_gen;,         ;,       },       break;,     case DELETE:,       refActions[0] = deleteRule();,       switch (jj_nt.kind) {,       case ON:,         jj_consume_token(ON);,         refActions[1] = updateRule();,         break;,       default:,         jj_la1[318] = jj_gen;,         ;,       },       break;,     default:,       jj_la1[319] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },   }, ,   final public int updateRule() throws ParseException {,         int action;,     jj_consume_token(UPDATE);,     action = updateReferentialAction();,                 {if (true) return action;},     throw new Error("Missing return statement in function");,   }, ,   final public int deleteRule() throws ParseException {,         int action;,     jj_consume_token(DELETE);,     action = deleteReferentialAction();,                 {if (true) return action;},     throw new Error("Missing return statement in function");,   }, ,   final public int updateReferentialAction() throws ParseException {,     switch (jj_nt.kind) {,     case RESTRICT:,       jj_consume_token(RESTRICT);,                       {if (true) return StatementType.RA_RESTRICT;},       break;,     case NO:,       jj_consume_token(NO);,       jj_consume_token(ACTION);,                          {if (true) return StatementType.RA_NOACTION;},       break;,     default:,       jj_la1[320] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public int deleteReferentialAction() throws ParseException {,     switch (jj_nt.kind) {,     case CASCADE:,       jj_consume_token(CASCADE);,                    {if (true) return StatementType.RA_CASCADE;},       break;,     case RESTRICT:,       jj_consume_token(RESTRICT);,                       {if (true) return StatementType.RA_RESTRICT;},       break;,     case NO:,       jj_consume_token(NO);,       jj_consume_token(ACTION);,                          {if (true) return StatementType.RA_NOACTION;},       break;,     case SET:,       jj_consume_token(SET);,       switch (jj_nt.kind) {,       case NULL:,         jj_consume_token(NULL);,                       {if (true) return StatementType.RA_SETNULL;},         break;,       case _DEFAULT:,         jj_consume_token(_DEFAULT);,                             {if (true) return StatementType.RA_SETDEFAULT;},         break;,       default:,         jj_la1[321] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[322] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="constraintCharacteristics">constraintCharacteristics</A>,  */,   final public boolean[] constraintCharacteristics() throws ParseException, StandardException {,     boolean deferrable =,         ConstraintDefinitionNode.DEFERRABLE_DEFAULT;,     boolean initiallyDeferred =,         ConstraintDefinitionNode.INITIALLY_DEFERRED_DEFAULT;,     boolean enforced =,         ConstraintDefinitionNode.ENFORCED_DEFAULT;,     boolean explicitlySpecified[] =,         new boolean[]{false, false};,     switch (jj_nt.kind) {,     case INITIALLY:,       initiallyDeferred = initiallyDeferred();,               explicitlySpecified[1] = true;,       if (getToken(1).kind == DEFERRABLE || getToken(2).kind == DEFERRABLE) {,         deferrable = deferrable();,               explicitlySpecified[0] = true;,       } else {,         ;,       },       if (getToken(1).kind == ENFORCED || getToken(2).kind == ENFORCED) {,         enforced = constraintEnforcement();,       } else {,         ;,       },       break;,     default:,       jj_la1[324] = jj_gen;,       if (getToken(1).kind == DEFERRABLE || getToken(2).kind == DEFERRABLE) {,         deferrable = deferrable();,               explicitlySpecified[0] = true;,         switch (jj_nt.kind) {,         case INITIALLY:,           initiallyDeferred = initiallyDeferred();,               explicitlySpecified[1] = true;,           break;,         default:,           jj_la1[323] = jj_gen;,           ;,         },         if (getToken(1).kind == ENFORCED || getToken(2).kind == ENFORCED) {,           enforced = constraintEnforcement();,         } else {,           ;,         },       } else if (getToken(1).kind == ENFORCED || getToken(2).kind == ENFORCED) {,         enforced = constraintEnforcement();,       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },         if (!explicitlySpecified[0] &&,             explicitlySpecified[1] && initiallyDeferred) {,             // "INITIALLY DEFERRED" implies "DEFERRABLE",             deferrable = true;,         }, ,         if (explicitlySpecified[0] && (!deferrable) &&,             explicitlySpecified[1] && initiallyDeferred) {,             // "NOT DEFERRABLE INITIALLY DEFERRED" is inconsistent,             {if (true) throw StandardException.newException(,                 SQLState.LANG_INCONSISTENT_CONSTRAINT_CHARACTERISTICS);},         }, ,         {if (true) return new boolean[]{deferrable, initiallyDeferred, enforced};},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="initiallyDeferred">initiallyDeferred</A>,  */,   final public boolean initiallyDeferred() throws ParseException {,     jj_consume_token(INITIALLY);,     switch (jj_nt.kind) {,     case IMMEDIATE:,       jj_consume_token(IMMEDIATE);,             {if (true) return false;},       break;,     case DEFERRED:,       jj_consume_token(DEFERRED);,             {if (true) return true;},       break;,     default:,       jj_la1[325] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="deferrable">deferrable</A>,  */,   final public boolean deferrable() throws ParseException {,     boolean deferrable = true;,     switch (jj_nt.kind) {,     case NOT:,       jj_consume_token(NOT);,           deferrable = false;,       break;,     default:,       jj_la1[326] = jj_gen;,       ;,     },     jj_consume_token(DEFERRABLE);,         {if (true) return deferrable;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="constraintEnforcement">constraintEnforcement</A>,  */,   final public boolean constraintEnforcement() throws ParseException {,     boolean enforced = true;,     switch (jj_nt.kind) {,     case NOT:,       jj_consume_token(NOT);,           enforced = false;,       break;,     default:,       jj_la1[327] = jj_gen;,       ;,     },     jj_consume_token(ENFORCED);,         {if (true) return enforced;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="columnConstraintDefinition">columnConstraintDefinition</A>,  */,   final public void columnConstraintDefinition(DataTypeDescriptor[] dataTypeDescriptor,,                                                    TableElementList tableElementList,,                                                    String columnName) throws ParseException, StandardException {,         int constraintType;,     ConstraintDefinitionNode tcdn;,         TableName constraintName = null;,     boolean[] cc = null;,     switch (jj_nt.kind) {,     case CONSTRAINT:,       constraintName = constraintNameDefinition();,       break;,     default:,       jj_la1[328] = jj_gen;,       ;,     },     tcdn = columnConstraint(constraintName, dataTypeDescriptor, columnName);,     if (jj_2_82(1)) {,       cc = constraintCharacteristics();,     } else {,       ;,     },         if (cc != null) {,             if (tcdn == null) {,                 {if (true) throw StandardException.newException(,                     SQLState.LANG_NOT_NULL_CHARACTERISTICS);},             }, ,             tcdn.setCharacteristics(cc);,         }, ,                 /* NOT NULL constraints are handled by marking the dataTypeDescriptor, 		 * as being non-nullable., 		 */,                 if (tcdn == null),                 {,                         {if (true) return;},                 }, ,                 /* All other constraints, whether column or table will be added as, 		 * table constraints.  We do this to facilitate the handling of, 		 * multiple column constraints on the same column., 		 */,                 tableElementList.addTableElement(tcdn);,   }, , /*,  * <A NAME="columnConstraint">columnConstraint</A>,  */,   final public ConstraintDefinitionNode columnConstraint(TableName constraintName,,                                  DataTypeDescriptor[] dataTypeDescriptor,,                                  String columnName) throws ParseException, StandardException {,         int constraintType;,         Properties properties = null;,         ConstraintDefinitionNode tcdn;,     ResultColumnList refRcl = new ResultColumnList(getContextManager());,         TableName referencedTable;,         int[] refActions = {StatementType.RA_NOACTION,,                             StatementType.RA_NOACTION} ;,     switch (jj_nt.kind) {,     case NOT:,       jj_consume_token(NOT);,       jj_consume_token(NULL);,                 // columns with generation clauses can omit the datatype,                 if ( dataTypeDescriptor[0] == null ) { {if (true) throw StandardException.newException(SQLState.LANG_NOT_NULL_NEEDS_DATATYPE);} }, ,                 dataTypeDescriptor[0] = dataTypeDescriptor[0].getNullabilityType(false);,                 {if (true) return null;},       break;,     case PRIMARY:,     case UNIQUE:,       //pass the columnname as the second parameter. It will be used to throw an,               //exception if null constraint is defined for this column-level primary ,               //key constraint,               constraintType = uniqueSpecification(columnName);,       switch (jj_nt.kind) {,       case DERBYDASHPROPERTIES:,         properties = propertyList(false);,         jj_consume_token(CHECK_PROPERTIES);,         break;,       default:,         jj_la1[329] = jj_gen;,         ;,       },         ResultColumnList uniqueColumnList =,             new ResultColumnList(getContextManager());,         uniqueColumnList.addElement(new ResultColumn(columnName,,                                                      null,,                                                      getContextManager()));, ,         {if (true) return new ConstraintDefinitionNode(,                         constraintName,,                                                 ReuseFactory.getInteger(constraintType),,                                                 uniqueColumnList,,                                                 properties,,                                                 null,,                                                 null,,                         StatementType.DROP_DEFAULT,,                         DataDictionary.DROP_CONSTRAINT,,                                                 getContextManager(),                                                 );},       break;,     case REFERENCES:,       referencedTable = referencesSpecification(refRcl, refActions);,       switch (jj_nt.kind) {,       case DERBYDASHPROPERTIES:,         properties = propertyList(false);,         jj_consume_token(CHECK_PROPERTIES);,         break;,       default:,         jj_la1[330] = jj_gen;,         ;,       },         ResultColumnList fkRcl = new ResultColumnList(getContextManager());,         fkRcl.addElement(new ResultColumn(columnName,,                                           null,,                                           getContextManager()));,         tcdn = new FKConstraintDefinitionNode(,                         constraintName,,                                                 referencedTable,,                                                 fkRcl,,                                                 refRcl,,                                                 refActions,,                                                 getContextManager());,                 if (properties != null),                 {,                         tcdn.setProperties(properties);,                 },                 {if (true) return tcdn;},       break;,     case CHECK:,       tcdn = checkConstraintDefinition(constraintName, columnName);,                 {if (true) return tcdn;},       break;,     default:,       jj_la1[331] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dropRoleStatement">dropRoleStatement</A>,  */,   final public StatementNode dropRoleStatement() throws ParseException, StandardException {,         String roleName;,     jj_consume_token(ROLE);,     roleName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_5, "ROLES");,                 checkSqlStandardAccess("DROP ROLE");, ,         {if (true) return new DropRoleNode(roleName, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode dropSchemaStatement() throws ParseException, StandardException {,         String schemaName;,     jj_consume_token(SCHEMA);,     schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     jj_consume_token(RESTRICT);,         StatementNode stmt = new DropSchemaNode(,             schemaName,,             StatementType.DROP_RESTRICT,,             getContextManager());, ,                 {if (true) return stmt;},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode alterTableStatement() throws ParseException, StandardException {,         StatementNode           node;,         TableName                       tableName;,     jj_consume_token(TABLE);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     node = alterTableBody(tableName);,                 {if (true) return node;},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode alterTableBody(TableName tableName) throws ParseException, StandardException {,         StatementNode sn;,         char                            lockGranularity = '\0';,         String               newTableName;,         TableElementList        tableElementList =,                             new TableElementList(getContextManager());,         int[]                           changeType = new int[1];,         int[]                           behavior = new int[1];,         String indexName = null;,     switch (jj_nt.kind) {,     case COMPRESS:,       jj_consume_token(COMPRESS);,       switch (jj_nt.kind) {,       case INPLACE:,         sn = inplaceCompress(tableName);,         break;,       default:,         jj_la1[332] = jj_gen;,         sn = sequentialCompress(tableName);,       },                 {if (true) return sn;},       break;,     case ALL:,       jj_consume_token(ALL);,       switch (jj_nt.kind) {,       case DROP:,         sn = dropStatistics(tableName);,         break;,       case UPDATE:,         sn = updateStatistics(tableName);,         break;,       default:,         jj_la1[333] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },                 {if (true) return sn;},       break;,     case UPDATE:,       jj_consume_token(UPDATE);,       jj_consume_token(STATISTICS);,       indexName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_5, "SYSCS_UPDATE_STATISTICS");,                 //This will make sure that this ALTER TABLE...syntax can't be called directly.,                 //This sql can only be generated internally (right now it is done for,                 //syscs_util.SYSCS_UPDATE_STATISTICS procedure,                 checkInternalFeature("UPDATE STATISTICS");,         {if (true) return new AlterTableNode(,                                                         tableName,,                             DDLStatementNode.UPDATE_STATISTICS,,                             false,,                                                         indexName,,                                                         getContextManager());},       break;,     case STATISTICS:,       jj_consume_token(STATISTICS);,       jj_consume_token(DROP);,       indexName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_9, "SYSCS_UPDATE_STATISTICS");,                 //This will make sure that this ALTER TABLE...syntax can't be called directly.,                 //This sql can only be generated internally (right now it is done for,                 //syscs_util.SYSCS_UPDATE_STATISTICS procedure,                 checkInternalFeature("DROP STATISTICS");,         {if (true) return new AlterTableNode(,                                                         tableName,,                             DDLStatementNode.DROP_STATISTICS,,                             false,,                                                         indexName,,                                                         getContextManager());},       break;,     case DROP:,       jj_consume_token(DROP);,       if (jj_2_83(1)) {,         sn = dropColumnDefinition(tableName, tableElementList, changeType, behavior);,       } else if (jj_2_84(1)) {,         sn = dropTableConstraintDefinitionCore(tableName, tableElementList, changeType, behavior);,       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },                      {if (true) return sn;},       break;,     default:,       jj_la1[334] = jj_gen;,       if (jj_2_85(1)) {,         lockGranularity = alterTableAction(tableElementList, changeType, behavior);,         {if (true) return new AlterTableNode(,                                                         tableName,,                             changeType[0],,                                                         tableElementList,,                             lockGranularity,,                             behavior[0],,                                                         getContextManager());},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * Called for ALTER TABLE ALL DROP STATISTICS. This is an internal,  *  syntax and can't be invoked by a user directly. DERBY-4115. This,  *  will drop all the statistics for the given table name,  *,  * By the time we get here, we've parsed,  *    ALTER TABLE tablename ALL ,  * and here we parse DROP STATISTICS clause,  */,   final public StatementNode dropStatistics(TableName tableName) throws ParseException, StandardException {,     jj_consume_token(DROP);,     jj_consume_token(STATISTICS);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_9, "SYSCS_DROP_STATISTICS");,                 //This will make sure that this ALTER TABLE...syntax can't be called directly.,                 //This sql can only be generated internally (right now it is done for,                 //syscs_util.SYSCS_DROP_STATISTICS procedure,                 checkInternalFeature("DROP STATISTICS");,         {if (true) return new AlterTableNode(,                                                         tableName,,                             DDLStatementNode.DROP_STATISTICS,,                             true, // drop all indexes,                             null, // no specific index given,                                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * Called for ALTER TABLE ALL UPDATE STATISTICS. This is an internal,  *  syntax and can't be invoked by a user directly. DERBY-269. This,  *  will update all the statistics for the given table name,  *,  * By the time we get here, we've parsed,  *    ALTER TABLE tablename ALL ,  * and here we parse UPDATE STATISTICS clause,  */,   final public StatementNode updateStatistics(TableName tableName) throws ParseException, StandardException {,     jj_consume_token(UPDATE);,     jj_consume_token(STATISTICS);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_5, "SYSCS_UPDATE_STATISTICS");,                 //This will make sure that this ALTER TABLE...syntax can't be called directly.,                 //This sql can only be generated internally (right now it is done for,                 //syscs_util.SYSCS_UPDATE_STATISTICS procedure,                 checkInternalFeature("UPDATE STATISTICS");,                 int[] changeType = new int[1];,         {if (true) return new AlterTableNode(,                                                         tableName,,                             DDLStatementNode.UPDATE_STATISTICS,,                             true, // update all indexes,                             null, // all indexes, so none given,                                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode inplaceCompress(TableName tableName) throws ParseException, StandardException {,         Token purge = null;,         Token defragment = null;,         Token truncate = null;,     jj_consume_token(INPLACE);,     switch (jj_nt.kind) {,     case PURGE:,       purge = jj_consume_token(PURGE);,       break;,     default:,       jj_la1[335] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case DEFRAGMENT:,       defragment = jj_consume_token(DEFRAGMENT);,       break;,     default:,       jj_la1[336] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case TRUNCATE_END:,       truncate = jj_consume_token(TRUNCATE_END);,       break;,     default:,       jj_la1[337] = jj_gen;,       ;,     },                 checkInternalFeature("COMPRESS");,         {if (true) return new AlterTableNode(,                                                         tableName,,                             purge != null,,                             defragment != null,,                             truncate != null,,                                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode sequentialCompress(TableName tableName) throws ParseException, StandardException {,         Token                           tok = null;,     switch (jj_nt.kind) {,     case SEQUENTIAL:,       tok = jj_consume_token(SEQUENTIAL);,       break;,     default:,       jj_la1[338] = jj_gen;,       ;,     },                 checkInternalFeature("COMPRESS");,         {if (true) return new AlterTableNode(,                                                         tableName,,                             tok != null,,                                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="alterTableRenameTableStatement">alterTableRenameTableStatement</A>,  */, /*, StatementNode, alterTableRenameTableStatement(TableName tableName) throws StandardException :, {, 	String newTableName;, }, {, 	<TO> newTableName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true), 	{,         return new RenameNode(, 							null,, 							newTableName,,                             true,,                             StatementType.RENAME_TABLE,, 							getContextManager());, 	}, }, */, , /*,  * <A NAME="alterTableRenameColumnStatement">alterTableRenameColumnStatement</A>,  */, /*, StatementNode, alterTableRenameColumnStatement(TableName tableName) throws StandardException :, {, 	String oldColumnName;, 	String newColumnName;, }, {, 	oldColumnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) <TO> newColumnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true), 	{,         return new RenameNode(, 							tableName,, 							oldColumnName,, 							newColumnName,,                             true,,                             StatementType.RENAME_COLUMN,, 							getContextManager());, 	}, }, */,   final public char alterTableAction(TableElementList tableElementList, int[] changeType, int[] behavior) throws ParseException, StandardException {,         char                            lockGranularity = '\0';,         TableElementNode        tableElement;,         DataTypeDescriptor      typeDescriptor;,         Token                           tok = null;,         String                          columnName;,         long[]                          autoIncrementInfo = new long[4];,     boolean             enforced;,     TableName           constraintName;,     switch (jj_nt.kind) {,     case ADD:,       jj_consume_token(ADD);,       if (jj_2_86(1)) {,         tableElement = addColumnDefinition(tableElementList);,       } else {,         switch (jj_nt.kind) {,         case CHECK:,         case CONSTRAINT:,         case FOREIGN:,         case PRIMARY:,         case UNIQUE:,           tableElement = tableConstraintDefinition();,           break;,         default:,           jj_la1[339] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },                 if (tableElement instanceof ColumnDefinitionNode),                 {,                         //bug 5724 - auto increment columns not allowed in ALTER TABLE statement,                         ColumnDefinitionNode cdn = (ColumnDefinitionNode) tableElement;,                         if ( cdn.isAutoincrementColumn()),                                 {if (true) throw StandardException.newException(SQLState.LANG_ALTER_TABLE_AUTOINCREMENT_COLUMN_NOT_ALLOWED);},                 },                 changeType[0] = DDLStatementNode.ADD_TYPE;,                 tableElementList.addTableElement(tableElement);,                 {if (true) return lockGranularity;},       break;,     default:,       jj_la1[341] = jj_gen;,       if (getToken(1).kind == ALTER && getToken(2).kind != CONSTRAINT) {,         jj_consume_token(ALTER);,         switch (jj_nt.kind) {,         case COLUMN:,           jj_consume_token(COLUMN);,           break;,         default:,           jj_la1[340] = jj_gen;,           ;,         },         columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         tableElement = columnAlterClause(columnName);,                 changeType[0] = DDLStatementNode.MODIFY_TYPE;,                 tableElementList.addTableElement(tableElement);,                 {if (true) return lockGranularity;},       } else {,         switch (jj_nt.kind) {,         case ALTER:,           jj_consume_token(ALTER);,           constraintName = constraintNameDefinition();,           enforced = constraintEnforcement();,         ConstraintDefinitionNode cdn = new ConstraintDefinitionNode(,             constraintName,,             DataDictionary.MODIFY_CONSTRAINT,,             null,,             null,,             null,,             null,,             StatementType.DROP_DEFAULT,,             DataDictionary.MODIFY_CONSTRAINT,,             getContextManager());, ,         boolean[] cc = new boolean[]{,             ConstraintDefinitionNode.DEFERRABLE_DEFAULT,,             ConstraintDefinitionNode.INITIALLY_DEFERRED_DEFAULT,,             enforced};, ,         cdn.setCharacteristics(cc);,         changeType[0] = DDLStatementNode.MODIFY_TYPE;,         tableElementList.addTableElement(cdn);, ,         {if (true) return lockGranularity;},           break;,         case LOCKSIZE:,           lockGranularity = DB2lockGranularityClause();,                 changeType[0] = DDLStatementNode.LOCKING_TYPE;,                 {if (true) return lockGranularity;},           break;,         default:,           jj_la1[342] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * Handle,  *,  *    ALTER TABLE tablename DROP [ COLUMN ] columnname [ CASCADE | RESTRICT ],  */,   final public StatementNode dropColumnDefinition(TableName tableName, TableElementList tableElementList, int[] changeType, int[] behavior) throws ParseException, StandardException {,         String columnName;,         TableElementNode tableElement;,     switch (jj_nt.kind) {,     case COLUMN:,       jj_consume_token(COLUMN);,       break;,     default:,       jj_la1[343] = jj_gen;,       ;,     },     columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,     dropColumnReferentialAction(behavior);,         tableElement =,             new ModifyColumnNode(ModifyColumnNode.K_DROP_COLUMN,,                                  columnName,,                                  null,,                                  null,,                                  null,,                                  getContextManager());,                 tableElementList.addTableElement(tableElement);,         {if (true) return new AlterTableNode(,                                                         tableName,,                             DDLStatementNode.DROP_TYPE,,                                                         tableElementList,,                             '\0',,                             behavior[0],,                                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public void dropColumnReferentialAction(int []behavior) throws ParseException {,         int refBehavior = StatementType.DROP_CASCADE;,     switch (jj_nt.kind) {,     case CASCADE:,     case RESTRICT:,       switch (jj_nt.kind) {,       case CASCADE:,         jj_consume_token(CASCADE);,                      refBehavior = StatementType.DROP_CASCADE;,         break;,       case RESTRICT:,         jj_consume_token(RESTRICT);,                         refBehavior = StatementType.DROP_RESTRICT;,         break;,       default:,         jj_la1[344] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[345] = jj_gen;,       ;,     },                 behavior[0] = refBehavior;,   }, ,   final public TableElementNode addColumnDefinition(TableElementList tableElementList) throws ParseException, StandardException {,         TableElementNode        tableElement;,     switch (jj_nt.kind) {,     case COLUMN:,       jj_consume_token(COLUMN);,       break;,     default:,       jj_la1[346] = jj_gen;,       ;,     },     tableElement = columnDefinition(tableElementList);,                 {if (true) return tableElement;},     throw new Error("Missing return statement in function");,   }, , /*,  * Various variants of the ALTER TABLE ALTER COLUMN statement.,  *,  * By the time we get here, we've parsed,  *    ALTER TABLE tablename ALTER [COLUMN] columnname,  * and here we parse the remainder of the ALTER COLUMN clause, one of:,  *		SET DATA TYPE data_type,  *		SET INCREMENT BY increment_value,  *		RESTART WITH increment_restart_value,  *		[SET | WITH] DEFAULT default_value,  *      DROP DEFAULT,  *      [NOT] NULL,  */,   final public TableElementNode columnAlterClause(String columnName) throws ParseException, StandardException {,         ValueNode       defaultNode;,         long[]                          autoIncrementInfo = new long[4];,         long                            autoIncrementIncrement = 1;,         long                            autoIncrementRestartWith = 1;,         DataTypeDescriptor      typeDescriptor = null;,     if (getToken(2).kind == DATA) {,       jj_consume_token(SET);,       jj_consume_token(DATA);,       jj_consume_token(TYPE);,       typeDescriptor = dataTypeDDL();,         {if (true) return,             new ModifyColumnNode(ModifyColumnNode.K_MODIFY_COLUMN_TYPE,,                                  columnName,,                                  null,,                                  typeDescriptor,,                                  null,,                                  getContextManager());},     } else if (getToken(2).kind == INCREMENT) {,       jj_consume_token(SET);,       jj_consume_token(INCREMENT);,       jj_consume_token(BY);,       autoIncrementIncrement = exactNumber();,                 autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;,                 autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE;,         {if (true) return,             new ModifyColumnNode(ModifyColumnNode.K_MODIFY_COLUMN_DEFAULT,,                                  columnName,,                                  null,,                                  null,,                                  autoIncrementInfo,,                                  getContextManager());},     } else {,       switch (jj_nt.kind) {,       case RESTART:,         jj_consume_token(RESTART);,         jj_consume_token(WITH);,         autoIncrementRestartWith = exactNumber();,                 autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = autoIncrementRestartWith;,                 autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE;,         {if (true) return,             new ModifyColumnNode(ModifyColumnNode.K_MODIFY_COLUMN_DEFAULT,,                                  columnName,,                                  null,,                                  null,,                                  autoIncrementInfo,,                                  getContextManager());},         break;,       default:,         jj_la1[348] = jj_gen;,         if (getToken(1).kind == WITH || getToken(1).kind == _DEFAULT ||,                             (getToken(1).kind == SET && getToken(2).kind == _DEFAULT)) {,           switch (jj_nt.kind) {,           case SET:,             jj_consume_token(SET);,             break;,           default:,             jj_la1[347] = jj_gen;,             ;,           },           defaultNode = defaultClause(autoIncrementInfo, columnName);,                 {if (true) return wrapAlterColumnDefaultValue(defaultNode,,                                                                                    columnName,,                                                                                    autoIncrementInfo);},         } else {,           switch (jj_nt.kind) {,           case DROP:,             jj_consume_token(DROP);,             jj_consume_token(_DEFAULT);,        defaultNode = new UntypedNullConstantNode(getContextManager());, ,                 {if (true) return wrapAlterColumnDefaultValue(defaultNode,,                                                                                    columnName,,                                                                                    autoIncrementInfo);},             break;,           default:,             jj_la1[349] = jj_gen;,             if (getToken(1).kind == NULL) {,               jj_consume_token(NULL);,                 // for a MODIFY column NULL clause form a modify_column node,                 // with all null values. In a column definition a [NOT] NULL,                 // column constraint is specified by setting the right value,                 // in the nullability field of the data type but we don't have,                 // a datatype here.,         {if (true) return,             new ModifyColumnNode(ModifyColumnNode.K_MODIFY_COLUMN_CONSTRAINT,,                                  columnName,,                                  null,,                                  null,,                                  null,,                                  getContextManager());},             } else if (getToken(1).kind == NOT) {,               jj_consume_token(NOT);,               jj_consume_token(NULL);,                 // for a MODIFY column NOT NULL clause form a modify_column node,                 // with all null values. In a column definition a [NOT] NULL,                 // column constraint is specified by setting the right value,                 // in the nullability field of the data type but we don't have,                 // a datatype here.,         {if (true) return new ModifyColumnNode(,             ModifyColumnNode.K_MODIFY_COLUMN_CONSTRAINT_NOT_NULL,,             columnName,,             null,,             null,,             null,,             getContextManager());},             } else {,               jj_consume_token(-1);,               throw new ParseException();,             },           },         },       },     },     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode dropTableConstraintDefinitionCore(TableName tableName, TableElementList tableElementList, int[] changeType, int[] behavior) throws ParseException, StandardException {,         TableElementNode tableElement;,     tableElement = dropTableConstraintDefinition();,                 tableElementList.addTableElement(tableElement);,         {if (true) return new AlterTableNode(,                                                         tableName,,                             DDLStatementNode.DROP_TYPE,,                                                         tableElementList,,                             '\0',,                             behavior[0],,                                                         getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public TableElementNode dropTableConstraintDefinition() throws ParseException, StandardException {,         TableName                constraintName;,     if (getToken(1).kind == CONSTRAINT) {,       jj_consume_token(CONSTRAINT);,       constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new ConstraintDefinitionNode(,                         constraintName,,                         DataDictionary.DROP_CONSTRAINT,,                                                 null,,                                                 null,,                                                 null,,                                                 null,,                         StatementType.DROP_DEFAULT,,                         DataDictionary.DROP_CONSTRAINT,,                                                 getContextManager(),                                                 );},     } else if (getToken(1).kind == PRIMARY) {,       jj_consume_token(PRIMARY);,       jj_consume_token(KEY);,         {if (true) return new ConstraintDefinitionNode(,                         null,,                         DataDictionary.DROP_CONSTRAINT,,                                                 null,,                                                 null,,                                                 null,,                                                 null,,                         StatementType.DROP_DEFAULT,,                         DataDictionary.DROP_CONSTRAINT,,                                                 getContextManager(),                                                 );},     } else if (getToken(1).kind == FOREIGN) {,       jj_consume_token(FOREIGN);,       jj_consume_token(KEY);,       constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new ConstraintDefinitionNode(,                         constraintName,,                         DataDictionary.DROP_CONSTRAINT,,                                                 null,,                                                 null,,                                                 null,,                                                 null,,                         StatementType.DROP_DEFAULT,,                         DataDictionary.FOREIGNKEY_CONSTRAINT,,                                                 getContextManager(),                                                 );},     } else if (getToken(1).kind == UNIQUE) {,       jj_consume_token(UNIQUE);,       constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new ConstraintDefinitionNode(,                         constraintName,,                         DataDictionary.DROP_CONSTRAINT,,                                                 null,,                                                 null,,                                                 null,,                                                 null,,                         StatementType.DROP_DEFAULT,,                         DataDictionary.UNIQUE_CONSTRAINT,,                                                 getContextManager(),                                                 );},     } else {,       switch (jj_nt.kind) {,       case CHECK:,         jj_consume_token(CHECK);,         constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new ConstraintDefinitionNode(,                         constraintName,,                         DataDictionary.DROP_CONSTRAINT,,                                                 null,,                                                 null,,                                                 null,,                                                 null,,                         StatementType.DROP_DEFAULT,,                         DataDictionary.CHECK_CONSTRAINT,,                                                 getContextManager(),                                                 );},         break;,       default:,         jj_la1[350] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dropTableStatement">dropTableStatement</A>,  */,   final public StatementNode dropTableStatement() throws ParseException, StandardException {,         TableName tableName;,     jj_consume_token(TABLE);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new DropTableNode(,             tableName,,             StatementType.DROP_DEFAULT,,             getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dropIndexStatement">dropIndexStatement</A>,  */,   final public StatementNode dropIndexStatement() throws ParseException, StandardException {,         TableName indexName;,     jj_consume_token(INDEX);,     indexName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new DropIndexNode(indexName, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="dropAliasStatement">dropAliasStatement</A>,  */,   final public StatementNode dropAliasStatement() throws ParseException, StandardException {,     TableName aliasName;,     switch (jj_nt.kind) {,     case PROCEDURE:,       jj_consume_token(PROCEDURE);,       aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,                 {if (true) return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR);},       break;,     case FUNCTION:,       jj_consume_token(FUNCTION);,       aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,                 {if (true) return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR);},       break;,     case SYNONYM:,       jj_consume_token(SYNONYM);,       aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "DROP SYNONYM");, ,                 {if (true) return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR);},       break;,     case TYPE:,       jj_consume_token(TYPE);,       aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,       jj_consume_token(RESTRICT);,                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_6, "DROP TYPE");, ,                 {if (true) return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_UDT_AS_CHAR);},       break;,     case DERBY:,       jj_consume_token(DERBY);,       jj_consume_token(AGGREGATE);,       aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,       jj_consume_token(RESTRICT);,                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_10, "DROP DERBY AGGREGATE");, ,                 {if (true) return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR);},       break;,     default:,       jj_la1[351] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode dropViewStatement() throws ParseException, StandardException {,         TableName viewName;,     jj_consume_token(VIEW);,     viewName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new DropViewNode(viewName, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode dropTriggerStatement() throws ParseException, StandardException {,         TableName triggerName;,     jj_consume_token(TRIGGER);,     triggerName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new DropTriggerNode(triggerName, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   final public StatementNode truncateTableStatement() throws ParseException, StandardException {,         TableName tableName;,     jj_consume_token(TRUNCATE);,     jj_consume_token(TABLE);,     tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new AlterTableNode(tableName, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="grantStatement">grantStatement</A>,  */,   final public StatementNode grantStatement() throws ParseException, StandardException {,         StatementNode node;,     if (getToken(1).kind == GRANT &&,                                     ((getToken(2).kind == TRIGGER &&,                                       ((getToken(3).kind == COMMA &&,                                             isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||,                                        getToken(3).kind == ON)) ||,                                      isPrivilegeKeywordExceptTrigger(getToken(2).kind))) {,       jj_consume_token(GRANT);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_2, "GRANT");,                 checkSqlStandardAccess( "GRANT");,       switch (jj_nt.kind) {,       case ALL:,       case DELETE:,       case INSERT:,       case REFERENCES:,       case SELECT:,       case UPDATE:,       case TRIGGER:,         node = tableGrantStatement();,         break;,       case EXECUTE:,         node = routineGrantStatement();,         break;,       case USAGE:,         node = usageGrantStatement();,         break;,       default:,         jj_la1[352] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },                 {if (true) return node;},     } else if (getToken(1).kind == GRANT &&,                                     ((getToken(2).kind == TRIGGER &&,                                       ((getToken(3).kind == COMMA &&,                                             !isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||,                                        getToken(3).kind == TO)) ||,                                      !isPrivilegeKeywordExceptTrigger(getToken(2).kind))) {,       jj_consume_token(GRANT);,       node = roleGrantStatement();,                 {if (true) return node;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="tableGrantStatement">tableGrantStatement</A>,  */,   final public StatementNode tableGrantStatement() throws ParseException, StandardException {,     PrivilegeNode privileges;,     List<String> grantees;,     privileges = tablePrivileges();,     jj_consume_token(TO);,     grantees = granteeList();,         {if (true) return new GrantNode(privileges, grantees, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,  // end of tableGrantStatement, , /*,  * <A NAME="tablePrivileges">tablePrivileges</A>,  */,   final public PrivilegeNode tablePrivileges() throws ParseException, StandardException {,     TablePrivilegesNode tablePrivilegesNode = null;,     TableName objectName = null;,     tablePrivilegesNode = tableActions();,     jj_consume_token(ON);,     switch (jj_nt.kind) {,     case TABLE:,       jj_consume_token(TABLE);,       break;,     default:,       jj_la1[353] = jj_gen;,       ;,     },     objectName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,         {if (true) return new PrivilegeNode(PrivilegeNode.TABLE_PRIVILEGES,,                                  objectName,,                                  tablePrivilegesNode,,                                  getContextManager());},     throw new Error("Missing return statement in function");,   }, ,   // end of   tablePrivilege                               , , /*,  * <A NAME="tableActions">tableActions</A>,  */,   final public TablePrivilegesNode tableActions() throws ParseException, StandardException {,     TablePrivilegesNode tableActionsNode =,         new TablePrivilegesNode(getContextManager());,     switch (jj_nt.kind) {,     case ALL:,       jj_consume_token(ALL);,       jj_consume_token(PRIVILEGES);,         tableActionsNode.addAll();,         {if (true) return tableActionsNode;},       break;,     case DELETE:,     case INSERT:,     case REFERENCES:,     case SELECT:,     case UPDATE:,     case TRIGGER:,       tableAction(tableActionsNode);,       label_40:,       while (true) {,         switch (jj_nt.kind) {,         case COMMA:,           ;,           break;,         default:,           jj_la1[354] = jj_gen;,           break label_40;,         },         jj_consume_token(COMMA);,         tableAction(tableActionsNode);,       },         {if (true) return tableActionsNode;},       break;,     default:,       jj_la1[355] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   // end of tableActions, , /*,  * <A NAME="routineGrantStatement">routineGrantStatement</A>,  */,   final public StatementNode routineGrantStatement() throws ParseException, StandardException {,     List<String> grantees;,     RoutineDesignator routine;,     jj_consume_token(EXECUTE);,     jj_consume_token(ON);,     routine = routineDesignator();,     jj_consume_token(TO);,     grantees = granteeList();,         PrivilegeNode routinePrivilege =,             new PrivilegeNode(PrivilegeNode.ROUTINE_PRIVILEGES,,                               routine,,                               null,,                               getContextManager());, ,         {if (true) return new GrantNode(routinePrivilege, grantees, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,  // end of routineGrantStatement, , /*,  * <A NAME="usageGrantStatement">usageGrantStatement</A>,  */,   final public StatementNode usageGrantStatement() throws ParseException, StandardException {,     List<String> grantees;,     TableName name;,     Integer objectType;,     jj_consume_token(USAGE);,     jj_consume_token(ON);,     objectType = usableObjects();,     name = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(TO);,     grantees = granteeList();,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_6, "GRANT USAGE");,         PrivilegeNode privilegeNode = new PrivilegeNode(,             objectType,,             name,,             PermDescriptor.USAGE_PRIV,,             false,,             getContextManager());, ,         {if (true) return new GrantNode(privilegeNode, grantees, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,  // end of usageGrantStatement, , /*,  * <A NAME="usableObjects">usableObjects</A>,  */,   final public Integer usableObjects() throws ParseException, StandardException {,     switch (jj_nt.kind) {,     case DERBY:,       jj_consume_token(DERBY);,       jj_consume_token(AGGREGATE);,         {if (true) return ReuseFactory.getInteger( PrivilegeNode.AGGREGATE_PRIVILEGES);},       break;,     case SEQUENCE:,       jj_consume_token(SEQUENCE);,         {if (true) return ReuseFactory.getInteger( PrivilegeNode.SEQUENCE_PRIVILEGES);},       break;,     case TYPE:,       jj_consume_token(TYPE);,         {if (true) return ReuseFactory.getInteger( PrivilegeNode.UDT_PRIVILEGES);},       break;,     default:,       jj_la1[356] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,  // end of routineGrantStatement, , /*,  * <A NAME="routineAlias">routineAlias</A>,  */,   final public RoutineDesignator routineDesignator() throws ParseException, StandardException {,     Token procOrFunction;,     TableName name;,     List<TypeDescriptor> paramTypeList = null;,     switch (jj_nt.kind) {,     case FUNCTION:,       procOrFunction = jj_consume_token(FUNCTION);,       break;,     case PROCEDURE:,       procOrFunction = jj_consume_token(PROCEDURE);,       break;,     default:,       jj_la1[357] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     name = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     switch (jj_nt.kind) {,     case LEFT_PAREN:,       jj_consume_token(LEFT_PAREN);,       paramTypeList = parameterTypeList();,       jj_consume_token(RIGHT_PAREN);,       break;,     default:,       jj_la1[358] = jj_gen;,       ;,     },         {if (true) return new RoutineDesignator( name,,                                       (procOrFunction.kind == FUNCTION),,                                       paramTypeList);},     throw new Error("Missing return statement in function");,   }, ,   // end of routineDesignator, , , /*,  * <A NAME="parameterTypeList">parameterTypeList</A>,  */,   final public List<TypeDescriptor> parameterTypeList() throws ParseException, StandardException {,     ArrayList<TypeDescriptor> list = new ArrayList<TypeDescriptor>();,     TypeDescriptor type;,     if (jj_2_87(1)) {,       type = catalogType();,             list.add(type);,       label_41:,       while (true) {,         switch (jj_nt.kind) {,         case COMMA:,           ;,           break;,         default:,           jj_la1[359] = jj_gen;,           break label_41;,         },         jj_consume_token(COMMA);,         type = catalogType();,             list.add(type);,       },     } else {,       ;,     },         {if (true) return list;},     throw new Error("Missing return statement in function");,   }, ,   // end of parameterTypeList, , , /*,  * <A NAME="tableAction">tableAction</A>,  */,   final public void tableAction(TablePrivilegesNode tablePrivilegesNode) throws ParseException, StandardException {,     ResultColumnList columnList = null;,     switch (jj_nt.kind) {,     case SELECT:,       jj_consume_token(SELECT);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         columnList = privilegeColumnList();,         break;,       default:,         jj_la1[360] = jj_gen;,         ;,       },         tablePrivilegesNode.addAction( TablePrivilegeInfo.SELECT_ACTION, columnList);,       break;,     case DELETE:,       jj_consume_token(DELETE);,         tablePrivilegesNode.addAction( TablePrivilegeInfo.DELETE_ACTION, (ResultColumnList) null);,       break;,     case INSERT:,       jj_consume_token(INSERT);,         tablePrivilegesNode.addAction( TablePrivilegeInfo.INSERT_ACTION, (ResultColumnList) null);,       break;,     case UPDATE:,       jj_consume_token(UPDATE);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         columnList = privilegeColumnList();,         break;,       default:,         jj_la1[361] = jj_gen;,         ;,       },         tablePrivilegesNode.addAction( TablePrivilegeInfo.UPDATE_ACTION, columnList);,       break;,     case REFERENCES:,       jj_consume_token(REFERENCES);,       switch (jj_nt.kind) {,       case LEFT_PAREN:,         columnList = privilegeColumnList();,         break;,       default:,         jj_la1[362] = jj_gen;,         ;,       },         tablePrivilegesNode.addAction( TablePrivilegeInfo.REFERENCES_ACTION, columnList);,       break;,     case TRIGGER:,       jj_consume_token(TRIGGER);,         tablePrivilegesNode.addAction( TablePrivilegeInfo.TRIGGER_ACTION, (ResultColumnList) null);,       break;,     default:,       jj_la1[363] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },   }, ,   // end of tableAction, , /*,  * <A NAME="privilegeColumnList">privilegeColumnList</A>,  */,   final public ResultColumnList privilegeColumnList() throws ParseException, StandardException {,     ResultColumnList cl = new ResultColumnList(getContextManager());,     jj_consume_token(LEFT_PAREN);,     columnNameList(cl);,     jj_consume_token(RIGHT_PAREN);,         {if (true) return cl;},     throw new Error("Missing return statement in function");,   }, ,   // end of privilegeColumnList, , /*,  * <A NAME="granteeList">granteeList</A>,  */,   final public List<String> granteeList() throws ParseException, StandardException {,     ArrayList<String> list = new ArrayList<String>();,     grantee(list);,     label_42:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[364] = jj_gen;,         break label_42;,       },       jj_consume_token(COMMA);,       grantee(list);,     },         {if (true) return list;},     throw new Error("Missing return statement in function");,   }, ,   final public void grantee(List<String> list) throws ParseException, StandardException {,     String str;,     if (jj_2_88(1)) {,       str = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         list.add(str);,     } else {,       switch (jj_nt.kind) {,       case PUBLIC:,         jj_consume_token(PUBLIC);,         list.add( Authorizer.PUBLIC_AUTHORIZATION_ID);,         break;,       default:,         jj_la1[365] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },   }, , /*,  * <A NAME="roleGrantStatement">roleGrantStatement</A>,  */,   final public StatementNode roleGrantStatement() throws ParseException, StandardException {,     List<String> rolesGranted;,     List<String> grantees;,     /*,     	 * GRANT <rolename> {, <rolename>}* TO <authentication identifier>,     	 *									{, <authentication identifier>}*,     	 *,     	 * not implemented: WITH ADMIN OPTION, GRANTED BY clauses,     	 */,             rolesGranted = roleList();,     jj_consume_token(TO);,     grantees = granteeList();,                 checkSqlStandardAccess("GRANT <role>");,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_5, "ROLES");, ,         {if (true) return new GrantRoleNode(rolesGranted, grantees, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="roleList">roleList</A>,  */,   final public List<String> roleList() throws ParseException, StandardException {,     ArrayList<String> list = new ArrayList<String>();,     roleElement(list);,     label_43:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[366] = jj_gen;,         break label_43;,       },       jj_consume_token(COMMA);,       roleElement(list);,     },         {if (true) return list;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="roleElement">roleElement</A>,  */,   final public void roleElement(List<String> list) throws ParseException, StandardException {,     String str;,     str = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,         list.add(str);,   }, , /*,  * <A NAME="revokeStatement">revokeStatement</A>,  */,   final public StatementNode revokeStatement() throws ParseException, StandardException {,     StatementNode node;,     if (getToken(1).kind == REVOKE &&,                                     ((getToken(2).kind == TRIGGER &&,                                       ((getToken(3).kind == COMMA &&,                                             isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||,                                        getToken(3).kind == ON)) ||,                                      isPrivilegeKeywordExceptTrigger(getToken(2).kind))) {,       jj_consume_token(REVOKE);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_2, "REVOKE");,                 checkSqlStandardAccess( "REVOKE");,       switch (jj_nt.kind) {,       case ALL:,       case DELETE:,       case INSERT:,       case REFERENCES:,       case SELECT:,       case UPDATE:,       case TRIGGER:,         node = tableRevokeStatement();,         break;,       case EXECUTE:,         node = routineRevokeStatement();,         break;,       case USAGE:,         node = usageRevokeStatement();,         break;,       default:,         jj_la1[367] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },                 {if (true) return node;},     } else if (getToken(1).kind == REVOKE &&,                                     ((getToken(2).kind == TRIGGER &&,                                       ((getToken(3).kind == COMMA &&,                                             !isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||,                                        getToken(3).kind == FROM)) ||,                                      !isPrivilegeKeywordExceptTrigger(getToken(2).kind))) {,       jj_consume_token(REVOKE);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_5, "ROLES");,                 checkSqlStandardAccess("REVOKE <role>");,       node = roleRevokeStatement();,                 {if (true) return node;},     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="tableRevokeStatement">tableRevokeStatement</A>,  */,   final public StatementNode tableRevokeStatement() throws ParseException, StandardException {,     PrivilegeNode privileges = null;,     List<String> grantees;,     privileges = tablePrivileges();,     jj_consume_token(FROM);,     grantees = granteeList();,         {if (true) return new RevokeNode(privileges, grantees, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,  // end of tableRevokeStatement, , /*,  * <A NAME="routineRevokeStatement">routineRevokeStatement</A>,  */,   final public StatementNode routineRevokeStatement() throws ParseException, StandardException {,     List<String> grantees;,     RoutineDesignator routine = null;,     jj_consume_token(EXECUTE);,     jj_consume_token(ON);,     routine = routineDesignator();,     jj_consume_token(FROM);,     grantees = granteeList();,     jj_consume_token(RESTRICT);,         PrivilegeNode routinePrivilege = new PrivilegeNode(,             PrivilegeNode.ROUTINE_PRIVILEGES,,             routine,,             null,,             getContextManager());, ,         {if (true) return new RevokeNode(routinePrivilege, grantees, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,  // end of routineRevokeStatement, , /*,  * <A NAME="usageRevokeStatement">usageRevokeStatement</A>,  */,   final public StatementNode usageRevokeStatement() throws ParseException, StandardException {,     List<String> grantees;,     TableName name;,     Integer objectType;,     jj_consume_token(USAGE);,     jj_consume_token(ON);,     objectType = usableObjects();,     name = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);,     jj_consume_token(FROM);,     grantees = granteeList();,     jj_consume_token(RESTRICT);,                 checkVersion( DataDictionary.DD_VERSION_DERBY_10_6, "REVOKE USAGE");,         PrivilegeNode privilegeNode = new PrivilegeNode(,                 objectType,,                 name,,                 PermDescriptor.USAGE_PRIV,,                 true,,                 getContextManager());, ,         {if (true) return new RevokeNode(privilegeNode, grantees, getContextManager());},     throw new Error("Missing return statement in function");,   }, ,  // end of usageRevokeStatement, , , /*,  * <A NAME="roleRevokeStatement">roleRevokeStatement</A>,  */,   final public StatementNode roleRevokeStatement() throws ParseException, StandardException {,     List<String> rolesRevoked;,     List<String> grantees;,     rolesRevoked = roleList();,     jj_consume_token(FROM);,     grantees = granteeList();,         {if (true) return new RevokeRoleNode(rolesRevoked, grantees, getContextManager());},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="identifier">identifier</A>,  */,   final public String internalIdentifier(int id_length_limit, boolean checkLength) throws ParseException, StandardException {,         String  str;,         Token   tok;,     switch (jj_nt.kind) {,     case IDENTIFIER:,       tok = jj_consume_token(IDENTIFIER);,         str = StringUtil.SQLToUpperCase(tok.image);, ,                 if (checkLength) {//if checkLength false, then calling method would do the length limit checks,                         //limit the identifier to the id length limit passed to this method,                         IdUtil.checkIdentifierLengthLimit(str, id_length_limit);,                 },                 // Remember whether last token was a delimited identifier,                 nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;,         lastTokenDelimitedIdentifier = false;,         thirdToLastIdentifierToken = nextToLastIdentifierToken;,                 nextToLastIdentifierToken = lastIdentifierToken;,                 lastIdentifierToken = tok;,                 {if (true) return str;},       break;,     case DELIMITED_IDENTIFIER:,       str = delimitedIdentifier();,                 if (checkLength) {//if checkLength false, then calling method would do the length limit checks,                         //limit the identifier to the id length limit passed to this method,                         IdUtil.checkIdentifierLengthLimit(str, id_length_limit);,                 },                 {if (true) return str;},       break;,     default:,       jj_la1[368] = jj_gen;,       if (jj_2_89(1)) {,         str = nonReservedKeyword();,                 {if (true) return StringUtil.SQLToUpperCase(str);},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, ,   final public String identifier(int id_length_limit, boolean checkLength) throws ParseException, StandardException {,         String  id;,     id = internalIdentifier(id_length_limit, checkLength);,         {if (true) return id;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="delimitedIdentifier">delimitedIdentifier</A>,  */,   final public String delimitedIdentifier() throws ParseException {,         String  str;,         Token   tok;,     tok = jj_consume_token(DELIMITED_IDENTIFIER);,                 str = tok.image.substring(1, tok.image.length() -1);,                 str = normalizeDelimitedID( str );,                 // Remember whether last token was a delimited identifier,                 nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;,         lastTokenDelimitedIdentifier = true;,         thirdToLastIdentifierToken = nextToLastIdentifierToken;,                 nextToLastIdentifierToken = lastIdentifierToken;,                 lastIdentifierToken = tok;, ,                 {if (true) return str;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="reservedKeyword">reservedKeyword</A>,  */,   final public String reservedKeyword() throws ParseException {,         Token   tok;,     switch (jj_nt.kind) {,     case ADD:,       /* SQL92 reserved Keywords */,               tok = jj_consume_token(ADD);,       break;,     case ALL:,       tok = jj_consume_token(ALL);,       break;,     case ALLOCATE:,       tok = jj_consume_token(ALLOCATE);,       break;,     case ALTER:,       tok = jj_consume_token(ALTER);,       break;,     case AND:,       tok = jj_consume_token(AND);,       break;,     case ANY:,       tok = jj_consume_token(ANY);,       break;,     case ARE:,       tok = jj_consume_token(ARE);,       break;,     case AS:,       tok = jj_consume_token(AS);,       break;,     case ASC:,       tok = jj_consume_token(ASC);,       break;,     case ASSERTION:,       tok = jj_consume_token(ASSERTION);,       break;,     case AT:,       tok = jj_consume_token(AT);,       break;,     case AUTHORIZATION:,       tok = jj_consume_token(AUTHORIZATION);,       break;,     case AVG:,       tok = jj_consume_token(AVG);,       break;,     case BEGIN:,       tok = jj_consume_token(BEGIN);,       break;,     case BETWEEN:,       tok = jj_consume_token(BETWEEN);,       break;,     case BIT:,       tok = jj_consume_token(BIT);,       break;,     case BOTH:,       tok = jj_consume_token(BOTH);,       break;,     case BY:,       tok = jj_consume_token(BY);,       break;,     case CASCADE:,       tok = jj_consume_token(CASCADE);,       break;,     case CASCADED:,       tok = jj_consume_token(CASCADED);,       break;,     case CASE:,       tok = jj_consume_token(CASE);,       break;,     case CAST:,       tok = jj_consume_token(CAST);,       break;,     case CHAR:,       tok = jj_consume_token(CHAR);,       break;,     case CHARACTER:,       tok = jj_consume_token(CHARACTER);,       break;,     case CHECK:,       tok = jj_consume_token(CHECK);,       break;,     case CLOSE:,       tok = jj_consume_token(CLOSE);,       break;,     case COLLATE:,       tok = jj_consume_token(COLLATE);,       break;,     case COLLATION:,       tok = jj_consume_token(COLLATION);,       break;,     case COLUMN:,       tok = jj_consume_token(COLUMN);,       break;,     case COMMIT:,       tok = jj_consume_token(COMMIT);,       break;,     case CONNECT:,       tok = jj_consume_token(CONNECT);,       break;,     case CONNECTION:,       tok = jj_consume_token(CONNECTION);,       break;,     case CONSTRAINT:,       tok = jj_consume_token(CONSTRAINT);,       break;,     case CONSTRAINTS:,       tok = jj_consume_token(CONSTRAINTS);,       break;,     case CONTINUE:,       tok = jj_consume_token(CONTINUE);,       break;,     case CONVERT:,       tok = jj_consume_token(CONVERT);,       break;,     case CORRESPONDING:,       tok = jj_consume_token(CORRESPONDING);,       break;,     case CREATE:,       tok = jj_consume_token(CREATE);,       break;,     case CROSS:,       tok = jj_consume_token(CROSS);,       break;,     case CURRENT:,       tok = jj_consume_token(CURRENT);,       break;,     case CURRENT_DATE:,       tok = jj_consume_token(CURRENT_DATE);,       break;,     case CURRENT_TIME:,       tok = jj_consume_token(CURRENT_TIME);,       break;,     case CURRENT_TIMESTAMP:,       tok = jj_consume_token(CURRENT_TIMESTAMP);,       break;,     case CURRENT_USER:,       tok = jj_consume_token(CURRENT_USER);,       break;,     case CURSOR:,       tok = jj_consume_token(CURSOR);,       break;,     case DEALLOCATE:,       tok = jj_consume_token(DEALLOCATE);,       break;,     case DEC:,       tok = jj_consume_token(DEC);,       break;,     case DECIMAL:,       tok = jj_consume_token(DECIMAL);,       break;,     case DECLARE:,       tok = jj_consume_token(DECLARE);,       break;,     case _DEFAULT:,       tok = jj_consume_token(_DEFAULT);,       break;,     case DEFERRABLE:,       tok = jj_consume_token(DEFERRABLE);,       break;,     case DEFERRED:,       tok = jj_consume_token(DEFERRED);,       break;,     case DELETE:,       tok = jj_consume_token(DELETE);,       break;,     case DESC:,       tok = jj_consume_token(DESC);,       break;,     case DESCRIBE:,       tok = jj_consume_token(DESCRIBE);,       break;,     case DIAGNOSTICS:,       tok = jj_consume_token(DIAGNOSTICS);,       break;,     case DISCONNECT:,       tok = jj_consume_token(DISCONNECT);,       break;,     case DISTINCT:,       tok = jj_consume_token(DISTINCT);,       break;,     case DOUBLE:,       tok = jj_consume_token(DOUBLE);,       break;,     case DROP:,       tok = jj_consume_token(DROP);,       break;,     case ELSE:,       tok = jj_consume_token(ELSE);,       break;,     case END:,       tok = jj_consume_token(END);,       break;,     case ENDEXEC:,       tok = jj_consume_token(ENDEXEC);,       break;,     case ESCAPE:,       tok = jj_consume_token(ESCAPE);,       break;,     case EXCEPT:,       tok = jj_consume_token(EXCEPT);,       break;,     case EXCEPTION:,       tok = jj_consume_token(EXCEPTION);,       break;,     case EXEC:,       tok = jj_consume_token(EXEC);,       break;,     case EXECUTE:,       tok = jj_consume_token(EXECUTE);,       break;,     case EXISTS:,       tok = jj_consume_token(EXISTS);,       break;,     case EXTERNAL:,       tok = jj_consume_token(EXTERNAL);,       break;,     case FALSE:,       tok = jj_consume_token(FALSE);,       break;,     case FETCH:,       tok = jj_consume_token(FETCH);,       break;,     case FIRST:,       tok = jj_consume_token(FIRST);,       break;,     case FLOAT:,       tok = jj_consume_token(FLOAT);,       break;,     case FOR:,       tok = jj_consume_token(FOR);,       break;,     case FOREIGN:,       tok = jj_consume_token(FOREIGN);,       break;,     case FOUND:,       tok = jj_consume_token(FOUND);,       break;,     case FROM:,       tok = jj_consume_token(FROM);,       break;,     case FULL:,       tok = jj_consume_token(FULL);,       break;,     case FUNCTION:,       tok = jj_consume_token(FUNCTION);,       break;,     case GET:,       tok = jj_consume_token(GET);,       break;,     case GET_CURRENT_CONNECTION:,       tok = jj_consume_token(GET_CURRENT_CONNECTION);,       break;,     case GLOBAL:,       tok = jj_consume_token(GLOBAL);,       break;,     case GO:,       tok = jj_consume_token(GO);,       break;,     case GOTO:,       tok = jj_consume_token(GOTO);,       break;,     case GRANT:,       tok = jj_consume_token(GRANT);,       break;,     case GROUP:,       tok = jj_consume_token(GROUP);,       break;,     case HAVING:,       tok = jj_consume_token(HAVING);,       break;,     case HOUR:,       tok = jj_consume_token(HOUR);,       break;,     case IDENTITY:,       tok = jj_consume_token(IDENTITY);,       break;,     case IMMEDIATE:,       tok = jj_consume_token(IMMEDIATE);,       break;,     case IN:,       tok = jj_consume_token(IN);,       break;,     case INDICATOR:,       tok = jj_consume_token(INDICATOR);,       break;,     case INITIALLY:,       tok = jj_consume_token(INITIALLY);,       break;,     case INNER:,       tok = jj_consume_token(INNER);,       break;,     case INOUT:,       tok = jj_consume_token(INOUT);,       break;,     case INPUT:,       tok = jj_consume_token(INPUT);,       break;,     case INSENSITIVE:,       tok = jj_consume_token(INSENSITIVE);,       break;,     case INSERT:,       tok = jj_consume_token(INSERT);,       break;,     case INT:,       tok = jj_consume_token(INT);,       break;,     case INTEGER:,       tok = jj_consume_token(INTEGER);,       break;,     case INTERSECT:,       tok = jj_consume_token(INTERSECT);,       break;,     case INTO:,       tok = jj_consume_token(INTO);,       break;,     case IS:,       tok = jj_consume_token(IS);,       break;,     case ISOLATION:,       tok = jj_consume_token(ISOLATION);,       break;,     case JOIN:,       tok = jj_consume_token(JOIN);,       break;,     case KEY:,       tok = jj_consume_token(KEY);,       break;,     case LAST:,       tok = jj_consume_token(LAST);,       break;,     case LEADING:,       tok = jj_consume_token(LEADING);,       break;,     case LEFT:,       tok = jj_consume_token(LEFT);,       break;,     case LIKE:,       tok = jj_consume_token(LIKE);,       break;,     case LOWER:,       tok = jj_consume_token(LOWER);,       break;,     case MATCH:,       tok = jj_consume_token(MATCH);,       break;,     case MAX:,       tok = jj_consume_token(MAX);,       break;,     case MIN:,       tok = jj_consume_token(MIN);,       break;,     case MINUTE:,       tok = jj_consume_token(MINUTE);,       break;,     case NATIONAL:,       tok = jj_consume_token(NATIONAL);,       break;,     case NATURAL:,       tok = jj_consume_token(NATURAL);,       break;,     case NCHAR:,       tok = jj_consume_token(NCHAR);,       break;,     case NVARCHAR:,       tok = jj_consume_token(NVARCHAR);,       break;,     case NEXT:,       tok = jj_consume_token(NEXT);,       break;,     case NO:,       tok = jj_consume_token(NO);,       break;,     case NONE:,       tok = jj_consume_token(NONE);,       break;,     case NOT:,       tok = jj_consume_token(NOT);,       break;,     case NULL:,       tok = jj_consume_token(NULL);,       break;,     case NULLIF:,       tok = jj_consume_token(NULLIF);,       break;,     case NUMERIC:,       tok = jj_consume_token(NUMERIC);,       break;,     case OF:,       tok = jj_consume_token(OF);,       break;,     case ON:,       tok = jj_consume_token(ON);,       break;,     case ONLY:,       tok = jj_consume_token(ONLY);,       break;,     case OPEN:,       tok = jj_consume_token(OPEN);,       break;,     case OPTION:,       tok = jj_consume_token(OPTION);,       break;,     case OR:,       tok = jj_consume_token(OR);,       break;,     case ORDER:,       tok = jj_consume_token(ORDER);,       break;,     case OUT:,       tok = jj_consume_token(OUT);,       break;,     case OUTER:,       tok = jj_consume_token(OUTER);,       break;,     case OUTPUT:,       tok = jj_consume_token(OUTPUT);,       break;,     case OVERLAPS:,       tok = jj_consume_token(OVERLAPS);,       break;,     case PAD:,       tok = jj_consume_token(PAD);,       break;,     case PARTIAL:,       tok = jj_consume_token(PARTIAL);,       break;,     case PREPARE:,       tok = jj_consume_token(PREPARE);,       break;,     case PRESERVE:,       tok = jj_consume_token(PRESERVE);,       break;,     case PRIMARY:,       tok = jj_consume_token(PRIMARY);,       break;,     case PRIOR:,       tok = jj_consume_token(PRIOR);,       break;,     case PRIVILEGES:,       tok = jj_consume_token(PRIVILEGES);,       break;,     case PROCEDURE:,       tok = jj_consume_token(PROCEDURE);,       break;,     case PUBLIC:,       tok = jj_consume_token(PUBLIC);,       break;,     case READ:,       tok = jj_consume_token(READ);,       break;,     case REAL:,       tok = jj_consume_token(REAL);,       break;,     case REFERENCES:,       tok = jj_consume_token(REFERENCES);,       break;,     case RELATIVE:,       tok = jj_consume_token(RELATIVE);,       break;,     case RESTRICT:,       tok = jj_consume_token(RESTRICT);,       break;,     case REVOKE:,       tok = jj_consume_token(REVOKE);,       break;,     case RIGHT:,       tok = jj_consume_token(RIGHT);,       break;,     case ROLLBACK:,       tok = jj_consume_token(ROLLBACK);,       break;,     case ROWS:,       tok = jj_consume_token(ROWS);,       break;,     case SCHEMA:,       tok = jj_consume_token(SCHEMA);,       break;,     case SCROLL:,       tok = jj_consume_token(SCROLL);,       break;,     case SECOND:,       tok = jj_consume_token(SECOND);,       break;,     case SELECT:,       tok = jj_consume_token(SELECT);,       break;,     case SESSION_USER:,       tok = jj_consume_token(SESSION_USER);,       break;,     case SET:,       tok = jj_consume_token(SET);,       break;,     case SMALLINT:,       tok = jj_consume_token(SMALLINT);,       break;,     case SOME:,       tok = jj_consume_token(SOME);,       break;,     case SPACE:,       tok = jj_consume_token(SPACE);,       break;,     case SQL:,       tok = jj_consume_token(SQL);,       break;,     case SQLCODE:,       tok = jj_consume_token(SQLCODE);,       break;,     case SQLERROR:,       tok = jj_consume_token(SQLERROR);,       break;,     case SQLSTATE:,       tok = jj_consume_token(SQLSTATE);,       break;,     case SUBSTRING:,       tok = jj_consume_token(SUBSTRING);,       break;,     case SUM:,       tok = jj_consume_token(SUM);,       break;,     case SYSTEM_USER:,       tok = jj_consume_token(SYSTEM_USER);,       break;,     case TABLE:,       tok = jj_consume_token(TABLE);,       break;,     case TEMPORARY:,       tok = jj_consume_token(TEMPORARY);,       break;,     case TIMEZONE_HOUR:,       tok = jj_consume_token(TIMEZONE_HOUR);,       break;,     case TIMEZONE_MINUTE:,       tok = jj_consume_token(TIMEZONE_MINUTE);,       break;,     case TO:,       tok = jj_consume_token(TO);,       break;,     case TRAILING:,       tok = jj_consume_token(TRAILING);,       break;,     case TRANSACTION:,       tok = jj_consume_token(TRANSACTION);,       break;,     case TRANSLATE:,       tok = jj_consume_token(TRANSLATE);,       break;,     case TRANSLATION:,       tok = jj_consume_token(TRANSLATION);,       break;,     case TRUE:,       tok = jj_consume_token(TRUE);,       break;,     case UNION:,       tok = jj_consume_token(UNION);,       break;,     case UNIQUE:,       tok = jj_consume_token(UNIQUE);,       break;,     case UNKNOWN:,       tok = jj_consume_token(UNKNOWN);,       break;,     case UPDATE:,       tok = jj_consume_token(UPDATE);,       break;,     case UPPER:,       tok = jj_consume_token(UPPER);,       break;,     case USER:,       tok = jj_consume_token(USER);,       break;,     case USING:,       tok = jj_consume_token(USING);,       break;,     case VALUES:,       tok = jj_consume_token(VALUES);,       break;,     case VARCHAR:,       tok = jj_consume_token(VARCHAR);,       break;,     case VARYING:,       tok = jj_consume_token(VARYING);,       break;,     case VIEW:,       tok = jj_consume_token(VIEW);,       break;,     case WHENEVER:,       tok = jj_consume_token(WHENEVER);,       break;,     case WHERE:,       tok = jj_consume_token(WHERE);,       break;,     case WITH:,       tok = jj_consume_token(WITH);,       break;,     case WORK:,       tok = jj_consume_token(WORK);,       break;,     case WRITE:,       tok = jj_consume_token(WRITE);,       break;,     case YEAR:,       tok = jj_consume_token(YEAR);,       break;,     case BOOLEAN:,       tok = jj_consume_token(BOOLEAN);,       break;,     case CALL:,       tok = jj_consume_token(CALL);,       break;,     case CURRENT_ROLE:,       tok = jj_consume_token(CURRENT_ROLE);,       break;,     case EXPLAIN:,       tok = jj_consume_token(EXPLAIN);,       break;,     case BIGINT:,       tok = jj_consume_token(BIGINT);,       break;,     case LTRIM:,       tok = jj_consume_token(LTRIM);,       break;,     case RTRIM:,       tok = jj_consume_token(RTRIM);,       break;,     case TRIM:,       tok = jj_consume_token(TRIM);,       break;,     case SUBSTR:,       tok = jj_consume_token(SUBSTR);,       break;,     case XML:,       tok = jj_consume_token(XML);,       break;,     case XMLPARSE:,       tok = jj_consume_token(XMLPARSE);,       break;,     case XMLSERIALIZE:,       tok = jj_consume_token(XMLSERIALIZE);,       break;,     case XMLEXISTS:,       tok = jj_consume_token(XMLEXISTS);,       break;,     case XMLQUERY:,       tok = jj_consume_token(XMLQUERY);,       break;,     default:,       jj_la1[369] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 // Remember whether last token was a delimited identifier,                 nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;,         lastTokenDelimitedIdentifier = false;,                 {if (true) return tok.image;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="nonReservedKeyword">nonReservedKeyword</A>,  */,   final public String nonReservedKeyword() throws ParseException {,         Token   tok;,     switch (jj_nt.kind) {,     case ABS:,       tok = jj_consume_token(ABS);,       break;,     case ABSVAL:,       tok = jj_consume_token(ABSVAL);,       break;,     case ACTION:,       tok = jj_consume_token(ACTION);,       break;,     case AFTER:,       tok = jj_consume_token(AFTER);,       break;,     case AGGREGATE:,       tok = jj_consume_token(AGGREGATE);,       break;,     case ALWAYS:,       tok = jj_consume_token(ALWAYS);,       break;,     case BEFORE:,       tok = jj_consume_token(BEFORE);,       break;,     case BINARY:,       tok = jj_consume_token(BINARY);,       break;,     case BLOB:,       tok = jj_consume_token(BLOB);,       break;,     case C:,       tok = jj_consume_token(C);,       break;,     case CALLED:,       tok = jj_consume_token(CALLED);,       break;,     case CLASS:,       tok = jj_consume_token(CLASS);,       break;,     case CLOB:,       tok = jj_consume_token(CLOB);,       break;,     case COALESCE:,       tok = jj_consume_token(COALESCE);,       break;,     case COBOL:,       tok = jj_consume_token(COBOL);,       break;,     case COMMITTED:,       tok = jj_consume_token(COMMITTED);,       break;,     case COMPRESS:,       tok = jj_consume_token(COMPRESS);,       break;,     case CONCAT:,       tok = jj_consume_token(CONCAT);,       break;,     case CONTAINS:,       tok = jj_consume_token(CONTAINS);,       break;,     case CONTENT:,       tok = jj_consume_token(CONTENT);,       break;,     case COUNT:,       tok = jj_consume_token(COUNT);,       break;,     case CS:,       tok = jj_consume_token(CS);,       break;,     case CURDATE:,       tok = jj_consume_token(CURDATE);,       break;,     case CURTIME:,       tok = jj_consume_token(CURTIME);,       break;,     case CYCLE:,       tok = jj_consume_token(CYCLE);,       break;,     case D:,       tok = jj_consume_token(D);,       break;,     case DATA:,       tok = jj_consume_token(DATA);,       break;,     case DATE:,       tok = jj_consume_token(DATE);,       break;,     case DAY:,       tok = jj_consume_token(DAY);,       break;,     case DEFRAGMENT:,       tok = jj_consume_token(DEFRAGMENT);,       break;,     case DIRTY:,       tok = jj_consume_token(DIRTY);,       break;,     case DYNAMIC:,       tok = jj_consume_token(DYNAMIC);,       break;,     case DATABASE:,       tok = jj_consume_token(DATABASE);,       break;,     case DB2SQL:,       tok = jj_consume_token(DB2SQL);,       break;,     case DERBY:,       tok = jj_consume_token(DERBY);,       break;,     case DERBY_JDBC_RESULT_SET:,       tok = jj_consume_token(DERBY_JDBC_RESULT_SET);,       break;,     case DOCUMENT:,       tok = jj_consume_token(DOCUMENT);,       break;,     case ENFORCED:,       tok = jj_consume_token(ENFORCED);,       break;,     case EACH:,       tok = jj_consume_token(EACH);,       break;,     case EMPTY:,       tok = jj_consume_token(EMPTY);,       break;,     case EXCLUSIVE:,       tok = jj_consume_token(EXCLUSIVE);,       break;,     case FN:,       tok = jj_consume_token(FN);,       break;,     case FORTRAN:,       tok = jj_consume_token(FORTRAN);,       break;,     case GENERATED:,       tok = jj_consume_token(GENERATED);,       break;,     case IDENTITY_VAL_LOCAL:,       tok = jj_consume_token(IDENTITY_VAL_LOCAL);,       break;,     case INCREMENT:,       tok = jj_consume_token(INCREMENT);,       break;,     case INDEX:,       tok = jj_consume_token(INDEX);,       break;,     case INITIAL:,       tok = jj_consume_token(INITIAL);,       break;,     case INPLACE:,       tok = jj_consume_token(INPLACE);,       break;,     case INTERVAL:,       tok = jj_consume_token(INTERVAL);,       break;,     case JAVA:,       tok = jj_consume_token(JAVA);,       break;,     case LANGUAGE:,       tok = jj_consume_token(LANGUAGE);,       break;,     case LARGE:,       tok = jj_consume_token(LARGE);,       break;,     case LCASE:,       tok = jj_consume_token(LCASE);,       break;,     case LENGTH:,       tok = jj_consume_token(LENGTH);,       break;,     case LEVEL:,       tok = jj_consume_token(LEVEL);,       break;,     case LIMIT:,       tok = jj_consume_token(LIMIT);,       break;,     case LOCATE:,       tok = jj_consume_token(LOCATE);,       break;,     case LOCK:,       tok = jj_consume_token(LOCK);,       break;,     case LOCKS:,       tok = jj_consume_token(LOCKS);,       break;,     case LOCKSIZE:,       tok = jj_consume_token(LOCKSIZE);,       break;,     case LOGGED:,       tok = jj_consume_token(LOGGED);,       break;,     case LONG:,       tok = jj_consume_token(LONG);,       break;,     case MATCHED:,       tok = jj_consume_token(MATCHED);,       break;,     case MAXVALUE:,       tok = jj_consume_token(MAXVALUE);,       break;,     case MERGE:,       tok = jj_consume_token(MERGE);,       break;,     case MINVALUE:,       tok = jj_consume_token(MINVALUE);,       break;,     case MESSAGE_LOCALE:,       tok = jj_consume_token(MESSAGE_LOCALE);,       break;,     case METHOD:,       tok = jj_consume_token(METHOD);,       break;,     case MOD:,       tok = jj_consume_token(MOD);,       break;,     case MODE:,       tok = jj_consume_token(MODE);,       break;,     case MODIFIES:,       tok = jj_consume_token(MODIFIES);,       break;,     case MODIFY:,       tok = jj_consume_token(MODIFY);,       break;,     case MODULE:,       tok = jj_consume_token(MODULE);,       break;,     case MONTH:,       tok = jj_consume_token(MONTH);,       break;,     case _MORE:,       tok = jj_consume_token(_MORE);,       break;,     case MUMPS:,       tok = jj_consume_token(MUMPS);,       break;,     case NAME:,       tok = jj_consume_token(NAME);,       break;,     case NCLOB:,       tok = jj_consume_token(NCLOB);,       break;,     case NEW:,       tok = jj_consume_token(NEW);,       break;,     case NEW_TABLE:,       tok = jj_consume_token(NEW_TABLE);,       break;,     case NULLABLE:,       tok = jj_consume_token(NULLABLE);,       break;,     case NULLS:,       tok = jj_consume_token(NULLS);,       break;,     case NUMBER:,       tok = jj_consume_token(NUMBER);,       break;,     case OBJECT:,       tok = jj_consume_token(OBJECT);,       break;,     case OFF:,       tok = jj_consume_token(OFF);,       break;,     default:,       jj_la1[370] = jj_gen;,       if (getToken(1).kind == OFFSET &&,                               !seeingOffsetClause()) {,         tok = jj_consume_token(OFFSET);,       } else {,         switch (jj_nt.kind) {,         case OLD:,           tok = jj_consume_token(OLD);,           break;,         case OLD_TABLE:,           tok = jj_consume_token(OLD_TABLE);,           break;,         case OJ:,           tok = jj_consume_token(OJ);,           break;,         case OVER:,           tok = jj_consume_token(OVER);,           break;,         case PASCAL:,           tok = jj_consume_token(PASCAL);,           break;,         case PASSING:,           tok = jj_consume_token(PASSING);,           break;,         case PLI:,           tok = jj_consume_token(PLI);,           break;,         case PRECISION:,           tok = jj_consume_token(PRECISION);,           break;,         case PROPERTIES:,           tok = jj_consume_token(PROPERTIES);,           break;,         case PURGE:,           tok = jj_consume_token(PURGE);,           break;,         case READS:,           tok = jj_consume_token(READS);,           break;,         case REF:,           tok = jj_consume_token(REF);,           break;,         case RELEASE:,           tok = jj_consume_token(RELEASE);,           break;,         case RENAME:,           tok = jj_consume_token(RENAME);,           break;,         case REPEATABLE:,           tok = jj_consume_token(REPEATABLE);,           break;,         case REFERENCING:,           tok = jj_consume_token(REFERENCING);,           break;,         case RESET:,           tok = jj_consume_token(RESET);,           break;,         case RESTART:,           tok = jj_consume_token(RESTART);,           break;,         case RESULT:,           tok = jj_consume_token(RESULT);,           break;,         case RETAIN:,           tok = jj_consume_token(RETAIN);,           break;,         case RETURNING:,           tok = jj_consume_token(RETURNING);,           break;,         case RETURNS:,           tok = jj_consume_token(RETURNS);,           break;,         case ROLE:,           tok = jj_consume_token(ROLE);,           break;,         case ROLLUP:,           tok = jj_consume_token(ROLLUP);,           break;,         case ROW:,           tok = jj_consume_token(ROW);,           break;,         case ROWNUMBER:,           tok = jj_consume_token(ROWNUMBER);,           break;,         case RR:,           tok = jj_consume_token(RR);,           break;,         case RS:,           tok = jj_consume_token(RS);,           break;,         case SCALE:,           tok = jj_consume_token(SCALE);,           break;,         case SAVEPOINT:,           tok = jj_consume_token(SAVEPOINT);,           break;,         case SECURITY:,           tok = jj_consume_token(SECURITY);,           break;,         case SEQUENCE:,           tok = jj_consume_token(SEQUENCE);,           break;,         case SEQUENTIAL:,           tok = jj_consume_token(SEQUENTIAL);,           break;,         case SERIALIZABLE:,           tok = jj_consume_token(SERIALIZABLE);,           break;,         case SETS:,           tok = jj_consume_token(SETS);,           break;,         case SHARE:,           tok = jj_consume_token(SHARE);,           break;,         case SPECIFIC:,           tok = jj_consume_token(SPECIFIC);,           break;,         case SQLID:,           tok = jj_consume_token(SQLID);,           break;,         case SQL_TSI_FRAC_SECOND:,           tok = jj_consume_token(SQL_TSI_FRAC_SECOND);,           break;,         case SQL_TSI_SECOND:,           tok = jj_consume_token(SQL_TSI_SECOND);,           break;,         case SQL_TSI_MINUTE:,           tok = jj_consume_token(SQL_TSI_MINUTE);,           break;,         case SQL_TSI_HOUR:,           tok = jj_consume_token(SQL_TSI_HOUR);,           break;,         case SQL_TSI_DAY:,           tok = jj_consume_token(SQL_TSI_DAY);,           break;,         case SQL_TSI_WEEK:,           tok = jj_consume_token(SQL_TSI_WEEK);,           break;,         case SQL_TSI_MONTH:,           tok = jj_consume_token(SQL_TSI_MONTH);,           break;,         case SQL_TSI_QUARTER:,           tok = jj_consume_token(SQL_TSI_QUARTER);,           break;,         case SQL_TSI_YEAR:,           tok = jj_consume_token(SQL_TSI_YEAR);,           break;,         case SQRT:,           tok = jj_consume_token(SQRT);,           break;,         case STABILITY:,           tok = jj_consume_token(STABILITY);,           break;,         case START:,           tok = jj_consume_token(START);,           break;,         case STATEMENT:,           tok = jj_consume_token(STATEMENT);,           break;,         case STATISTICS:,           tok = jj_consume_token(STATISTICS);,           break;,         case STRIP:,           tok = jj_consume_token(STRIP);,           break;,         case SYNONYM:,           tok = jj_consume_token(SYNONYM);,           break;,         case STYLE:,           tok = jj_consume_token(STYLE);,           break;,         case T:,           tok = jj_consume_token(T);,           break;,         case THEN:,           tok = jj_consume_token(THEN);,           break;,         case TIME:,           tok = jj_consume_token(TIME);,           break;,         case TIMESTAMP:,           tok = jj_consume_token(TIMESTAMP);,           break;,         case TIMESTAMPADD:,           tok = jj_consume_token(TIMESTAMPADD);,           break;,         case TIMESTAMPDIFF:,           tok = jj_consume_token(TIMESTAMPDIFF);,           break;,         case TRIGGER:,           tok = jj_consume_token(TRIGGER);,           break;,         case TRUNCATE:,           tok = jj_consume_token(TRUNCATE);,           break;,         case TRUNCATE_END:,           tok = jj_consume_token(TRUNCATE_END);,           break;,         case TS:,           tok = jj_consume_token(TS);,           break;,         case TYPE:,           tok = jj_consume_token(TYPE);,           break;,         case UCASE:,           tok = jj_consume_token(UCASE);,           break;,         case UNCOMMITTED:,           tok = jj_consume_token(UNCOMMITTED);,           break;,         case UR:,           tok = jj_consume_token(UR);,           break;,         case USAGE:,           tok = jj_consume_token(USAGE);,           break;,         case VALUE:,           tok = jj_consume_token(VALUE);,           break;,         case VARBINARY:,           tok = jj_consume_token(VARBINARY);,           break;,         case PARAMETER:,           tok = jj_consume_token(PARAMETER);,           break;,         case WHEN:,           tok = jj_consume_token(WHEN);,           break;,         case WHITESPACE:,           tok = jj_consume_token(WHITESPACE);,           break;,         default:,           jj_la1[371] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },     },                 // Remember whether last token was a delimited identifier,                 nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;,         lastTokenDelimitedIdentifier = false;,         thirdToLastIdentifierToken = nextToLastIdentifierToken;,                 nextToLastIdentifierToken = lastIdentifierToken;,                 lastIdentifierToken = tok;,                 {if (true) return tok.image;},     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="caseSensitiveIdentifierPlusReservedWords">caseSensitiveIdentifierPlusReservedWords</A>,  */,   final public String caseSensitiveIdentifierPlusReservedWords() throws ParseException {,         String str;,     if (jj_2_90(1)) {,       str = caseSensitiveIdentifier();,                 {if (true) return str;},     } else {,       switch (jj_nt.kind) {,       case ADD:,       case ALL:,       case ALLOCATE:,       case ALTER:,       case AND:,       case ANY:,       case ARE:,       case AS:,       case ASC:,       case ASSERTION:,       case AT:,       case AUTHORIZATION:,       case AVG:,       case BEGIN:,       case BETWEEN:,       case BIT:,       case BOTH:,       case BY:,       case CASCADE:,       case CASCADED:,       case CASE:,       case CAST:,       case CHAR:,       case CHARACTER:,       case CHECK:,       case CLOSE:,       case COLLATE:,       case COLLATION:,       case COLUMN:,       case COMMIT:,       case CONNECT:,       case CONNECTION:,       case CONSTRAINT:,       case CONSTRAINTS:,       case CONTINUE:,       case CONVERT:,       case CORRESPONDING:,       case CREATE:,       case CROSS:,       case CURRENT:,       case CURRENT_DATE:,       case CURRENT_TIME:,       case CURRENT_TIMESTAMP:,       case CURRENT_USER:,       case CURSOR:,       case DEALLOCATE:,       case DEC:,       case DECIMAL:,       case DECLARE:,       case _DEFAULT:,       case DEFERRABLE:,       case DEFERRED:,       case DELETE:,       case DESC:,       case DESCRIBE:,       case DIAGNOSTICS:,       case DISCONNECT:,       case DISTINCT:,       case DOUBLE:,       case DROP:,       case ELSE:,       case END:,       case ENDEXEC:,       case ESCAPE:,       case EXCEPT:,       case EXCEPTION:,       case EXEC:,       case EXECUTE:,       case EXISTS:,       case EXTERNAL:,       case FALSE:,       case FETCH:,       case FIRST:,       case FLOAT:,       case FOR:,       case FOREIGN:,       case FOUND:,       case FROM:,       case FULL:,       case FUNCTION:,       case GET:,       case GLOBAL:,       case GO:,       case GOTO:,       case GRANT:,       case GROUP:,       case HAVING:,       case HOUR:,       case IDENTITY:,       case IMMEDIATE:,       case IN:,       case INDICATOR:,       case INITIALLY:,       case INNER:,       case INPUT:,       case INSENSITIVE:,       case INSERT:,       case INT:,       case INTEGER:,       case INTERSECT:,       case INTO:,       case IS:,       case ISOLATION:,       case JOIN:,       case KEY:,       case LAST:,       case LEADING:,       case LEFT:,       case LIKE:,       case LOWER:,       case MATCH:,       case MAX:,       case MIN:,       case MINUTE:,       case NATIONAL:,       case NATURAL:,       case NCHAR:,       case NEXT:,       case NO:,       case NOT:,       case NULL:,       case NULLIF:,       case NUMERIC:,       case OF:,       case ON:,       case ONLY:,       case OPEN:,       case OPTION:,       case OR:,       case ORDER:,       case OUTER:,       case OUTPUT:,       case OVERLAPS:,       case PAD:,       case PARTIAL:,       case PREPARE:,       case PRESERVE:,       case PRIMARY:,       case PRIOR:,       case PRIVILEGES:,       case PROCEDURE:,       case PUBLIC:,       case READ:,       case REAL:,       case REFERENCES:,       case RELATIVE:,       case RESTRICT:,       case REVOKE:,       case RIGHT:,       case ROLLBACK:,       case ROWS:,       case SCHEMA:,       case SCROLL:,       case SECOND:,       case SELECT:,       case SESSION_USER:,       case SET:,       case SMALLINT:,       case SOME:,       case SPACE:,       case SQL:,       case SQLCODE:,       case SQLERROR:,       case SQLSTATE:,       case SUBSTRING:,       case SUM:,       case SYSTEM_USER:,       case TABLE:,       case TEMPORARY:,       case TIMEZONE_HOUR:,       case TIMEZONE_MINUTE:,       case TO:,       case TRANSACTION:,       case TRANSLATE:,       case TRANSLATION:,       case TRAILING:,       case TRIM:,       case TRUE:,       case UNION:,       case UNIQUE:,       case UNKNOWN:,       case UPDATE:,       case UPPER:,       case USER:,       case USING:,       case VALUES:,       case VARCHAR:,       case VARYING:,       case VIEW:,       case WHENEVER:,       case WHERE:,       case WITH:,       case WORK:,       case WRITE:,       case YEAR:,       case INOUT:,       case BOOLEAN:,       case CALL:,       case CURRENT_ROLE:,       case GET_CURRENT_CONNECTION:,       case EXPLAIN:,       case BIGINT:,       case LTRIM:,       case NONE:,       case RTRIM:,       case SUBSTR:,       case XML:,       case XMLEXISTS:,       case XMLPARSE:,       case XMLQUERY:,       case XMLSERIALIZE:,       case NVARCHAR:,       case OUT:,         str = reservedKeyword();,                 {if (true) return str;},         break;,       default:,         jj_la1[372] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="caseInsensitiveIdentifierPlusReservedWords">caseInsensitiveIdentifierPlusReservedWords</A>,  */,   final public String caseInsensitiveIdentifierPlusReservedWords() throws ParseException, StandardException {,         String str;,     if (jj_2_91(1)) {,       str = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);,                 {if (true) return str;},     } else {,       switch (jj_nt.kind) {,       case ADD:,       case ALL:,       case ALLOCATE:,       case ALTER:,       case AND:,       case ANY:,       case ARE:,       case AS:,       case ASC:,       case ASSERTION:,       case AT:,       case AUTHORIZATION:,       case AVG:,       case BEGIN:,       case BETWEEN:,       case BIT:,       case BOTH:,       case BY:,       case CASCADE:,       case CASCADED:,       case CASE:,       case CAST:,       case CHAR:,       case CHARACTER:,       case CHECK:,       case CLOSE:,       case COLLATE:,       case COLLATION:,       case COLUMN:,       case COMMIT:,       case CONNECT:,       case CONNECTION:,       case CONSTRAINT:,       case CONSTRAINTS:,       case CONTINUE:,       case CONVERT:,       case CORRESPONDING:,       case CREATE:,       case CROSS:,       case CURRENT:,       case CURRENT_DATE:,       case CURRENT_TIME:,       case CURRENT_TIMESTAMP:,       case CURRENT_USER:,       case CURSOR:,       case DEALLOCATE:,       case DEC:,       case DECIMAL:,       case DECLARE:,       case _DEFAULT:,       case DEFERRABLE:,       case DEFERRED:,       case DELETE:,       case DESC:,       case DESCRIBE:,       case DIAGNOSTICS:,       case DISCONNECT:,       case DISTINCT:,       case DOUBLE:,       case DROP:,       case ELSE:,       case END:,       case ENDEXEC:,       case ESCAPE:,       case EXCEPT:,       case EXCEPTION:,       case EXEC:,       case EXECUTE:,       case EXISTS:,       case EXTERNAL:,       case FALSE:,       case FETCH:,       case FIRST:,       case FLOAT:,       case FOR:,       case FOREIGN:,       case FOUND:,       case FROM:,       case FULL:,       case FUNCTION:,       case GET:,       case GLOBAL:,       case GO:,       case GOTO:,       case GRANT:,       case GROUP:,       case HAVING:,       case HOUR:,       case IDENTITY:,       case IMMEDIATE:,       case IN:,       case INDICATOR:,       case INITIALLY:,       case INNER:,       case INPUT:,       case INSENSITIVE:,       case INSERT:,       case INT:,       case INTEGER:,       case INTERSECT:,       case INTO:,       case IS:,       case ISOLATION:,       case JOIN:,       case KEY:,       case LAST:,       case LEADING:,       case LEFT:,       case LIKE:,       case LOWER:,       case MATCH:,       case MAX:,       case MIN:,       case MINUTE:,       case NATIONAL:,       case NATURAL:,       case NCHAR:,       case NEXT:,       case NO:,       case NOT:,       case NULL:,       case NULLIF:,       case NUMERIC:,       case OF:,       case ON:,       case ONLY:,       case OPEN:,       case OPTION:,       case OR:,       case ORDER:,       case OUTER:,       case OUTPUT:,       case OVERLAPS:,       case PAD:,       case PARTIAL:,       case PREPARE:,       case PRESERVE:,       case PRIMARY:,       case PRIOR:,       case PRIVILEGES:,       case PROCEDURE:,       case PUBLIC:,       case READ:,       case REAL:,       case REFERENCES:,       case RELATIVE:,       case RESTRICT:,       case REVOKE:,       case RIGHT:,       case ROLLBACK:,       case ROWS:,       case SCHEMA:,       case SCROLL:,       case SECOND:,       case SELECT:,       case SESSION_USER:,       case SET:,       case SMALLINT:,       case SOME:,       case SPACE:,       case SQL:,       case SQLCODE:,       case SQLERROR:,       case SQLSTATE:,       case SUBSTRING:,       case SUM:,       case SYSTEM_USER:,       case TABLE:,       case TEMPORARY:,       case TIMEZONE_HOUR:,       case TIMEZONE_MINUTE:,       case TO:,       case TRANSACTION:,       case TRANSLATE:,       case TRANSLATION:,       case TRAILING:,       case TRIM:,       case TRUE:,       case UNION:,       case UNIQUE:,       case UNKNOWN:,       case UPDATE:,       case UPPER:,       case USER:,       case USING:,       case VALUES:,       case VARCHAR:,       case VARYING:,       case VIEW:,       case WHENEVER:,       case WHERE:,       case WITH:,       case WORK:,       case WRITE:,       case YEAR:,       case INOUT:,       case BOOLEAN:,       case CALL:,       case CURRENT_ROLE:,       case GET_CURRENT_CONNECTION:,       case EXPLAIN:,       case BIGINT:,       case LTRIM:,       case NONE:,       case RTRIM:,       case SUBSTR:,       case XML:,       case XMLEXISTS:,       case XMLPARSE:,       case XMLQUERY:,       case XMLSERIALIZE:,       case NVARCHAR:,       case OUT:,         str = reservedKeyword();,                 {if (true) return StringUtil.SQLToUpperCase(str);},         break;,       default:,         jj_la1[373] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, , /*,  * <A NAME="caseSensitiveIdentifier">caseSensitiveIdentifier</A>,  */,   final public String caseSensitiveIdentifier() throws ParseException {,         String  str;,         Token   tok;,     switch (jj_nt.kind) {,     case IDENTIFIER:,       tok = jj_consume_token(IDENTIFIER);,                 // Remember whether last token was a delimited identifier,                 nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;,         lastTokenDelimitedIdentifier = false;,                 {if (true) return tok.image;},       break;,     case DELIMITED_IDENTIFIER:,       str = delimitedIdentifier();,                 {if (true) return str;},       break;,     default:,       jj_la1[374] = jj_gen;,       if (jj_2_92(1)) {,         str = nonReservedKeyword();,                 {if (true) return str;},       } else {,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, ,   final private boolean jj_2_1(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_1(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(0, xla); },   }, ,   final private boolean jj_2_2(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_2(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(1, xla); },   }, ,   final private boolean jj_2_3(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_3(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(2, xla); },   }, ,   final private boolean jj_2_4(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_4(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(3, xla); },   }, ,   final private boolean jj_2_5(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_5(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(4, xla); },   }, ,   final private boolean jj_2_6(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_6(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(5, xla); },   }, ,   final private boolean jj_2_7(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_7(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(6, xla); },   }, ,   final private boolean jj_2_8(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_8(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(7, xla); },   }, ,   final private boolean jj_2_9(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_9(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(8, xla); },   }, ,   final private boolean jj_2_10(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_10(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(9, xla); },   }, ,   final private boolean jj_2_11(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_11(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(10, xla); },   }, ,   final private boolean jj_2_12(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_12(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(11, xla); },   }, ,   final private boolean jj_2_13(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_13(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(12, xla); },   }, ,   final private boolean jj_2_14(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_14(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(13, xla); },   }, ,   final private boolean jj_2_15(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_15(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(14, xla); },   }, ,   final private boolean jj_2_16(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_16(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(15, xla); },   }, ,   final private boolean jj_2_17(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_17(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(16, xla); },   }, ,   final private boolean jj_2_18(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_18(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(17, xla); },   }, ,   final private boolean jj_2_19(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_19(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(18, xla); },   }, ,   final private boolean jj_2_20(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_20(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(19, xla); },   }, ,   final private boolean jj_2_21(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_21(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(20, xla); },   }, ,   final private boolean jj_2_22(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_22(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(21, xla); },   }, ,   final private boolean jj_2_23(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_23(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(22, xla); },   }, ,   final private boolean jj_2_24(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_24(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(23, xla); },   }, ,   final private boolean jj_2_25(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_25(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(24, xla); },   }, ,   final private boolean jj_2_26(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_26(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(25, xla); },   }, ,   final private boolean jj_2_27(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_27(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(26, xla); },   }, ,   final private boolean jj_2_28(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_28(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(27, xla); },   }, ,   final private boolean jj_2_29(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_29(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(28, xla); },   }, ,   final private boolean jj_2_30(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_30(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(29, xla); },   }, ,   final private boolean jj_2_31(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_31(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(30, xla); },   }, ,   final private boolean jj_2_32(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_32(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(31, xla); },   }, ,   final private boolean jj_2_33(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_33(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(32, xla); },   }, ,   final private boolean jj_2_34(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_34(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(33, xla); },   }, ,   final private boolean jj_2_35(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_35(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(34, xla); },   }, ,   final private boolean jj_2_36(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_36(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(35, xla); },   }, ,   final private boolean jj_2_37(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_37(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(36, xla); },   }, ,   final private boolean jj_2_38(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_38(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(37, xla); },   }, ,   final private boolean jj_2_39(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_39(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(38, xla); },   }, ,   final private boolean jj_2_40(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_40(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(39, xla); },   }, ,   final private boolean jj_2_41(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_41(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(40, xla); },   }, ,   final private boolean jj_2_42(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_42(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(41, xla); },   }, ,   final private boolean jj_2_43(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_43(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(42, xla); },   }, ,   final private boolean jj_2_44(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_44(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(43, xla); },   }, ,   final private boolean jj_2_45(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_45(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(44, xla); },   }, ,   final private boolean jj_2_46(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_46(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(45, xla); },   }, ,   final private boolean jj_2_47(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_47(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(46, xla); },   }, ,   final private boolean jj_2_48(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_48(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(47, xla); },   }, ,   final private boolean jj_2_49(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_49(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(48, xla); },   }, ,   final private boolean jj_2_50(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_50(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(49, xla); },   }, ,   final private boolean jj_2_51(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_51(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(50, xla); },   }, ,   final private boolean jj_2_52(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_52(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(51, xla); },   }, ,   final private boolean jj_2_53(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_53(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(52, xla); },   }, ,   final private boolean jj_2_54(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_54(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(53, xla); },   }, ,   final private boolean jj_2_55(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_55(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(54, xla); },   }, ,   final private boolean jj_2_56(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_56(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(55, xla); },   }, ,   final private boolean jj_2_57(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_57(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(56, xla); },   }, ,   final private boolean jj_2_58(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_58(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(57, xla); },   }, ,   final private boolean jj_2_59(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_59(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(58, xla); },   }, ,   final private boolean jj_2_60(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_60(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(59, xla); },   }, ,   final private boolean jj_2_61(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_61(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(60, xla); },   }, ,   final private boolean jj_2_62(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_62(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(61, xla); },   }, ,   final private boolean jj_2_63(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_63(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(62, xla); },   }, ,   final private boolean jj_2_64(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_64(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(63, xla); },   }, ,   final private boolean jj_2_65(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_65(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(64, xla); },   }, ,   final private boolean jj_2_66(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_66(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(65, xla); },   }, ,   final private boolean jj_2_67(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_67(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(66, xla); },   }, ,   final private boolean jj_2_68(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_68(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(67, xla); },   }, ,   final private boolean jj_2_69(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_69(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(68, xla); },   }, ,   final private boolean jj_2_70(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_70(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(69, xla); },   }, ,   final private boolean jj_2_71(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_71(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(70, xla); },   }, ,   final private boolean jj_2_72(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_72(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(71, xla); },   }, ,   final private boolean jj_2_73(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_73(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(72, xla); },   }, ,   final private boolean jj_2_74(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_74(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(73, xla); },   }, ,   final private boolean jj_2_75(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_75(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(74, xla); },   }, ,   final private boolean jj_2_76(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_76(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(75, xla); },   }, ,   final private boolean jj_2_77(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_77(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(76, xla); },   }, ,   final private boolean jj_2_78(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_78(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(77, xla); },   }, ,   final private boolean jj_2_79(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_79(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(78, xla); },   }, ,   final private boolean jj_2_80(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_80(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(79, xla); },   }, ,   final private boolean jj_2_81(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_81(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(80, xla); },   }, ,   final private boolean jj_2_82(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_82(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(81, xla); },   }, ,   final private boolean jj_2_83(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_83(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(82, xla); },   }, ,   final private boolean jj_2_84(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_84(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(83, xla); },   }, ,   final private boolean jj_2_85(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_85(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(84, xla); },   }, ,   final private boolean jj_2_86(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_86(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(85, xla); },   }, ,   final private boolean jj_2_87(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_87(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(86, xla); },   }, ,   final private boolean jj_2_88(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_88(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(87, xla); },   }, ,   final private boolean jj_2_89(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_89(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(88, xla); },   }, ,   final private boolean jj_2_90(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_90(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(89, xla); },   }, ,   final private boolean jj_2_91(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_91(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(90, xla); },   }, ,   final private boolean jj_2_92(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_92(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(91, xla); },   }, ,   final private boolean jj_3R_271() {,     if (jj_scan_token(CURRENT_ROLE)) return true;,     return false;,   }, ,   final private boolean jj_3R_84() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_170()) {,     jj_scanpos = xsp;,     if (jj_3R_171()) {,     jj_scanpos = xsp;,     if (jj_3R_172()) {,     jj_scanpos = xsp;,     if (jj_3_44()) {,     jj_scanpos = xsp;,     if (jj_3R_173()) {,     jj_scanpos = xsp;,     if (jj_3R_174()) {,     jj_scanpos = xsp;,     if (jj_3R_175()) {,     jj_scanpos = xsp;,     if (jj_3R_176()) return true;,     },     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_170() {,     if (jj_scan_token(GET_CURRENT_CONNECTION)) return true;,     return false;,   }, ,   final private boolean jj_3_36() {,     if (jj_3R_83()) return true;,     return false;,   }, ,   final private boolean jj_3_29() {,     if (jj_3R_76()) return true;,     return false;,   }, ,   final private boolean jj_3_82() {,     if (jj_3R_113()) return true;,     return false;,   }, ,   final private boolean jj_3_59() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3R_343() {,     if (jj_scan_token(SESSION_USER)) return true;,     return false;,   }, ,   final private boolean jj_3R_365() {,     if (jj_scan_token(XML)) return true;,     return false;,   }, ,   final private boolean jj_3R_127() {,     if (jj_scan_token(DROP)) return true;,     return false;,   }, ,   final private boolean jj_3R_238() {,     if (jj_scan_token(CURRENT)) return true;,     return false;,   }, ,   final private boolean jj_3R_342() {,     if (jj_scan_token(CURRENT_USER)) return true;,     return false;,   }, ,   final private boolean jj_3R_360() {,     if (jj_scan_token(RELEASE)) return true;,     return false;,   }, ,   final private boolean jj_3R_75() {,     if (jj_3R_81()) return true;,     return false;,   }, ,   final private boolean jj_3_43() {,     if (jj_3R_87()) return true;,     return false;,   }, ,   final private boolean jj_3R_133() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(172)) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == CURRENT && getToken(2).kind == ISOLATION;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_238()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_292() {,     if (jj_3R_361()) return true;,     return false;,   }, ,   final private boolean jj_3R_359() {,     if (jj_scan_token(ROLLBACK)) return true;,     return false;,   }, ,   final private boolean jj_3R_341() {,     if (jj_scan_token(USER)) return true;,     return false;,   }, ,   final private boolean jj_3R_270() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_341()) {,     jj_scanpos = xsp;,     if (jj_3R_342()) {,     jj_scanpos = xsp;,     if (jj_3R_343()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_282() {,     if (jj_scan_token(CHECK)) return true;,     return false;,   }, ,   final private boolean jj_3_42() {,     if (jj_3R_86()) return true;,     return false;,   }, ,   final private boolean jj_3R_98() {,     if (jj_3R_199()) return true;,     return false;,   }, ,   final private boolean jj_3R_97() {,     if (jj_3R_198()) return true;,     return false;,   }, ,   final private boolean jj_3_58() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = newInvocationFollows(1);,     lookingAhead = false;,     if (!jj_semLA || jj_3R_97()) {,     jj_scanpos = xsp;,     if (jj_3R_98()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_197() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3_58()) {,     jj_scanpos = xsp;,     if (jj_3_59()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == LEFT_PAREN &&,                                 (,                                         getToken(2).kind == SELECT ||,                                         getToken(2).kind == VALUES,                                 );,     lookingAhead = false;,     if (!jj_semLA || jj_3R_266()) {,     jj_scanpos = xsp;,     if (jj_3R_267()) return true;,     },     },     },     return false;,   }, ,   final private boolean jj_3R_354() {,     if (jj_scan_token(NOT)) return true;,     return false;,   }, ,   final private boolean jj_3R_54() {,     if (jj_3R_133()) return true;,     return false;,   }, ,   final private boolean jj_3R_358() {,     if (jj_scan_token(SAVEPOINT)) return true;,     return false;,   }, ,   final private boolean jj_3R_291() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_358()) {,     jj_scanpos = xsp;,     if (jj_3R_359()) {,     jj_scanpos = xsp;,     if (jj_3R_360()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_277() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_354()) jj_scanpos = xsp;,     if (jj_scan_token(ENFORCED)) return true;,     return false;,   }, ,   final private boolean jj_3R_397() {,     if (jj_3R_271()) return true;,     return false;,   }, ,   final private boolean jj_3_28() {,     if (jj_3R_75()) return true;,     return false;,   }, ,   final private boolean jj_3_35() {,     if (jj_3R_82()) return true;,     return false;,   }, ,   final private boolean jj_3R_396() {,     if (jj_3R_270()) return true;,     return false;,   }, ,   final private boolean jj_3R_201() {,     if (jj_3R_77()) return true;,     return false;,   }, ,   final private boolean jj_3R_281() {,     if (jj_scan_token(UNIQUE)) return true;,     return false;,   }, ,   final private boolean jj_3R_132() {,     if (jj_scan_token(EXECUTE)) return true;,     return false;,   }, ,   final private boolean jj_3R_240() {,     if (jj_3R_292()) return true;,     return false;,   }, ,   final private boolean jj_3R_137() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = javaClassFollows();,     lookingAhead = false;,     if (!jj_semLA || jj_3R_240()) {,     jj_scanpos = xsp;,     if (jj_3_35()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_395() {,     if (jj_3R_412()) return true;,     return false;,   }, ,   final private boolean jj_3R_370() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_395()) {,     jj_scanpos = xsp;,     if (jj_3R_396()) {,     jj_scanpos = xsp;,     if (jj_3R_397()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_311() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(65)) {,     jj_scanpos = xsp;,     if (jj_scan_token(66)) {,     jj_scanpos = xsp;,     if (jj_scan_token(67)) {,     jj_scanpos = xsp;,     if (jj_scan_token(68)) {,     jj_scanpos = xsp;,     if (jj_scan_token(69)) {,     jj_scanpos = xsp;,     if (jj_scan_token(70)) {,     jj_scanpos = xsp;,     if (jj_scan_token(71)) {,     jj_scanpos = xsp;,     if (jj_scan_token(72)) {,     jj_scanpos = xsp;,     if (jj_scan_token(73)) {,     jj_scanpos = xsp;,     if (jj_scan_token(74)) {,     jj_scanpos = xsp;,     if (jj_scan_token(75)) {,     jj_scanpos = xsp;,     if (jj_scan_token(76)) {,     jj_scanpos = xsp;,     if (jj_scan_token(77)) {,     jj_scanpos = xsp;,     if (jj_scan_token(78)) {,     jj_scanpos = xsp;,     if (jj_scan_token(79)) {,     jj_scanpos = xsp;,     if (jj_scan_token(81)) {,     jj_scanpos = xsp;,     if (jj_scan_token(82)) {,     jj_scanpos = xsp;,     if (jj_scan_token(83)) {,     jj_scanpos = xsp;,     if (jj_scan_token(84)) {,     jj_scanpos = xsp;,     if (jj_scan_token(85)) {,     jj_scanpos = xsp;,     if (jj_scan_token(86)) {,     jj_scanpos = xsp;,     if (jj_scan_token(87)) {,     jj_scanpos = xsp;,     if (jj_scan_token(88)) {,     jj_scanpos = xsp;,     if (jj_scan_token(89)) {,     jj_scanpos = xsp;,     if (jj_scan_token(91)) {,     jj_scanpos = xsp;,     if (jj_scan_token(92)) {,     jj_scanpos = xsp;,     if (jj_scan_token(94)) {,     jj_scanpos = xsp;,     if (jj_scan_token(95)) {,     jj_scanpos = xsp;,     if (jj_scan_token(96)) {,     jj_scanpos = xsp;,     if (jj_scan_token(97)) {,     jj_scanpos = xsp;,     if (jj_scan_token(98)) {,     jj_scanpos = xsp;,     if (jj_scan_token(99)) {,     jj_scanpos = xsp;,     if (jj_scan_token(100)) {,     jj_scanpos = xsp;,     if (jj_scan_token(101)) {,     jj_scanpos = xsp;,     if (jj_scan_token(102)) {,     jj_scanpos = xsp;,     if (jj_scan_token(103)) {,     jj_scanpos = xsp;,     if (jj_scan_token(104)) {,     jj_scanpos = xsp;,     if (jj_scan_token(106)) {,     jj_scanpos = xsp;,     if (jj_scan_token(107)) {,     jj_scanpos = xsp;,     if (jj_scan_token(108)) {,     jj_scanpos = xsp;,     if (jj_scan_token(109)) {,     jj_scanpos = xsp;,     if (jj_scan_token(110)) {,     jj_scanpos = xsp;,     if (jj_scan_token(111)) {,     jj_scanpos = xsp;,     if (jj_scan_token(112)) {,     jj_scanpos = xsp;,     if (jj_scan_token(113)) {,     jj_scanpos = xsp;,     if (jj_scan_token(115)) {,     jj_scanpos = xsp;,     if (jj_scan_token(116)) {,     jj_scanpos = xsp;,     if (jj_scan_token(117)) {,     jj_scanpos = xsp;,     if (jj_scan_token(118)) {,     jj_scanpos = xsp;,     if (jj_scan_token(119)) {,     jj_scanpos = xsp;,     if (jj_scan_token(120)) {,     jj_scanpos = xsp;,     if (jj_scan_token(121)) {,     jj_scanpos = xsp;,     if (jj_scan_token(122)) {,     jj_scanpos = xsp;,     if (jj_scan_token(123)) {,     jj_scanpos = xsp;,     if (jj_scan_token(124)) {,     jj_scanpos = xsp;,     if (jj_scan_token(125)) {,     jj_scanpos = xsp;,     if (jj_scan_token(126)) {,     jj_scanpos = xsp;,     if (jj_scan_token(127)) {,     jj_scanpos = xsp;,     if (jj_scan_token(128)) {,     jj_scanpos = xsp;,     if (jj_scan_token(129)) {,     jj_scanpos = xsp;,     if (jj_scan_token(130)) {,     jj_scanpos = xsp;,     if (jj_scan_token(131)) {,     jj_scanpos = xsp;,     if (jj_scan_token(132)) {,     jj_scanpos = xsp;,     if (jj_scan_token(133)) {,     jj_scanpos = xsp;,     if (jj_scan_token(134)) {,     jj_scanpos = xsp;,     if (jj_scan_token(135)) {,     jj_scanpos = xsp;,     if (jj_scan_token(136)) {,     jj_scanpos = xsp;,     if (jj_scan_token(137)) {,     jj_scanpos = xsp;,     if (jj_scan_token(138)) {,     jj_scanpos = xsp;,     if (jj_scan_token(139)) {,     jj_scanpos = xsp;,     if (jj_scan_token(140)) {,     jj_scanpos = xsp;,     if (jj_scan_token(141)) {,     jj_scanpos = xsp;,     if (jj_scan_token(142)) {,     jj_scanpos = xsp;,     if (jj_scan_token(143)) {,     jj_scanpos = xsp;,     if (jj_scan_token(144)) {,     jj_scanpos = xsp;,     if (jj_scan_token(145)) {,     jj_scanpos = xsp;,     if (jj_scan_token(146)) {,     jj_scanpos = xsp;,     if (jj_scan_token(147)) {,     jj_scanpos = xsp;,     if (jj_scan_token(148)) {,     jj_scanpos = xsp;,     if (jj_scan_token(149)) {,     jj_scanpos = xsp;,     if (jj_scan_token(150)) {,     jj_scanpos = xsp;,     if (jj_scan_token(366)) {,     jj_scanpos = xsp;,     if (jj_scan_token(151)) {,     jj_scanpos = xsp;,     if (jj_scan_token(152)) {,     jj_scanpos = xsp;,     if (jj_scan_token(153)) {,     jj_scanpos = xsp;,     if (jj_scan_token(154)) {,     jj_scanpos = xsp;,     if (jj_scan_token(155)) {,     jj_scanpos = xsp;,     if (jj_scan_token(156)) {,     jj_scanpos = xsp;,     if (jj_scan_token(157)) {,     jj_scanpos = xsp;,     if (jj_scan_token(158)) {,     jj_scanpos = xsp;,     if (jj_scan_token(159)) {,     jj_scanpos = xsp;,     if (jj_scan_token(160)) {,     jj_scanpos = xsp;,     if (jj_scan_token(161)) {,     jj_scanpos = xsp;,     if (jj_scan_token(162)) {,     jj_scanpos = xsp;,     if (jj_scan_token(163)) {,     jj_scanpos = xsp;,     if (jj_scan_token(296)) {,     jj_scanpos = xsp;,     if (jj_scan_token(164)) {,     jj_scanpos = xsp;,     if (jj_scan_token(165)) {,     jj_scanpos = xsp;,     if (jj_scan_token(166)) {,     jj_scanpos = xsp;,     if (jj_scan_token(167)) {,     jj_scanpos = xsp;,     if (jj_scan_token(168)) {,     jj_scanpos = xsp;,     if (jj_scan_token(169)) {,     jj_scanpos = xsp;,     if (jj_scan_token(170)) {,     jj_scanpos = xsp;,     if (jj_scan_token(171)) {,     jj_scanpos = xsp;,     if (jj_scan_token(172)) {,     jj_scanpos = xsp;,     if (jj_scan_token(173)) {,     jj_scanpos = xsp;,     if (jj_scan_token(174)) {,     jj_scanpos = xsp;,     if (jj_scan_token(175)) {,     jj_scanpos = xsp;,     if (jj_scan_token(176)) {,     jj_scanpos = xsp;,     if (jj_scan_token(177)) {,     jj_scanpos = xsp;,     if (jj_scan_token(178)) {,     jj_scanpos = xsp;,     if (jj_scan_token(179)) {,     jj_scanpos = xsp;,     if (jj_scan_token(180)) {,     jj_scanpos = xsp;,     if (jj_scan_token(181)) {,     jj_scanpos = xsp;,     if (jj_scan_token(182)) {,     jj_scanpos = xsp;,     if (jj_scan_token(183)) {,     jj_scanpos = xsp;,     if (jj_scan_token(185)) {,     jj_scanpos = xsp;,     if (jj_scan_token(186)) {,     jj_scanpos = xsp;,     if (jj_scan_token(187)) {,     jj_scanpos = xsp;,     if (jj_scan_token(411)) {,     jj_scanpos = xsp;,     if (jj_scan_token(188)) {,     jj_scanpos = xsp;,     if (jj_scan_token(189)) {,     jj_scanpos = xsp;,     if (jj_scan_token(371)) {,     jj_scanpos = xsp;,     if (jj_scan_token(190)) {,     jj_scanpos = xsp;,     if (jj_scan_token(191)) {,     jj_scanpos = xsp;,     if (jj_scan_token(192)) {,     jj_scanpos = xsp;,     if (jj_scan_token(193)) {,     jj_scanpos = xsp;,     if (jj_scan_token(194)) {,     jj_scanpos = xsp;,     if (jj_scan_token(195)) {,     jj_scanpos = xsp;,     if (jj_scan_token(196)) {,     jj_scanpos = xsp;,     if (jj_scan_token(197)) {,     jj_scanpos = xsp;,     if (jj_scan_token(198)) {,     jj_scanpos = xsp;,     if (jj_scan_token(199)) {,     jj_scanpos = xsp;,     if (jj_scan_token(200)) {,     jj_scanpos = xsp;,     if (jj_scan_token(416)) {,     jj_scanpos = xsp;,     if (jj_scan_token(201)) {,     jj_scanpos = xsp;,     if (jj_scan_token(202)) {,     jj_scanpos = xsp;,     if (jj_scan_token(203)) {,     jj_scanpos = xsp;,     if (jj_scan_token(204)) {,     jj_scanpos = xsp;,     if (jj_scan_token(205)) {,     jj_scanpos = xsp;,     if (jj_scan_token(206)) {,     jj_scanpos = xsp;,     if (jj_scan_token(207)) {,     jj_scanpos = xsp;,     if (jj_scan_token(208)) {,     jj_scanpos = xsp;,     if (jj_scan_token(209)) {,     jj_scanpos = xsp;,     if (jj_scan_token(210)) {,     jj_scanpos = xsp;,     if (jj_scan_token(211)) {,     jj_scanpos = xsp;,     if (jj_scan_token(212)) {,     jj_scanpos = xsp;,     if (jj_scan_token(213)) {,     jj_scanpos = xsp;,     if (jj_scan_token(214)) {,     jj_scanpos = xsp;,     if (jj_scan_token(215)) {,     jj_scanpos = xsp;,     if (jj_scan_token(216)) {,     jj_scanpos = xsp;,     if (jj_scan_token(217)) {,     jj_scanpos = xsp;,     if (jj_scan_token(218)) {,     jj_scanpos = xsp;,     if (jj_scan_token(219)) {,     jj_scanpos = xsp;,     if (jj_scan_token(220)) {,     jj_scanpos = xsp;,     if (jj_scan_token(221)) {,     jj_scanpos = xsp;,     if (jj_scan_token(222)) {,     jj_scanpos = xsp;,     if (jj_scan_token(223)) {,     jj_scanpos = xsp;,     if (jj_scan_token(224)) {,     jj_scanpos = xsp;,     if (jj_scan_token(225)) {,     jj_scanpos = xsp;,     if (jj_scan_token(226)) {,     jj_scanpos = xsp;,     if (jj_scan_token(227)) {,     jj_scanpos = xsp;,     if (jj_scan_token(228)) {,     jj_scanpos = xsp;,     if (jj_scan_token(229)) {,     jj_scanpos = xsp;,     if (jj_scan_token(230)) {,     jj_scanpos = xsp;,     if (jj_scan_token(231)) {,     jj_scanpos = xsp;,     if (jj_scan_token(232)) {,     jj_scanpos = xsp;,     if (jj_scan_token(233)) {,     jj_scanpos = xsp;,     if (jj_scan_token(234)) {,     jj_scanpos = xsp;,     if (jj_scan_token(235)) {,     jj_scanpos = xsp;,     if (jj_scan_token(236)) {,     jj_scanpos = xsp;,     if (jj_scan_token(237)) {,     jj_scanpos = xsp;,     if (jj_scan_token(239)) {,     jj_scanpos = xsp;,     if (jj_scan_token(240)) {,     jj_scanpos = xsp;,     if (jj_scan_token(241)) {,     jj_scanpos = xsp;,     if (jj_scan_token(242)) {,     jj_scanpos = xsp;,     if (jj_scan_token(243)) {,     jj_scanpos = xsp;,     if (jj_scan_token(247)) {,     jj_scanpos = xsp;,     if (jj_scan_token(244)) {,     jj_scanpos = xsp;,     if (jj_scan_token(245)) {,     jj_scanpos = xsp;,     if (jj_scan_token(246)) {,     jj_scanpos = xsp;,     if (jj_scan_token(249)) {,     jj_scanpos = xsp;,     if (jj_scan_token(251)) {,     jj_scanpos = xsp;,     if (jj_scan_token(252)) {,     jj_scanpos = xsp;,     if (jj_scan_token(253)) {,     jj_scanpos = xsp;,     if (jj_scan_token(254)) {,     jj_scanpos = xsp;,     if (jj_scan_token(255)) {,     jj_scanpos = xsp;,     if (jj_scan_token(256)) {,     jj_scanpos = xsp;,     if (jj_scan_token(257)) {,     jj_scanpos = xsp;,     if (jj_scan_token(259)) {,     jj_scanpos = xsp;,     if (jj_scan_token(261)) {,     jj_scanpos = xsp;,     if (jj_scan_token(262)) {,     jj_scanpos = xsp;,     if (jj_scan_token(263)) {,     jj_scanpos = xsp;,     if (jj_scan_token(264)) {,     jj_scanpos = xsp;,     if (jj_scan_token(265)) {,     jj_scanpos = xsp;,     if (jj_scan_token(267)) {,     jj_scanpos = xsp;,     if (jj_scan_token(268)) {,     jj_scanpos = xsp;,     if (jj_scan_token(269)) {,     jj_scanpos = xsp;,     if (jj_scan_token(270)) {,     jj_scanpos = xsp;,     if (jj_scan_token(360)) {,     jj_scanpos = xsp;,     if (jj_scan_token(361)) {,     jj_scanpos = xsp;,     if (jj_scan_token(363)) {,     jj_scanpos = xsp;,     if (jj_scan_token(367)) {,     jj_scanpos = xsp;,     if (jj_scan_token(368)) {,     jj_scanpos = xsp;,     if (jj_scan_token(370)) {,     jj_scanpos = xsp;,     if (jj_scan_token(375)) {,     jj_scanpos = xsp;,     if (jj_scan_token(248)) {,     jj_scanpos = xsp;,     if (jj_scan_token(376)) {,     jj_scanpos = xsp;,     if (jj_scan_token(377)) {,     jj_scanpos = xsp;,     if (jj_scan_token(379)) {,     jj_scanpos = xsp;,     if (jj_scan_token(381)) {,     jj_scanpos = xsp;,     if (jj_scan_token(378)) {,     jj_scanpos = xsp;,     if (jj_scan_token(380)) return true;,     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_353() {,     if (jj_scan_token(NOT)) return true;,     return false;,   }, ,   final private boolean jj_3R_276() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_353()) jj_scanpos = xsp;,     if (jj_scan_token(DEFERRABLE)) return true;,     return false;,   }, ,   final private boolean jj_3R_363() {,     if (jj_scan_token(LONG)) return true;,     return false;,   }, ,   final private boolean jj_3R_101() {,     if (jj_3R_201()) return true;,     return false;,   }, ,   final private boolean jj_3R_246() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3R_155() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == PERIOD &&,                         (,                                 getToken(3).kind == ASTERISK ||,                                 (getToken(4).kind == PERIOD && getToken(5).kind == ASTERISK),                         );,     lookingAhead = false;,     if (!jj_semLA || jj_3R_246()) {,     jj_scanpos = xsp;,     if (jj_3_28()) return true;,     },     return false;,   }, ,   final private boolean jj_3_15() {,     if (jj_3R_60()) return true;,     return false;,   }, ,   final private boolean jj_3R_126() {,     if (jj_scan_token(CREATE)) return true;,     return false;,   }, ,   final private boolean jj_3R_280() {,     if (jj_scan_token(FOREIGN)) return true;,     return false;,   }, ,   final private boolean jj_3R_96() {,     if (jj_3R_197()) return true;,     return false;,   }, ,   final private boolean jj_3R_406() {,     if (jj_scan_token(FALSE)) return true;,     return false;,   }, ,   final private boolean jj_3R_192() {,     if (jj_3R_265()) return true;,     return false;,   }, ,   final private boolean jj_3R_405() {,     if (jj_scan_token(TRUE)) return true;,     return false;,   }, ,   final private boolean jj_3R_379() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_405()) {,     jj_scanpos = xsp;,     if (jj_3R_406()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_368() {,     if (jj_3R_87()) return true;,     return false;,   }, ,   final private boolean jj_3R_301() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == PERIOD &&,                 getToken(4).kind == LEFT_PAREN;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_368()) {,     jj_scanpos = xsp;,     if (jj_3_15()) return true;,     },     return false;,   }, ,   final private boolean jj_3_66() {,     if (jj_3R_101()) return true;,     return false;,   }, ,   final private boolean jj_3R_53() {,     if (jj_3R_132()) return true;,     return false;,   }, ,   final private boolean jj_3R_152() {,     if (jj_scan_token(DOUBLE)) return true;,     return false;,   }, ,   final private boolean jj_3_3() {,     if (jj_3R_46()) return true;,     return false;,   }, ,   final private boolean jj_3R_92() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3_34()) {,     jj_scanpos = xsp;,     if (jj_3R_192()) return true;,     },     return false;,   }, ,   final private boolean jj_3_34() {,     if (jj_3R_81()) return true;,     return false;,   }, ,   final private boolean jj_3_2() {,     if (jj_3R_45()) return true;,     return false;,   }, ,   final private boolean jj_3R_72() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == PRECISION;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_152()) {,     jj_scanpos = xsp;,     if (jj_scan_token(128)) return true;,     },     return false;,   }, ,   final private boolean jj_3R_52() {,     if (jj_3R_131()) return true;,     return false;,   }, ,   final private boolean jj_3R_74() {,     if (jj_3R_155()) return true;,     return false;,   }, ,   final private boolean jj_3R_279() {,     if (jj_scan_token(PRIMARY)) return true;,     return false;,   }, ,   final private boolean jj_3R_275() {,     if (jj_scan_token(INITIALLY)) return true;,     return false;,   }, ,   final private boolean jj_3_25() {,     if (jj_3R_72()) return true;,     return false;,   }, ,   final private boolean jj_3_1() {,     if (jj_3R_44()) return true;,     return false;,   }, ,   final private boolean jj_3R_51() {,     if (jj_3R_130()) return true;,     return false;,   }, ,   final private boolean jj_3R_284() {,     if (jj_scan_token(DELIMITED_IDENTIFIER)) return true;,     return false;,   }, ,   final private boolean jj_3R_50() {,     if (jj_3R_129()) return true;,     return false;,   }, ,   final private boolean jj_3R_49() {,     if (jj_3R_128()) return true;,     return false;,   }, ,   final private boolean jj_3R_310() {,     if (jj_3R_84()) return true;,     return false;,   }, ,   final private boolean jj_3R_253() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = ( (getToken(1).kind == GET_CURRENT_CONNECTION ||,                 getToken(1).kind == ABS ||,                 getToken(1).kind == ABSVAL ||,                 getToken(1).kind == SQRT ||,                 getToken(1).kind == MOD ||,                 getToken(1).kind == COALESCE ||,                 getToken(1).kind == VALUE ||,                 getToken(1).kind == IDENTITY_VAL_LOCAL ||,                 getToken(1).kind == SUBSTRING ||,                 getToken(1).kind == SUBSTR ||,                 getToken(1).kind == UPPER ||,                 getToken(1).kind == LOWER ||,                 getToken(1).kind == UCASE ||,                 getToken(1).kind == LCASE ||,                 getToken(1).kind == LTRIM ||,                 getToken(1).kind == RTRIM ||,                 getToken(1).kind == TRIM ||,                 getToken(1).kind == DATE ||,                 getToken(1).kind == TIME ||,                 getToken(1).kind == TIMESTAMP ||,                 getToken(1).kind == DOUBLE ||,                 getToken(1).kind == CHAR ||,                 getToken(1).kind == VARCHAR ||,                 getToken(1).kind == INTEGER ||,                 getToken(1).kind == INT ||,                 getToken(1).kind == SMALLINT ||,         getToken(1).kind == BIGINT ||,                 getToken(1).kind == YEAR ||,                 getToken(1).kind == MONTH ||,                 getToken(1).kind == DAY ||,                 getToken(1).kind == HOUR ||,                 getToken(1).kind == MINUTE ||,                 getToken(1).kind == SECOND ||,                 getToken(1).kind == LENGTH ||,                 getToken(1).kind == LOCATE ||,                 getToken(1).kind == XMLPARSE ||,                 getToken(1).kind == XMLSERIALIZE ||,                 getToken(1).kind == XMLEXISTS ||,                 getToken(1).kind == XMLQUERY ) &&,               getToken(2).kind == LEFT_PAREN,               );,     lookingAhead = false;,     if (!jj_semLA || jj_3R_310()) {,     jj_scanpos = xsp;,     if (jj_3_42()) {,     jj_scanpos = xsp;,     if (jj_3_43()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_48() {,     if (jj_3R_127()) return true;,     return false;,   }, ,   final private boolean jj_3R_47() {,     if (jj_3R_126()) return true;,     return false;,   }, ,   final private boolean jj_3_27() {,     if (jj_3R_74()) return true;,     return false;,   }, ,   final private boolean jj_3_4() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_47()) {,     jj_scanpos = xsp;,     if (jj_3R_48()) {,     jj_scanpos = xsp;,     if (jj_3R_49()) {,     jj_scanpos = xsp;,     if (jj_3R_50()) {,     jj_scanpos = xsp;,     if (jj_3R_51()) {,     jj_scanpos = xsp;,     if (jj_3_1()) {,     jj_scanpos = xsp;,     if (jj_3R_52()) {,     jj_scanpos = xsp;,     if (jj_3_2()) {,     jj_scanpos = xsp;,     if (jj_3_3()) {,     jj_scanpos = xsp;,     if (jj_3R_53()) return true;,     },     },     },     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_151() {,     if (jj_scan_token(REAL)) return true;,     return false;,   }, ,   final private boolean jj_3R_278() {,     if (jj_scan_token(CONSTRAINT)) return true;,     return false;,   }, ,   final private boolean jj_3R_136() {,     if (jj_scan_token(WHEN)) return true;,     return false;,   }, ,   final private boolean jj_3R_224() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == CONSTRAINT;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_278()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == PRIMARY;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_279()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == FOREIGN;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_280()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == UNIQUE;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_281()) {,     jj_scanpos = xsp;,     if (jj_3R_282()) return true;,     },     },     },     },     return false;,   }, ,   final private boolean jj_3_57() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(72)) jj_scanpos = xsp;,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_57() {,     if (jj_3R_81()) return true;,     return false;,   }, ,   final private boolean jj_3_14() {,     if (jj_3R_59()) return true;,     return false;,   }, ,   final private boolean jj_3R_223() {,     if (jj_3R_277()) return true;,     return false;,   }, ,   final private boolean jj_3R_61() {,     if (jj_3R_138()) return true;,     return false;,   }, ,   final private boolean jj_3R_115() {,     if (jj_3R_224()) return true;,     return false;,   }, ,   final private boolean jj_3_40() {,     if (jj_3R_81()) return true;,     return false;,   }, ,   final private boolean jj_3R_168() {,     if (jj_3R_255()) return true;,     return false;,   }, ,   final private boolean jj_3R_167() {,     if (jj_3R_254()) return true;,     return false;,   }, ,   final private boolean jj_3R_329() {,     if (jj_3R_373()) return true;,     return false;,   }, ,   final private boolean jj_3_89() {,     if (jj_3R_118()) return true;,     return false;,   }, ,   final private boolean jj_3R_412() {,     if (jj_scan_token(QUESTION_MARK)) return true;,     return false;,   }, ,   final private boolean jj_3R_222() {,     if (jj_3R_276()) return true;,     return false;,   }, ,   final private boolean jj_3R_328() {,     if (jj_scan_token(TIMESTAMP)) return true;,     return false;,   }, ,   final private boolean jj_3R_59() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == WHEN && getToken(2).kind != NOT;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_135()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == WHEN && getToken(2).kind == NOT;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_136()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_135() {,     if (jj_scan_token(WHEN)) return true;,     return false;,   }, ,   final private boolean jj_3R_196() {,     if (jj_scan_token(LEFT_BRACE)) return true;,     return false;,   }, ,   final private boolean jj_3R_242() {,     if (jj_3R_284()) return true;,     return false;,   }, ,   final private boolean jj_3R_154() {,     if (jj_scan_token(ALL)) return true;,     return false;,   }, ,   final private boolean jj_3_56() {,     if (jj_3R_96()) return true;,     return false;,   }, ,   final private boolean jj_3R_95() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3_56()) {,     jj_scanpos = xsp;,     if (jj_3R_196()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_327() {,     if (jj_scan_token(DATE)) return true;,     return false;,   }, ,   final private boolean jj_3R_71() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_150()) {,     jj_scanpos = xsp;,     if (jj_3R_151()) {,     jj_scanpos = xsp;,     if (jj_3_25()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_150() {,     if (jj_scan_token(FLOAT)) return true;,     return false;,   }, ,   final private boolean jj_3R_221() {,     if (jj_3R_275()) return true;,     return false;,   }, ,   final private boolean jj_3_65() {,     if (jj_3R_77()) return true;,     return false;,   }, ,   final private boolean jj_3R_166() {,     if (jj_scan_token(LEFT_PAREN)) return true;,     return false;,   }, ,   final private boolean jj_3R_326() {,     if (jj_scan_token(TIME)) return true;,     return false;,   }, ,   final private boolean jj_3R_262() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_326()) {,     jj_scanpos = xsp;,     if (jj_3R_327()) {,     jj_scanpos = xsp;,     if (jj_3R_328()) {,     jj_scanpos = xsp;,     if (jj_3R_329()) return true;,     },     },     },     return false;,   }, ,   final private boolean jj_3R_113() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_221()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == DEFERRABLE || getToken(2).kind == DEFERRABLE;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_222()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == ENFORCED || getToken(2).kind == ENFORCED;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_223()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3_55() {,     if (jj_3R_95()) return true;,     return false;,   }, ,   final private boolean jj_3R_241() {,     if (jj_scan_token(IDENTIFIER)) return true;,     return false;,   }, ,   final private boolean jj_3_41() {,     if (jj_3R_85()) return true;,     return false;,   }, ,   final private boolean jj_3R_138() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_241()) {,     jj_scanpos = xsp;,     if (jj_3R_242()) {,     jj_scanpos = xsp;,     if (jj_3_89()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_73() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == DISTINCT &&,                         !(,                                 getToken(2).kind == PERIOD ||,                                 getToken(2).kind == DOUBLE_COLON,                         );,     lookingAhead = false;,     if (!jj_semLA || jj_3R_153()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == ALL &&,                         !(,                                 getToken(2).kind == PERIOD ||,                                 getToken(2).kind == DOUBLE_COLON,                         );,     lookingAhead = false;,     if (!jj_semLA || jj_3R_154()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_153() {,     if (jj_scan_token(DISTINCT)) return true;,     return false;,   }, ,   final private boolean jj_3R_331() {,     if (jj_scan_token(VARCHAR)) return true;,     return false;,   }, ,   final private boolean jj_3R_165() {,     if (jj_3R_253()) return true;,     return false;,   }, ,   final private boolean jj_3_26() {,     if (jj_3R_73()) return true;,     return false;,   }, ,   final private boolean jj_3R_330() {,     if (jj_scan_token(CHAR)) return true;,     return false;,   }, ,   final private boolean jj_3R_263() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_330()) {,     jj_scanpos = xsp;,     if (jj_3R_331()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_334() {,     if (jj_scan_token(BIGINT)) return true;,     return false;,   }, ,   final private boolean jj_3R_249() {,     if (jj_scan_token(PERIOD)) return true;,     return false;,   }, ,   final private boolean jj_3R_333() {,     if (jj_scan_token(SMALLINT)) return true;,     return false;,   }, ,   final private boolean jj_3R_164() {,     if (jj_3R_252()) return true;,     return false;,   }, ,   final private boolean jj_3R_332() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(168)) {,     jj_scanpos = xsp;,     if (jj_scan_token(167)) return true;,     },     return false;,   }, ,   final private boolean jj_3R_264() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_332()) {,     jj_scanpos = xsp;,     if (jj_3R_333()) {,     jj_scanpos = xsp;,     if (jj_3R_334()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_187() {,     if (jj_3R_264()) return true;,     return false;,   }, ,   final private boolean jj_3R_428() {,     if (jj_scan_token(SELECT)) return true;,     return false;,   }, ,   final private boolean jj_3R_288() {,     if (jj_scan_token(MERGE)) return true;,     return false;,   }, ,   final private boolean jj_3R_89() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3_49()) {,     jj_scanpos = xsp;,     if (jj_3R_187()) return true;,     },     return false;,   }, ,   final private boolean jj_3_49() {,     if (jj_3R_72()) return true;,     return false;,   }, ,   final private boolean jj_3R_163() {,     if (jj_3R_198()) return true;,     return false;,   }, ,   final private boolean jj_3R_299() {,     if (jj_3R_264()) return true;,     return false;,   }, ,   final private boolean jj_3R_255() {,     if (jj_scan_token(NEXT)) return true;,     return false;,   }, ,   final private boolean jj_3R_162() {,     if (jj_3R_251()) return true;,     return false;,   }, ,   final private boolean jj_3_51() {,     if (jj_3R_93()) return true;,     return false;,   }, ,   final private boolean jj_3R_427() {,     if (jj_3R_429()) return true;,     return false;,   }, ,   final private boolean jj_3R_161() {,     if (jj_scan_token(CURRENT)) return true;,     return false;,   }, ,   final private boolean jj_3R_426() {,     if (jj_3R_428()) return true;,     return false;,   }, ,   final private boolean jj_3R_425() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_426()) {,     jj_scanpos = xsp;,     if (jj_3R_427()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_248() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(478)) {,     jj_scanpos = xsp;,     if (jj_scan_token(460)) return true;,     },     return false;,   }, ,   final private boolean jj_3R_157() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(3).kind == LEFT_PAREN;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_248()) {,     jj_scanpos = xsp;,     if (jj_3R_249()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_160() {,     if (jj_scan_token(CURRENT)) return true;,     return false;,   }, ,   final private boolean jj_3R_82() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = escapedValueFunctionFollows();,     lookingAhead = false;,     if (!jj_semLA || jj_3R_159()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == SCHEMA || getToken(2).kind == SQLID;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_160()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == ISOLATION;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_161()) {,     jj_scanpos = xsp;,     if (jj_3R_162()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = newInvocationFollows(1);,     lookingAhead = false;,     if (!jj_semLA || jj_3R_163()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = windowOrAggregateFunctionFollows();,     lookingAhead = false;,     if (!jj_semLA || jj_3R_164()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = miscBuiltinFollows();,     lookingAhead = false;,     if (!jj_semLA || jj_3R_165()) {,     jj_scanpos = xsp;,     if (jj_3_41()) {,     jj_scanpos = xsp;,     if (jj_3R_166()) {,     jj_scanpos = xsp;,     if (jj_3R_167()) {,     jj_scanpos = xsp;,     if (jj_3R_168()) return true;,     },     },     },     },     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_159() {,     if (jj_scan_token(LEFT_BRACE)) return true;,     return false;,   }, ,   final private boolean jj_3R_283() {,     if (jj_scan_token(LOCKSIZE)) return true;,     return false;,   }, ,   final private boolean jj_3R_80() {,     if (jj_3R_157()) return true;,     return false;,   }, ,   final private boolean jj_3R_194() {,     if (jj_scan_token(NULLS)) return true;,     return false;,   }, ,   final private boolean jj_3R_254() {,     if (jj_scan_token(CAST)) return true;,     return false;,   }, ,   final private boolean jj_3R_366() {,     if (jj_scan_token(NUMERIC)) return true;,     return false;,   }, ,   final private boolean jj_3_33() {,     if (jj_3R_80()) return true;,     return false;,   }, ,   final private boolean jj_3R_93() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == LAST;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_193()) {,     jj_scanpos = xsp;,     if (jj_3R_194()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_193() {,     if (jj_scan_token(NULLS)) return true;,     return false;,   }, ,   final private boolean jj_3R_191() {,     if (jj_scan_token(RETURNING)) return true;,     return false;,   }, ,   final private boolean jj_3R_298() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_366()) {,     jj_scanpos = xsp;,     if (jj_scan_token(117)) {,     jj_scanpos = xsp;,     if (jj_scan_token(116)) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_245() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_298()) {,     jj_scanpos = xsp;,     if (jj_3R_299()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_60() {,     if (jj_3R_137()) return true;,     return false;,   }, ,   final private boolean jj_3R_419() {,     if (jj_scan_token(LTRIM)) return true;,     return false;,   }, ,   final private boolean jj_3R_91() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == SEQUENCE;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_190()) {,     jj_scanpos = xsp;,     if (jj_3R_191()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_190() {,     if (jj_scan_token(RETURNING)) return true;,     return false;,   }, ,   final private boolean jj_3R_418() {,     if (jj_scan_token(RTRIM)) return true;,     return false;,   }, ,   final private boolean jj_3R_413() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_418()) {,     jj_scanpos = xsp;,     if (jj_3R_419()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_409() {,     if (jj_3R_412()) return true;,     return false;,   }, ,   final private boolean jj_3R_398() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(181)) {,     jj_scanpos = xsp;,     if (jj_scan_token(77)) {,     jj_scanpos = xsp;,     if (jj_scan_token(182)) {,     jj_scanpos = xsp;,     if (jj_scan_token(236)) return true;,     },     },     },     return false;,   }, ,   final private boolean jj_3R_393() {,     if (jj_scan_token(MINUS_SIGN)) return true;,     return false;,   }, ,   final private boolean jj_3_24() {,     if (jj_3R_71()) return true;,     return false;,   }, ,   final private boolean jj_3R_392() {,     if (jj_scan_token(PLUS_SIGN)) return true;,     return false;,   }, ,   final private boolean jj_3R_367() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_392()) {,     jj_scanpos = xsp;,     if (jj_3R_393()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_70() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_149()) {,     jj_scanpos = xsp;,     if (jj_3_24()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_149() {,     if (jj_3R_245()) return true;,     return false;,   }, ,   final private boolean jj_3R_416() {,     if (jj_scan_token(LEFT_PAREN)) return true;,     return false;,   }, ,   final private boolean jj_3R_415() {,     if (jj_3R_425()) return true;,     return false;,   }, ,   final private boolean jj_3R_408() {,     if (jj_scan_token(CALL)) return true;,     return false;,   }, ,   final private boolean jj_3R_407() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_415()) {,     jj_scanpos = xsp;,     if (jj_3R_416()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_381() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_408()) {,     jj_scanpos = xsp;,     if (jj_3R_409()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_117() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(96)) jj_scanpos = xsp;,     if (jj_3R_63()) return true;,     return false;,   }, ,   final private boolean jj_3R_371() {,     if (jj_3R_398()) return true;,     return false;,   }, ,   final private boolean jj_3R_357() {,     if (jj_scan_token(LEFT_BRACE)) return true;,     return false;,   }, ,   final private boolean jj_3R_391() {,     if (jj_scan_token(NATIONAL)) return true;,     return false;,   }, ,   final private boolean jj_3R_377() {,     if (jj_scan_token(HEX_STRING)) return true;,     return false;,   }, ,   final private boolean jj_3R_356() {,     if (jj_3R_381()) return true;,     return false;,   }, ,   final private boolean jj_3R_125() {,     if (jj_scan_token(REVOKE)) return true;,     return false;,   }, ,   final private boolean jj_3R_390() {,     if (jj_3R_244()) return true;,     return false;,   }, ,   final private boolean jj_3R_189() {,     if (jj_scan_token(BY)) return true;,     return false;,   }, ,   final private boolean jj_3R_290() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_356()) {,     jj_scanpos = xsp;,     if (jj_3R_357()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_389() {,     if (jj_scan_token(BINARY)) return true;,     return false;,   }, ,   final private boolean jj_3R_90() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == REF;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_188()) {,     jj_scanpos = xsp;,     if (jj_3R_189()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_188() {,     if (jj_scan_token(BY)) return true;,     return false;,   }, ,   final private boolean jj_3_38() {,     if (jj_scan_token(FROM)) return true;,     return false;,   }, ,   final private boolean jj_3_64() {,     if (jj_3R_73()) return true;,     return false;,   }, ,   final private boolean jj_3R_388() {,     if (jj_scan_token(NCLOB)) return true;,     return false;,   }, ,   final private boolean jj_3_39() {,     if (jj_3R_77()) return true;,     return false;,   }, ,   final private boolean jj_3R_99() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3_64()) jj_scanpos = xsp;,     if (jj_3R_77()) return true;,     return false;,   }, ,   final private boolean jj_3R_417() {,     if (jj_scan_token(EXISTS)) return true;,     return false;,   }, ,   final private boolean jj_3R_376() {,     if (jj_scan_token(STRING)) return true;,     return false;,   }, ,   final private boolean jj_3R_387() {,     if (jj_scan_token(CLOB)) return true;,     return false;,   }, ,   final private boolean jj_3R_300() {,     if (jj_3R_367()) return true;,     return false;,   }, ,   final private boolean jj_3R_46() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == REVOKE &&,                                 ((getToken(2).kind == TRIGGER &&,                                   ((getToken(3).kind == COMMA &&,                                         isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||,                                    getToken(3).kind == ON)) ||,                                  isPrivilegeKeywordExceptTrigger(getToken(2).kind));,     lookingAhead = false;,     if (!jj_semLA || jj_3R_124()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == REVOKE &&,                                 ((getToken(2).kind == TRIGGER &&,                                   ((getToken(3).kind == COMMA &&,                                         !isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||,                                    getToken(3).kind == FROM)) ||,                                  !isPrivilegeKeywordExceptTrigger(getToken(2).kind));,     lookingAhead = false;,     if (!jj_semLA || jj_3R_125()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_124() {,     if (jj_scan_token(REVOKE)) return true;,     return false;,   }, ,   final private boolean jj_3R_386() {,     if (jj_scan_token(BLOB)) return true;,     return false;,   }, ,   final private boolean jj_3_12() {,     if (jj_3R_57()) return true;,     return false;,   }, ,   final private boolean jj_3R_114() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(96)) jj_scanpos = xsp;,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_364() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_386()) {,     jj_scanpos = xsp;,     if (jj_3R_387()) {,     jj_scanpos = xsp;,     if (jj_3R_388()) {,     jj_scanpos = xsp;,     if (jj_3R_389()) {,     jj_scanpos = xsp;,     if (jj_3R_390()) {,     jj_scanpos = xsp;,     if (jj_3R_391()) return true;,     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_200() {,     return false;,   }, ,   final private boolean jj_3R_247() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_300()) jj_scanpos = xsp;,     if (jj_3R_301()) return true;,     return false;,   }, ,   final private boolean jj_3_63() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3_62() {,     if (jj_3R_100()) return true;,     return false;,   }, ,   final private boolean jj_3R_400() {,     if (jj_scan_token(TRIM)) return true;,     return false;,   }, ,   final private boolean jj_3R_100() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == LEFT_PAREN ||,                           getToken(2).kind == IDENTIFIER;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_200()) return true;,     if (jj_scan_token(OVER)) return true;,     return false;,   }, ,   final private boolean jj_3R_399() {,     if (jj_3R_413()) return true;,     return false;,   }, ,   final private boolean jj_3R_372() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_399()) {,     jj_scanpos = xsp;,     if (jj_3R_400()) return true;,     },     return false;,   }, ,   final private boolean jj_3_61() {,     if (jj_3R_100()) return true;,     return false;,   }, ,   final private boolean jj_3R_228() {,     if (jj_3R_283()) return true;,     return false;,   }, ,   final private boolean jj_3R_309() {,     if (jj_scan_token(ROWNUMBER)) return true;,     return false;,   }, ,   final private boolean jj_3_13() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3R_148() {,     if (jj_scan_token(NVARCHAR)) return true;,     return false;,   }, ,   final private boolean jj_3_48() {,     if (jj_3R_90()) return true;,     return false;,   }, ,   final private boolean jj_3R_308() {,     if (jj_3R_371()) return true;,     return false;,   }, ,   final private boolean jj_3_81() {,     if (jj_3R_113()) return true;,     return false;,   }, ,   final private boolean jj_3R_147() {,     if (jj_scan_token(NCHAR)) return true;,     return false;,   }, ,   final private boolean jj_3_60() {,     if (jj_3R_99()) return true;,     return false;,   }, ,   final private boolean jj_3_92() {,     if (jj_3R_118()) return true;,     return false;,   }, ,   final private boolean jj_3R_380() {,     if (jj_3R_407()) return true;,     return false;,   }, ,   final private boolean jj_3R_227() {,     if (jj_scan_token(ALTER)) return true;,     return false;,   }, ,   final private boolean jj_3R_321() {,     if (jj_scan_token(LOCATE)) return true;,     return false;,   }, ,   final private boolean jj_3R_230() {,     if (jj_3R_284()) return true;,     return false;,   }, ,   final private boolean jj_3R_307() {,     if (jj_scan_token(COUNT)) return true;,     return false;,   }, ,   final private boolean jj_3R_252() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_307()) {,     jj_scanpos = xsp;,     if (jj_3R_308()) {,     jj_scanpos = xsp;,     if (jj_3R_309()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_320() {,     if (jj_3R_372()) return true;,     return false;,   }, ,   final private boolean jj_3R_146() {,     if (jj_scan_token(NATIONAL)) return true;,     return false;,   }, ,   final private boolean jj_3R_226() {,     if (jj_scan_token(ALTER)) return true;,     return false;,   }, ,   final private boolean jj_3R_119() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_229()) {,     jj_scanpos = xsp;,     if (jj_3R_230()) {,     jj_scanpos = xsp;,     if (jj_3_92()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_229() {,     if (jj_scan_token(IDENTIFIER)) return true;,     return false;,   }, ,   final private boolean jj_3R_319() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(444)) {,     jj_scanpos = xsp;,     if (jj_scan_token(403)) return true;,     },     return false;,   }, ,   final private boolean jj_3R_69() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_146()) {,     jj_scanpos = xsp;,     if (jj_3R_147()) {,     jj_scanpos = xsp;,     if (jj_3R_148()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3_86() {,     if (jj_3R_117()) return true;,     return false;,   }, ,   final private boolean jj_3R_318() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(255)) {,     jj_scanpos = xsp;,     if (jj_scan_token(179)) return true;,     },     return false;,   }, ,   final private boolean jj_3R_156() {,     if (jj_3R_247()) return true;,     return false;,   }, ,   final private boolean jj_3R_182() {,     if (jj_scan_token(CURRENT_TIMESTAMP)) return true;,     return false;,   }, ,   final private boolean jj_3R_116() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_225()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == ALTER && getToken(2).kind != CONSTRAINT;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_226()) {,     jj_scanpos = xsp;,     if (jj_3R_227()) {,     jj_scanpos = xsp;,     if (jj_3R_228()) return true;,     },     },     },     return false;,   }, ,   final private boolean jj_3R_225() {,     if (jj_scan_token(ADD)) return true;,     return false;,   }, ,   final private boolean jj_3R_317() {,     if (jj_scan_token(SUBSTR)) return true;,     return false;,   }, ,   final private boolean jj_3R_258() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_317()) {,     jj_scanpos = xsp;,     if (jj_3R_318()) {,     jj_scanpos = xsp;,     if (jj_3R_319()) {,     jj_scanpos = xsp;,     if (jj_3R_320()) {,     jj_scanpos = xsp;,     if (jj_3R_321()) return true;,     },     },     },     },     return false;,   }, ,   final private boolean jj_3_80() {,     if (jj_3R_77()) return true;,     return false;,   }, ,   final private boolean jj_3R_181() {,     if (jj_scan_token(CURRENT)) return true;,     return false;,   }, ,   final private boolean jj_3_91() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_180() {,     if (jj_scan_token(CURRENT_TIME)) return true;,     return false;,   }, ,   final private boolean jj_3_88() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_289() {,     if (jj_scan_token(UPDATE)) return true;,     return false;,   }, ,   final private boolean jj_3R_179() {,     if (jj_scan_token(CURRENT)) return true;,     return false;,   }, ,   final private boolean jj_3R_402() {,     if (jj_scan_token(SECOND)) return true;,     return false;,   }, ,   final private boolean jj_3R_256() {,     if (jj_3R_311()) return true;,     return false;,   }, ,   final private boolean jj_3R_195() {,     if (jj_3R_77()) return true;,     return false;,   }, ,   final private boolean jj_3R_178() {,     if (jj_scan_token(CURRENT_DATE)) return true;,     return false;,   }, ,   final private boolean jj_3R_401() {,     if (jj_3R_414()) return true;,     return false;,   }, ,   final private boolean jj_3R_373() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_401()) {,     jj_scanpos = xsp;,     if (jj_3R_402()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_355() {,     if (jj_3R_380()) return true;,     return false;,   }, ,   final private boolean jj_3_90() {,     if (jj_3R_119()) return true;,     return false;,   }, ,   final private boolean jj_3R_169() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3_90()) {,     jj_scanpos = xsp;,     if (jj_3R_256()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_378() {,     if (jj_scan_token(LEFT_BRACE)) return true;,     return false;,   }, ,   final private boolean jj_3_11() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3R_86() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = (getToken(1).kind == CURRENT && getToken(2).kind == DATE);,     lookingAhead = false;,     if (!jj_semLA || jj_3R_177()) {,     jj_scanpos = xsp;,     if (jj_3R_178()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = (getToken(1).kind == CURRENT && getToken(2).kind == TIME);,     lookingAhead = false;,     if (!jj_semLA || jj_3R_179()) {,     jj_scanpos = xsp;,     if (jj_3R_180()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = (getToken(1).kind == CURRENT && getToken(2).kind == TIMESTAMP);,     lookingAhead = false;,     if (!jj_semLA || jj_3R_181()) {,     jj_scanpos = xsp;,     if (jj_3R_182()) return true;,     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_177() {,     if (jj_scan_token(CURRENT)) return true;,     return false;,   }, ,   final private boolean jj_3R_244() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(88)) {,     jj_scanpos = xsp;,     if (jj_scan_token(89)) return true;,     },     return false;,   }, ,   final private boolean jj_3R_94() {,     if (jj_3R_195()) return true;,     return false;,   }, ,   final private boolean jj_3R_85() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3_46() {,     if (jj_3R_90()) return true;,     return false;,   }, ,   final private boolean jj_3_54() {,     if (jj_3R_94()) return true;,     return false;,   }, ,   final private boolean jj_3R_287() {,     if (jj_scan_token(INSERT)) return true;,     return false;,   }, ,   final private boolean jj_3R_145() {,     if (jj_3R_244()) return true;,     return false;,   }, ,   final private boolean jj_3_47() {,     if (jj_3R_91()) return true;,     return false;,   }, ,   final private boolean jj_3R_144() {,     if (jj_scan_token(VARCHAR)) return true;,     return false;,   }, ,   final private boolean jj_3R_429() {,     if (jj_scan_token(VALUES)) return true;,     return false;,   }, ,   final private boolean jj_3R_77() {,     if (jj_3R_156()) return true;,     return false;,   }, ,   final private boolean jj_3R_67() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_144()) {,     jj_scanpos = xsp;,     if (jj_3R_145()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_337() {,     if (jj_scan_token(NO)) return true;,     return false;,   }, ,   final private boolean jj_3R_306() {,     if (jj_scan_token(CASE)) return true;,     return false;,   }, ,   final private boolean jj_3R_58() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_336() {,     if (jj_scan_token(CYCLE)) return true;,     return false;,   }, ,   final private boolean jj_3R_268() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_336()) {,     jj_scanpos = xsp;,     if (jj_3R_337()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_297() {,     if (jj_3R_365()) return true;,     return false;,   }, ,   final private boolean jj_3R_296() {,     if (jj_3R_364()) return true;,     return false;,   }, ,   final private boolean jj_3R_295() {,     if (jj_3R_363()) return true;,     return false;,   }, ,   final private boolean jj_3R_68() {,     return false;,   }, ,   final private boolean jj_3_87() {,     if (jj_3R_110()) return true;,     return false;,   }, ,   final private boolean jj_3R_404() {,     if (jj_scan_token(APPROXIMATE_NUMERIC)) return true;,     return false;,   }, ,   final private boolean jj_3R_66() {,     return false;,   }, ,   final private boolean jj_3R_293() {,     if (jj_3R_362()) return true;,     return false;,   }, ,   final private boolean jj_3_23() {,     if (jj_3R_70()) return true;,     return false;,   }, ,   final private boolean jj_3R_385() {,     if (jj_scan_token(TIMESTAMP)) return true;,     return false;,   }, ,   final private boolean jj_3R_294() {,     if (jj_scan_token(BOOLEAN)) return true;,     return false;,   }, ,   final private boolean jj_3_22() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(3).kind != LARGE;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_68()) return true;,     if (jj_3R_69()) return true;,     return false;,   }, ,   final private boolean jj_3R_305() {,     if (jj_scan_token(NULLIF)) return true;,     return false;,   }, ,   final private boolean jj_3R_205() {,     if (jj_3R_268()) return true;,     return false;,   }, ,   final private boolean jj_3R_107() {,     if (jj_scan_token(NO)) return true;,     return false;,   }, ,   final private boolean jj_3R_286() {,     if (jj_3R_355()) return true;,     return false;,   }, ,   final private boolean jj_3_21() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind != LARGE;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_66()) return true;,     if (jj_3R_67()) return true;,     return false;,   }, ,   final private boolean jj_3R_106() {,     if (jj_scan_token(MINVALUE)) return true;,     return false;,   }, ,   final private boolean jj_3R_304() {,     if (jj_3R_370()) return true;,     return false;,   }, ,   final private boolean jj_3R_403() {,     if (jj_scan_token(EXACT_NUMERIC)) return true;,     return false;,   }, ,   final private boolean jj_3R_375() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_403()) {,     jj_scanpos = xsp;,     if (jj_3R_404()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_316() {,     if (jj_scan_token(IDENTITY_VAL_LOCAL)) return true;,     return false;,   }, ,   final private boolean jj_3_71() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_106()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken( 2 ).kind == MINVALUE;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_107()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_303() {,     if (jj_3R_272()) return true;,     return false;,   }, ,   final private boolean jj_3R_251() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_303()) {,     jj_scanpos = xsp;,     if (jj_3R_304()) {,     jj_scanpos = xsp;,     if (jj_3R_305()) {,     jj_scanpos = xsp;,     if (jj_3R_306()) return true;,     },     },     },     return false;,   }, ,   final private boolean jj_3R_105() {,     if (jj_scan_token(NO)) return true;,     return false;,   }, ,   final private boolean jj_3R_104() {,     if (jj_scan_token(MAXVALUE)) return true;,     return false;,   }, ,   final private boolean jj_3R_315() {,     if (jj_scan_token(MOD)) return true;,     return false;,   }, ,   final private boolean jj_3R_384() {,     if (jj_scan_token(TIME)) return true;,     return false;,   }, ,   final private boolean jj_3_70() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_104()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken( 2 ).kind == MAXVALUE;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_105()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_243() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3_21()) {,     jj_scanpos = xsp;,     if (jj_3_22()) {,     jj_scanpos = xsp;,     if (jj_3_23()) {,     jj_scanpos = xsp;,     if (jj_3R_293()) {,     jj_scanpos = xsp;,     if (jj_3R_294()) {,     jj_scanpos = xsp;,     if (jj_3R_295()) {,     jj_scanpos = xsp;,     if (jj_3R_296()) {,     jj_scanpos = xsp;,     if (jj_3R_297()) return true;,     },     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_204() {,     if (jj_scan_token(INCREMENT)) return true;,     return false;,   }, ,   final private boolean jj_3R_383() {,     if (jj_scan_token(DATE)) return true;,     return false;,   }, ,   final private boolean jj_3R_362() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_383()) {,     jj_scanpos = xsp;,     if (jj_3R_384()) {,     jj_scanpos = xsp;,     if (jj_3R_385()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_203() {,     if (jj_scan_token(START)) return true;,     return false;,   }, ,   final private boolean jj_3R_202() {,     if (jj_scan_token(AS)) return true;,     return false;,   }, ,   final private boolean jj_3R_314() {,     if (jj_scan_token(SQRT)) return true;,     return false;,   }, ,   final private boolean jj_3_20() {,     if (jj_3R_65()) return true;,     return false;,   }, ,   final private boolean jj_3R_103() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_202()) {,     jj_scanpos = xsp;,     if (jj_3R_203()) {,     jj_scanpos = xsp;,     if (jj_3R_204()) {,     jj_scanpos = xsp;,     if (jj_3_70()) {,     jj_scanpos = xsp;,     if (jj_3_71()) {,     jj_scanpos = xsp;,     if (jj_3R_205()) return true;,     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3_74() {,     if (jj_3R_110()) return true;,     return false;,   }, ,   final private boolean jj_3R_313() {,     if (jj_scan_token(ABSVAL)) return true;,     return false;,   }, ,   final private boolean jj_3R_312() {,     if (jj_scan_token(ABS)) return true;,     return false;,   }, ,   final private boolean jj_3R_257() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_312()) {,     jj_scanpos = xsp;,     if (jj_3R_313()) {,     jj_scanpos = xsp;,     if (jj_3R_314()) {,     jj_scanpos = xsp;,     if (jj_3R_315()) {,     jj_scanpos = xsp;,     if (jj_3R_316()) return true;,     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_79() {,     if (jj_scan_token(LEFT_BRACE)) return true;,     return false;,   }, ,   final private boolean jj_3R_78() {,     if (jj_scan_token(ESCAPE)) return true;,     return false;,   }, ,   final private boolean jj_3_32() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_78()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == LEFT_BRACE && getToken(2).kind != LIMIT;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_79()) return true;,     },     return false;,   }, ,   final private boolean jj_3_53() {,     if (jj_3R_81()) return true;,     return false;,   }, ,   final private boolean jj_3R_208() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_110() {,     if (jj_3R_64()) return true;,     return false;,   }, ,   final private boolean jj_3R_109() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_208()) jj_scanpos = xsp;,     if (jj_3R_64()) return true;,     return false;,   }, ,   final private boolean jj_3_10() {,     if (jj_3R_57()) return true;,     return false;,   }, ,   final private boolean jj_3R_361() {,     if (jj_3R_382()) return true;,     return false;,   }, ,   final private boolean jj_3_84() {,     if (jj_3R_115()) return true;,     return false;,   }, ,   final private boolean jj_3_79() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3_85() {,     if (jj_3R_116()) return true;,     return false;,   }, ,   final private boolean jj_3_83() {,     if (jj_3R_114()) return true;,     return false;,   }, ,   final private boolean jj_3_31() {,     if (jj_3R_77()) return true;,     return false;,   }, ,   final private boolean jj_3R_348() {,     if (jj_3R_379()) return true;,     return false;,   }, ,   final private boolean jj_3R_143() {,     if (jj_3R_65()) return true;,     return false;,   }, ,   final private boolean jj_3R_64() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = commonDatatypeName(false);,     lookingAhead = false;,     if (!jj_semLA || jj_3R_142()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind != GENERATED;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_143()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_142() {,     if (jj_3R_243()) return true;,     return false;,   }, ,   final private boolean jj_3R_347() {,     if (jj_3R_378()) return true;,     return false;,   }, ,   final private boolean jj_3R_239() {,     if (jj_scan_token(CURRENT)) return true;,     return false;,   }, ,   final private boolean jj_3R_134() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(222)) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == CURRENT && ( getToken(2).kind == SCHEMA ||  getToken(2).kind == SQLID );,     lookingAhead = false;,     if (!jj_semLA || jj_3R_239()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_346() {,     if (jj_3R_377()) return true;,     return false;,   }, ,   final private boolean jj_3_69() {,     if (jj_3R_103()) return true;,     return false;,   }, ,   final private boolean jj_3R_345() {,     if (jj_3R_376()) return true;,     return false;,   }, ,   final private boolean jj_3_73() {,     if (jj_3R_109()) return true;,     return false;,   }, ,   final private boolean jj_3R_374() {,     if (jj_3R_367()) return true;,     return false;,   }, ,   final private boolean jj_3R_344() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_374()) jj_scanpos = xsp;,     if (jj_3R_375()) return true;,     return false;,   }, ,   final private boolean jj_3R_272() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_344()) {,     jj_scanpos = xsp;,     if (jj_3R_345()) {,     jj_scanpos = xsp;,     if (jj_3R_346()) {,     jj_scanpos = xsp;,     if (jj_3R_347()) {,     jj_scanpos = xsp;,     if (jj_3R_348()) return true;,     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_261() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3R_55() {,     if (jj_3R_134()) return true;,     return false;,   }, ,   final private boolean jj_3R_118() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(271)) {,     jj_scanpos = xsp;,     if (jj_scan_token(272)) {,     jj_scanpos = xsp;,     if (jj_scan_token(273)) {,     jj_scanpos = xsp;,     if (jj_scan_token(382)) {,     jj_scanpos = xsp;,     if (jj_scan_token(383)) {,     jj_scanpos = xsp;,     if (jj_scan_token(274)) {,     jj_scanpos = xsp;,     if (jj_scan_token(384)) {,     jj_scanpos = xsp;,     if (jj_scan_token(80)) {,     jj_scanpos = xsp;,     if (jj_scan_token(275)) {,     jj_scanpos = xsp;,     if (jj_scan_token(276)) {,     jj_scanpos = xsp;,     if (jj_scan_token(277)) {,     jj_scanpos = xsp;,     if (jj_scan_token(385)) {,     jj_scanpos = xsp;,     if (jj_scan_token(278)) {,     jj_scanpos = xsp;,     if (jj_scan_token(93)) {,     jj_scanpos = xsp;,     if (jj_scan_token(279)) {,     jj_scanpos = xsp;,     if (jj_scan_token(280)) {,     jj_scanpos = xsp;,     if (jj_scan_token(386)) {,     jj_scanpos = xsp;,     if (jj_scan_token(281)) {,     jj_scanpos = xsp;,     if (jj_scan_token(282)) {,     jj_scanpos = xsp;,     if (jj_scan_token(387)) {,     jj_scanpos = xsp;,     if (jj_scan_token(105)) {,     jj_scanpos = xsp;,     if (jj_scan_token(388)) {,     jj_scanpos = xsp;,     if (jj_scan_token(362)) {,     jj_scanpos = xsp;,     if (jj_scan_token(364)) {,     jj_scanpos = xsp;,     if (jj_scan_token(283)) {,     jj_scanpos = xsp;,     if (jj_scan_token(114)) {,     jj_scanpos = xsp;,     if (jj_scan_token(284)) {,     jj_scanpos = xsp;,     if (jj_scan_token(285)) {,     jj_scanpos = xsp;,     if (jj_scan_token(286)) {,     jj_scanpos = xsp;,     if (jj_scan_token(393)) {,     jj_scanpos = xsp;,     if (jj_scan_token(394)) {,     jj_scanpos = xsp;,     if (jj_scan_token(289)) {,     jj_scanpos = xsp;,     if (jj_scan_token(365)) {,     jj_scanpos = xsp;,     if (jj_scan_token(390)) {,     jj_scanpos = xsp;,     if (jj_scan_token(391)) {,     jj_scanpos = xsp;,     if (jj_scan_token(392)) {,     jj_scanpos = xsp;,     if (jj_scan_token(395)) {,     jj_scanpos = xsp;,     if (jj_scan_token(290)) {,     jj_scanpos = xsp;,     if (jj_scan_token(396)) {,     jj_scanpos = xsp;,     if (jj_scan_token(397)) {,     jj_scanpos = xsp;,     if (jj_scan_token(398)) {,     jj_scanpos = xsp;,     if (jj_scan_token(399)) {,     jj_scanpos = xsp;,     if (jj_scan_token(291)) {,     jj_scanpos = xsp;,     if (jj_scan_token(292)) {,     jj_scanpos = xsp;,     if (jj_scan_token(293)) {,     jj_scanpos = xsp;,     if (jj_scan_token(294)) {,     jj_scanpos = xsp;,     if (jj_scan_token(400)) {,     jj_scanpos = xsp;,     if (jj_scan_token(295)) {,     jj_scanpos = xsp;,     if (jj_scan_token(401)) {,     jj_scanpos = xsp;,     if (jj_scan_token(297)) {,     jj_scanpos = xsp;,     if (jj_scan_token(402)) {,     jj_scanpos = xsp;,     if (jj_scan_token(299)) {,     jj_scanpos = xsp;,     if (jj_scan_token(300)) {,     jj_scanpos = xsp;,     if (jj_scan_token(403)) {,     jj_scanpos = xsp;,     if (jj_scan_token(301)) {,     jj_scanpos = xsp;,     if (jj_scan_token(302)) {,     jj_scanpos = xsp;,     if (jj_scan_token(303)) {,     jj_scanpos = xsp;,     if (jj_scan_token(404)) {,     jj_scanpos = xsp;,     if (jj_scan_token(405)) {,     jj_scanpos = xsp;,     if (jj_scan_token(304)) {,     jj_scanpos = xsp;,     if (jj_scan_token(305)) {,     jj_scanpos = xsp;,     if (jj_scan_token(306)) {,     jj_scanpos = xsp;,     if (jj_scan_token(369)) {,     jj_scanpos = xsp;,     if (jj_scan_token(307)) {,     jj_scanpos = xsp;,     if (jj_scan_token(308)) {,     jj_scanpos = xsp;,     if (jj_scan_token(309)) {,     jj_scanpos = xsp;,     if (jj_scan_token(310)) {,     jj_scanpos = xsp;,     if (jj_scan_token(406)) {,     jj_scanpos = xsp;,     if (jj_scan_token(407)) {,     jj_scanpos = xsp;,     if (jj_scan_token(311)) {,     jj_scanpos = xsp;,     if (jj_scan_token(408)) {,     jj_scanpos = xsp;,     if (jj_scan_token(312)) {,     jj_scanpos = xsp;,     if (jj_scan_token(313)) {,     jj_scanpos = xsp;,     if (jj_scan_token(184)) {,     jj_scanpos = xsp;,     if (jj_scan_token(314)) {,     jj_scanpos = xsp;,     if (jj_scan_token(315)) {,     jj_scanpos = xsp;,     if (jj_scan_token(316)) {,     jj_scanpos = xsp;,     if (jj_scan_token(317)) {,     jj_scanpos = xsp;,     if (jj_scan_token(318)) {,     jj_scanpos = xsp;,     if (jj_scan_token(409)) {,     jj_scanpos = xsp;,     if (jj_scan_token(410)) {,     jj_scanpos = xsp;,     if (jj_scan_token(319)) {,     jj_scanpos = xsp;,     if (jj_scan_token(320)) {,     jj_scanpos = xsp;,     if (jj_scan_token(321)) {,     jj_scanpos = xsp;,     if (jj_scan_token(322)) {,     jj_scanpos = xsp;,     if (jj_scan_token(413)) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == OFFSET &&,                         !seeingOffsetClause();,     lookingAhead = false;,     if (!jj_semLA || jj_scan_token(323)) {,     jj_scanpos = xsp;,     if (jj_scan_token(414)) {,     jj_scanpos = xsp;,     if (jj_scan_token(415)) {,     jj_scanpos = xsp;,     if (jj_scan_token(412)) {,     jj_scanpos = xsp;,     if (jj_scan_token(372)) {,     jj_scanpos = xsp;,     if (jj_scan_token(324)) {,     jj_scanpos = xsp;,     if (jj_scan_token(418)) {,     jj_scanpos = xsp;,     if (jj_scan_token(325)) {,     jj_scanpos = xsp;,     if (jj_scan_token(326)) {,     jj_scanpos = xsp;,     if (jj_scan_token(419)) {,     jj_scanpos = xsp;,     if (jj_scan_token(420)) {,     jj_scanpos = xsp;,     if (jj_scan_token(421)) {,     jj_scanpos = xsp;,     if (jj_scan_token(422)) {,     jj_scanpos = xsp;,     if (jj_scan_token(327)) {,     jj_scanpos = xsp;,     if (jj_scan_token(424)) {,     jj_scanpos = xsp;,     if (jj_scan_token(328)) {,     jj_scanpos = xsp;,     if (jj_scan_token(423)) {,     jj_scanpos = xsp;,     if (jj_scan_token(425)) {,     jj_scanpos = xsp;,     if (jj_scan_token(329)) {,     jj_scanpos = xsp;,     if (jj_scan_token(426)) {,     jj_scanpos = xsp;,     if (jj_scan_token(427)) {,     jj_scanpos = xsp;,     if (jj_scan_token(428)) {,     jj_scanpos = xsp;,     if (jj_scan_token(330)) {,     jj_scanpos = xsp;,     if (jj_scan_token(373)) {,     jj_scanpos = xsp;,     if (jj_scan_token(331)) {,     jj_scanpos = xsp;,     if (jj_scan_token(332)) {,     jj_scanpos = xsp;,     if (jj_scan_token(374)) {,     jj_scanpos = xsp;,     if (jj_scan_token(429)) {,     jj_scanpos = xsp;,     if (jj_scan_token(430)) {,     jj_scanpos = xsp;,     if (jj_scan_token(334)) {,     jj_scanpos = xsp;,     if (jj_scan_token(333)) {,     jj_scanpos = xsp;,     if (jj_scan_token(335)) {,     jj_scanpos = xsp;,     if (jj_scan_token(432)) {,     jj_scanpos = xsp;,     if (jj_scan_token(433)) {,     jj_scanpos = xsp;,     if (jj_scan_token(336)) {,     jj_scanpos = xsp;,     if (jj_scan_token(434)) {,     jj_scanpos = xsp;,     if (jj_scan_token(435)) {,     jj_scanpos = xsp;,     if (jj_scan_token(437)) {,     jj_scanpos = xsp;,     if (jj_scan_token(436)) {,     jj_scanpos = xsp;,     if (jj_scan_token(337)) {,     jj_scanpos = xsp;,     if (jj_scan_token(338)) {,     jj_scanpos = xsp;,     if (jj_scan_token(339)) {,     jj_scanpos = xsp;,     if (jj_scan_token(340)) {,     jj_scanpos = xsp;,     if (jj_scan_token(341)) {,     jj_scanpos = xsp;,     if (jj_scan_token(342)) {,     jj_scanpos = xsp;,     if (jj_scan_token(343)) {,     jj_scanpos = xsp;,     if (jj_scan_token(344)) {,     jj_scanpos = xsp;,     if (jj_scan_token(345)) {,     jj_scanpos = xsp;,     if (jj_scan_token(438)) {,     jj_scanpos = xsp;,     if (jj_scan_token(439)) {,     jj_scanpos = xsp;,     if (jj_scan_token(346)) {,     jj_scanpos = xsp;,     if (jj_scan_token(347)) {,     jj_scanpos = xsp;,     if (jj_scan_token(431)) {,     jj_scanpos = xsp;,     if (jj_scan_token(440)) {,     jj_scanpos = xsp;,     if (jj_scan_token(348)) {,     jj_scanpos = xsp;,     if (jj_scan_token(441)) {,     jj_scanpos = xsp;,     if (jj_scan_token(238)) {,     jj_scanpos = xsp;,     if (jj_scan_token(349)) {,     jj_scanpos = xsp;,     if (jj_scan_token(350)) {,     jj_scanpos = xsp;,     if (jj_scan_token(351)) {,     jj_scanpos = xsp;,     if (jj_scan_token(352)) {,     jj_scanpos = xsp;,     if (jj_scan_token(353)) {,     jj_scanpos = xsp;,     if (jj_scan_token(442)) {,     jj_scanpos = xsp;,     if (jj_scan_token(354)) {,     jj_scanpos = xsp;,     if (jj_scan_token(443)) {,     jj_scanpos = xsp;,     if (jj_scan_token(250)) {,     jj_scanpos = xsp;,     if (jj_scan_token(355)) {,     jj_scanpos = xsp;,     if (jj_scan_token(444)) {,     jj_scanpos = xsp;,     if (jj_scan_token(356)) {,     jj_scanpos = xsp;,     if (jj_scan_token(445)) {,     jj_scanpos = xsp;,     if (jj_scan_token(357)) {,     jj_scanpos = xsp;,     if (jj_scan_token(258)) {,     jj_scanpos = xsp;,     if (jj_scan_token(260)) {,     jj_scanpos = xsp;,     if (jj_scan_token(417)) {,     jj_scanpos = xsp;,     if (jj_scan_token(358)) {,     jj_scanpos = xsp;,     if (jj_scan_token(446)) return true;,     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_214() {,     if (jj_3R_272()) return true;,     return false;,   }, ,   final private boolean jj_3_76() {,     if (jj_3R_86()) return true;,     return false;,   }, ,   final private boolean jj_3R_260() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3_19() {,     if (jj_3R_64()) return true;,     return false;,   }, ,   final private boolean jj_3R_63() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3_78() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_285() {,     if (jj_scan_token(DELETE)) return true;,     return false;,   }, ,   final private boolean jj_3R_184() {,     if (jj_3R_261()) return true;,     return false;,   }, ,   final private boolean jj_3R_213() {,     if (jj_3R_253()) return true;,     return false;,   }, ,   final private boolean jj_3R_87() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = !distinctUDAFollows();,     lookingAhead = false;,     if (!jj_semLA || jj_3R_183()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = distinctUDAFollows();,     lookingAhead = false;,     if (!jj_semLA || jj_3R_184()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_183() {,     if (jj_3R_260()) return true;,     return false;,   }, ,   final private boolean jj_3R_338() {,     if (jj_scan_token(IN)) return true;,     return false;,   }, ,   final private boolean jj_3R_269() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_338()) {,     jj_scanpos = xsp;,     if (jj_3R_339()) {,     jj_scanpos = xsp;,     if (jj_3R_340()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3_50() {,     if (jj_3R_92()) return true;,     return false;,   }, ,   final private boolean jj_3_68() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_212() {,     if (jj_3R_253()) return true;,     return false;,   }, ,   final private boolean jj_3R_340() {,     if (jj_scan_token(INOUT)) return true;,     return false;,   }, ,   final private boolean jj_3R_411() {,     if (jj_3R_417()) return true;,     return false;,   }, ,   final private boolean jj_3R_339() {,     if (jj_scan_token(OUT)) return true;,     return false;,   }, ,   final private boolean jj_3_30() {,     if (jj_3R_77()) return true;,     return false;,   }, ,   final private boolean jj_3R_237() {,     if (jj_3R_291()) return true;,     return false;,   }, ,   final private boolean jj_3R_211() {,     if (jj_3R_271()) return true;,     return false;,   }, ,   final private boolean jj_3R_206() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_269()) jj_scanpos = xsp;,     return false;,   }, ,   final private boolean jj_3_18() {,     if (jj_3R_63()) return true;,     return false;,   }, ,   final private boolean jj_3R_335() {,     if (jj_scan_token(LEFT_PAREN)) return true;,     return false;,   }, ,   final private boolean jj_3R_236() {,     if (jj_3R_290()) return true;,     return false;,   }, ,   final private boolean jj_3R_210() {,     if (jj_3R_270()) return true;,     return false;,   }, ,   final private boolean jj_3R_394() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3_30()) {,     jj_scanpos = xsp;,     if (jj_3R_411()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_123() {,     if (jj_scan_token(GRANT)) return true;,     return false;,   }, ,   final private boolean jj_3R_235() {,     if (jj_3R_289()) return true;,     return false;,   }, ,   final private boolean jj_3R_234() {,     if (jj_3R_288()) return true;,     return false;,   }, ,   final private boolean jj_3R_207() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_111() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == SCHEMA || getToken(2).kind == SQLID;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_209()) {,     jj_scanpos = xsp;,     if (jj_3R_210()) {,     jj_scanpos = xsp;,     if (jj_3R_211()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == DATE ||,                 getToken(1).kind == TIME ||,                 getToken(1).kind == TIMESTAMP;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_212()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == LEFT_PAREN ||,                        (getToken(4).kind == LEFT_PAREN &&,                         getToken(2).kind != COMMA);,     lookingAhead = false;,     if (!jj_semLA || jj_3R_213()) {,     jj_scanpos = xsp;,     if (jj_3_76()) {,     jj_scanpos = xsp;,     if (jj_3R_214()) return true;,     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_209() {,     if (jj_scan_token(CURRENT)) return true;,     return false;,   }, ,   final private boolean jj_3R_233() {,     if (jj_3R_287()) return true;,     return false;,   }, ,   final private boolean jj_3R_108() {,     if (jj_3R_206()) return true;,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_207()) jj_scanpos = xsp;,     if (jj_3R_64()) return true;,     return false;,   }, ,   final private boolean jj_3R_369() {,     if (jj_3R_394()) return true;,     return false;,   }, ,   final private boolean jj_3R_325() {,     if (jj_scan_token(XMLQUERY)) return true;,     return false;,   }, ,   final private boolean jj_3R_232() {,     if (jj_3R_286()) return true;,     return false;,   }, ,   final private boolean jj_3R_324() {,     if (jj_scan_token(XMLEXISTS)) return true;,     return false;,   }, ,   final private boolean jj_3R_45() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == GRANT &&,                                 ((getToken(2).kind == TRIGGER &&,                                   ((getToken(3).kind == COMMA &&,                                         isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||,                                    getToken(3).kind == ON)) ||,                                  isPrivilegeKeywordExceptTrigger(getToken(2).kind));,     lookingAhead = false;,     if (!jj_semLA || jj_3R_122()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == GRANT &&,                                 ((getToken(2).kind == TRIGGER &&,                                   ((getToken(3).kind == COMMA &&,                                         !isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||,                                    getToken(3).kind == TO)) ||,                                  !isPrivilegeKeywordExceptTrigger(getToken(2).kind));,     lookingAhead = false;,     if (!jj_semLA || jj_3R_123()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_122() {,     if (jj_scan_token(GRANT)) return true;,     return false;,   }, ,   final private boolean jj_3R_130() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_231()) {,     jj_scanpos = xsp;,     if (jj_3R_232()) {,     jj_scanpos = xsp;,     if (jj_3R_233()) {,     jj_scanpos = xsp;,     if (jj_3R_234()) {,     jj_scanpos = xsp;,     if (jj_3R_235()) {,     jj_scanpos = xsp;,     if (jj_3R_236()) {,     jj_scanpos = xsp;,     if (jj_3R_237()) return true;,     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_231() {,     if (jj_3R_285()) return true;,     return false;,   }, ,   final private boolean jj_3R_323() {,     if (jj_scan_token(XMLSERIALIZE)) return true;,     return false;,   }, ,   final private boolean jj_3R_102() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3R_322() {,     if (jj_scan_token(XMLPARSE)) return true;,     return false;,   }, ,   final private boolean jj_3R_259() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_322()) {,     jj_scanpos = xsp;,     if (jj_3R_323()) {,     jj_scanpos = xsp;,     if (jj_3R_324()) {,     jj_scanpos = xsp;,     if (jj_3R_325()) return true;,     },     },     },     return false;,   }, ,   final private boolean jj_3_72() {,     if (jj_3R_108()) return true;,     return false;,   }, ,   final private boolean jj_3_75() {,     if (jj_3R_111()) return true;,     return false;,   }, ,   final private boolean jj_3R_302() {,     if (jj_3R_369()) return true;,     return false;,   }, ,   final private boolean jj_3R_141() {,     if (jj_scan_token(ON)) return true;,     return false;,   }, ,   final private boolean jj_3R_140() {,     if (jj_scan_token(ON)) return true;,     return false;,   }, ,   final private boolean jj_3R_131() {,     if (jj_scan_token(TRUNCATE)) return true;,     return false;,   }, ,   final private boolean jj_3R_139() {,     if (jj_scan_token(NOT)) return true;,     return false;,   }, ,   final private boolean jj_3R_186() {,     if (jj_3R_263()) return true;,     return false;,   }, ,   final private boolean jj_3R_62() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_139()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == ON && getToken(2).kind == COMMIT;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_140()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == ON && getToken(2).kind == ROLLBACK;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_141()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3_9() {,     if (jj_3R_56()) return true;,     return false;,   }, ,   final private boolean jj_3_45() {,     if (jj_3R_89()) return true;,     return false;,   }, ,   final private boolean jj_3R_199() {,     if (jj_scan_token(TABLE)) return true;,     return false;,   }, ,   final private boolean jj_3_37() {,     if (jj_3R_84()) return true;,     return false;,   }, ,   final private boolean jj_3R_88() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_185()) {,     jj_scanpos = xsp;,     if (jj_3_45()) {,     jj_scanpos = xsp;,     if (jj_3R_186()) return true;,     },     },     return false;,   }, ,   final private boolean jj_3R_185() {,     if (jj_3R_262()) return true;,     return false;,   }, ,   final private boolean jj_3R_382() {,     if (jj_3R_410()) return true;,     return false;,   }, ,   final private boolean jj_3R_250() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(190)) jj_scanpos = xsp;,     if (jj_3R_302()) return true;,     return false;,   }, ,   final private boolean jj_3R_352() {,     if (jj_scan_token(UR)) return true;,     return false;,   }, ,   final private boolean jj_3_67() {,     if (jj_3R_102()) return true;,     return false;,   }, ,   final private boolean jj_3_17() {,     if (jj_3R_62()) return true;,     return false;,   }, ,   final private boolean jj_3R_351() {,     if (jj_scan_token(CS)) return true;,     return false;,   }, ,   final private boolean jj_3R_350() {,     if (jj_scan_token(RS)) return true;,     return false;,   }, ,   final private boolean jj_3R_56() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3R_424() {,     if (jj_scan_token(MINUTE)) return true;,     return false;,   }, ,   final private boolean jj_3R_349() {,     if (jj_scan_token(RR)) return true;,     return false;,   }, ,   final private boolean jj_3R_265() {,     if (jj_scan_token(NULL)) return true;,     return false;,   }, ,   final private boolean jj_3R_129() {,     if (jj_scan_token(DECLARE)) return true;,     return false;,   }, ,   final private boolean jj_3R_410() {,     if (jj_3R_169()) return true;,     return false;,   }, ,   final private boolean jj_3R_267() {,     if (jj_scan_token(LEFT_PAREN)) return true;,     return false;,   }, ,   final private boolean jj_3R_220() {,     if (jj_scan_token(READ)) return true;,     return false;,   }, ,   final private boolean jj_3R_423() {,     if (jj_scan_token(HOUR)) return true;,     return false;,   }, ,   final private boolean jj_3R_176() {,     if (jj_3R_259()) return true;,     return false;,   }, ,   final private boolean jj_3R_273() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_349()) {,     jj_scanpos = xsp;,     if (jj_3R_350()) {,     jj_scanpos = xsp;,     if (jj_3R_351()) {,     jj_scanpos = xsp;,     if (jj_3R_352()) return true;,     },     },     },     return false;,   }, ,   final private boolean jj_3R_219() {,     if (jj_scan_token(READ)) return true;,     return false;,   }, ,   final private boolean jj_3R_422() {,     if (jj_scan_token(DAY)) return true;,     return false;,   }, ,   final private boolean jj_3_8() {,     if (jj_3R_54()) return true;,     return false;,   }, ,   final private boolean jj_3R_158() {,     if (jj_3R_250()) return true;,     return false;,   }, ,   final private boolean jj_3_7() {,     if (jj_3R_55()) return true;,     return false;,   }, ,   final private boolean jj_3R_421() {,     if (jj_scan_token(MONTH)) return true;,     return false;,   }, ,   final private boolean jj_3R_175() {,     if (jj_scan_token(LENGTH)) return true;,     return false;,   }, ,   final private boolean jj_3R_218() {,     if (jj_scan_token(DIRTY)) return true;,     return false;,   }, ,   final private boolean jj_3R_420() {,     if (jj_scan_token(YEAR)) return true;,     return false;,   }, ,   final private boolean jj_3R_414() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_420()) {,     jj_scanpos = xsp;,     if (jj_3R_421()) {,     jj_scanpos = xsp;,     if (jj_3R_422()) {,     jj_scanpos = xsp;,     if (jj_3R_423()) {,     jj_scanpos = xsp;,     if (jj_3R_424()) return true;,     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_121() {,     if (jj_scan_token(SET)) return true;,     return false;,   }, ,   final private boolean jj_3R_274() {,     if (jj_scan_token(REPEATABLE)) return true;,     return false;,   }, ,   final private boolean jj_3R_65() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3R_217() {,     if (jj_scan_token(CURSOR)) return true;,     return false;,   }, ,   final private boolean jj_3_52() {,     if (jj_3R_81()) return true;,     return false;,   }, ,   final private boolean jj_3R_174() {,     if (jj_scan_token(VALUE)) return true;,     return false;,   }, ,   final private boolean jj_3R_216() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_274()) {,     jj_scanpos = xsp;,     if (jj_scan_token(336)) return true;,     },     return false;,   }, ,   final private boolean jj_3_6() {,     if (jj_3R_55()) return true;,     return false;,   }, ,   final private boolean jj_3_5() {,     if (jj_3R_54()) return true;,     return false;,   }, ,   final private boolean jj_3R_215() {,     if (jj_3R_273()) return true;,     return false;,   }, ,   final private boolean jj_3R_81() {,     if (jj_3R_158()) return true;,     return false;,   }, ,   final private boolean jj_3R_173() {,     if (jj_scan_token(COALESCE)) return true;,     return false;,   }, ,   final private boolean jj_3R_198() {,     if (jj_scan_token(NEW)) return true;,     return false;,   }, ,   final private boolean jj_3R_266() {,     if (jj_3R_335()) return true;,     return false;,   }, ,   final private boolean jj_3R_44() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == SET && getToken(2).kind != CURRENT;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_120()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == SET && getToken(2).kind == CURRENT;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_121()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_120() {,     if (jj_scan_token(SET)) return true;,     return false;,   }, ,   final private boolean jj_3_44() {,     if (jj_3R_88()) return true;,     return false;,   }, ,   final private boolean jj_3_77() {,     if (jj_3R_112()) return true;,     return false;,   }, ,   final private boolean jj_3R_112() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_215()) {,     jj_scanpos = xsp;,     if (jj_3R_216()) {,     jj_scanpos = xsp;,     if (jj_3R_217()) {,     jj_scanpos = xsp;,     if (jj_3R_218()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == READ && getToken(2).kind == COMMITTED;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_219()) {,     jj_scanpos = xsp;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == READ && getToken(2).kind == UNCOMMITTED;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_220()) return true;,     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3_16() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_83() {,     if (jj_3R_169()) return true;,     return false;,   }, ,   final private boolean jj_3R_172() {,     if (jj_3R_258()) return true;,     return false;,   }, ,   final private boolean jj_3R_76() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(72)) jj_scanpos = xsp;,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_171() {,     if (jj_3R_257()) return true;,     return false;,   }, ,   final private boolean jj_3R_128() {,     if (jj_scan_token(ALTER)) return true;,     return false;,   }, ,   public SQLParserTokenManager token_source;,   public Token token, jj_nt;,   private Token jj_scanpos, jj_lastpos;,   private int jj_la;,   public boolean lookingAhead = false;,   private boolean jj_semLA;,   private int jj_gen;,   final private int[] jj_la1 = new int[375];,   static private int[] jj_la1_0;,   static private int[] jj_la1_1;,   static private int[] jj_la1_2;,   static private int[] jj_la1_3;,   static private int[] jj_la1_4;,   static private int[] jj_la1_5;,   static private int[] jj_la1_6;,   static private int[] jj_la1_7;,   static private int[] jj_la1_8;,   static private int[] jj_la1_9;,   static private int[] jj_la1_10;,   static private int[] jj_la1_11;,   static private int[] jj_la1_12;,   static private int[] jj_la1_13;,   static private int[] jj_la1_14;,   static private int[] jj_la1_15;,   static {,       jj_la1_0();,       jj_la1_1();,       jj_la1_2();,       jj_la1_3();,       jj_la1_4();,       jj_la1_5();,       jj_la1_6();,       jj_la1_7();,       jj_la1_8();,       jj_la1_9();,       jj_la1_10();,       jj_la1_11();,       jj_la1_12();,       jj_la1_13();,       jj_la1_14();,       jj_la1_15();,    },    private static void jj_la1_0() {,       jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};,    },    private static void jj_la1_1() {,       jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x8000000,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};,    },    private static void jj_la1_2() {,       jj_la1_2 = new int[] {0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x8000000,0x8000000,0x0,0x8000000,0x8000000,0x3010000,0x0,0x0,0x3000000,0x0,0x3000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3010000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x4,0x4,0x0,0x0,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x20,0x0,0x0,0x0,0x0,0x8000,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x400000,0x800000,0x0,0x20000000,0x0,0x0,0x1000000,0x0,0x0,0x100,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x44,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x2000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x8000000,0x0,0x2,0x10,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x4,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0xdbfefffe,0x20010000,0x0,0xdbfefffe,0xdbfefffe,0x0,};,    },    private static void jj_la1_3() {,       jj_la1_3 = new int[] {0x4000000,0x0,0x4400400,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x2000000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x10,0x800010,0x10,0x10,0x800000,0x10,0x800010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300000,0x300000,0x0,0x0,0x300000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x80000000,0x80000000,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x10000,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x4000,0x8000,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x40000,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x800000,0x0,0x0,0x0,0x2000000,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x1,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x4000000,0x0,0xfffbfdff,0x40200,0x0,0xfffbfdff,0xfffbfdff,0x0,};,    },    private static void jj_la1_4() {,       jj_la1_4 = new int[] {0x0,0x0,0x2,0x0,0x200,0x0,0x0,0x200000,0x200000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x1,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0xc,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x200000,0x200,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0xffffffff,0x0,0x0,0xffffffff,0xffffffff,0x0,};,    },    private static void jj_la1_5() {,       jj_la1_5 = new int[] {0x40,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x40000000,0x40000000,0x40000000,0x0,0x40000000,0x40000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa000000,0x0,0x0,0x0,0x0,0x2000000,0x180,0x0,0x0,0x0,0x180,0x180,0x180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x800,0x0,0x40000000,0x40040001,0x0,0x40001,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x80000,0x0,0x0,0x80000,0x0,0x0,0x10000,0x0,0x0,0x0,0x10000000,0x80000,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x180,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4022008,0x20008,0x20008,0x0,0x20008,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x600000,0x0,0x0,0x600000,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x60000000,0x0,0x0,0x60000000,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x80000000,0x20000000,0x4,0x4,0x0,0x40000000,0x40000000,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x40,0x0,0xfeffffff,0x1000000,0x0,0xfeffffff,0xfeffffff,0x0,};,    },    private static void jj_la1_6() {,       jj_la1_6 = new int[] {0x0,0x0,0x10000000,0x0,0x0,0x0,0x40000000,0x40080000,0x40080000,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x10000000,0x8,0x0,0x0,0x8000,0x0,0x10000,0x810000,0x810000,0x810000,0x0,0x810000,0x810000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x0,0x2,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x20000000,0x4,0x200000,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x8000000,0x200,0x8000000,0x8000000,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x40000000,0x40000000,0x0,0x1,0x0,0x0,0x0,0x10000,0x10000,0x8,0x0,0x8,0x8,0x0,0x2000000,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x810000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x80000,0x800000,0x0,0x0,0x800000,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x100000,0x0,0x800000,0x0,0xffffffff,0x0,0x0,0xffffffff,0xffffffff,0x0,};,    },    private static void jj_la1_7() {,       jj_la1_7 = new int[] {0x40000002,0x0,0x40000002,0x0,0x0,0x0,0x0,0x10008000,0x8000,0x0,0x0,0x0,0x0,0x40000002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x10000000,0x0,0x80000,0x0,0x10000000,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x10000000,0x10000000,0x0,0x10000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x10,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x804,0x0,0x0,0x0,0x0,0x1,0x0,0x80000000,0x0,0x0,0x81000000,0x1000000,0x0,0x800000,0x0,0x0,0x2000004,0x0,0x81000000,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x1,0x0,0x2000000,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x8000,0x8000,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x2000000,0x0,0x2000000,0x0,0x0,0x4004000,0x8000,0x0,0x80000,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000004,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x40000000,0x40000000,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x40000002,0x8000,0x0,0x40000002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000002,0x0,0x0,0x0,0x40000002,0x0,0xfbffbfff,0x0,0x4004000,0xfbffbfff,0xfbffbfff,0x0,};,    },    private static void jj_la1_8() {,       jj_la1_8 = new int[] {0x8,0x0,0x8,0x0,0x0,0x0,0x80,0x80,0x80,0x0,0x0,0x0,0x0,0x8,0x200,0x0,0x0,0x200,0x0,0x0,0x0,0x800,0x0,0x200,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x800,0x0,0x800,0x20480000,0x0,0x40,0x20,0x0,0x0,0x0,0x40,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x480000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40004000,0x0,0x2000001,0x0,0x0,0x18000,0x0,0x40004000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x18000,0x4,0x0,0x60004000,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60004000,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4200000,0x0,0x0,0x4200000,0x200000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x4200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x40000,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7beb,0x7fff8000,0x14,0x7beb,0x7beb,0x0,};,    },    private static void jj_la1_9() {,       jj_la1_9 = new int[] {0x200000,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x10,0x0,0x10,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x800020,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800020,0x2000,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x400000,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000803,0x2,0x20000000,0x1000803,0x0,0x400,0x0,0x0,0x0,0x100,0x100,0x1000803,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0xfffffafe,0x0,0x100,0x100,0x0,};,    },    private static void jj_la1_10() {,       jj_la1_10 = new int[] {0x0,0x0,0x2080,0x0,0x0,0x0,0x10000000,0x10000000,0x10000000,0x0,0x0,0x0,0x0,0x2080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fe0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x8,0x0,0x0,0x0,0x8,0x0,0x1000,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x400,0x0,0x8000,0x400,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8001000,0x0,0x1000,0x1000,0x1000,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10100,0x10100,0x0,0x10100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0xfffffff0,0x0,0x0,0x0,};,    },    private static void jj_la1_11() {,       jj_la1_11 = new int[] {0x200,0x0,0x200,0x4,0x0,0x0,0x200000,0x200008,0x200008,0x200000,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2020100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x10000,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1403,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1840000,0x840000,0x0,0x0,0x840000,0x0,0x800,0x0,0x1844000,0x3c000000,0x0,0x0,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x80000,0x0,0x0,0x0,0x0,0x0,0x800,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x20,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x3f8dcb00,0xc0023400,0x70007f,0x3f8dcb00,0x3f8dcb00,0x0,};,    },    private static void jj_la1_12() {,       jj_la1_12 = new int[] {0x0,0x200000,0x0,0x0,0x0,0x200000,0x0,0x10080,0x10080,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x180000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0xc6000000,0x0,0x0,0x0,0x0,0xc6000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x4000,0x0,0x0,0x0,0x0,0x0,0x410,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x4,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x27ffffdf,0xd0000000,0x8000000,0x8000000,0x0,};,    },    private static void jj_la1_13() {,       jj_la1_13 = new int[] {0x0,0x100,0x0,0x0,0x0,0x100,0x4010000,0x4010000,0x4010000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x10000000,0x0,0x10000000,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x10400000,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200422,0x0,0x0,0x200422,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x200422,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x200,0x0,0x20006000,0x20006000,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x10,0x0,0x8000000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x4000000,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x4000000,0x0,0x1,0x0,0x7ffffffe,0x1,0x1,0x0,};,    },    private static void jj_la1_14() {,       jj_la1_14 = new int[] {0x1000028,0x0,0x1000028,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x1000028,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000008,0x1000000,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x20,0x0,0x20,0x0,0x0,0x20,0x20,0x20,0x20,0x0,0x0,0x0,0x400,0x20,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0xa00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x80,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfe0000,0x0,0x0,0xfe0000,0xa00,0xa00,0x20002080,0x20002080,0xa00,0x40001000,0x1000,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x400,0x0,0x400,0x0,0x0,0x400,0x0,0x0,0x40,0x0,0x0,0x0,0x1000a08,0x20,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x440,0x0,0x1000000,0x0,0x400,0x400,0x0,0x0,0x0,0x0,0x0,0x1000a00,0x1000a00,0x0,0x1000a00,0x0,0x0,0x1000a00,0x1000a00,0x0,0x0,0x0,0x400,0x400,0x0,0x0,0x0,0x400,0x0,0x400,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x8,0x0,0x20,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x20,0x0,0x20,0x400,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x80,0x0,0x0,0x20,0x0,0x0,0x0,0x400,0x400,0x0,0x180,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x80000000,0x0,0x0,0x0,0x400,0x80000000,0x0,0x400,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x400,0x0,0x0,0x0,0xa08,0xa00,0xa08,0xa00,0x0,0x0,0x0,0x0,0x80000,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x80000,0x0,0x0,0x1000000,0x1000a08,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x20,0x400,0x20,0x20,0x20,0x0,0x400,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};,    },    private static void jj_la1_15() {,       jj_la1_15 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x280,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x0,0x80,0x0,0x0,0x80,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c80,0x0,0x1c80,0x0,0x1080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x400,0x1c80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x41,0x0,0x0,0x0,0x0,0x0,0x41,};,    },   final private JJCalls[] jj_2_rtns = new JJCalls[92];,   private boolean jj_rescan = false;,   private int jj_gc = 0;, ,   public SQLParser(CharStream stream) {,     token_source = new SQLParserTokenManager(stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 375; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public void ReInit(CharStream stream) {,     token_source.ReInit(stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 375; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public SQLParser(SQLParserTokenManager tm) {,     token_source = tm;,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 375; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public void ReInit(SQLParserTokenManager tm) {,     token_source = tm;,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 375; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   final private Token jj_consume_token(int kind) throws ParseException {,     Token oldToken = token;,     if ((token = jj_nt).next != null) jj_nt = jj_nt.next;,     else jj_nt = jj_nt.next = token_source.getNextToken();,     if (token.kind == kind) {,       jj_gen++;,       if (++jj_gc > 100) {,         jj_gc = 0;,         for (int i = 0; i < jj_2_rtns.length; i++) {,           JJCalls c = jj_2_rtns[i];,           while (c != null) {,             if (c.gen < jj_gen) c.first = null;,             c = c.next;,           },         },       },       return token;,     },     jj_nt = token;,     token = oldToken;,     jj_kind = kind;,     throw generateParseException();,   }, ,   static private final class LookaheadSuccess extends java.lang.Error { },   final private LookaheadSuccess jj_ls = new LookaheadSuccess();,   final private boolean jj_scan_token(int kind) {,     if (jj_scanpos == jj_lastpos) {,       jj_la--;,       if (jj_scanpos.next == null) {,         jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();,       } else {,         jj_lastpos = jj_scanpos = jj_scanpos.next;,       },     } else {,       jj_scanpos = jj_scanpos.next;,     },     if (jj_rescan) {,       int i = 0; Token tok = token;,       while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; },       if (tok != null) jj_add_error_token(kind, i);,     },     if (jj_scanpos.kind != kind) return true;,     if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;,     return false;,   }, ,   final public Token getNextToken() {,     if ((token = jj_nt).next != null) jj_nt = jj_nt.next;,     else jj_nt = jj_nt.next = token_source.getNextToken();,     jj_gen++;,     return token;,   }, ,   final public Token getToken(int index) {,     Token t = lookingAhead ? jj_scanpos : token;,     for (int i = 0; i < index; i++) {,       if (t.next != null) t = t.next;,       else t = t.next = token_source.getNextToken();,     },     return t;,   }, ,   private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();,   private int[] jj_expentry;,   private int jj_kind = -1;,   private int[] jj_lasttokens = new int[100];,   private int jj_endpos;, ,   private void jj_add_error_token(int kind, int pos) {,     if (pos >= 100) return;,     if (pos == jj_endpos + 1) {,       jj_lasttokens[jj_endpos++] = kind;,     } else if (jj_endpos != 0) {,       jj_expentry = new int[jj_endpos];,       for (int i = 0; i < jj_endpos; i++) {,         jj_expentry[i] = jj_lasttokens[i];,       },       boolean exists = false;,       for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {,         int[] oldentry = (int[])(e.nextElement());,         if (oldentry.length == jj_expentry.length) {,           exists = true;,           for (int i = 0; i < jj_expentry.length; i++) {,             if (oldentry[i] != jj_expentry[i]) {,               exists = false;,               break;,             },           },           if (exists) break;,         },       },       if (!exists) jj_expentries.addElement(jj_expentry);,       if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;,     },   }, ,   public ParseException generateParseException() {,     jj_expentries.removeAllElements();,     boolean[] la1tokens = new boolean[505];,     for (int i = 0; i < 505; i++) {,       la1tokens[i] = false;,     },     if (jj_kind >= 0) {,       la1tokens[jj_kind] = true;,       jj_kind = -1;,     },     for (int i = 0; i < 375; i++) {,       if (jj_la1[i] == jj_gen) {,         for (int j = 0; j < 32; j++) {,           if ((jj_la1_0[i] & (1<<j)) != 0) {,             la1tokens[j] = true;,           },           if ((jj_la1_1[i] & (1<<j)) != 0) {,             la1tokens[32+j] = true;,           },           if ((jj_la1_2[i] & (1<<j)) != 0) {,             la1tokens[64+j] = true;,           },           if ((jj_la1_3[i] & (1<<j)) != 0) {,             la1tokens[96+j] = true;,           },           if ((jj_la1_4[i] & (1<<j)) != 0) {,             la1tokens[128+j] = true;,           },           if ((jj_la1_5[i] & (1<<j)) != 0) {,             la1tokens[160+j] = true;,           },           if ((jj_la1_6[i] & (1<<j)) != 0) {,             la1tokens[192+j] = true;,           },           if ((jj_la1_7[i] & (1<<j)) != 0) {,             la1tokens[224+j] = true;,           },           if ((jj_la1_8[i] & (1<<j)) != 0) {,             la1tokens[256+j] = true;,           },           if ((jj_la1_9[i] & (1<<j)) != 0) {,             la1tokens[288+j] = true;,           },           if ((jj_la1_10[i] & (1<<j)) != 0) {,             la1tokens[320+j] = true;,           },           if ((jj_la1_11[i] & (1<<j)) != 0) {,             la1tokens[352+j] = true;,           },           if ((jj_la1_12[i] & (1<<j)) != 0) {,             la1tokens[384+j] = true;,           },           if ((jj_la1_13[i] & (1<<j)) != 0) {,             la1tokens[416+j] = true;,           },           if ((jj_la1_14[i] & (1<<j)) != 0) {,             la1tokens[448+j] = true;,           },           if ((jj_la1_15[i] & (1<<j)) != 0) {,             la1tokens[480+j] = true;,           },         },       },     },     for (int i = 0; i < 505; i++) {,       if (la1tokens[i]) {,         jj_expentry = new int[1];,         jj_expentry[0] = i;,         jj_expentries.addElement(jj_expentry);,       },     },     jj_endpos = 0;,     jj_rescan_token();,     jj_add_error_token(0, 0);,     int[][] exptokseq = new int[jj_expentries.size()][];,     for (int i = 0; i < jj_expentries.size(); i++) {,       exptokseq[i] = (int[])jj_expentries.elementAt(i);,     },     return new ParseException(token, exptokseq, SQLParserConstants.tokenImage);,   }, ,   final public void enable_tracing() {,   }, ,   final public void disable_tracing() {,   }, ,   final private void jj_rescan_token() {,     jj_rescan = true;,     for (int i = 0; i < 92; i++) {,     try {,       JJCalls p = jj_2_rtns[i];,       do {,         if (p.gen > jj_gen) {,           jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;,           switch (i) {,             case 0: jj_3_1(); break;,             case 1: jj_3_2(); break;,             case 2: jj_3_3(); break;,             case 3: jj_3_4(); break;,             case 4: jj_3_5(); break;,             case 5: jj_3_6(); break;,             case 6: jj_3_7(); break;,             case 7: jj_3_8(); break;,             case 8: jj_3_9(); break;,             case 9: jj_3_10(); break;,             case 10: jj_3_11(); break;,             case 11: jj_3_12(); break;,             case 12: jj_3_13(); break;,             case 13: jj_3_14(); break;,             case 14: jj_3_15(); break;,             case 15: jj_3_16(); break;,             case 16: jj_3_17(); break;,             case 17: jj_3_18(); break;,             case 18: jj_3_19(); break;,             case 19: jj_3_20(); break;,             case 20: jj_3_21(); break;,             case 21: jj_3_22(); break;,             case 22: jj_3_23(); break;,             case 23: jj_3_24(); break;,             case 24: jj_3_25(); break;,             case 25: jj_3_26(); break;,             case 26: jj_3_27(); break;,             case 27: jj_3_28(); break;,             case 28: jj_3_29(); break;,             case 29: jj_3_30(); break;,             case 30: jj_3_31(); break;,             case 31: jj_3_32(); break;,             case 32: jj_3_33(); break;,             case 33: jj_3_34(); break;,             case 34: jj_3_35(); break;,             case 35: jj_3_36(); break;,             case 36: jj_3_37(); break;,             case 37: jj_3_38(); break;,             case 38: jj_3_39(); break;,             case 39: jj_3_40(); break;,             case 40: jj_3_41(); break;,             case 41: jj_3_42(); break;,             case 42: jj_3_43(); break;,             case 43: jj_3_44(); break;,             case 44: jj_3_45(); break;,             case 45: jj_3_46(); break;,             case 46: jj_3_47(); break;,             case 47: jj_3_48(); break;,             case 48: jj_3_49(); break;,             case 49: jj_3_50(); break;,             case 50: jj_3_51(); break;,             case 51: jj_3_52(); break;,             case 52: jj_3_53(); break;,             case 53: jj_3_54(); break;,             case 54: jj_3_55(); break;,             case 55: jj_3_56(); break;,             case 56: jj_3_57(); break;,             case 57: jj_3_58(); break;,             case 58: jj_3_59(); break;,             case 59: jj_3_60(); break;,             case 60: jj_3_61(); break;,             case 61: jj_3_62(); break;,             case 62: jj_3_63(); break;,             case 63: jj_3_64(); break;,             case 64: jj_3_65(); break;,             case 65: jj_3_66(); break;,             case 66: jj_3_67(); break;,             case 67: jj_3_68(); break;,             case 68: jj_3_69(); break;,             case 69: jj_3_70(); break;,             case 70: jj_3_71(); break;,             case 71: jj_3_72(); break;,             case 72: jj_3_73(); break;,             case 73: jj_3_74(); break;,             case 74: jj_3_75(); break;,             case 75: jj_3_76(); break;,             case 76: jj_3_77(); break;,             case 77: jj_3_78(); break;,             case 78: jj_3_79(); break;,             case 79: jj_3_80(); break;,             case 80: jj_3_81(); break;,             case 81: jj_3_82(); break;,             case 82: jj_3_83(); break;,             case 83: jj_3_84(); break;,             case 84: jj_3_85(); break;,             case 85: jj_3_86(); break;,             case 86: jj_3_87(); break;,             case 87: jj_3_88(); break;,             case 88: jj_3_89(); break;,             case 89: jj_3_90(); break;,             case 90: jj_3_91(); break;,             case 91: jj_3_92(); break;,           },         },         p = p.next;,       } while (p != null);,       } catch(LookaheadSuccess ls) { },     },     jj_rescan = false;,   }, ,   final private void jj_save(int index, int xla) {,     JJCalls p = jj_2_rtns[index];,     while (p.gen > jj_gen) {,       if (p.next == null) { p = p.next = new JJCalls(); break; },       p = p.next;,     },     p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;,   }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_10,1961-1961,[         return jjStopAtPos(0, 35);],,jjMoveStringLiteralDfa0_10,1963-1963,[         return jjStopAtPos(0, 35);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_11,1198-1198,[         return jjStopAtPos(0, 38);],,jjMoveStringLiteralDfa0_11,1200-1200,[         return jjStopAtPos(0, 38);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_12,540-540,[         return jjStopAtPos(0, 41);],,jjMoveStringLiteralDfa0_12,542-542,[         return jjStopAtPos(0, 41);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_13,948-948,[         return jjStopAtPos(0, 44);],,jjMoveStringLiteralDfa0_13,950-950,[         return jjStopAtPos(0, 44);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_14,9045-9045,[         return jjStopAtPos(0, 47);],,jjMoveStringLiteralDfa0_14,9047-9047,[         return jjStopAtPos(0, 47);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_15,823-823,[         return jjStopAtPos(0, 50);],,jjMoveStringLiteralDfa0_15,825-825,[         return jjStopAtPos(0, 50);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_16,303-303,[         return jjStopAtPos(0, 53);],,jjMoveStringLiteralDfa0_16,305-305,[         return jjStopAtPos(0, 53);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_17,142-142,[         return jjStopAtPos(0, 56);],,jjMoveStringLiteralDfa0_17,144-144,[         return jjStopAtPos(0, 56);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_18,8554-8554,[         return jjMoveStringLiteralDfa1_18(0x800000000000000L);],,jjMoveStringLiteralDfa0_18,8558-8558,[         return jjMoveStringLiteralDfa1_18(0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_18,8556-8556,[         return jjStopAtPos(0, 60);],,jjMoveStringLiteralDfa0_18,8560-8560,[         return jjStopAtPos(0, 60);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_3,1316-1319,[         jjmatchedKind = 14;,          jjmatchedPos = 0;,          },          return jjMoveNfa_3(0, 0);],,jjMoveStringLiteralDfa0_3,1322-1325,[         jjmatchedKind = 14;,          jjmatchedPos = 0;,          },          return jjMoveNfa_3(0, 0);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_4,1711-1711,[         return jjStopAtPos(0, 17);],,jjMoveStringLiteralDfa0_4,1713-1713,[         return jjStopAtPos(0, 17);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_5,1586-1586,[         return jjStopAtPos(0, 20);],,jjMoveStringLiteralDfa0_5,1588-1588,[         return jjStopAtPos(0, 20);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_6,665-665,[         return jjStopAtPos(0, 23);],,jjMoveStringLiteralDfa0_6,667-667,[         return jjStopAtPos(0, 23);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_7,1073-1073,[         return jjStopAtPos(0, 26);],,jjMoveStringLiteralDfa0_7,1075-1075,[         return jjStopAtPos(0, 26);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa0_9,9170-9170,[         return jjStopAtPos(0, 32);],,jjMoveStringLiteralDfa0_9,9172-9172,[         return jjStopAtPos(0, 32);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa10_18,8755-8755,[         return jjMoveStringLiteralDfa11_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa10_18,8757-8757,[         return jjMoveStringLiteralDfa11_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa11_18,8775-8775,[         return jjMoveStringLiteralDfa12_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa11_18,8777-8777,[         return jjMoveStringLiteralDfa12_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa12_18,8795-8795,[         return jjMoveStringLiteralDfa13_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa12_18,8797-8797,[         return jjMoveStringLiteralDfa13_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa13_18,8815-8815,[         return jjMoveStringLiteralDfa14_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa13_18,8817-8817,[         return jjMoveStringLiteralDfa14_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa14_18,8835-8835,[         return jjMoveStringLiteralDfa15_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa14_18,8837-8837,[         return jjMoveStringLiteralDfa15_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa15_18,8855-8855,[         return jjMoveStringLiteralDfa16_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa15_18,8857-8857,[         return jjMoveStringLiteralDfa16_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa16_18,8875-8875,[         return jjMoveStringLiteralDfa17_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa16_18,8877-8877,[         return jjMoveStringLiteralDfa17_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa17_18,8895-8895,[         return jjMoveStringLiteralDfa18_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa17_18,8897-8897,[         return jjMoveStringLiteralDfa18_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa18_18,8915-8916,[         if ((active0 & 0x800000000000000L) != 0L),             return jjStopAtPos(18, 59);],,jjMoveStringLiteralDfa18_18,8919-8920,[         if ((active0 & 0x800000000000000L) != 0L),             return jjStopAtPos(18, 59);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa19_0,7436-7436,[         return jjMoveStringLiteralDfa20_0(active5, 0L, active6, 0x100L);],,jjMoveStringLiteralDfa19_0,7445-7445,[         return jjMoveStringLiteralDfa20_0(active5, 0L, active6, 0x100L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa19_0,7438-7441,[         if ((active5 & 0x400000000000L) != 0L),          {,             jjmatchedKind = 366;,             jjmatchedPos = 19;],,jjMoveStringLiteralDfa19_0,7447-7450,[         if ((active5 & 0x400000000000L) != 0L),          {,             jjmatchedKind = 366;,             jjmatchedPos = 19;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa1_18,8575-8575,[         return jjMoveStringLiteralDfa2_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa1_18,8577-8577,[         return jjMoveStringLiteralDfa2_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa20_0,7469-7472,[         if ((active6 & 0x100L) != 0L),          {,             jjmatchedKind = 392;,             jjmatchedPos = 20;],,jjMoveStringLiteralDfa20_0,7476-7479,[         if ((active6 & 0x100L) != 0L),          {,             jjmatchedKind = 392;,             jjmatchedPos = 20;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa2_18,8595-8595,[         return jjMoveStringLiteralDfa3_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa2_18,8597-8597,[         return jjMoveStringLiteralDfa3_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa3_18,8615-8615,[         return jjMoveStringLiteralDfa4_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa3_18,8617-8617,[         return jjMoveStringLiteralDfa4_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa4_18,8635-8635,[         return jjMoveStringLiteralDfa5_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa4_18,8637-8637,[         return jjMoveStringLiteralDfa5_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa5_18,8655-8655,[         return jjMoveStringLiteralDfa6_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa5_18,8657-8657,[         return jjMoveStringLiteralDfa6_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa6_18,8675-8675,[         return jjMoveStringLiteralDfa7_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa6_18,8677-8677,[         return jjMoveStringLiteralDfa7_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa7_18,8695-8695,[         return jjMoveStringLiteralDfa8_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa7_18,8697-8697,[         return jjMoveStringLiteralDfa8_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa8_18,8715-8715,[         return jjMoveStringLiteralDfa9_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa8_18,8717-8717,[         return jjMoveStringLiteralDfa9_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa9_18,8735-8735,[         return jjMoveStringLiteralDfa10_18(active0, 0x800000000000000L);],,jjMoveStringLiteralDfa9_18,8737-8737,[         return jjMoveStringLiteralDfa10_18(active0, 0x800000000000000L);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStopStringLiteralDfa_18,8347-8356,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8358-8367,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8369-8378,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8380-8389,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8391-8400,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8402-8411,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8413-8422,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8424-8433,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8435-8444,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8446-8455,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8457-8466,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8468-8477,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8479-8488,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8490-8499,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8501-8510,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8512-8521,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,jjStopStringLiteralDfa_18,8523-8532,[         if ((active0 & 0x800000000000000L) != 0L),          {,             if (jjmatchedPos == 0),             {,                jjmatchedKind = 62;,                jjmatchedPos = 0;,             },             return -1;,          },          return -1;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa11_0,6829-6829,[   if (((active1 &= old1) | (active2 &= old2) | (active3 &= old3) | (active4 &= old4) | (active5 &= old5) | (active6 &= old6)) == 0L)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa15_0,7269-7269,[   if (((active1 &= old1) | (active3 &= old3) | (active4 &= old4) | (active5 &= old5) | (active6 &= old6)) == 0L)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa17_0,7351-7351,[   if (((active1 &= old1) | (active4 &= old4) | (active5 &= old5) | (active6 &= old6)) == 0L)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa18_0,7390-7390,[   if (((active4 &= old4) | (active5 &= old5) | (active6 &= old6)) == 0L)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa20_0,7460-7460,[   if (((active5 &= old5) | (active6 &= old6)) == 0L)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa2_0,2609-2609,[   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2) | (active3 &= old3) | (active4 &= old4) | (active5 &= old5) | (active6 &= old6) | (active7 &= old7)) == 0L)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveStringLiteralDfa3_0,3053-3053,[   if (((active1 &= old1) | (active2 &= old2) | (active3 &= old3) | (active4 &= old4) | (active5 &= old5) | (active6 &= old6) | (active7 &= old7)) == 0L)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveNfa_19,465-465,[         long l = 1L << (curChar & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveNfa_20,1511-1511,[         long l = 1L << (curChar & 077);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjMoveNfa_8,1892-1892,[         long l = 1L << (curChar & 077);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,CommonTokenAction,71-73,[                t.beginOffset = input_stream.getBeginOffset();,                 t.endOffset = input_stream.getEndOffset();,         }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,MoreLexicalActions,9820-9847,[   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);,    switch(jjmatchedKind),    {,       case 6 :,          if (image == null),             image = new StringBuffer();,          image.append(input_stream.GetSuffix(jjimageLen));,          jjimageLen = 0;,                commentNestingDepth = 1;,          break;,       case 8 :,          if (image == null),             image = new StringBuffer();,          image.append(input_stream.GetSuffix(jjimageLen));,          jjimageLen = 0;,                commentNestingDepth++;,          break;,       case 9 :,          if (image == null),             image = new StringBuffer();,          image.append(input_stream.GetSuffix(jjimageLen));,          jjimageLen = 0;,           commentNestingDepth--; SwitchTo(commentNestingDepth == 0 ? IN_BRACKETED_COMMENT : IN_NESTED_BRACKETED_COMMENT);,          break;,       default : ,          break;,    }, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,ReInit,9538-9542,[   jjmatchedPos = jjnewStateCnt = 0;,    curLexState = defaultLexState;,    input_stream = stream;,    ReInitRounds();, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,ReInit,9552-9554,[   ReInit(stream);,    SwitchTo(lexState);, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,ReInitRounds,9546-9549,[   jjround = 0x80000001;,    for (i = 137; i-- > 0;),       jjrounds[i] = 0x80000000;, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,SkipLexicalActions,9812-9817,[   switch(jjmatchedKind),    {,       default :,          break;,    }, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,SwitchTo,9557-9561,[   if (lexState >= 21 || lexState < 0),       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);,    else,       curLexState = lexState;, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,TokenLexicalActions,9850-9861,[   switch(jjmatchedKind),    {,       case 60 :,         if (image == null),             image = new StringBuffer();,             image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));,       matchedToken.kind = DERBYDASHPROPERTIES;,          break;,       default : ,          break;,    }, }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,getNextToken,9621-9752,[     switch(curLexState),      {,        case 0:,          jjmatchedKind = 0x7fffffff;,          jjmatchedPos = 0;,          curPos = jjMoveStringLiteralDfa0_0();,          break;,        case 1:,          jjmatchedKind = 0x7fffffff;,          jjmatchedPos = 0;,          curPos = jjMoveStringLiteralDfa0_1();,          if (jjmatchedPos == 0 && jjmatchedKind > 10),          {,             jjmatchedKind = 10;,          },          break;,        case 2:,          jjmatchedKind = 0x7fffffff;,          jjmatchedPos = 0;,          curPos = jjMoveStringLiteralDfa0_2();,          if (jjmatchedPos == 0 && jjmatchedKind > 10),          {,             jjmatchedKind = 10;,          },          break;,        case 3:,          jjmatchedKind = 15;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_3();,          break;,        case 4:,          jjmatchedKind = 18;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_4();,          break;,        case 5:,          jjmatchedKind = 21;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_5();,          break;,        case 6:,          jjmatchedKind = 24;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_6();,          break;,        case 7:,          jjmatchedKind = 27;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_7();,          break;,        case 8:,          jjmatchedKind = 30;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_8();,          break;,        case 9:,          jjmatchedKind = 33;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_9();,          break;,        case 10:,          jjmatchedKind = 36;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_10();,          break;,        case 11:,          jjmatchedKind = 39;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_11();,          break;,        case 12:,          jjmatchedKind = 42;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_12();,          break;,        case 13:,          jjmatchedKind = 45;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_13();,          break;,        case 14:,          jjmatchedKind = 48;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_14();,          break;,        case 15:,          jjmatchedKind = 51;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_15();,          break;,        case 16:,          jjmatchedKind = 54;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_16();,          break;,        case 17:,          jjmatchedKind = 57;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_17();,          break;,        case 18:,          jjmatchedKind = 61;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_18();,          break;,        case 19:,          jjmatchedKind = 63;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_19();,          break;,        case 20:,          jjmatchedKind = 64;,          jjmatchedPos = -1;,          curPos = 0;,          curPos = jjMoveStringLiteralDfa0_20();],,
STYLE,UC_USELESS_VOID_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,SkipLexicalActions,9817-9817,[}],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjCheckNAddStates,176-178,[   jjCheckNAdd(jjnextStates[start]);,    jjCheckNAdd(jjnextStates[start + 1]);, }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_10,1950-1954,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_10(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_11,1187-1191,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_11(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_12,529-533,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_12(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_13,937-941,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_13(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_14,9034-9038,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_14(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_15,812-816,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_15(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_16,292-296,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_16(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_17,131-135,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_17(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_18,8543-8547,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_18(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_4,1700-1704,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_4(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_5,1575-1579,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_5(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_6,654-658,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_6(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_7,1062-1066,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_7(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_8,1825-1829,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_8(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfaWithStates_9,9159-9163,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { return pos + 1; },    return jjMoveNfa_9(state, pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_10,1946-1946,[   return jjMoveNfa_10(jjStopStringLiteralDfa_10(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_11,1183-1183,[   return jjMoveNfa_11(jjStopStringLiteralDfa_11(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_12,525-525,[   return jjMoveNfa_12(jjStopStringLiteralDfa_12(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_13,933-933,[   return jjMoveNfa_13(jjStopStringLiteralDfa_13(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_14,9030-9030,[   return jjMoveNfa_14(jjStopStringLiteralDfa_14(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_15,808-808,[   return jjMoveNfa_15(jjStopStringLiteralDfa_15(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_16,288-288,[   return jjMoveNfa_16(jjStopStringLiteralDfa_16(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_17,127-127,[   return jjMoveNfa_17(jjStopStringLiteralDfa_17(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_4,1696-1696,[   return jjMoveNfa_4(jjStopStringLiteralDfa_4(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_5,1571-1571,[   return jjMoveNfa_5(jjStopStringLiteralDfa_5(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_6,650-650,[   return jjMoveNfa_6(jjStopStringLiteralDfa_6(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_7,1058-1058,[   return jjMoveNfa_7(jjStopStringLiteralDfa_7(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_8,1821-1821,[   return jjMoveNfa_8(jjStopStringLiteralDfa_8(pos, active0), pos + 1);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,jjStartNfa_9,9155-9155,[   return jjMoveNfa_9(jjStopStringLiteralDfa_9(pos, active0), pos + 1);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,,9820-9820,[   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,,77-77,[  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/ScrollInsensitiveResultSetNode.java,generate,82-82,[		int erdNumber = acb.addItem(makeResultDescription());],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/sql/compile/SelectNode.java,bindExpressions,526-526,[		int fromListSize = fromList.size();],,bindExpressions,530-530,[            SanityManager.ASSERT(fromList != null && getResultColumns() != null,],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/compile/SpecialFunctionNode.java,bindExpression,142-150,[            switch (kind) {,                 case K_USER:,                     sqlName = "USER";,                     break;,                 case K_CURRENT_USER:,                     sqlName = "CURRENT_USER";,                     break;,                 case K_SYSTEM_USER:,                     sqlName = "SYSTEM_USER";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/SpecialFunctionNode.java,generateExpression,262-262,[		if (methodName.equals("getCurrentRoleIdDelimited") ||],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/SpecialFunctionNode.java,isEquivalent,306-306,[			return methodName.equals(other.methodName);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/compile/StaticClassFieldReferenceNode.java,,76-76,[        this.classNameDelimitedIdentifier = classNameDelimitedIdentifier;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/StaticClassFieldReferenceNode.java,generateExpression,232-232,[		mb.getStaticField(field.getDeclaringClass().getName(),],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/sql/compile/StaticMethodCallNode.java,optimizeDomainValueConversion,488-488,[		int		count = methodParms.length;],,optimizeDomainValueConversion,495-495,[            if ( (methodParms != null) && methodParms[ parm ].mustCastToPrimitive() ) { continue; }],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/derby/impl/sql/compile/SubqueryNode.java,pushNewPredicate,1471-1471,[		ucoNode.bindComparisonOperator();],,pushNewPredicate,1335-1335,[		UnaryComparisonOperatorNode	ucoNode = null;],,pushNewPredicate,1468-1468,[                    SanityManager.NOTREACHED();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/compile/TableElementList.java,genConstraintActions,997-997,[			ConstraintDefinitionNode constraintDN = (ConstraintDefinitionNode) ten;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/compile/TableElementList.java,validate,233-233,[			ConstraintDefinitionNode cdn = (ConstraintDefinitionNode) tableElement;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/compile/TableElementList.java,validatePrimaryKeyNullability,360-360,[			ConstraintDefinitionNode cdn = (ConstraintDefinitionNode) tableElement;],,
CORRECTNESS,IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN,org/apache/derby/impl/sql/compile/TableOperatorNode.java,optimizeSource,853-853,[			optimizer = optimizerFactory.getOptimizer(optList,],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,,71-71,[                t.beginOffset = input_stream.getBeginOffset();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,,9574-9574,[      t.beginColumn = t.endColumn = input_stream.getBeginColumn();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,,9573-9573,[      t.beginLine = t.endLine = input_stream.getBeginLine();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/compile/SQLParserTokenManager.java,,72-72,[                t.endOffset = input_stream.getEndOffset();],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/compile/ParseException.java,,137-137,[    Token tok = currentToken.next;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/TokenMgrError.java,LexicalError,119-123,[      return("Lexical error at line " +,            errorLine + ", column " +,            errorColumn + ".  Encountered: " +,            (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +,            "after : \"" + addEscapes(errorAfter) + "\"");],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/TypeCompilerFactoryImpl.java,staticGetTypeCompiler,143-143,[                          sqlTypeName = typeId.getSQLTypeName();],,staticGetTypeCompiler,93-93,[                          sqlTypeName = typeId.getSQLTypeName();],,staticGetTypeCompiler,190-190,[                          sqlTypeName = typeId.getSQLTypeName();],,staticGetTypeCompiler,137-137,[                      sqlTypeName = typeId.getSQLTypeName();],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/sql/compile/UCode_CharStream.java,<init>,370-370,[     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/sql/compile/UCode_CharStream.java,ReInit,382-382,[     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,BeginToken,167-178,[	 if (inBuf > 0), 	 {, 		--inBuf;, 		return buffer[tokenBegin = (bufpos == bufsize - 1) ? (bufpos = 0), 															: ++bufpos];, 	 }, ,      tokenBegin = 0;, 	 bufpos = -1;,      char c = readChar();, ,      return c;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,Done,417-425,[     nextCharBuf = null;,      buffer = null;,      bufline = null;,      bufcolumn = null;, , 	// The next line was added to support ability to get the input, 	// between two tokens., 	 charOffset = null;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,ExpandBuff,63-122,[     char[] newbuffer = new char[bufsize + 2048];,      int newbufline[] = new int[bufsize + 2048];,      int newbufcolumn[] = new int[bufsize + 2048];, , 	// The next line was added to support ability to get the input, 	// between two tokens., 	int newcharOffset[] = new int[bufsize + 2048];, ,      try,      {,         if (wrapAround),         {,            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);,            System.arraycopy(buffer, 0, newbuffer,,                                              bufsize - tokenBegin, bufpos);,            buffer = newbuffer;, ,            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);,            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);,            bufline = newbufline;, ,            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);,            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);,            bufcolumn = newbufcolumn;, , 			// The next three lines were added to support ability to get input, 			// between two tokens., 		   System.arraycopy(charOffset, tokenBegin, newcharOffset, 0, bufsize - tokenBegin);, 		   System.arraycopy(charOffset, 0, newcharOffset, bufsize - tokenBegin, bufpos);, 		   charOffset = newcharOffset;, ,            bufpos += (bufsize - tokenBegin);,         },         else,         {,            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);,            buffer = newbuffer;, ,            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);,            bufline = newbufline;, ,            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);,            bufcolumn = newbufcolumn;, , 			// The next two lines were added to support ability to get input, 			// between two tokens., 		   System.arraycopy(charOffset, tokenBegin, newcharOffset, 0, bufsize - tokenBegin);, 		   charOffset = newcharOffset;, ,            bufpos -= tokenBegin;,         },      },      catch (Throwable t),      {,         throw new Error(t.getMessage());,      }, ,      available = (bufsize += 2048);,      tokenBegin = 0;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,FillBuff,126-155,[     if (maxNextCharInd == nextCharBuf.length),         maxNextCharInd = nextCharInd = 0;, ,      int i;,      try {,         if ((i = inputStream.read(nextCharBuf, maxNextCharInd,,                                   nextCharBuf.length - maxNextCharInd)) == -1),         {,            inputStream.close();,            throw new java.io.IOException();,         },         else,            maxNextCharInd += i;,      },      catch(java.io.IOException e) {,         if (bufpos != 0),         {,            --bufpos;,            backup(0);,         },         else,         {,            bufline[bufpos] = line;,            bufcolumn[bufpos] = column;,         },         if (tokenBegin == -1),            tokenBegin = bufpos;,         throw e;,      },   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,GetImage,392-395,[     if (bufpos >= tokenBegin),         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);,      else,         return new String(buffer, tokenBegin, bufsize - tokenBegin) +],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,GetSuffix,401-412,[     char[] ret = new char[len];, ,      if ((bufpos + 1) >= len),         System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);,      else,      {,         System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,,                                                           len - bufpos - 1);,         System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);,      }, ,      return ret;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,ReInit,387-388,[     ReInit(dstream, startline, startcolumn, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,ReInit,382-383,[     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,ReInit,365-366,[     ReInit(dstream, startline, startcolumn, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,ReInit,343-360,[    inputStream = dstream;,     line = startline;,     column = startcolumn - 1;, ,     if (buffer == null || buffersize != buffer.length),     {,       available = bufsize = buffersize;,       buffer = new char[buffersize];,       nextCharBuf = new char[buffersize];,       bufline = new int[buffersize];,       bufcolumn = new int[buffersize];,     }, , 	// The next line was added to support ability to get the input, 	// between two tokens., 	inBuf = maxNextCharInd = charCnt = tokenBegin = 0;, 	nextCharInd = bufpos = -1;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,ReadChar,159-162,[     if (++nextCharInd >= maxNextCharInd),         FillBuff();, , 	 return nextCharBuf[nextCharInd];],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/sql/compile/UCode_CharStream.java,UpdateLineColumn,183-219,[     column++;, ,      if (prevCharIsLF),      {,         prevCharIsLF = false;,         line += (column = 1);,      },      else if (prevCharIsCR),      {,         prevCharIsCR = false;,         if (c == '\n'),         {,            prevCharIsLF = true;,         },         else,            line += (column = 1);,      }, ,      switch (c),      {,         case '\r' :,            prevCharIsCR = true;,            break;,         case '\n' :,            prevCharIsLF = true;,            break;,         case '\t' :,            column--;,            column += (8 - (column & 07));,            break;,         default :,            break;,      }, , 	 bufline[bufpos] = line;, 	 bufcolumn[bufpos] = column;,   }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/compile/UpdateNode.java,addGeneratedColumns,1458-1458,[            int mentionedColumnCount = mentionedColumnNames.length;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/UpdateNode.java,makeConstantAction,863-863,[											getTrulyTheBestAccessPath().],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/UpdateNode.java,setDeferredForUpdateOfIndexColumn,952-952,[											getTrulyTheBestAccessPath().],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/compile/UserDefinedTypeCompiler.java,convertible,53-53,[            UserDefinedTypeIdImpl thisTypeID = (UserDefinedTypeIdImpl) getTypeId().getBaseTypeId();],,convertible,54-54,[            UserDefinedTypeIdImpl thatTypeID = (UserDefinedTypeIdImpl) otherType.getBaseTypeId();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/sql/compile/UserDefinedTypeCompiler.java,storable,90-90,[        UserDefinedTypeIdImpl thisTypeID = (UserDefinedTypeIdImpl) getTypeId().getBaseTypeId();],,storable,91-91,[        UserDefinedTypeIdImpl thatTypeID = (UserDefinedTypeIdImpl) otherType.getBaseTypeId();],,
STYLE,UC_USELESS_OBJECT,org/apache/derby/impl/sql/compile/XMLOptTrace.java,formatPlanSummary,717-717,[            StringBuilder   buffer = new StringBuilder();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/compile/XMLOptTrace.java,,195-195,[            this.queryBlockID = queryBlockID;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/compile/XMLOptTrace.java,traceConsideringConglomerate,427-427,[            ( DECORATION_JOIN_STRATEGY, _currentQueryBlock.currentDecorationStrategy.getName() );],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/conn/CachedStatement.java,clearIdentity,90-90,[			SanityManager.DEBUG("StatementCacheInfo","CLEARING IDENTITY: "+ps.getSource());],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java,compareConstraintModes,3795-3795,[        DataDictionary dd = getDataDictionary();],,
PERFORMANCE,DM_GC,org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java,verifyAllHeldResultSetsAreClosed,2044-2044,[        System.gc();],,
PERFORMANCE,DM_GC,org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java,verifyNoOpenResultSets,2136-2136,[        System.gc();],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java,autoincrementFlushCache,3457-3457,[                autoincrementCacheHashtable.get(key);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/conn/GenericLanguageConnectionFactory.java,validate,353-353,[			String value_s = (String)value;],,validate,365-365,[			String value_s = (String)value;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/conn/GenericLanguageConnectionFactory.java,validate,354-354,[			if (value_s != null &&],,
STYLE,DB_DUPLICATE_BRANCHES,org/apache/derby/impl/sql/depend/BasicDependencyManager.java,addInMemoryDependency,178-178,[            addedToProvs = addDependencyToTable(providers, p.getObjectID(), dy);],,addInMemoryDependency,180-180,[            addedToProvs = addDependencyToTable(providers, p.getObjectID(), dy);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/depend/BasicDependencyManager.java,dropDependency,242-252,[			if (! d.isPersistent() || ! p.isPersistent()), 			{, 				SanityManager.NOTREACHED();, 			}, 		}, , 		DependencyDescriptor dependencyDescriptor = new DependencyDescriptor(d, p);, , 		dd.dropStoredDependency( dependencyDescriptor, , 								 lcc.getTransactionExecute() );, 	}],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/AggregateSortObserver.java,insertDuplicateKey,161-161,[			return null;],,insertDuplicateKey,181-181,[		return null;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/AlterConstraintConstantAction.java,executeConstantAction,105-105,[        final DependencyManager dm = dd.getDependencyManager();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/AlterTableConstantAction.java,dropColumnFromTable,1384-1384,[		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/AlterTableConstantAction.java,compressIndexArrays,3676-3676,[			return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/AlterTableConstantAction.java,getNextRowFromRowSource,3162-3162,[		return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/impl/sql/execute/AlterTableConstantAction.java,getNextRowFromRowSource,3127-3127,[				if (currentRow == null)],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/sql/execute/AlterTableConstantAction.java,executeConstantActionBody,323-323,[                    vis.get(td.getHeapConglomerateId());],,executeConstantActionBody,325-325,[            if (td == null) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/AlterTableConstantAction.java,,243-243,[		this.tableType              = tableType;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/AlterTableConstantAction.java,objectifyStreamingColumns,3230-3230,[		for (int i = 0; i < currentRow.getRowArray().length; i++)],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/sql/execute/AlterTableConstantAction.java,,432-432,[			sd = getAndCheckSchemaDescriptor(dd, schemaId, "ALTER TABLE");],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derby/impl/sql/execute/AnyResultSet.java,cleanUp,48-48,[public class AnyResultSet extends NoPutResultSetImpl],,cleanup,236-272,[		lcc.popTriggerExecutionContext(this);, , 		/*, 		** Explicitly close all result sets that we have, 		** given out to the user.  , 	 	*/, 		for (Enumeration<java.sql.ResultSet> e = resultSetVector.elements();, 			 e.hasMoreElements(); ), 		{, 			java.sql.ResultSet rs = e.nextElement();, 			try, 			{, 				rs.close();, 			} catch (SQLException se) {}, 		}, 		resultSetVector = null;, 	, 		/*, 		** We should have already closed our underlying, 		** ExecResultSets by closing the jdbc result sets,, 		** but in case we got an error that we caught and, 		** ignored, explicitly close them., 		*/	, 		if (afterResultSet != null), 		{, 			afterResultSet.close();, 			afterResultSet = null;, 		}, 		if (beforeResultSet != null), 		{, 			beforeResultSet.close();, 			beforeResultSet = null;, 		}, , 		lcc = null;, 		cleanupCalled = true;, 	}],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/AutoincrementCounter.java,getCurrentValue,177-177,[		return new Long(counter);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/AutoincrementCounter.java,,83-83,[		this.schemaName = s;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/AutoincrementCounter.java,,84-84,[		this.tableName = t;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/execute/AvgAggregator.java,merge,130-130,[		AvgAggregator otherAvg = (AvgAggregator) addend;],,
STYLE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/BaseActivation.java,getColumnFromRow,1474-1474,[        if (row[rsNumber] == null) {],,
STYLE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/BaseActivation.java,getCurrentRow,1407-1407,[        return row[resultSetNumber];],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/BaseActivation.java,,1365-1365,[			if (row != null)],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/BaseActivation.java,,557-557,[		return numSubqueries;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/derby/impl/sql/execute/BasicNoPutResultSetImpl.java,,1178-1180,[    public  static  final   class   FieldComparator implements Comparator<Field>,     {,         public  int compare( Field left, Field right ) { return left.getName().compareTo( right.getName() ); }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/sql/execute/BulkTableScanResultSet.java,,79-466,[	private static int OUT_OF_ROWS = 0;, ,     /**,  	 * Constructor.  Just save off the rowsPerRead argument, 	 * and pass everything else down to TableScanResultSet, 	 * , 	 * @see org.apache.derby.iapi.sql.execute.ResultSetFactory#getBulkTableScanResultSet, 	 *, 	 * @exception StandardException thrown on failure to open, 	 */,     BulkTableScanResultSet(long conglomId,, 		StaticCompiledOpenConglomInfo scoci, Activation activation, , 		int resultRowTemplate,, 		int resultSetNumber,, 		GeneratedMethod startKeyGetter, int startSearchOperator,, 		GeneratedMethod stopKeyGetter, int stopSearchOperator,, 		boolean sameStartStopPosition,, 		Qualifier[][] qualifiers,, 		String tableName,, 		String userSuppliedOptimizerOverrides,, 		String indexName,, 		boolean isConstraint,, 		boolean forUpdate,, 		int colRefItem,, 		int indexColItem,, 		int lockMode,, 		boolean tableLocked,, 		int isolationLevel,, 		int rowsPerRead,,         boolean disableForHoldable,, 		boolean oneRowScan,, 		double optimizerEstimatedRowCount,, 		double optimizerEstimatedCost), 			throws StandardException,     {, 		super(conglomId,, 			scoci,, 			activation,, 			resultRowTemplate,, 			resultSetNumber,, 			startKeyGetter,, 			startSearchOperator,, 			stopKeyGetter,, 			stopSearchOperator,, 			sameStartStopPosition,, 			qualifiers,, 			tableName,, 			userSuppliedOptimizerOverrides,, 			indexName,, 			isConstraint,, 			forUpdate,, 			colRefItem,, 			indexColItem,, 			lockMode,, 			tableLocked,, 			isolationLevel,,             adjustBulkFetchSize(activation, rowsPerRead, disableForHoldable),, 			oneRowScan,, 			optimizerEstimatedRowCount,, 			optimizerEstimatedCost);, , 		if (SanityManager.DEBUG), 		{, 			/* Bulk fetch of size 1 is same as a regular table scan, 			 * and is supposed to be detected at compile time., 			 */, 			if (rowsPerRead == 1), 			{, 				SanityManager.THROWASSERT(, 					"rowsPerRead not expected to be 1");, 			}, 			/* Bulk table scan implies that scan is not, 			 * a 1 row scan., 			 */, 			if (oneRowScan), 			{, 				SanityManager.THROWASSERT(, 					"oneRowScan expected to be false - " +, 					"rowsPerRead = " + rowsPerRead);, 			}, 		}, ,         // determine whether we should fetch row locations,         setRowLocationsState();, ,         //,         // The following code block was introduced to support the driving left join,         // of the MERGE statement. If we are executing a MERGE statement, we need,         // to fetch the row location of every row in the target table. If we are in this,         // situation, then the last column in the candidate row will be a RowLocation template,         // and the highest bit in accessedCols will be set. We want to smudge out this,         // information before we ask the Store for rows. The Store will be confused if we ask,         // for the RowLocation in the same row array as the actual base columns.,         //,         if ( fetchRowLocations ),         {,             resultColumnCount = accessedCols == null ? candidate.nColumns() : accessedCols.getNumBitsSet();,             baseColumnCount = candidate.nColumns() - 1;,             candidate.setRowArray( lopOffRowLocation() );, ,             // remove the RowLocation from the accessed column map,             if ( accessedCols == null ),             {,                 accessedCols = new FormatableBitSet( baseColumnCount );,                 for ( int i = 0; i < baseColumnCount; i++ ) { accessedCols.set( i ); },             },             else,             {,                 FormatableBitSet    newCols = new FormatableBitSet( baseColumnCount );,                 for ( int i = 0; i < baseColumnCount; i++ ),                 {,                     if ( accessedCols.isSet( i ) ) { newCols.set( i ); },                 },                 accessedCols = newCols;,             },         },     }, ,     /**,      * Adjust the bulk fetch size according to the parameters. Bulk fetch may,      * be disabled by returning 1 from this method. Disabling of bulk fetch,      * may happen if the cursor is holdable and it contains LOB columns,      * (DERBY-1511) because,      *,      * @param activation the activation for the executing statement,      * @param rowsPerRead how many rows to read in each chunk if a bulk fetch,      * is OK to use,      * @param disableForHoldable whether or not bulk fetch should be disabled,      * for holdable cursors,      * @return the bulk fetch size to use,      */,     private static int adjustBulkFetchSize(,             Activation activation, int rowsPerRead, boolean disableForHoldable),     {,         if (disableForHoldable && activation.getResultSetHoldability()) {,             // We have a holdable cursor, and we've been requested to disable,             // bulk fetch if the cursor is holdable, so change bulk size to 1.,             return 1;,         } else {,             return rowsPerRead;,         },     }, ,     /**,  	 * Open the scan controller, 	 *, 	 * @param tc transaction controller will open one if null,      *, 	 * @exception StandardException thrown on failure to open, 	 */, 	protected void openScanController(TransactionController tc), 		throws StandardException, 	{, 		DataValueDescriptor[] startPositionRow = startPosition == null ? null : startPosition.getRowArray();, 		DataValueDescriptor[] stopPositionRow = stopPosition == null ? null : stopPosition.getRowArray();, , 		// Clear the Qualifiers's Orderable cache , 		if (qualifiers != null), 		{, 			clearOrderableCache(qualifiers);, 		}, , 		// Get the current transaction controller, 		if (tc == null), 			tc = activation.getTransactionController();, 		scanController = tc.openCompiledScan(, 				activation.getResultSetHoldability(),, 				(forUpdate ? TransactionController.OPENMODE_FORUPDATE : 0),,                 lockMode,,                 isolationLevel,, 				accessedCols,, 				startPositionRow,, 					// not used when giving null start position, 				startSearchOperator,, 				qualifiers,, 				stopPositionRow,, 					// not used when giving null stop position, 				stopSearchOperator,, 				scoci,, 				dcoci);, , 		/* Remember that we opened the scan */, 		scanControllerOpened = true;, , 		rowsThisScan = 0;, , 		/*, 		** Inform the activation of the estimated number of rows.  Only, 		** do it here, not in reopen, so that we don't do this costly, 		** check too often., 		*/, 		activation.informOfRowCount(, 									this,, 									scanController.getEstimatedRowCount(), 									);, 	}, , 	/**, 	 * Open up the result set.  Delegate, 	 * most work to TableScanResultSet.openCore()., 	 * Create a new array with <rowsPerRead> rows, 	 * for use in fetchNextGroup()., 	 *, 	 * @exception StandardException thrown on failure to open, 	 */, 	public void openCore() throws StandardException, 	{, 		super.openCore();, 		/*, 		** Add the extra time we spent after, 		** the super class -- TableScanResultSet(), 		** already added up its time in openCore()., 		*/, 		beginTime = getCurrentTimeMillis();, 		rowArray = new DataValueDescriptor[rowsPerRead][];,         if ( fetchRowLocations ) { rowLocations = new RowLocation[ rowsPerRead ]; }, , 		// we only allocate the first row -- the, 		// store clones as needed for the rest, 		// of the rows, 		rowArray[0] = candidate.getRowArrayClone();, 		numRowsInArray = 0;, 		curRowPosition = -1;, 		, 		openTime += getElapsedMillis(beginTime);, 	}, ,     /**,      * Get a blank row by cloning the candidate row and lopping off,      * the trailing RowLocation column for scans done on,      * behalf of MERGE statements.,      */,     private DataValueDescriptor[]   lopOffRowLocation(),         throws StandardException,     {,         DataValueDescriptor[]   temp = candidate.getRowArrayClone();, ,         int     count = temp.length - 1;,         DataValueDescriptor[]   result = new DataValueDescriptor[ count ] ;,         for ( int i = 0; i < count; i++ ) { result[ i ] = temp[ i ]; }, ,         return result;,     }, , 	/**, 	 * Reopen the result set.  Delegate, 	 * most work to TableScanResultSet.reopenCore()., 	 * Reuse the array of rows., 	 *, 	 * @exception StandardException thrown on failure to open, 	 */, 	public void reopenCore() throws StandardException, 	{, 		super.reopenCore();, 		numRowsInArray = 0;, 		curRowPosition = -1;, 	}, 		, 	/**, 	 * Return the next row (if any) from the scan (if open)., 	 * Reload the rowArray as necessary., 	 *, 	 * @exception StandardException thrown on failure to get next row, 	 */, 	public ExecRow getNextRowCore() throws StandardException, 	{, 		if( isXplainOnlyMode() ), 			return null;, , 	    ExecRow result = null;,             ,         checkCancellationFlag();, , 		beginTime = getCurrentTimeMillis();, 		if (isOpen && scanControllerOpened), 		{, 			if (currentRow == null), 			{, 				currentRow =, 					getCompactRow(candidate,, 									accessedCols,, 									isKeyed);, 			}, , outer:		for (;;), 			{, 				if (curRowPosition >= numRowsInArray - 1), 				{, 					if (reloadArray() == OUT_OF_ROWS), 					{, 						clearCurrentRow();, 						setRowCountIfPossible(rowsThisScan);, 						return null;, 					}, 				}	, , 				while (++curRowPosition < numRowsInArray), 				{, 					candidate.setRowArray(rowArray[curRowPosition]);, 					currentRow = setCompactRow(candidate, currentRow);, 					rowsSeen++;, 					rowsThisScan++;, , 					/*, 					** Skip rows where there are start or stop positioners, 					** that do not implement ordered null semantics and, 					** there are columns in those positions that contain, 					** null., 					*/, 					if (skipRow(candidate)), 					{, 						rowsFiltered++;, 						continue;, 					}, , 					result = currentRow;,                     if ( fetchRowLocations ),                     {,                         result = new ValueRow( resultColumnCount );,                         int     idx = 1;, ,                         for ( ; idx < resultColumnCount; idx++ ),                         {,                             result.setColumn( idx, currentRow.getColumn( idx ) );,                         },                         result.setColumn( idx, rowLocations[ curRowPosition ] );,                     }, 					break outer;, 				}, 			}, 		}, , 		setCurrentRow(result);, 		nextTime += getElapsedMillis(beginTime);, 	    return result;, 	}, , 	/*, 	** Load up rowArray with a batch of, 	** rows., 	*/, 	private int reloadArray() throws StandardException, 	{, 		curRowPosition = -1;, 		numRowsInArray =, 				((GroupFetchScanController) scanController).fetchNextGroup(,                                                rowArray, rowLocations);, , 		return numRowsInArray;, 	}, , 	/**, 	 * If the result set has been opened,, 	 * close the open scan.  Delegate most, 	 * of the work to TableScanResultSet., 	 *, 	 * @exception StandardException on error, 	 */, 	public void	close() throws StandardException, 	{, 		/*, 		** We'll let TableScanResultSet track, 		** the time it takes to close up, so, 		** no timing here., 		*/, 		super.close();, 		numRowsInArray = -1;, 		curRowPosition = -1;, 		rowArray = null;,         rowLocations = null;, 	}, , 	/**, 	 * Can we get instantaneous locks when getting share row, 	 * locks at READ COMMITTED., 	 */, 	protected boolean canGetInstantaneousLocks(), 	{, 		return !forUpdate;, 	}, , 	/**, 	 * @see NoPutResultSet#requiresRelocking, 	 */, 	public boolean requiresRelocking(), 	{, 		// IndexRowToBaseRow needs to relock if we didn't keep the lock, 		return(],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/apache/derby/impl/sql/execute/CardinalityCounter.java,keepCount,148-148,[				prevKey = clone(currentKey);],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/derby/impl/sql/execute/CreateConstraintConstantAction.java,toString,569-569,[				strbuf.append("\n\tcol["+ix+"]"+columnNames[ix].toString());],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/sql/execute/CreateConstraintConstantAction.java,executeConstantAction,298-298,[                if (constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT ||],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java,executeConstantAction,816-816,[                        (cd != null && cd.getUUID() != null && td != null))],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/sql/execute/CreateIndexConstantAction.java,executeConstantAction,636-636,[				if (uniqueWithDuplicateNulls) ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/CreateTableConstantAction.java,executeConstantAction,160-160,[		DependencyManager dm = dd.getDependencyManager();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/impl/sql/execute/CurrentDatetime.java,getCurrentDate,84-84,[		return currentDate;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/impl/sql/execute/CurrentDatetime.java,getCurrentTimestamp,100-100,[		return currentTimestamp;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/execute/CurrentOfResultSet.java,getNextRowCore,149-149,[					if (scan.indexCols != null && currentRow != null)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/execute/CurrentOfResultSet.java,getNextRowCore,130-130,[				if (rowLocation == null  || ],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/DMLVTIResultSet.java,,69-69,[        tc = activation.getTransactionController();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/execute/DeferredConstraintsMemory.java,makeDeferredCheck,289-295,[        final int[] keyCols = new int[cols];, ,         for (int i = 0; i < cols; i++) {,             keyCols[i] = i;,         }, ,         return new BackingStoreHashtable(],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/DeleteCascadeResultSet.java,<init>,82-82,[			passedInConstantAction = activation.getConstantAction(); //root table],,<init>,86-86,[				(ConstantAction) activation.getPreparedStatement().getSavedObject(constantActionItem);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/DeleteResultSet.java,,273-273,[		numIndexes = constants.irgs.length;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/DependentResultSet.java,printPosition,679-679,[					output = output +  "\n";],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/DependentResultSet.java,,154-154,[		this.conglomId = conglomId;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/DependentResultSet.java,,86-86,[	protected boolean		firstScan = true;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/DependentResultSet.java,,180-180,[		this.oneRowScan = oneRowScan;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/DependentResultSet.java,,173-173,[		this.qualifiers = qualifiers;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/DependentResultSet.java,,171-171,[		this.startSearchOperator = startSearchOperator;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/DependentResultSet.java,,172-172,[		this.stopSearchOperator = stopSearchOperator;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/DependentResultSet.java,,175-175,[		this.userSuppliedOptimizerOverrides = userSuppliedOptimizerOverrides;],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/sql/execute/DependentResultSet.java,,493-493,[		if(isOpen)],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/DependentResultSet.java,,314-314,[			currentRow =],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/DistinctScalarAggregateResultSet.java,loadSorter,400-400,[		inputRowCountEstimate = rowsInput;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/DistinctScalarAggregateResultSet.java,,150-150,[		sorted = true;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/DropSequenceConstantAction.java,executeConstantAction,82-82,[        TransactionController tc = lcc.getTransactionExecute();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/DropTableConstantAction.java,dropAllConstraintDescriptors,291-291,[		TransactionController tc = lcc.getTransactionExecute();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/sql/execute/GenericAggregator.java,getAggregatorInstance,318-318,[			} catch (Exception e)],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/GenericRIChecker.java,getScanController,128-128,[		Long			hashKey = new Long(conglomNumber);],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derby/impl/sql/execute/GrantRoleConstantAction.java,,52-52,[    private final boolean withAdminOption = false; // not impl.],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/sql/execute/GrantRoleConstantAction.java,executeConstantAction,141-141,[                if (rgd != null &&],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/execute/GroupedAggregateResultSet.java,dumpAllRows,812-815,[            System.out.println("dumpAllRows("+cR+"/"+resultRows.length+"):");,             for (int r = 0; r < resultRows.length; r++),                 System.out.println(dumpRow(resultRows[r]));,         }],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/sql/execute/GroupedAggregateResultSet.java,,302-302,[				sortTemplateRow.getRowArray(),],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/sql/execute/HashScanResultSet.java,openCore,284-284,[				hashtableSize = hashtable.size();],,openCore,293-293,[					if (hashtable != null)],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/HashScanResultSet.java,printPosition,749-749,[				output = output +  "\n";],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/HashScanResultSet.java,,145-145,[        this.scoci = scoci;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/HashScanResultSet.java,,168-168,[        this.userSuppliedOptimizerOverrides = userSuppliedOptimizerOverrides;],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/derby/impl/sql/execute/HashTableResultSet.java,getNextRowCore,373-373,[                           if (! (columns[i] instanceof Storable))],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/HashTableResultSet.java,getNextRowFromRowSource,721-721,[		return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/execute/HashTableResultSet.java,openCore,228-228,[					if (ht != null)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/IndexChanger.java,setScan,255-255,[			RowLocation templateBaseRowLocation = baseCC.newRowLocationTemplate();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/IndexChanger.java,doDelete,367-367,[                args[1] = new Long(indexCID);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/sql/execute/IndexRowToBaseRowResultSet.java,<init>,190-190,[        _includeRowLocation = (_baseColumnCount < accessedHeapCols.getLength());],,<init>,161-161,[		if (accessedHeapCols == null) {],,<init>,162-162,[			rowArray = resultRow.getRowArray();],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/IndexSetChanger.java,toString,381-381,[                fixOnUpdate_s += fixOnUpdate[ix];],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/IndexSetChanger.java,openIndexes,196-196,[			if (whatToOpen == UPDATE_INDEXES &&],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/IndexSetChanger.java,toString,376-376,[			for (int ix = 0; ix < fixOnUpdate.length; ix++)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/IndexSetChanger.java,update,288-288,[			if (fixOnUpdate[ix])],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/InsertResultSet.java,bulkValidateForeignKeys,1612-1612,[				Long fkConglom = indexConversionTable.get(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/InsertResultSet.java,open,530-530,[								new Long(aiCache[i].getLong()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/InsertResultSet.java,updateAllIndexes,2095-2095,[			indexConversionTable.put(new Long(constants.indexCIDS[index]),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/InsertResultSet.java,verifyAutoGeneratedColumnsIndexes,569-569,[				throw StandardException.newException(],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/execute/InsertResultSet.java,getColumnNames,2615-2621,[		int length = baseColumnPositions.length;, 		String[] columnNames = new String[length];, 		for(int i = 0; i < length; i++), 		{, 			columnNames[i] = constants.getColumnName(i);, 		}, 		return columnNames;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/execute/InsertResultSet.java,getTableScanResultSet,2573-2610,[		if (tableScan == null), 		{, 			tableScan = ,                 new BulkTableScanResultSet(,                     conglomId,,                     tc.getStaticCompiledConglomInfo(conglomId),,                     activation,,                     fullTemplateId,,                     0,						// result set number,                     (GeneratedMethod)null, 	// start key getter,                     0, 						// start search operator,                     (GeneratedMethod)null,	// stop key getter,                     0, 						// start search operator,                     false,,                     (Qualifier[][])null,	// qualifiers,                     "tableName",,                     (String)null,,                     (String)null,			// index name,                     false,					// is constraint,                     false,					// for update,                     -1,						// saved object for referenced bitImpl,                     -1,,                     TransactionController.MODE_TABLE,,                     true,					// table locked,                     TransactionController.ISOLATION_READ_COMMITTED,,                     LanguageProperties.BULK_FETCH_DEFAULT_INT,	// rows per read,                     false,                  // never disable bulk fetch,                     false,					// not a 1 row per scan,                     0d,						// estimated rows,                     0d 					// estimated cost,                     );, 			tableScan.openCore();, 		}, 		else, 		{	, 			tableScan.reopenCore();, 		}, 		return tableScan;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/InsertResultSet.java,setUpAllSorts,1805-1805,[			indexRows[index] = constants.irgs[index].getIndexRowTemplate();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/execute/InsertVTIResultSet.java,<init>,71-71,[		this.vtiRS = (VTIResultSet) vtiRS;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/sql/execute/InternalTriggerExecutionContext.java,cleanup,249-249,[			} catch (SQLException se) {}],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/InternalTriggerExecutionContext.java,,192-192,[		this.event = event;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/InternalTriggerExecutionContext.java,updateAICounters,578-578,[			DataValueDescriptor dvd = afterRow.getColumn(aic.getColumnPosition());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/InternalTriggerExecutionContext.java,setAfterResultSet,174-174,[			if (triggerd.isRowTrigger())],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/InternalTriggerExecutionContext.java,toString,586-586,[		return triggerd.getName();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/InternalTriggerExecutionContext.java,validateStatement,316-316,[			throw StandardException.newException(SQLState.LANG_NO_DDL_IN_TRIGGER, triggerd.getName());],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/sql/execute/JarUtil.java,install,111-111,[			catch (IOException ioe) {}],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/sql/execute/JarUtil.java,replace,259-259,[			catch (IOException ioe) {}],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/JarUtil.java,run,390-390,[                            return new Long(generationId);],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java,,699-699,[			return new RealHashLeftOuterJoinStatistics(],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/sql/execute/LastIndexKeyResultSet.java,<init>,125-125,[			if (SanityManager.DEBUG_ON("ScanTrace"))],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/LastIndexKeyResultSet.java,,117-117,[		runTimeStatisticsOn = getLanguageConnectionContext().getRunTimeStatisticsMode();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/LastIndexKeyResultSet.java,,114-114,[		this.userSuppliedOptimizerOverrides = userSuppliedOptimizerOverrides;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/LockTableConstantAction.java,executeConstantAction,113-113,[			String msgId = se.getMessageId();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/execute/MatchingClauseConstantAction.java,executeConstantAction,153-153,[        GeneratedMethod actionGM = ((BaseActivation) activation).getMethod( _actionMethodName );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/MatchingClauseConstantAction.java,executeConstantAction,153-153,[        GeneratedMethod actionGM = ((BaseActivation) activation).getMethod( _actionMethodName );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/MatchingClauseConstantAction.java,executeConstantAction,171-171,[                Activation  cursorActivation = sourceRS.getActivation();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/MatchingClauseConstantAction.java,readExternal,328-328,[        int oldVersion = in.readInt();],,
STYLE,DMI_NONSERIALIZABLE_OBJECT_WRITTEN,org/apache/derby/impl/sql/execute/MatchingClauseConstantAction.java,writeExternal,357-357,[        out.writeObject( _thenAction );],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/sql/execute/MatchingClauseConstantAction.java,executeConstantAction,180-180,[            catch (Exception e) { throw StandardException.plainWrapException( e ); }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/MergeConstantAction.java,readExternal,129-129,[        int oldVersion = in.readInt();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/execute/MergeResultSet.java,collectAffectedRows,234-238,[                switch ( candidate.clauseType() ),                 {,                 case ConstantAction.WHEN_MATCHED_THEN_UPDATE:,                 case ConstantAction.WHEN_MATCHED_THEN_DELETE:,                     isWhenMatchedClause = true;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/sql/execute/MultiProbeTableScanResultSet.java,,135-492,[        super(conglomId,,             scoci,,             activation,,             resultRowTemplate,,             resultSetNumber,,             startKeyGetter,,             startSearchOperator,,             stopKeyGetter,,             stopSearchOperator,,             sameStartStopPosition,,             qualifiers,,             tableName,,             userSuppliedOptimizerOverrides,,             indexName,,             isConstraint,,             forUpdate,,             colRefItem,,             indexColItem,,             lockMode,,             tableLocked,,             isolationLevel,,             1, // rowsPerRead,             oneRowScan,,             optimizerEstimatedRowCount,,             optimizerEstimatedCost);, ,         if (SanityManager.DEBUG),         {,             SanityManager.ASSERT(,                 (probingVals != null) && (probingVals.length > 0),,                 "No probe values found for multi-probe scan.");,         }, ,         this.origProbeValues = probingVals;,         this.sortRequired = sortRequired;,     }, ,     /**,      * @see NoPutResultSet#openCore,      */,     public void openCore() throws StandardException,     {,         /* If the probe values are not already sorted then sort them now.  This,          * allows us to skip over duplicate probe values (otherwise we could,          * end up with duplicate rows in the result set).,          *,          * Note: If all of the probe values were provided as constants then we,          * sorted them at compile time (during preprocessing) so we don't have,          * to do it now. But if one or more was specified as a param then we,          * have to do the sort here, at execution time, because this is the,          * only point at which we know what values the parameters have.,          */,         if (sortRequired == RowOrdering.DONTCARE),         {,             /* DONTCARE really means that the values are already sorted,              * in ascending order, and that's good enough.,              */,             probeValues = origProbeValues;,         },         else,         {,             /* RESOLVE: For some reason sorting the probeValues array,              * directly leads to incorrect parameter value assignment when,              * executing a prepared statement multiple times.  Need to figure,              * out why (maybe related to DERBY-827?).  In the meantime, if,              * we're going to sort the values we use clones.  This is not,              * ideal, but it works for now.,              */,             DataValueDescriptor [] pVals =,                 new DataValueDescriptor[origProbeValues.length];, ,             for (int i = 0; i < pVals.length; i++),                 pVals[i] = origProbeValues[i].cloneValue(false);, ,             if (sortRequired == RowOrdering.ASCENDING),                 java.util.Arrays.sort(pVals);,             else,             {,                 // Sort the values in DESCENDING order.,                 java.util.Arrays.sort(,                     pVals, java.util.Collections.reverseOrder());,             }, ,             probeValues = pVals;,         }, ,         probeValIndex = 0;,         super.openCore();,     }, ,     /**,      * @see NoPutResultSet#reopenCore,      */,     public void reopenCore() throws StandardException,     {,         reopenCore(false);,     }, ,     /**,      * There are two scenarios for which we reopen this kind of scan:,      *,      *   A - The first is for join processing.  In this case we have,      * a(nother) row from some outer table and we want to reopen this,      * scan to look for rows matching the new outer row.,      *,      *   B - The second is for multi-probing.  Here we want to reopen,      * the scan on this table to look for rows matching the next value,      * in the probe list.,      *,      * If we are reopening the scan for scenario A (join processing),      * then we need to reset our position within the probe list. ,      * If we are reopening the scan for scenario B then we do *not*,      * want to reset our position within the probe list because that,      * position tells us where to find the next probe value.,      *,      * That said, this method does the work of reopenCore() using,      * the received boolean to determine which of the two scenarios,      * we are in.  Note that if our current position (i.e. the value,      * of probeValIndex) is beyond the length of the probe list then,      * we know that we are reopening the scan for scenario A.  Or put,      * another away, we should never get here for scenario B if,      * probeValIndex is greater than or equal to the length of the,      * probe list.  The reason is that the call to reopenCore() for,      * scenario B will only ever happen when moreInListVals() returns,      * true--and in that case we know that probeValIndex will be less,      * than the length of the probeValues.  But the opposite is not,      * true: i.e. it is *not* safe to say that a probeValIndex which,      * is less than the length of probe list is always for scenario,      * B.  That's not true because it's possible that the join to,      * which this scan belongs is a "oneRowRightSide" join, meaning,      * that this, the "right" side scan, will be "interrupted" after,      * we return a single row for the current outer row.  If we then,      * come back with a new outer row we need to reset our position--,      * even though probeValIndex will be less than probeValues.length,      * in that case.  DERBY-3603.,      */,     private void reopenCore(boolean forNextProbe) throws StandardException,     {,         if (!forNextProbe),             probeValIndex = 0;, ,         super.reopenCore();,     }, ,     /**,      * Reopen the scan controller,      *,      * @exception StandardException thrown on failure to open,      */,     protected void reopenScanController() throws StandardException,     {,         // TableScanResultSet.reopenScanController() will reset rowsThisScan,         // because it thinks this is a completely new scan. However, we want,         // it to reflect the total number of rows seen in the multi-probe,         // scan, so we keep the original value and restore it after reopening,         // the controller. Instead, we reset rowsThisScan to 0 each time,         // initStartAndStopKey() is called on the first probe value.,         long rows = rowsThisScan;,         super.reopenScanController();,         rowsThisScan = rows;,     }, ,     /**,      * Initialize the start key and the stop key used in the scan. Both keys,      * will be set to the probe value. If no new probe value was found (the,      * probe list was exhausted), the flag skipNextScan will be {@code true},      * when the method returns to prevent a new scan from being reopened with,      * a missing or incorrect probe value.,      */,     void initStartAndStopKey() throws StandardException {, ,         // Make sure the fields are initialized with a placeholder.,         // startPosition and stopPosition will always be non-null in a,         // MultiProbeTableScanResultSet, and they will always be initialized,         // to the first value in the probe list. They will be changed to,         // the actual probe value later in this method.,         super.initStartAndStopKey();, ,         /* If we're looking for the first value in the probe list, then,          * reset the row scan count.  Otherwise leave it unchanged since,          * we're just continuing an already-opened scan.  Note that we,          * have to do this check *before* we call getNextProbeValue(),          * because that method will increment probeValIndex.,          */,         if (probeValIndex == 0),             rowsThisScan = 0;, ,         DataValueDescriptor[] startPositionRow = startPosition.getRowArray();,         DataValueDescriptor[] stopPositionRow = stopPosition.getRowArray();, ,         DataValueDescriptor probeValue = getNextProbeValue();, , 		/* If we have a probe value then we do the "probe" by positioning, 		 * the scan at the first row matching the value.  The way to do, 		 * that is to use the value as a start key, which is what will, 		 * happen if we plug it into first column of "startPositionRow"., 		 * So in this case startPositionRow[0] functions as a "place-holder", 		 * for the probe value.  The same goes for stopPositionRow[0]., 		 *, 		 * Note that it *is* possible for a start/stop key to contain more, 		 * than one column (ex. if we're scanning a multi-column index). In, 		 * that case we plug probeValue into the first column of the start, 		 * and/or stop key and leave the rest of the key as it is.  As an, 		 * example, assume we have the following predicates:, 		 *, 		 *    ... where d in (1, 20000) and b > 200 and b <= 500, 		 *, 		 * And assume further that we have an index defined on (d, b)., 		 * In this case it's possible that we have TWO start predicates, 		 * and TWO stop predicates: the IN list will give us "d = probeVal",, 		 * which is a start predicate and a stop predicate; then "b > 200", 		 * may give us a second start predicate, while "b <= 500" may give, 		 * us a second stop predicate.  So in this situation we want our, 		 * start key to be:, 		 *, 		 *    (probeValue, 200), 		 *, 		 * and our stop key to be:, 		 *, 		 *    (probeValue, 500)., 		 *, 		 * This will effectively limit the scan so that it only returns, 		 * rows whose "D" column equals probeValue and whose "B" column, 		 * falls in the range of 200 thru 500., 		 *, 		 * Note: Derby currently only allows a single start/stop predicate, 		 * per column. See PredicateList.orderUsefulPredicates()., 		 */,         if (probeValue != null) {,             startPositionRow[0] = probeValue;,             if (!sameStartStopPosition) {,                 stopPositionRow[0] = startPositionRow[0];,             },         }, ,         // If we didn't find a new probe value, the probe list is exhausted,,         // and we shouldn't open a new scan. skipScan() will detect this and,         // prevent (re)openScanController() from being called.,         skipNextScan = (probeValue == null);,     }, ,     /**,      * Check if the scan should be skipped. It should be skipped if (1),      * {@link #initStartAndStopKey()} exhausted the probe list, or (2) the scan,      * should return no results because of nulls in the start key or stop key.,      * See {@link NoPutResultSetImpl#skipScan(ExecIndexRow,ExecIndexRow)} for,      * details about (2).,      *,      * @param startPosition the key on which to start the scan,      * @param stopPosition the key on which to stop the scan,      * @return {@code true} if scan should be skipped, {@code false} otherwise,      */,     protected boolean skipScan(,             ExecIndexRow startPosition, ExecIndexRow stopPosition), 		throws StandardException,     {,         return skipNextScan || super.skipScan(startPosition, stopPosition);,     }, ,     /**,      * Return the next row (if any) from the scan (if open).,      *,      * More specifically we do the following:,      *,      *  1 - See if we have a row to read from the current scan position.,      *    If so, return that row (done).,      *,      *  2 - If there are no more rows to read from the current scan,      *    position AND if there are more probe values to look at,,      *    then a) reposition the scan using the next probe value,      *    as the start/stop key and b) go back to step 1.  Otherwise,      *    proceed to step 3.,      *    ,      *  3 - Return null (no more rows).,      *,      * Note that step 1 is important for cases where multiple rows in this,      * table match a single probe value.  In such a scenario we have to,      * be sure that we do *not* move on to the next probe value until,      * we have returned all of the rows for the _current_ probe value.,      *,      * @exception StandardException thrown on failure to get next row,      */,     public ExecRow getNextRowCore() throws StandardException,     {, 		if( isXplainOnlyMode() ), 			return null;, ,         checkCancellationFlag();, ,         // Step 1.,         ExecRow result = super.getNextRowCore();, ,         // Steps 2, 1, 2, 1, 2, ...,         while ((result == null) && moreInListVals()),         {,             /* Repositioning the scan (if needed) is simply a matter of,              * reopening the core scan again. As part of that method we will,              * figure out what the next probe value should be (and thus,              * where to position the scan).,              */,             reopenCore(true);,             result = super.getNextRowCore();,         }, ,         // Step 3: result will be null if there are no more rows.,         return result;,     }, ,     /**,      * @see NoPutResultSet#close,      */,     public void close() throws StandardException,     {,         /* We'll let TableScanResultSet track the time it takes to close up,,          * so no timing here.,          */,         super.close();, ,         /* Note: We can't set probeValues == null here because we may end,          * up reopening this scan again later, in which case we'll need the,          * list of probe values.,          */,     }, ,     /**,      * Figure out whether or not we can (re-)position the scan,      * controller based on the next value in probeValues.  This,      * will return false when we have exhausted the probe list,      * (i.e. when we've gone through all of the values).,      */,     private boolean moreInListVals(),     {,         return (probeValIndex < probeValues.length);,     }, ,     /**,      * Return the next non-duplicate value from the probe list.,      * Assumption is that the list is sorted so that duplicates,      * appear next to each other, and that probeValIndex is the,      * index of the next value. If we've exhausted the probe list,      * then just return null.,      */,     private DataValueDescriptor getNextProbeValue(),     {,         int ctr = probeValIndex;, ,         // Skip over duplicate values.,         while ((ctr > 0) && (ctr < probeValues.length) &&,             probeValues[probeValIndex-1].equals(probeValues[ctr])),         {,             ctr++;,         }, ,         probeValIndex = ctr;,         if (probeValIndex < probeValues.length),             return probeValues[probeValIndex++];, ,         return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/MultiProbeTableScanResultSet.java,getNextProbeValue,482-482,[        while ((ctr > 0) && (ctr < probeValues.length) &&],,getNextProbeValue,489-489,[        if (probeValIndex < probeValues.length)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/MultiProbeTableScanResultSet.java,moreInListVals,467-467,[        return (probeValIndex < probeValues.length);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java,getNextRowFromRowSource,254-254,[		return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java,unpackHashValue,578-578,[        if ( hashValue == null ) { return null; }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java,skipRow,454-454,[			if (row.getColumn(checkNullCols[i]).isNull())],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java,getNextRowFromRowSource,249-249,[			clonedExecRow = targetResultSet.preprocessSourceRow(execRow);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java,offendingRowLocation,302-302,[        targetResultSet.offendingRowLocation(rl, containdId);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/sql/execute/NoPutResultSetImpl.java,rowLocation,296-296,[		targetResultSet.changedRow(clonedExecRow, rl);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/execute/NoRowsResultSetImpl.java,evaluateGenerationClauses,600-600,[                if ( generatedColumnPositions == null ) { setupGeneratedColumns( activation, (ValueRow) newRow ); }],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/RIBulkChecker.java,getNextFK,222-222,[				return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/RIBulkChecker.java,getNextRef,248-248,[				return null;],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java,getResultSetStatistics,537-540,[					instantaneousLocks = true;, 					//fall through, 				case TransactionController.ISOLATION_READ_COMMITTED:, 					isolationLevel = MessageService.getTextMessage(],,getResultSetStatistics,1041-1044,[					instantaneousLocks = true;, 					//fall through, 				case TransactionController.ISOLATION_READ_COMMITTED:, 					isolationLevel = MessageService.getTextMessage(],,getResultSetStatistics,1260-1263,[					instantaneousLocks = true;, 					//fall through, 				case TransactionController.ISOLATION_READ_COMMITTED:, 					isolationLevel = MessageService.getTextMessage(],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java,getResultSetStatistics,522-546,[			switch (tsrs.isolationLevel), 			{, 				case TransactionController.ISOLATION_SERIALIZABLE:, 					isolationLevel = ,                         MessageService.getTextMessage(,                             SQLState.LANG_SERIALIZABLE);, 					break;, , 				case TransactionController.ISOLATION_REPEATABLE_READ:, 					isolationLevel = ,                         MessageService.getTextMessage(,                             SQLState.LANG_REPEATABLE_READ);, 					break;, , 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:, 					instantaneousLocks = true;, 					//fall through, 				case TransactionController.ISOLATION_READ_COMMITTED:, 					isolationLevel = MessageService.getTextMessage(, 												SQLState.LANG_READ_COMMITTED);, 					break;, , 				case TransactionController.ISOLATION_READ_UNCOMMITTED:, 					isolationLevel = ,                         MessageService.getTextMessage(],,getResultSetStatistics,570-586,[			switch (tsrs.lockMode), 			{, 				case TransactionController.MODE_TABLE:, 					// RESOLVE: Not sure this will really work, as we, 					// are tacking together English words to make a phrase., 					// Will this work in other languages?, 					lockRequestString = lockString + " " +, 										MessageService.getTextMessage(, 											SQLState.LANG_TABLE);, 					break;, , 				case TransactionController.MODE_RECORD:, 					// RESOLVE: Not sure this will really work, as we, 					// are tacking together English words to make a phrase., 					// Will this work in other languages?, 					lockRequestString = lockString + " " +, 										MessageService.getTextMessage(],,getResultSetStatistics,641-662,[			switch (lrs.isolationLevel), 			{, 				case TransactionController.ISOLATION_SERIALIZABLE:, 					isolationLevel = ,                         MessageService.getTextMessage(,                             SQLState.LANG_SERIALIZABLE);, 					break;, , 				case TransactionController.ISOLATION_REPEATABLE_READ:, 					isolationLevel = ,                         MessageService.getTextMessage(,                             SQLState.LANG_REPEATABLE_READ);, 					break;, , 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:, 				case TransactionController.ISOLATION_READ_COMMITTED:, 					isolationLevel = MessageService.getTextMessage(, 												SQLState.LANG_READ_COMMITTED);, 					break;, , 				case TransactionController.ISOLATION_READ_UNCOMMITTED:, 					isolationLevel = MessageService.getTextMessage(],,getResultSetStatistics,667-675,[			switch (lrs.lockMode), 			{, 				case TransactionController.MODE_TABLE:, 					lockRequestString = MessageService.getTextMessage(, 													SQLState.LANG_SHARE_TABLE);, 					break;, , 				case TransactionController.MODE_RECORD:, 					lockRequestString = MessageService.getTextMessage(],,getResultSetStatistics,1026-1044,[			switch (hsrs.isolationLevel), 			{, 				case TransactionController.ISOLATION_SERIALIZABLE:, 					isolationLevel = ,                         MessageService.getTextMessage(,                             SQLState.LANG_SERIALIZABLE);, 					break;, , 				case TransactionController.ISOLATION_REPEATABLE_READ:, 					isolationLevel = ,                         MessageService.getTextMessage(,                             SQLState.LANG_REPEATABLE_READ);, 					break;, , 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:, 					instantaneousLocks = true;, 					//fall through, 				case TransactionController.ISOLATION_READ_COMMITTED:, 					isolationLevel = MessageService.getTextMessage(],,getResultSetStatistics,1069-1085,[			switch (hsrs.lockMode), 			{, 				case TransactionController.MODE_TABLE:, 					// RESOLVE: Not sure this will really work, as we, 					// are tacking together English words to make a phrase., 					// Will this work in other languages?, 					lockString = lockString + " " +, 									MessageService.getTextMessage(, 														SQLState.LANG_TABLE);, 					break;, , 				case TransactionController.MODE_RECORD:, 					// RESOLVE: Not sure this will really work, as we, 					// are tacking together English words to make a phrase., 					// Will this work in other languages?, 					lockString = lockString + " " +, 									MessageService.getTextMessage(],,getResultSetStatistics,1245-1269,[			switch (dsrs.isolationLevel), 			{, 				case TransactionController.ISOLATION_SERIALIZABLE:, 					isolationLevel = ,                         MessageService.getTextMessage(,                             SQLState.LANG_SERIALIZABLE);, 					break;, , 				case TransactionController.ISOLATION_REPEATABLE_READ:, 					isolationLevel = ,                         MessageService.getTextMessage(,                             SQLState.LANG_REPEATABLE_READ);, 					break;, , 				case TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK:, 					instantaneousLocks = true;, 					//fall through, 				case TransactionController.ISOLATION_READ_COMMITTED:, 					isolationLevel = MessageService.getTextMessage(, 												SQLState.LANG_READ_COMMITTED);, 					break;, , 				case TransactionController.ISOLATION_READ_UNCOMMITTED:, 					isolationLevel = ,                         MessageService.getTextMessage(],,getResultSetStatistics,1293-1309,[			switch (dsrs.lockMode), 			{, 				case TransactionController.MODE_TABLE:, 					// RESOLVE: Not sure this will really work, as we, 					// are tacking together English words to make a phrase., 					// Will this work in other languages?, 					lockRequestString = lockString + " " +, 										MessageService.getTextMessage(, 											SQLState.LANG_TABLE);, 					break;, , 				case TransactionController.MODE_RECORD:, 					// RESOLVE: Not sure this will really work, as we, 					// are tacking together English words to make a phrase., 					// Will this work in other languages?, 					lockRequestString = lockString + " " +, 										MessageService.getTextMessage(],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/RenameConstantAction.java,execGutsRenameColumn,370-370,[		td = dd.getTableDescriptor(td.getObjectID());],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/RenameConstantAction.java,executeConstantAction,206-206,[		DependencyManager dm = dd.getDependencyManager();],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/sql/execute/RenameConstantAction.java,,237-237,[			sd = getAndCheckSchemaDescriptor(dd, schemaId, "RENAME TABLE");],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/RevokeRoleConstantAction.java,executeConstantAction,76-76,[        TransactionController tc = lcc.getTransactionExecute();],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derby/impl/sql/execute/RevokeRoleConstantAction.java,,48-48,[    private final boolean withAdminOption = false; // not impl.],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/sql/execute/RevokeRoleConstantAction.java,executeConstantAction,133-133,[                if (rd != null && withAdminOption) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/RowChangerImpl.java,,139-139,[		this.baseRowReadMap = baseRowReadMap;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/ScalarAggregateResultSet.java,,83-83,[		this.isInSortedOrder = isInSortedOrder;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java,<init>,180-180,[			target = ((CursorActivation)activation).getTargetResultSet();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java,getNextRowFromSource,811-811,[			long beginTCTime = getCurrentTimeMillis();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java,markRowAsDeleted,1191-1191,[		RowLocation rowLoc = (RowLocation) hashRowArray[POS_ROWLOCATION];],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java,getRowFromHashTable,1030-1030,[		resultRow.setRowArray(resultRowArray);],,getRowFromHashTable,1037-1037,[		if (resultRow != null)],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java,getAbsoluteRow,377-377,[		currentRow = null;],,getAbsoluteRow,352-352,[		else if (row < 0)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/sql/execute/SetOpResultSet.java,getNextRowCore,177-177,[                        SanityManager.ASSERT( rightInputRow != null && compare == 0,],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/sql/execute/SetOpResultSet.java,advanceRightPastDuplicates,213-220,[        while ((rightInputRow = rightSource.getNextRowCore()) != null),         {,             rowsSeenRight++;, ,             if (compare(leftColumns, rightInputRow.getRowArray()) == 0) ,                 continue;,         },     } // end of advanceRightPastDuplicates],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/SetOpResultSet.java,,86-86,[        this.activation = activation;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/SetRoleConstantAction.java,executeConstantAction,104-104,[        final String currentAuthId = lcc.getCurrentUserId(activation);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/sql/execute/SetRoleConstantAction.java,executeConstantAction,106-106,[            getAuthorizationDatabaseOwner();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/SortResultSet.java,,259-259,[				sorted = true;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/sql/execute/TableScanResultSet.java,<init>,148-148,[		super(activation,],,<init>,196-196,[		runTimeStatisticsOn = (activation != null &&],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/TableScanResultSet.java,printPosition,1145-1145,[				output = output +  "\n";],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/sql/execute/TableScanResultSet.java,close,566-566,[				if (SanityManager.DEBUG_ON("ScanTrace"))],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/sql/execute/TableScanResultSet.java,openCore,260-260,[				if (SanityManager.DEBUG_ON("ScanTrace"))],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/sql/execute/TemporaryRowHolderImpl.java,insert,305-305,[                    inputRow.getRowArray(),],,
CORRECTNESS,UWF_NULL_FIELD,org/apache/derby/impl/sql/execute/TemporaryRowHolderImpl.java,,569-569,[		if (scan != null)],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java,getNextRowFromRowSource,1164-1164,[		return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java,justTheRequiredColumnsPositions,256-256,[			return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java,shrinkArray,232-232,[			return null;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/TemporaryRowHolderResultSet.java,,123-123,[		finished = false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/execute/TriggerEvent.java,<init>,62-73,[		switch(type), 		{, 			case BEFORE_INSERT:		, 			case BEFORE_DELETE:		, 			case BEFORE_UPDATE:		, 				before = true;, 				break;, , 			case AFTER_INSERT:		, 			case AFTER_DELETE:		, 			case AFTER_UPDATE:		, 				before = false;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/sql/execute/UnionResultSet.java,getCurrentRow,290-297,[	    switch (whichSource) , 		{, 	        case 1: , 				result = ((CursorResultSet) source1).getCurrentRow();, 	            break;, , 	        case 2: , 				result = ((CursorResultSet) source2).getCurrentRow();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/UnionResultSet.java,,53-53,[    private int source1FinalRowCount = -1;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/UniqueIndexSortObserver.java,,61-61,[        this.tc = tc;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/sql/execute/UniqueWithDuplicateNullsIndexSortObserver.java,,75-75,[        this.tc = tc;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/sql/execute/UserDefinedAggregator.java,merge,128-128,[        UserDefinedAggregator  other = (UserDefinedAggregator) addend;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/sql/execute/VTIResultSet.java,setNullableColumnList,367-367,[			return null;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/sql/execute/ValidateCheckConstraintResultSet.java,,75-214,[        super(conglomId,,                 scoci,,                 activation,,                 resultRowTemplate,,                 resultSetNumber,,                 startKeyGetter, startSearchOperator,,                 stopKeyGetter, stopSearchOperator,,                 sameStartStopPosition,,                 qualifiers,,                 tableName,,                 userSuppliedOptimizerOverrides,,                 indexName,,                 isConstraint,,                 forUpdate,,                 colRefItem,,                 indexColItem,,                 lockMode,,                 tableLocked,,                 isolationLevel,,                 rowsPerRead,,                 oneRowScan,,                 optimizerEstimatedRowCount,,                 optimizerEstimatedCost);,     }, ,     /**,      * Return the current row (if any) from the base table scan, positioned,      * correctly by our caller (ProjectRestrictNode). It overrides,      * getNextRowCore from TableSCanResultSet, by using "fetch" instead of,      * "fetchNext" on the underlying controller, otherwise it's identical.,      * (This means it's probably over-general for the usage we have of it,,      * but it felt safer to keep the code as similar as possible.),      * @return the row retrieved,      * @exception StandardException thrown on failure to get next row,      */,     @Override,     public ExecRow getNextRowCore() throws StandardException    {,         if (isXplainOnlyMode()) {,             return null;,         }, ,         checkCancellationFlag();, ,         if (SanityManager.DEBUG) {,             SanityManager.ASSERT(scanRepositioned);,         }, ,         if (currentRow == null || scanRepositioned) {,             currentRow = getCompactRow(candidate, accessedCols, isKeyed);,         }, ,         beginTime = getCurrentTimeMillis();, ,         ExecRow result = null;, ,         if (isOpen  && !nextDone) {,             // Only need to do 1 next per scan for 1 row scans.,             nextDone = oneRowScan;, ,             if (scanControllerOpened) {,                 boolean moreRows = true;, ,                 while (moreRows) {,                     try {,                         scanController.fetch(candidate.getRowArray());,                     } catch (StandardException e) {,                         // Offending rows may have been deleted in the,                         // transaction.  As for compress, we won't even get here,                         // since we use a normal SELECT query then.,                         if (e.getSQLState().equals(,                                 ExceptionUtil.getSQLStateFromIdentifier(,                                         SQLState.AM_RECORD_NOT_FOUND))) {,                             moreRows = false;,                             break;,                         } else {,                             throw e;,                         },                     }, ,                     rowsSeen++;,                     rowsThisScan++;, ,                     /*,                     ** Skip rows where there are start or stop positioners,                     ** that do not implement ordered null semantics and,                     ** there are columns in those positions that contain,                     ** null.,                     ** No need to check if start and stop positions are the,                     ** same, since all predicates in both will be ='s,,                     ** and hence evaluated in the store.,                     */,                     if ((! sameStartStopPosition) && skipRow(candidate)) {,                         rowsFiltered++;,                         continue;,                     }, ,                     /* beetle 3865, updateable cursor use index. If we have a,                      * hash table that holds updated records, and we hit it,                      * again, skip it, and remove it from hash since we can't,                      * hit it again, and we have a space in hash, so can stop,                      * scanning forward.,                      */,                     if (past2FutureTbl != null) {,                         RowLocation rowLoc = (RowLocation)currentRow.getColumn(,                             currentRow.nColumns());,                         if (past2FutureTbl.remove(rowLoc) != null) {,                             continue;,                         },                     }, ,                     result = currentRow;,                     break;,                 }, ,                 /*,                 ** If we just finished a full scan of the heap, update,                 ** the number of rows in the scan controller.,                 **,                 ** NOTE: It would be more efficient to only update the,                 ** scan controller if the optimizer's estimated number of,                 ** rows were wrong by more than some threshold (like 10%).,                 ** This would require a little more work than I have the,                 ** time for now, however, as the row estimate that is given,                 ** to this result set is the total number of rows for all,                 ** scans, not the number of rows per scan.,                 */,                 if (! moreRows) {,                     setRowCountIfPossible(rowsThisScan);,                     currentRow = null;,                 },             },         }, ,         setCurrentRow(result);,         currentRowIsValid = true;,         scanRepositioned = false;,         qualify = true;, ,         nextTime += getElapsedMillis(beginTime);,         return result;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/ValueRow.java,toString,188-188,[				s += ", ";],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealBasicNoPutResultSetStatistics.java,dumpEstimatedCosts,132-132,[		return	subIndent +],,dumpEstimatedCosts,133-133,[            MessageService.getTextMessage(SQLState.RTS_OPT_EST_RC,],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealBasicNoPutResultSetStatistics.java,getResultSetDescriptor,220-220,[           getRSXplainDetails(),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealBasicNoPutResultSetStatistics.java,getResultSetDescriptor,220-220,[           getRSXplainDetails(),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealBasicNoPutResultSetStatistics.java,getResultSetTimingsDescriptor,244-244,[        return new XPLAINResultSetTimingsDescriptor(],,getResultSetTimingsDescriptor,250-250,[           new Long(this.getNodeTime()),],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/rts/RealDeleteCascadeResultSetStatistics.java,getScanStatisticsText,146-146,[					dependentInfo = dependentInfo +],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/rts/RealDistinctScanStatistics.java,getStatementExecutionPlanText,167-167,[				hashKeyColumnString = hashKeyColumnString + "," + hashKeyColumns[index];],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealGroupedAggregateStatistics.java,getResultSetDescriptor,207-207,[           getRSXplainDetails(),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealGroupedAggregateStatistics.java,getResultSetDescriptor,207-207,[           getRSXplainDetails(),],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealHashScanStatistics.java,getResultSetDescriptor,370-370,[           getRSXplainDetails(),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealHashScanStatistics.java,getResultSetDescriptor,370-370,[           getRSXplainDetails(),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealHashScanStatistics.java,getScanPropsDescriptor,334-334,[        XPLAINScanPropsDescriptor scanRSDescriptor =            ],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/rts/RealHashScanStatistics.java,getStatementExecutionPlanText,201-201,[				hashKeyColumnString = hashKeyColumnString + "," + hashKeyColumns[index];],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealHashTableStatistics.java,getScanPropsDescriptor,312-312,[        XPLAINScanPropsDescriptor scanRSDescriptor =            ],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/rts/RealHashTableStatistics.java,getStatementExecutionPlanText,174-174,[				hashKeyColumnString = hashKeyColumnString + "," + hashKeyColumns[index];],,
STYLE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/rts/RealHashTableStatistics.java,,306-306,[        String isoLevel = XPLAINUtil.getIsolationLevelCode(this.isolationLevel);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/rts/RealJoinResultSetStatistics.java,,96-96,[		this.restrictionTime = restrictionTime;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealMaterializedResultSetStatistics.java,getResultSetTimingsDescriptor,188-188,[        return new XPLAINResultSetTimingsDescriptor(],,getResultSetTimingsDescriptor,194-194,[           new Long(this.getNodeTime()),],,getResultSetTimingsDescriptor,195-195,[           XPLAINUtil.getAVGNextTime( (long)this.nextTime, this.rowsSeen),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealNoRowsResultSetStatistics.java,getResultSetTimingsDescriptor,175-175,[        return new XPLAINResultSetTimingsDescriptor(],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/sql/execute/rts/RealNoRowsResultSetStatistics.java,,100-100,[		subIndent = new String(subIndentchars);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealProjectRestrictStatistics.java,getResultSetTimingsDescriptor,319-319,[        return new XPLAINResultSetTimingsDescriptor(],,getResultSetTimingsDescriptor,325-325,[           new Long(this.getNodeTime()),],,getResultSetTimingsDescriptor,326-326,[           XPLAINUtil.getAVGNextTime( (long)this.nextTime, this.rowsSeen),],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/rts/RealProjectRestrictStatistics.java,getScanStatisticsText,206-206,[					subqueryInfo = subqueryInfo +],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealScalarAggregateStatistics.java,getResultSetDescriptor,188-188,[           getRSXplainDetails(),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealScalarAggregateStatistics.java,getResultSetDescriptor,188-188,[           getRSXplainDetails(),],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealSetOpResultSetStatistics.java,getResultSetDescriptor,255-255,[           getRSXplainDetails(),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealSetOpResultSetStatistics.java,getResultSetDescriptor,255-255,[           getRSXplainDetails(),],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealSortStatistics.java,getResultSetDescriptor,219-219,[           getRSXplainDetails(),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealSortStatistics.java,getResultSetDescriptor,219-219,[           getRSXplainDetails(),],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealUnionResultSetStatistics.java,getResultSetDescriptor,213-213,[           getRSXplainDetails(),],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/rts/RealUnionResultSetStatistics.java,getResultSetDescriptor,213-213,[           getRSXplainDetails(),],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/derby/impl/sql/execute/xplain/XPLAINFactory.java,getXPLAINVisitor,61-61,[            if (schema != currentSchema)],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/sql/execute/xplain/XPLAINSystemTableVisitor.java,doXPLAIN,213-213,[                 new Long(rss.getParseTimeInMillis()),         // the Parse Time],,doXPLAIN,214-214,[                 new Long(rss.getBindTimeInMillis()),          // the Bind Time],,doXPLAIN,215-215,[                 new Long(rss.getOptimizeTimeInMillis()),      // the Optimize Time],,doXPLAIN,216-216,[                 new Long(rss.getGenerateTimeInMillis()),      // the Generate Time],,doXPLAIN,217-217,[                 new Long(rss.getCompileTimeInMillis()),       // the Compile Time],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/sql/execute/xplain/XPLAINSystemTableVisitor.java,addArraysToSystemCatalogs,371-371,[        PreparedStatement ps = conn.prepareStatement(],,addArraysToSystemCatalogs,373-373,[        Iterator<XPLAINResultSetDescriptor> rsetsiter = rsets.iterator();],,addArraysToSystemCatalogs,374-374,[        while (rsetsiter.hasNext())],,addArraysToSystemCatalogs,376-376,[            XPLAINResultSetDescriptor rset =],,addArraysToSystemCatalogs,377-377,[                rsetsiter.next();],,addArraysToSystemCatalogs,378-378,[            rset.setStatementParameters(ps);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/sql/execute/xplain/XPLAINSystemTableVisitor.java,addStmtDescriptorsToSystemCatalog,342-342,[        PreparedStatement ps = conn.prepareStatement(],,addStmtDescriptorsToSystemCatalog,344-344,[        stmt.setStatementParameters(ps);],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/sql/execute/xplain/XPLAINSystemTableVisitor.java,addArraysToSystemCatalogs,371-371,[        PreparedStatement ps = conn.prepareStatement(],,addArraysToSystemCatalogs,398-398,[        ps = conn.prepareStatement(],,addArraysToSystemCatalogs,386-386,[            ps = conn.prepareStatement(],,addArraysToSystemCatalogs,410-410,[        ps = conn.prepareStatement(],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/sql/execute/xplain/XPLAINSystemTableVisitor.java,addStmtDescriptorsToSystemCatalog,342-342,[        PreparedStatement ps = conn.prepareStatement(],,addStmtDescriptorsToSystemCatalog,350-350,[            ps = conn.prepareStatement(],,
I18N,DM_CONVERT_CASE,org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java,getLockGranularityCode,226-226,[         lockString = lockString.toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java,getLockModeCode,178-178,[         lockString = lockString.toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java,getStatementType,239-239,[         String text = SQLText.toUpperCase().trim();],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java,getHashKeyColumnNumberString,168-168,[                hashKeyColumnString = hashKeyColumnString + "," + hashKeyColumns[index];],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/BackingStoreHashTableFromScan.java,<init>,128-128,[            prop = null;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/PC_XenaVersion.java,readExternal,79-79,[		int majorVersion = in.readInt();],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/PropertyConglomerate.java,saveProperty,324-324,[            scan = null;],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/impl/store/access/PropertyConglomerate.java,<init>,121-121,[					propertiesConglomId = Long.valueOf(id).longValue();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/RAMAccessManager.java,startXATransaction,772-772,[            rtc = ],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/RAMAccessManager.java,boot,1165-1165,[        tc = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/RAMAccessManager.java,findMethodFactoryByImpl,647-647,[		conglomProperties = null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMAccessManager.java,conglomCacheAddEntry,508-508,[        CacheableConglomerate conglom_entry = (CacheableConglomerate)],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMAccessManager.java,conglomCacheFind,464-464,[        Long         conglomid_obj = new Long(conglomid);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMAccessManager.java,conglomCacheRemoveEntry,524-524,[        CacheableConglomerate conglom_entry = (CacheableConglomerate)],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMAccessManager.java,getFactoryFromConglomId,384-384,[			throw StandardException.newException(],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/derby/impl/store/access/RAMTransaction.java,openCompiledScan,1601-1601,[            SanityManager.ASSERT(],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/derby/impl/store/access/RAMTransaction.java,openCompiledScan,1599-1599,[            SanityManager.ASSERT(],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/RAMTransaction.java,getInternalTransaction,2240-2240,[        RAMTransactionContext rtc   = ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/RAMTransaction.java,startNestedUserTransaction,2334-2334,[        RAMTransactionContext rtc   = ],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMTransaction.java,addColumnToConglomerate,594-594,[			throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMTransaction.java,createConglomerate,817-817,[			tempCongloms.put(new Long(conglomId), conglom);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMTransaction.java,dropConglomerate,1000-1000,[				tempCongloms.remove(new Long(conglomId));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMTransaction.java,findConglomerate,409-409,[				conglom = (Conglomerate) tempCongloms.get(new Long(conglomId));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMTransaction.java,findExistingConglomerate,387-387,[			throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMTransaction.java,openSort,1828-1828,[			throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMTransaction.java,openSortRowSource,1924-1924,[			throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/RAMTransaction.java,openSortScan,1897-1897,[			throw StandardException.newException(],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/store/access/RAMTransaction.java,openSortCostController,1863-1863,[		if (implementation == null)],,
STYLE,NS_NON_SHORT_CIRCUIT,org/apache/derby/impl/store/access/RAMTransaction.java,defragmentConglomerate,1519-1519,[			if (!(lock_level == MODE_RECORD |],,
STYLE,NS_NON_SHORT_CIRCUIT,org/apache/derby/impl/store/access/RAMTransaction.java,openGroupFetchScan,1388-1388,[			if (!(lock_level == MODE_RECORD |],,
STYLE,NS_NON_SHORT_CIRCUIT,org/apache/derby/impl/store/access/RAMTransaction.java,openScan,510-510,[            if (!((lock_level == MODE_RECORD | lock_level == MODE_TABLE)))],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/impl/store/access/RAMTransaction.java,openSortCostController,1863-1863,[		if (implementation == null)],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/store/access/RAMTransaction.java,debugOpened,931-931,[                str += "open scan controller: " + sc + "\n";],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/store/access/RAMTransaction.java,countOpens,733-752,[        switch (which_to_count),         {,             case OPEN_CONGLOMERATE:,                 ret_val = conglomerateControllers.size();,                 break;,             case OPEN_SCAN:,                 ret_val = scanControllers.size();,                 break;,             case OPEN_CREATED_SORTS:,                 ret_val = countCreatedSorts();,                 break;,             case OPEN_SORT:,                 ret_val = ,                     ((sortControllers != null) ? sortControllers.size() : 0);,                 break;,             case OPEN_TOTAL:,                 ret_val = ,                     conglomerateControllers.size() + scanControllers.size() +,                     ((sortControllers != null) ? sortControllers.size() : 0) +,                     countCreatedSorts();],,
CORRECTNESS,SIO_SUPERFLUOUS_INSTANCEOF,org/apache/derby/impl/store/access/RAMTransaction.java,openCompiledScan,1599-1599,[            SanityManager.ASSERT(],,
CORRECTNESS,SIO_SUPERFLUOUS_INSTANCEOF,org/apache/derby/impl/store/access/RAMTransaction.java,openCompiledScan,1601-1601,[            SanityManager.ASSERT(],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/store/access/RAMTransaction.java,closeControllers,245-245,[                if (sc.closeForEndTransaction(closeHeldControllers))],,closeControllers,271-271,[                if (cc.closeForEndTransaction(closeHeldControllers))],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/derby/impl/store/access/RAMTransaction.java,debugOpened,971-971,[					Conglomerate c = tempCongloms.get(conglomId);],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/impl/store/access/StorableFormatId.java,,50-275,[    private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( StorableFormatId.class);, ,     public int estimateMemoryUsage(),     {,         return BASE_MEMORY_USAGE;,     }, ,     /* Constructors: */, ,     public StorableFormatId(),     {,     }, ,     public StorableFormatId(int value),     {,         this.format_id = value;,     }, ,     /* Private methods */, ,     public int getValue(),     {,         // RESOLVE (mikem) just temporary; value could be null,         return format_id;,     }, ,     public void setValue(int input_value),     {,         this.format_id = input_value;,     }, , 	/*, 	 * Storable interface, implies Externalizable, TypedFormat, 	 */, , 	/**, 		Return my format identifier., , 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId, 	*/, 	public int getTypeFormatId(),     {, 		return StoredFormatIds.ACCESS_FORMAT_ID;, 	}, ,     public boolean isNull(),     {,         return false;,     }, , 	public void writeExternal(ObjectOutput out) throws IOException,     {,        FormatIdUtil.writeFormatIdInteger(out, format_id);,     }, , 	/** @see java.io.Externalizable#readExternal */, 	public void readExternal(ObjectInput in) throws IOException,     {,         format_id = FormatIdUtil.readFormatIdInteger(in);,     }, ,     public void restoreToNull(),     {,         format_id = 0;,     }, ,     /**************************************************************************,      * Public Methods implementing DataValueDescriptor interface.,      **************************************************************************,      */, , 	/**, 	 * Gets the length of the data value.  The meaning of this is, 	 * implementation-dependent.  For string types, it is the number of, 	 * characters in the string.  For numeric types, it is the number of, 	 * bytes used to store the number.  This is the actual length, 	 * of this value, not the length of the type it was defined as., 	 * For example, a VARCHAR value may be shorter than the declared, 	 * VARCHAR (maximum) length., 	 *, 	 * @return	The length of the data value, 	 *, 	 * @exception StandardException   On error,      * ,      * @see org.apache.derby.iapi.types.DataValueDescriptor#getLength, 	 */, 	public int	getLength() ,         throws StandardException,     {,         throw(StandardException.newException(,                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));,     }, 	/**, 	 * Gets the value in the data value descriptor as a String., 	 * Throws an exception if the data value is not a string., 	 *, 	 * @return	The data value as a String., 	 *, 	 * @exception StandardException   Thrown on error,      *,      * @see org.apache.derby.iapi.types.DataValueDescriptor#getString, 	 */, 	public String	getString() throws StandardException,     {,         throw(StandardException.newException(,                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));,     }, , 	/**, 	 * Gets the value in the data value descriptor as a Java Object., 	 * The type of the Object will be the Java object type corresponding, 	 * to the data value's SQL type. JDBC defines a mapping between Java, 	 * object types and SQL types - we will allow that to be extended, 	 * through user type definitions. Throws an exception if the data, 	 * value is not an object (yeah, right)., 	 *, 	 * @return	The data value as an Object., 	 *, 	 * @exception StandardException   Thrown on error,      *,      * @see org.apache.derby.iapi.types.DataValueDescriptor#getObject, 	 */, 	public Object	getObject() throws StandardException,     {,         return(this);,     }, , 	/**,      * @see org.apache.derby.iapi.types.DataValueDescriptor#cloneValue, 	 */,     public DataValueDescriptor cloneValue(boolean forceMaterialization),     {,         if (SanityManager.DEBUG),             SanityManager.THROWASSERT("Not implemented!.");, ,         return(null);,     }, , 	/**, 	 * Get a new null value of the same type as this data value., 	 *,      * @see org.apache.derby.iapi.types.DataValueDescriptor#getNewNull, 	 */, 	public DataValueDescriptor getNewNull(),     {,         if (SanityManager.DEBUG),             SanityManager.THROWASSERT("Not implemented!.");, ,         return(null);,     }, , 	/**, 	 * Set the value based on the value for the specified DataValueDescriptor, 	 * from the specified ResultSet., 	 *, 	 * @param resultSet		The specified ResultSet., 	 * @param colNumber		The 1-based column # into the resultSet., 	 * @param isNullable	Whether or not the column is nullable, 	 *						(No need to call wasNull() if not), 	 * , 	 * @exception StandardException		Thrown on error, 	 * @exception SQLException		Error accessing the result set,      *,      * @see org.apache.derby.iapi.types.DataValueDescriptor#setValueFromResultSet, 	 */, 	public void setValueFromResultSet(,     ResultSet   resultSet, ,     int         colNumber,,     boolean     isNullable), 		throws StandardException, SQLException,     {,         throw(StandardException.newException(,                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));,     }, , 	/**, 	 * Set the value of this DataValueDescriptor from another., 	 *, 	 * @param theValue	The Date value to set this DataValueDescriptor to, 	 *,      * @see org.apache.derby.iapi.types.DataValueDescriptor#setValue, 	 */, 	protected void setFrom(DataValueDescriptor theValue) ,         throws StandardException,     {,         throw(StandardException.newException(,                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));,     }, , 	/**, 	 * Get the SQL name of the datatype, 	 *, 	 * @return	The SQL name of the datatype,      *,      * @see org.apache.derby.iapi.types.DataValueDescriptor#getTypeName, 	 */, 	public String	getTypeName(),     {,         if (SanityManager.DEBUG),             SanityManager.THROWASSERT("Not implemented!.");, ,         return(null);,     }, , 	/**, 	 * Compare this Orderable with a given Orderable for the purpose of, 	 * index positioning.  This method treats nulls as ordered values -, 	 * that is, it treats SQL null as equal to null and less than all, 	 * other values., 	 *, 	 * @param other		The Orderable to compare this one to., 	 *, 	 * @return  <0 - this Orderable is less than other., 	 * 			 0 - this Orderable equals other., 	 *			>0 - this Orderable is greater than other.,      *,      *			The code should not explicitly look for -1, or 1., 	 *, 	 * @exception StandardException		Thrown on error,      *,      * @see DataValueDescriptor#compare, 	 */, 	public int compare(DataValueDescriptor other) ,         throws StandardException, 	{,         throw(StandardException.newException(],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/store/access/btree/BTree.java,create,480-480,[        uniqueWithDuplicateNulls = new Boolean (result_string).booleanValue();],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/impl/store/access/btree/BTree.java,create,490-490,[                maxRowsPerPage = Integer.parseInt(result_string);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/store/access/btree/index/B2I.java,writeExternal_v10_2,1079-1079,[        FormatableBitSet ascDescBits = ],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/store/access/btree/index/B2I.java,readExternal,1153-1153,[        collation_ids = new int[format_ids.length];],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/BTreeController.java,do_load_split,1172-1172,[        leaf = null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/btree/BTreeController.java,getTableProperties,1420-1420,[            throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/btree/BTreeController.java,insert,1361-1361,[                throw StandardException.newException(],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/access/btree/BTreeController.java,reclaim_deleted_rows,133-133,[            if ((controlRow = ControlRow.get(open_btree, pageno)) == null)],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/BTreeMaxScan.java,moveToLeftSibling,134-134,[                leftPage = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/BTreePostCommit.java,doShrink,127-127,[        root = null;],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/derby/impl/store/access/btree/BTreeRowPosition.java,toString,203-203,[                super.toString() + ],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/derby/impl/store/access/btree/BTreeScan.java,reposition,882-882,[                SanityManager.THROWASSERT(],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/derby/impl/store/access/btree/BTreeScan.java,toString,2169-2169,[                "\n\tbtree = " + this.getConglomerate() +],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/derby/impl/store/access/btree/BTreeScan.java,toString,2198-2198,[                     Integer.toString(init_startSearchOperator))) +],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/store/access/btree/BTreeScan.java,reposition,890-890,[            throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/btree/BTreeScan.java,delete,1121-1121,[                throw StandardException.newException(],,delete,1124-1124,[                        new Long(scan_position.current_rh.getPageNumber()),],,delete,1125-1125,[                        new Long(scan_position.current_rh.getId()));],,delete,1163-1163,[                        throw StandardException.newException(],,delete,1166-1166,[                                new Long(scan_position.current_rh.getPageNumber()),],,delete,1167-1167,[                                new Long(scan_position.current_rh.getId()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/btree/BTreeScan.java,fetch,1357-1357,[                throw StandardException.newException(],,fetch,1360-1360,[                        new Long(scan_position.current_rh.getPageNumber()),],,fetch,1361-1361,[                        new Long(scan_position.current_rh.getId()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/btree/BTreeScan.java,reposition,873-873,[            throw StandardException.newException(],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/BranchControlRow.java,restartSplitFor,211-211,[        child  = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/BranchControlRow.java,restartSplitFor,210-210,[        parent = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/BranchControlRow.java,splitFor,781-781,[            newbranchrow = null;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/btree/ControlRow.java,compareRowsOnSiblings,1495-1495,[                    left_sib.page.fetchFromSlot(],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/btree/ControlRow.java,compareRowsOnSiblings,1501-1501,[                    right_sib.page.fetchFromSlot(],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/btree/ControlRow.java,checkRowOrder,1434-1434,[                   page.fetchFromSlot(],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/btree/ControlRow.java,checkRowOrder,1430-1430,[                   page.fetchFromSlot(],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/impl/store/access/btree/ControlRow.java,compareIndexRowFromPageToKey,1289-1289,[					return -r;],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/impl/store/access/btree/ControlRow.java,compareIndexRowToKey,1344-1344,[					return -r;],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/derby/impl/store/access/btree/D_BTreeController.java,diag_onelevel,204-204,[            "\tpage overhead bytes   = " + prop.getProperty(Page.DIAG_PAGEOVERHEAD) + " bytes per page.\n"         +],,diag_onelevel,212-212,[            out_summary(],,diag_onelevel,217-217,[            out_summary(],,diag_onelevel,222-222,[            out_summary(],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/store/access/btree/D_BTreeController.java,diag_tabulate,311-311,[            ret_string += diag_onelevel(prop, li);],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/store/access/btree/D_BTreeController.java,olddiag_tabulate,348-348,[            ret_string += ],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/store/access/btree/D_BTreeController.java,olddiag_tabulate,321-362,[        String ret_string   = "";,         long   total_pages  = 0;,         long   total_res    = 0;, ,         for (int level = 0; level < level_info.length; level++) ,         {,             total_pages += level_info[level].num_pages;,         }, , ,         // Totals:,         ret_string += ,             "Btree conglom has:\n" + ,             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +,             "\t" + total_pages               + " total pages ("                +,                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * ,                      total_pages) + " bytes)\n"                                +,             "\t" + level_info.length         + " total levels\n"               +,             "\t" + level_info[0].num_entries + " total user records\n";, ,         // Totals by level:,         for (int level = 0; level < level_info.length; level++) ,         {,             LevelInfo   li = level_info[level];, ,             ret_string += "level[" + level + "] stats:\n";, ,             ret_string += ,                 "\t# of pages           = " + li.num_pages      + ".\n" +,                 "\t# of entries         = " + li.num_entries    + ".  " +,                 "(" + (li.num_entries / li.num_pages) + " entries/page).\n" +,                 "\t# of deleted entries = " + li.num_deleted    + ".  " +,                 "(" + (li.num_deleted / li.num_pages) + " deleted/page).\n" +,                 "\t# of free bytes      = " + li.num_res_bytes + ".  " +,                 "(" + (li.num_res_bytes / li.num_pages) + " reserved bytes/page).\n" +,                 "\t# of free bytes      = " + li.num_free_bytes + ".  " +,                 "(" + (li.num_free_bytes / li.num_pages) + " free bytes/page).\n" +,                 "\t# of slot table bytes= " + li.num_slottab_bytes + ".  " +,                 "(" + (li.num_slottab_bytes / li.num_pages) + " slot table bytes/page).\n";,         }, ,         return(ret_string);],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/LeafControlRow.java,splitFor,731-731,[        branchrow = null;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/store/access/btree/LeafControlRow.java,growRoot,912-912,[        if (leafroot != null)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/access/btree/LeafControlRow.java,growRoot,910-910,[        if (branchroot != null)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/access/btree/LeafControlRow.java,allocate,914-914,[        if (newleaf != null)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/impl/store/access/btree/LeafControlRow.java,growRoot,912-912,[        if (leafroot != null)],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/btree/OpenBTree.java,checkConsistency,272-272,[                throw(StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/btree/OpenBTree.java,init,397-397,[            throw StandardException.newException(],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/impl/store/access/btree/SearchParameters.java,<init>,161-161,[		this.searchKey              = searchKey;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/impl/store/access/btree/SearchParameters.java,<init>,163-163,[		this.template               = template;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/access/btree/index/B2I.java,open,819-819,[		b2ic.init(],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/access/btree/index/B2I.java,openScan,865-865,[		b2is.init(xact_manager, rawtran, ],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/impl/store/access/btree/index/B2I.java,,243-1200,[public class B2I extends BTree, {,     private static final String PROPERTY_BASECONGLOMID = "baseConglomerateId";,     private static final String PROPERTY_ROWLOCCOLUMN  = "rowLocationColumn";, ,     static final int FORMAT_NUMBER = StoredFormatIds.ACCESS_B2I_V5_ID;, , 	/*, 	** Fields of B2I., 	*/, , 	/**, 	The id of the conglomerate which contains the base table., 	Row locations inserted into this secondary index are assumed, 	to refer to that conglomerate.  Used to obtain table/row locks on the,     base table rows which the index rows point at., 	**/, 	long baseConglomerateId;, , 	/**, 	The column id (zero-based integer index) of the column which holds the row ,     location to the base conglomerate., 	The default value of RowLocationColumn is the last key column.,     Used to obtain table/row locks on the base table rows with the index rows,     point at., 	Currently, RowLocationColumn must be the last key column., 	**/, 	int rowLocationColumn;, ,     private static final int BASE_MEMORY_USAGE = ,         ClassSize.estimateBaseFromCatalog( B2I.class);, ,     public int estimateMemoryUsage(),     {,         return BASE_MEMORY_USAGE;,     }, ,     /**************************************************************************,      * Constructors for This class:,      **************************************************************************,      */, ,     /**************************************************************************,      * Protected locking implmentations of abtract BTree routines:,      *     getBtreeLockingPolicy,      *     lockTable,      **************************************************************************,      */, ,     /**,      * Create a new btree locking policy from scratch.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     protected BTreeLockingPolicy getBtreeLockingPolicy(,     Transaction             rawtran,,     int                     lock_level,,     int                     mode,,     int                     isolation_level,,     ConglomerateController  base_cc,,     OpenBTree               open_btree), 		throws StandardException,     {,         BTreeLockingPolicy ret_locking_policy = null;, ,         if (SanityManager.DEBUG),         {,             SanityManager.ASSERT(,                 (isolation_level == ,                      TransactionController.ISOLATION_SERIALIZABLE)      ||,                 (isolation_level == ,                      TransactionController.ISOLATION_REPEATABLE_READ)   ||,                 (isolation_level == ,                      TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK) ||,                 (isolation_level == ,                      TransactionController.ISOLATION_READ_COMMITTED)    ||,                 (isolation_level == ,                      TransactionController.ISOLATION_READ_UNCOMMITTED),,                 "bad isolation_level = " + isolation_level);,         }, ,         if (lock_level == TransactionController.MODE_TABLE),         {,             ret_locking_policy = ,                 new B2ITableLocking3(,                     rawtran,,                     lock_level,,                     rawtran.newLockingPolicy(,                         LockingPolicy.MODE_CONTAINER, ,                         isolation_level,,                         true), ,                     base_cc,,                     open_btree);,         },         else if (lock_level == TransactionController.MODE_RECORD),         {,             if (isolation_level == TransactionController.ISOLATION_SERIALIZABLE),             {,                 ret_locking_policy = ,                     new B2IRowLocking3(,                         rawtran,,                         lock_level,,                         rawtran.newLockingPolicy(,                             LockingPolicy.MODE_RECORD, ,                             isolation_level,,                             true), ,                         base_cc,,                         open_btree);,             },             else if ((isolation_level == ,                         TransactionController.ISOLATION_REPEATABLE_READ)),             {,                 ret_locking_policy = ,                     new B2IRowLockingRR(,                         rawtran,,                         lock_level,,                         rawtran.newLockingPolicy(,                             LockingPolicy.MODE_RECORD, ,                             isolation_level,,                             true), ,                         base_cc,,                         open_btree);,             },             else if ((isolation_level == ,                         TransactionController.ISOLATION_READ_COMMITTED) ||,                      (isolation_level == ,                         TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK)),             {,                 ret_locking_policy = ,                     new B2IRowLocking2(,                         rawtran,,                         lock_level,,                         rawtran.newLockingPolicy(,                             LockingPolicy.MODE_RECORD, ,                             isolation_level,,                             true), ,                         base_cc,,                         open_btree);,             },             else if (isolation_level == ,                         TransactionController.ISOLATION_READ_UNCOMMITTED),             {,                 ret_locking_policy = ,                     new B2IRowLocking1(,                         rawtran,,                         lock_level,,                         rawtran.newLockingPolicy(,                             LockingPolicy.MODE_RECORD, ,                             isolation_level,,                             true), ,                         base_cc,,                         open_btree);,             },         }, , ,         if (SanityManager.DEBUG),         {,             SanityManager.ASSERT(,                 ret_locking_policy != null, "ret_locking_policy == null");,         }, ,         return(ret_locking_policy);,     }, ,     /**,      * Lock the base table.,      * <p>,      * Assumes that segment of the base container is the same as the segment,      * of the btree segment.,      * <p>,      * RESOLVE - we really want to get the lock without opening the container.,      * raw store will be providing this.,      *,      * @param xact_manager Transaction to associate the lock with.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public final ConglomerateController lockTable(,     TransactionManager  xact_manager,,     int                 open_mode,,     int                 lock_level,,     int                 isolation_level), 		throws StandardException,     {,         open_mode |= TransactionController.OPENMODE_FOR_LOCK_ONLY;, ,         // open the base conglomerate - just to get the table lock.,         ConglomerateController cc = ,             xact_manager.openConglomerate(,                 this.baseConglomerateId, false, open_mode, lock_level, ,                 isolation_level);, ,         return(cc);,     },     ,     /**************************************************************************, 	 *  Private methods of B2I, arranged alphabetically.,      **************************************************************************,      */, , ,     private void traverseRight(),     {,         // RESOLVE - Do I have to do this???????????????, , 		if (SanityManager.DEBUG), 			SanityManager.THROWASSERT("not implemented.");,     }, , , 	/*, 	** Methods of B2I., 	*/, , 	/**, 	Create an empty secondary index b-tree, using the generic b-tree to do the,     generic part of the creation process., ,     This routine opens the newly created container, adds a single page, and,     makes this page the root by inserting a LeafControlRow onto this page,     at slot 0 and marking in that control row that the page is a root page., ,     The following properties are specific to the b-tree secondary index:,     <UL>,     <LI> "baseConglomerateId" (integer).  The conglomerate id of the base,     conglomerate is never actually accessed by the b-tree secondary,     index implementation, it only serves as a namespace for row locks.,     This property is required.,     <LI> "rowLocationColumn" (integer).  The zero-based index into the row which,     the b-tree secondary index will assume holds a @see RowLocation of,     the base row in the base conglomerate.  This value will be used,     for acquiring locks.  In this implementation RowLocationColumn must be ,     the last key column.,     This property is required.,     </UL>, ,     A secondary index i (a, b) on table t (a, b, c) would have rows,     which looked like (a, b, row_location).  baseConglomerateId is set to the,     conglomerate id of t.  rowLocationColumns is set to 2.  allowsDuplicates,     would be set to false, @see BTree#create.  To create a unique,     secondary index set uniquenessColumns to 2, this means that the btree,     code will compare the key values but not the row id when determing,     uniqueness.  To create a nonunique secondary index set uniquenessColumns,     to 3, this would mean that the uniqueness test would include the row,     location and since all row locations will be unique  all rows inserted ,     into the index will be differentiated (at least) by row location.  , , 	@see BTree#create, , 	@exception StandardException Standard exception policy., 	**/, 	public void create(,     TransactionManager      xact_manager,,     int                     segmentId, ,     long                    input_conglomid, ,     DataValueDescriptor[]	template, , 	ColumnOrdering[]	    columnOrder,,     int[]                   collationIds,,     Properties              properties,, 	int                     temporaryFlag), 		throws StandardException, 	{,         String      property_value = null;,         Transaction rawtran        = xact_manager.getRawStoreXact();, ,         if (properties == null),         {,             throw(StandardException.newException(,                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));,         }, ,         // Get baseConglomerateId //,         property_value = properties.getProperty(PROPERTY_BASECONGLOMID);,         if (property_value == null),         {,             throw(StandardException.newException(,                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));,         }, ,         if (SanityManager.DEBUG),         {, 			if (property_value == null),             	SanityManager.THROWASSERT(,                 	PROPERTY_BASECONGLOMID +, 					"property not passed to B2I.create()");,         }, ,         baseConglomerateId = Long.parseLong(property_value);, ,         // Get rowLocationColumn //,         property_value = properties.getProperty(PROPERTY_ROWLOCCOLUMN);, ,         if (SanityManager.DEBUG),         {, 			if (property_value == null),             	SanityManager.THROWASSERT(,                 	PROPERTY_ROWLOCCOLUMN +, 					"property not passed to B2I.create()");,         }, ,         if (property_value == null),         {,             throw(StandardException.newException(,                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));,         }, ,         rowLocationColumn = Integer.parseInt(property_value);, ,         // Currently the row location column must be the last column (makes),         // comparing the columns in the index easier.,         if (SanityManager.DEBUG),         {,             SanityManager.ASSERT(rowLocationColumn == template.length - 1, ,                 "rowLocationColumn is not the last column in the index");,             SanityManager.ASSERT(,                 template[rowLocationColumn] instanceof ,                     RowLocation);, ,             // There must be at least one key column, 			if (rowLocationColumn < 1),             	SanityManager.THROWASSERT(, 					"rowLocationColumn (" + rowLocationColumn +, 					") expected to be >= 1");,         }, , , 		/* convert the sorting order information into a boolean array map., 		 * If the sorting order for the columns is not provided, we, 		 * assign the default as Ascending Order., 		 * array length is equal to template length, because column order, 		 * length changes whether it is unique or is non unique. store assumes, 		 * template length arrays. So, we make template length array and make, 		 * the last column as ascending instead of having lot of execeptions ,          * code., 		 */, 		, 		ascDescInfo = new boolean[template.length];, 		for (int i=0 ; i < ascDescInfo.length; i++), 		{, 			if (columnOrder != null && i < columnOrder.length), 				ascDescInfo[i] = columnOrder[i].getIsAscending();, 			else, 				ascDescInfo[i] = true;  // default values - ascending order, 		}, ,         // get collation ids from input collation ids, store it in the ,         // conglom state.,         collation_ids = ,             ConglomerateUtil.createCollationIds(template.length, collationIds);,         hasCollatedTypes = hasCollatedColumns(collation_ids);, , 		// Do the generic part of creating the b-tree., 		super.create(,             rawtran, segmentId, input_conglomid, template, ,             properties, getTypeFormatId(), temporaryFlag);, ,         // open the base conglomerate - to get the lock,         ConglomerateController base_cc = ,             xact_manager.openConglomerate(,                 baseConglomerateId,,                 false,,                 TransactionController.OPENMODE_FOR_LOCK_ONLY, ,                 TransactionController.MODE_TABLE,,                 TransactionController.ISOLATION_SERIALIZABLE);,         ,         OpenBTree open_btree = new OpenBTree();, ,         BTreeLockingPolicy b2i_locking_policy = ,             new B2ITableLocking3(,                 rawtran,,                 TransactionController.MODE_TABLE,,                 rawtran.newLockingPolicy(,                     LockingPolicy.MODE_CONTAINER,,                     TransactionController.ISOLATION_SERIALIZABLE, true), ,                 base_cc, open_btree);, , ,         // The following call will "open" the new btree.  Create is,         // an interesting case.  What we really want is read only table lock,         // on the base conglomerate and update locks on the index.  For now,         // just get the update lock on the base table, this is done by the,         // lockTable() call made by base class., ,         open_btree.init(,             (TransactionManager) xact_manager,  // current user xact,             (TransactionManager) xact_manager,  // current xact,             (ContainerHandle) null,     // have init open the container.,             rawtran, ,             false,,             (ContainerHandle.MODE_FORUPDATE),,             TransactionController.MODE_TABLE,,             b2i_locking_policy,         // get table level lock.,             this,                       ,             (LogicalUndo) null,         // no logical undo necessary, as ,                                         // initEmptyBtree(),                                         // work will be done single user and,                                         // rows will not move.,             (DynamicCompiledOpenConglomInfo) null);,                                         , 		// Open the newly created container, and insert the first control row.,         LeafControlRow.initEmptyBtree(open_btree);, ,         open_btree.close();, ,         base_cc.close();, 	}, , , , 	/*, 	** Methods of Conglomerate, 	*/, ,     /**,      * Retrieve the maximum value row in an ordered conglomerate.,      * <p>,      * Returns true and fetches the rightmost row of an ordered conglomerate ,      * into "fetchRow" if there is at least one row in the conglomerate.  If,      * there are no rows in the conglomerate it returns false.,      * <p>,      * Non-ordered conglomerates will not implement this interface, calls,      * will generate a StandardException.,      * <p>,      * RESOLVE - this interface is temporary, long term equivalent (and more) ,      * functionality will be provided by the openBackwardScan() interface.  ,      *, 	 * @param xact_manager    The TransactionController under which this ,      *                        operation takes place.,      *, 	 * @param conglomId       The identifier of the conglomerate, 	 *                        to open the scan for.,      *, 	 * @param open_mode       Specifiy flags to control opening of table.  ,      *                        OPENMODE_FORUPDATE - if set open the table for,      *                        update otherwise open table shared.,      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).,      *,      * @param isolation_level The isolation level to lock the conglomerate at.,      *                        One of (ISOLATION_READ_COMMITTED or ,      *                        ISOLATION_SERIALIZABLE).,      *, 	 * @param scanColumnList  A description of which columns to return from ,      *                        every fetch in the scan.  template, ,      *                        and scanColumnList work together,      *                        to describe the row to be returned by the scan - ,      *                        see RowUtil for description of how these three ,      *                        parameters work together to describe a "row".,      *,      * @param fetchRow        The row to retrieve the maximum value into.,      *, 	 * @return boolean indicating if a row was found and retrieved or not.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public boolean fetchMaxOnBTree(,     TransactionManager      xact_manager,,     Transaction             rawtran,,     long                    conglomId,,     int                     open_mode,,     int                     lock_level,,     LockingPolicy           locking_policy,,     int                     isolation_level,,     FormatableBitSet                 scanColumnList,,     DataValueDescriptor[]   fetchRow),         throws StandardException,     {,         boolean row_exists;, ,         // row level locking implementation., ,         // RESOLVE (revisit implementation after all the Xena rowlocking,         // changes have been made).  Can probably come up with single,         // path implementation.,         ,         // Create a new b-tree secondary index scan.,         B2IMaxScan b2is = new B2IMaxScan();, ,         // Initialize it.,         b2is.init(,             xact_manager, ,             rawtran, ,             open_mode,,             lock_level,,             locking_policy,,             isolation_level,,             true /* get locks on base table as part of open */,,             scanColumnList,,             this, ,             new B2IUndo());, ,         row_exists = b2is.fetchMax(fetchRow);, ,         b2is.close();, ,         return(row_exists);,     }, , , 	/**, 	Bulk Load a B-tree secondary index., , 	@see Conglomerate#load, 	@exception StandardException Standard Derby Error policy., 	raise SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION if a duplicate ,     key is detected in the load., 	**/, , 	public long load(, 	TransactionManager      xact_manager,, 	boolean                 createConglom,, 	RowLocationRetRowSource rowSource), 		 throws StandardException, 	{,         long num_rows_loaded = 0;, 		B2IController b2ic = new B2IController();, , 		try, 		{,             int open_mode = TransactionController.OPENMODE_FORUPDATE;, ,             if (createConglom),             {,                 open_mode |=,                     (ContainerHandle.MODE_UNLOGGED |,                      ContainerHandle.MODE_CREATE_UNLOGGED);,             }, ,             // Do the actual open of the container in the super class.,             b2ic.init(,                 xact_manager,                    // current transaction   ,                 xact_manager.getRawStoreXact(),  // current raw store xact,                 false,                           // Not holdable,                 open_mode,,                 TransactionController.MODE_TABLE,,                 xact_manager.getRawStoreXact().newLockingPolicy(,                     LockingPolicy.MODE_CONTAINER,,                     TransactionController.ISOLATION_SERIALIZABLE, true),,                 true,,                 this, ,                 new B2IUndo(),,                 (B2IStaticCompiledInfo) null,,                 (DynamicCompiledOpenConglomInfo) null);, ,             num_rows_loaded = b2ic.load(xact_manager, createConglom, rowSource);, , 		}, 		finally, 		{, 			b2ic.close();, 		}, ,         return(num_rows_loaded);, 	}, , 	/**, 	Open a b-tree controller., 	@see Conglomerate#open, , 	@exception StandardException Standard exception policy., 	**/, 	public ConglomerateController open(,     TransactionManager              xact_manager,,     Transaction                     rawtran, ,     boolean                         hold,,     int                             open_mode,,     int                             lock_level,,     LockingPolicy                   locking_policy,,     StaticCompiledOpenConglomInfo   static_info,,     DynamicCompiledOpenConglomInfo  dynamic_info), 		throws StandardException, 	{, 		// Create a new b-tree secondary index controller., 		B2IController b2ic = new B2IController();, , 		// Do the actual open of the container in the super class., 		b2ic.init(,             xact_manager,               // current transaction   ,             rawtran,                    // current raw store transaction,             hold,                       // holdability,             open_mode,,             lock_level,,             locking_policy,,             true,,             this, ,             new B2IUndo(),,             (B2IStaticCompiledInfo) static_info,,             dynamic_info);, , 		// Return it to the caller., 		return b2ic;, 	}, , 	/**, 	Open a b-tree secondary index scan controller., 	@see Conglomerate#openScan, 	@see BTree#openScan, , 	@exception StandardException Standard exception policy., 	**/, 	public ScanManager openScan(,     TransactionManager              xact_manager,,     Transaction                     rawtran,,     boolean                         hold,,     int                             open_mode,,     int                             lock_level,,     LockingPolicy                   locking_policy,,     int                             isolation_level,, 	FormatableBitSet                         scanColumnList,,     DataValueDescriptor[]			startKeyValue,,     int                             startSearchOperator,,     Qualifier                       qualifier[][],,     DataValueDescriptor[]			stopKeyValue,,     int                             stopSearchOperator,,     StaticCompiledOpenConglomInfo   static_info,,     DynamicCompiledOpenConglomInfo  dynamic_info), 			throws StandardException, 	{, 		// Create a new b-tree secondary index scan., 		B2IForwardScan b2is = new B2IForwardScan();, , 		// Initialize it., 		b2is.init(xact_manager, rawtran, ,                   hold,,                   open_mode,,                   lock_level,,                   locking_policy,,                   isolation_level,,                   true /* get locks on base table as part of open */,,                   scanColumnList,,                   startKeyValue, startSearchOperator,,                   qualifier,,                   stopKeyValue, stopSearchOperator, this, new B2IUndo(),,                   (B2IStaticCompiledInfo) static_info,,                   dynamic_info);, , 		// Return it to the caller., 		return b2is;, 	}, ,     /**,      * Open a b-tree compress scan.,      * <p>,      * B2I does not support a compress scan.,      * <p>, 	 * @see Conglomerate#defragmentConglomerate,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public ScanManager defragmentConglomerate(,     TransactionManager              xact_manager,,     Transaction                     rawtran,,     boolean                         hold,,     int                             open_mode,,     int                             lock_level,,     LockingPolicy                   locking_policy,,     int                             isolation_level), 			throws StandardException, 	{,         throw StandardException.newException(,             SQLState.BTREE_UNIMPLEMENTED_FEATURE);, 	}, , 	public void purgeConglomerate(,     TransactionManager              xact_manager,,     Transaction                     rawtran),         throws StandardException,     {,         // currently on work to do in btree's for purge rows, purging,         // happens best when split is about to happen.,         return;,     }, , 	public void compressConglomerate(,     TransactionManager              xact_manager,,     Transaction                     rawtran),         throws StandardException,     {, 		B2IController b2ic = new B2IController();, , 		try, 		{,             int open_mode = TransactionController.OPENMODE_FORUPDATE;, ,             // Do the actual open of the container in the super class.,             b2ic.init(,                 xact_manager,                    // current transaction   ,                 xact_manager.getRawStoreXact(),  // current raw store xact,                 false,                           // Not holdable,                 open_mode,,                 TransactionController.MODE_TABLE,,                 xact_manager.getRawStoreXact().newLockingPolicy(,                     LockingPolicy.MODE_CONTAINER,,                     TransactionController.ISOLATION_SERIALIZABLE, true),,                 true,,                 this, ,                 new B2IUndo(),,                 (B2IStaticCompiledInfo) null,,                 (DynamicCompiledOpenConglomInfo) null);, ,             b2ic.getContainer().compressContainer();, , 		}, 		finally, 		{, 			b2ic.close();, 		}, ,         return;,     }, ,     /**,      * Return an open StoreCostController for the conglomerate.,      * <p>,      * Return an open StoreCostController which can be used to ask about ,      * the estimated row counts and costs of ScanController and ,      * ConglomerateController operations, on the given conglomerate.,      * <p>, 	 * @param xact_manager The TransactionController under which this ,      *                     operation takes place., 	 * @param rawtran  raw transaction context in which scan is managed.,      *, 	 * @return The open StoreCostController.,      *, 	 * @exception  StandardException  Standard exception policy.,      *,      * @see StoreCostController,      **/,     public StoreCostController openStoreCost(,     TransactionManager  xact_manager,,     Transaction         rawtran), 		throws StandardException,     {,         B2ICostController b2icost = new B2ICostController();, ,         b2icost.init(xact_manager, this, rawtran);, ,         return(b2icost);,     }, , 	/**, 	Drop this b-tree secondary index., 	@see Conglomerate#drop, 	@see BTree#drop, , 	@exception StandardException Standard exception policy., 	**/, 	public void drop(TransactionManager xact_manager), 		throws StandardException, 	{,         // HACK to get around problem where index is dropped after the base,         // table.,         ConglomerateController base_cc = null;, , ,         /* Get X table lock to make sure no thread is accessing index */,         base_cc = ,             lockTable(,                 xact_manager, ,                 TransactionController.OPENMODE_FORUPDATE, ,                 TransactionController.MODE_TABLE,,                 TransactionController.ISOLATION_REPEATABLE_READ);, ,         xact_manager.getRawStoreXact().dropContainer(id);, ,         if (base_cc != null),             base_cc.close();, 	}, ,     /**,      * Return static information about the conglomerate to be included in a,      * a compiled plan.,      * <p>,      * The static info would be valid until any ddl was executed on the ,      * conglomid, and would be up to the caller to throw away when that ,      * happened.  This ties in with what language already does for other ,      * invalidation of static info.  The type of info in this would be ,      * containerid and array of format id's from which templates can be created.,      * The info in this object is read only and can be shared among as many ,      * threads as necessary.,      * <p>,      *, 	 * @return The static compiled information.,      *,      * @param conglomId The identifier of the conglomerate to open.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(,     TransactionController   xact_manager,,     long                    conglomId), 		throws StandardException,     {,         return(new B2IStaticCompiledInfo(xact_manager, this));,     }, , 	/*, 	** Methods of Storable (via Conglomerate via BTree)., 	** This class is responsible for re/storing its, 	** own state and calling its superclass to store its'., 	*/, , , 	/*, 	 * Storable interface, implies Externalizable, TypedFormat, 	 */, , , 	/**, 		Return my format identifier., , 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId, 	*/, 	public int getTypeFormatId() ,     {, 		return StoredFormatIds.ACCESS_B2I_V5_ID;, 	}, , ,     /**,      * Store the stored representation of the column value in the,      * stream.,      * <p>,      * For more detailed description of the ACCESS_B2I_V3_ID format see ,      * documentation at top of file.,      *,      * @see java.io.Externalizable#writeExternal,      **/, 	public void writeExternal_v10_2(ObjectOutput out) ,         throws IOException ,     {, 		super.writeExternal(out);, 		out.writeLong(baseConglomerateId);, 		out.writeInt(rowLocationColumn);, ,         //write the columns ascend/descend information as bits,         FormatableBitSet ascDescBits = ,             new FormatableBitSet(ascDescInfo.length);, ,         for (int i = 0; i < ascDescInfo.length; i++),         {	,             if (ascDescInfo[i]),                 ascDescBits.set(i);,         },         ascDescBits.writeExternal(out);, 	}, ,     /**,      * Store the stored representation of the column value in the,      * stream.,      * <p>,      * For more detailed description of the ACCESS_B2I_V3_ID and ,      * ACCESS_B2I_V4_ID formats see documentation at top of file.,      *,      * @see java.io.Externalizable#writeExternal,      **/, 	public void writeExternal_v10_3(ObjectOutput out) ,         throws IOException ,     {,         // First part of ACCESS_B2I_V4_ID format is the ACCESS_B2I_V3_ID format.,         writeExternal_v10_2(out);, 		if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V4_ID,                 || conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID),         {,             // Now append sparse array of collation ids,             ConglomerateUtil.writeCollationIdArray(collation_ids, out);,         },     }, , ,     /**,      * Store the stored representation of the column value in the,      * stream.,      * <p>,      * For more detailed description of the ACCESS_B2I_V3_ID and ,      * ACCESS_B2I_V5_ID formats see documentation at top of file.,      *,      * @see java.io.Externalizable#writeExternal,      **/,     public void writeExternal(ObjectOutput out) throws IOException {,         writeExternal_v10_3 (out);,         if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID),             out.writeBoolean (isUniqueWithDuplicateNulls());,     }, ,     /**,      * Restore the in-memory representation from the stream.,      * <p>,      *,      * @exception ClassNotFoundException Thrown if the stored representation ,      *                                   is serialized and a class named in ,      *                                   the stream could not be found.,      *,      * @see java.io.Externalizable#readExternal,      **/,     public void readExternal(ObjectInput in), 		throws IOException, ClassNotFoundException, 	{, 		super.readExternal(in);, 		baseConglomerateId = in.readLong();, 		rowLocationColumn  = in.readInt();, ,         // read the column sort order info,         FormatableBitSet ascDescBits = new FormatableBitSet();,         ascDescBits.readExternal(in);,         ascDescInfo = new boolean[ascDescBits.getLength()];,         for(int i =0 ; i < ascDescBits.getLength(); i++),             ascDescInfo[i] = ascDescBits.isSet(i);,         ,         // In memory maintain a collation id per column in the template.,         collation_ids = new int[format_ids.length];,         if (SanityManager.DEBUG) {,             SanityManager.ASSERT(!hasCollatedTypes);,         }, ,         // initialize all the entries to COLLATION_TYPE_UCS_BASIC, ,         // and then reset as necessary.  For version ACCESS_B2I_V3_ID,,         // this is the default and no resetting is necessary.,         for (int i = 0; i < format_ids.length; i++),             collation_ids[i] = StringDataValue.COLLATION_TYPE_UCS_BASIC;, ,         // initialize the unique with null setting to false, to be reset,         // below when read from disk.  For version ACCESS_B2I_V3_ID and,         // ACCESS_B2I_V4_ID, this is the default and no resetting is necessary.,         setUniqueWithDuplicateNulls(false);, , 		if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V4_ID,                 || conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID),         {,             // current format id, read collation info from disk,             if (SanityManager.DEBUG),             {,                 // length must include row location column and at least,                 // one other field.,                 SanityManager.ASSERT(,                     collation_ids.length >= 2, ,                     "length = " + collation_ids.length);,             }, ,             hasCollatedTypes =,                     ConglomerateUtil.readCollationIdArray(collation_ids, in);,         },         else if (conglom_format_id != StoredFormatIds.ACCESS_B2I_V3_ID),         {,             // Currently only V3, V4 and V5 should be possible in a Derby DB.,             // Actual work for V3 is handled by default code above, so no,             // special work is necessary., ,             if (SanityManager.DEBUG),             {,                 SanityManager.THROWASSERT(,                     "Unexpected format id: " + conglom_format_id);,             },         },         if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID) {,             setUniqueWithDuplicateNulls(in.readBoolean());,         }, 	}],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/access/btree/index/B2I.java,create,525-525,[			if (property_value == null)],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/store/access/btree/index/B2I.java,traverseRight,450-451,[			SanityManager.THROWASSERT("not implemented.");,     }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/btree/index/B2IFactory.java,readConglomerate,277-277,[                    new Long(container_key.getContainerId()));],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/store/access/btree/index/B2IRowLocking1.java,,70-158,[        super(rawtran, lock_level, locking_policy, base_cc, open_btree);,     }, , ,     /**************************************************************************,      * Public Methods of This class:,      **************************************************************************,      */, , ,     /**************************************************************************,      * Abstract Protected lockScan*() locking methods of BTree:,      *     lockScanRow              - lock row, only if row is forUpdate and,      *                                not a previous key lock.,      *     unlockScanRecordAfterRead- unlock the scan record if we locked it in,      *                                lockScanRow.,      *                                 ,      **************************************************************************,      */, , , ,     /**,      * Lock a row as part of doing the scan.,      * <p>,      * Lock the row at the given slot (or the previous row if slot is 0).,      * <p>,      * If this routine returns true all locks were acquired while maintaining,      * the latch on leaf.  If this routine returns false, locks may or may,      * not have been acquired, and the routine should be called again after,      * the client has researched the tree to reget the latch on the ,      * appropriate page.,      *, 	 * @return Whether locks were acquired without releasing latch on leaf.,      *,      * @param open_btree        The open_btree to associate latches with - ,      *                          used if routine has to scan backward.,      * @param pos               The position of the row to lock.,      * @param lock_template     A scratch area to use to read in rows.,      * @param previous_key_lock Is this a previous key lock call?,      * @param forUpdate         Is the scan for update or for read only.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public boolean lockScanRow(,     OpenBTree               open_btree,,     BTreeRowPosition        pos,,     FetchDescriptor         lock_fetch_desc,,     DataValueDescriptor[]   lock_template,,     RowLocation             lock_row_loc,,     boolean                 previous_key_lock,,     boolean                 forUpdate,,     int                     lock_operation), 		throws StandardException,     {,         // only get the row lock if it is not a previous key lock and iff,         // it is an update lock.,         return(,             _lockScanRow(,                  open_btree,,                  pos,,                  (forUpdate && !previous_key_lock), // only get update row lock,                  lock_fetch_desc, lock_template, lock_row_loc,,                  previous_key_lock,,                  forUpdate,,                  lock_operation));,     }, ,     /**,      * Release read lock on a row.,      *,      * Because this is read uncommitted no S row locks will have been requested,,      * thus none need be released.  The only locks that need to be released,      * are U locks requested if the scan was opened for update.,      *,      * @param pos               The position of the row to unlock.,      * @param forUpdate         Is the scan for update or for read only.,      *,      **/,     public void unlockScanRecordAfterRead(,     BTreeRowPosition        pos,,     boolean                 forUpdate), 		throws StandardException,     {,         if (forUpdate),         {,             super.unlockScanRecordAfterRead(pos, forUpdate);,         },     }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/store/access/btree/index/B2IRowLocking2.java,,62-97,[        super(rawtran, lock_level, locking_policy, base_cc, open_btree);,     }, ,     /**************************************************************************,      * Public Methods of This class:,      **************************************************************************,      */, , ,     /**,      * Release read lock on a row.,      *,      * @param forUpdate         Is the scan for update or for read only.,      *,      **/,     public void unlockScanRecordAfterRead(,     BTreeRowPosition        pos,,     boolean                 forUpdate), 		throws StandardException,     {, 		if (SanityManager.DEBUG), 		{, 			SanityManager.ASSERT(open_btree != null, "open_btree is null");, , 			SanityManager.ASSERT(,                 pos.current_lock_row_loc != null , ,                 "pos.current_lock_row_loc is null");, , 			SanityManager.ASSERT(,                 !pos.current_lock_row_loc.isNull(), ,                 "pos.current_lock_row_loc isNull()");, 		}, ,         // always unlock in read committed, so pass false for qualified arg.,         base_cc.unlockRowAfterRead(pos.current_lock_row_loc, forUpdate, false);,     }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,lockRowOnPage,267-267,[            current_leaf.getPage().fetchFromSlot(],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,lockNonScanRow,856-856,[                aux_leaf = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,lockNonScanRow,851-851,[                current_leaf = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,lockPreviousToFirstKey,168-168,[                aux_leaf = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,lockPreviousToFirstKey,163-163,[            current_leaf = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,lockRowOnPage,298-298,[                aux_leaf = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,lockRowOnPage,293-293,[                current_leaf = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,searchLeftAndLockPreviousKey,442-442,[                        current_leaf     = null;],,searchLeftAndLockPreviousKey,420-420,[                        current_leaf     = null;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,lockRowOnPage,242-242,[                current_slot >= current_leaf.getPage().recordCount())],,lockRowOnPage,289-289,[            else if (current_leaf != null)],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/store/access/btree/index/B2IRowLocking3.java,,95-95,[        this.rawtran             = rawtran;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/store/access/btree/index/B2IRowLockingRR.java,,60-147,[        super(rawtran, lock_level, locking_policy, base_cc, open_btree);,     }, ,     /**************************************************************************,      * Public Methods of This class:,      **************************************************************************,      */, ,     /**,      * Lock a row as part of doing the scan.,      * <p>,      * Lock the row at the given slot (or the previous row if slot is 0).,      * <p>,      * If this routine returns true all locks were acquired while maintaining,      * the latch on leaf.  If this routine returns false, locks may or may,      * not have been acquired, and the routine should be called again after,      * the client has researched the tree to reget the latch on the ,      * appropriate page.,      *, 	 * @return Whether locks were acquired without releasing latch on leaf.,      *,      * @param open_btree        The open_btree to associate latches with - ,      *                          used if routine has to scan backward.,      * @param pos               The position of the row to lock.,      * @param lock_template     A scratch area to use to read in rows.,      * @param previous_key_lock Is this a previous key lock call?,      * @param forUpdate         Is the scan for update or for read only.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public boolean lockScanRow(,     OpenBTree               open_btree,,     BTreeRowPosition        pos,,     FetchDescriptor         lock_fetch_desc,,     DataValueDescriptor[]   lock_template,,     RowLocation             lock_row_loc,,     boolean                 previous_key_lock,,     boolean                 forUpdate,,     int                     lock_operation), 		throws StandardException,     {,         // don't request row lock if this a previous key lock request, previous,         // key lock is not required in isolation level 2.,         return(,             _lockScanRow(,                 open_btree,,                 pos,,                 !previous_key_lock, // request row lock iff not prev key lock ,                 lock_fetch_desc, lock_template, lock_row_loc,,                 previous_key_lock,,                 forUpdate,,                 lock_operation));,     }, ,     /**,      * Unlock a record after it has been locked for read.,      * <p>,      * In repeatable read only unlock records which "did not qualify".  For,      * example in a query like "select * from foo where a = 1" on a table,      * with no index it is only necessary to hold locks on rows where a=1, but,      * in the process of finding those rows the system will get locks on other,      * rows to verify they are committed before applying the qualifier.  Those,      * locks can be released under repeatable read isolation.,      * <p>,      * if it is forUpdate then get S lock and release U lock, else there is ,      * nothing to do in serializable - we keep the S locks until end of ,      * transaction.,      *,      * @param forUpdate         Is the scan for update or for read only.,      *,      **/,     public void unlockScanRecordAfterRead(,     BTreeRowPosition        pos,,     boolean                 forUpdate), 		throws StandardException,     {,         if (!pos.current_rh_qualified),         {,             if (SanityManager.DEBUG),             {,                 SanityManager.ASSERT(,                     pos.current_lock_row_loc != null , "row_loc is null");,             }, ,             base_cc.unlockRowAfterRead(,                 pos.current_lock_row_loc, forUpdate, pos.current_rh_qualified);,         },     }],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/derby/impl/store/access/btree/index/B2IUndo.java,findUndo,142-142,[                SanityManager.ASSERT(btree instanceof B2I);],,
CORRECTNESS,SIO_SUPERFLUOUS_INSTANCEOF,org/apache/derby/impl/store/access/btree/index/B2IUndo.java,findUndo,142-142,[                SanityManager.ASSERT(btree instanceof B2I);],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/impl/store/access/btree/index/B2I_10_3.java,,105-127,[public class B2I_10_3 extends B2I {, ,     /**,      * Return my format identifier.,      * @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId,      */,     public int getTypeFormatId() {,         return StoredFormatIds.ACCESS_B2I_V4_ID;,     }, ,     /**,      * Store the stored representation of the column value in the,      * stream.,      * <p>,      * For more detailed description of the format see documentation,      * at top of file.,      *,      * @see java.io.Externalizable#writeExternal,      **/,     ,     public void writeExternal(ObjectOutput out) throws IOException {,         writeExternal_v10_3(out);,     }],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/impl/store/access/btree/index/B2I_v10_2.java,,123-161,[        super();,     }, , ,     /**************************************************************************,      * Public Methods required by Storable interface, implies ,      *     Externalizable, TypedFormat:,      **************************************************************************,      */, ,     /**,      * Return my format identifier.,      * <p>,      * This identifier was used for B2I in all Derby versions prior to and,      * including 10.2.  Databases hard upgraded to a version subsequent,      * to 10.2 will write the new format, see B2I.  Databases created in,      * a version subsequent to 10.2 will also write the new formate, see,      * B2I.,      *,      * @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId,      **/, 	public int getTypeFormatId() ,     {, 		return StoredFormatIds.ACCESS_B2I_V3_ID;, 	}, ,     /**,      * Store the stored representation of the column value in the,      * stream.,      * <p>,      * For more detailed description of the format see documentation,      * at top of file.,      *,      * @see java.io.Externalizable#writeExternal,      **/, 	public void writeExternal(ObjectOutput out) throws IOException ,     {, 		super.writeExternal_v10_2(out);, 	}],,
BAD_PRACTICE,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,org/apache/derby/impl/store/access/conglomerate/BinaryOrderableWrapper.java,,53-178,[    {,     }, ,     /* Private/Protected methods of This class: */,     /**,      * Short one line description of routine.,      * <p>,      * Longer descrption of routine.,      * <p>,      *,      * @param ref_object    The object that this object is wrapping (ie. being,      *                      read from disk),      * @param other_object  The object to compare ref_object to.,      **/,     protected void init (,     BinaryOrderable ref_object,,     BinaryOrderable other_object),     {,         this.ref_object     = ref_object;,         this.other_object   = other_object;,     }, ,     /* Public Methods of This class: */,     /**,      * Short one line description of routine.,      * <p>,      * Longer descrption of routine.,      * <p>,      *, 	 * @return The identifier to be used to open the conglomerate later.,      **/,     public int getCmpResult(),     {,         return(this.cmp_result);,     }, , ,     /* Public Methods of Storable interface - Externalizable, TypedFormat: ,     */, , 	public int getTypeFormatId() {,         // RESOLVE - what should this return?,         if (SanityManager.DEBUG),             SanityManager.THROWASSERT("If someone calls this it is a problem.");,         return(((TypedFormat)this.ref_object).getTypeFormatId());, 	}, , 	/**, 	Return whether the value is null or not., 	The containerid being zero is what determines nullness;  subclasses, 	are not expected to override this method., 	@see org.apache.derby.iapi.services.io.Storable#isNull, 	**/, 	public boolean isNull(), 	{,         // RESOLVE - what does it mean for this wrapper to be called isNull()?,         if (SanityManager.DEBUG),             SanityManager.THROWASSERT("If someone calls this it is a problem.");,         return(false);, 	}, , 	/**, 	Restore the in-memory representation to the null value., 	The containerid being zero is what determines nullness;  subclasses, 	are not expected to override this method., , 	@see org.apache.derby.iapi.services.io.Storable#restoreToNull, 	**/, 	public void restoreToNull(), 	{,         // RESOLVE - base object is null.,         if (SanityManager.DEBUG),             SanityManager.THROWASSERT("WORK TODO - code up null compare.");, ,         return;, 	}, , 	/**, 	Restore the in-memory representation from the stream., , 	@exception ClassNotFoundException Thrown if the stored representation is, 	serialized and a class named in the stream could not be found., ,     @exception IOException thrown by readObject(), , 	, 	@see java.io.Externalizable#readExternal, 	*/, 	public void readExternal(ObjectInput in) ,         throws IOException, ClassNotFoundException, 	{, ,         // do the read byte by byte and return the comparison ,         this.cmp_result = this.ref_object.binarycompare(in, this.other_object);,         ,         if (SanityManager.DEBUG),             SanityManager.THROWASSERT("WORK TODO - code up readExternal.");, 	}, 	public void readExternalFromArray(ArrayInputStream in) ,         throws IOException, ClassNotFoundException, 	{, ,         // do the read byte by byte and return the comparison ,         this.cmp_result = this.ref_object.binarycompare(in, this.other_object);,         ,         if (SanityManager.DEBUG),             SanityManager.THROWASSERT("WORK TODO - code up readExternal.");, 	}, 	,     /**,      * Store the stored representation of the column value in the stream.,      * <p>,      * A BinaryOrderableWrapper is never used to store data out, only to read,      * data from disk and compare it to another byte stream.,      *,      * @param out    Stream to write the object to.,      *,      * @exception IOException thrown by writeObject(),      *,      **/, 	public void writeExternal(ObjectOutput out) ,         throws IOException,     {,         if (SanityManager.DEBUG),             SanityManager.THROWASSERT("Write should never be called.");,         return;],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/derby/impl/store/access/conglomerate/ConglomerateUtil.java,createFormatIds,148-148,[				if (!(template[i] instanceof Formatable))],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/store/access/conglomerate/ConglomerateUtil.java,debugPage,354-354,[            string.append(page.getPageNumber());],,debugPage,359-359,[                if (page != null)],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.java,fetch,249-249,[                throw(StandardException.newException(],,fetch,252-252,[                        new Long(open_conglom.getFormatIds().length)));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.java,fetch,354-354,[                throw(StandardException.newException(],,fetch,357-357,[                        new Long(open_conglom.getFormatIds().length)));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.java,replace,458-458,[                throw(StandardException.newException(],,replace,461-461,[                        new Long(open_conglom.getFormatIds().length)));],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.java,closeForEndTransaction,131-131,[        if ((!open_conglom.getHold()) || closeHeldScan) ],,closeForEndTransaction,135-135,[            if ((open_conglom != null) && (open_conglom.getXactMgr() != null))],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/conglomerate/GenericScanController.java,fetch,1512-1512,[                    new Long(scan_position.current_rh.getPageNumber()),],,fetch,1513-1513,[                    new Long(scan_position.current_rh.getId()));],,fetch,1546-1546,[                    new Long(scan_position.current_rh.getPageNumber()),],,fetch,1547-1547,[                    new Long(scan_position.current_rh.getId()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/conglomerate/GenericScanController.java,repositionScanForUpateOper,250-250,[                    new Long(scan_position.current_rh.getPageNumber()),],,repositionScanForUpateOper,251-251,[                    new Long(scan_position.current_rh.getId()));],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/impl/store/access/conglomerate/GenericScanController.java,getQualifier,975-975,[        return(init_qualifier);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/impl/store/access/conglomerate/GenericScanController.java,getStartKeyValue,959-959,[        return(init_startKeyValue);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/impl/store/access/conglomerate/GenericScanController.java,getStopKeyValue,967-967,[        return(init_stopKeyValue);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/store/access/conglomerate/OpenConglomerate.java,,869-869,[        init_dynamic_info       = dynamic_info;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/impl/store/access/conglomerate/OpenConglomerateScratchSpace.java,get_scratch_row,189-189,[        return(scratch_row);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/derby/impl/store/access/conglomerate/OpenConglomerateScratchSpace.java,get_template,215-215,[        return(scratch_template);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/impl/store/access/conglomerate/OpenConglomerateScratchSpace.java,<init>,117-117,[        this.collation_ids  = collation_ids;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/impl/store/access/conglomerate/OpenConglomerateScratchSpace.java,<init>,116-116,[        this.format_ids     = format_ids;],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/derby/impl/store/access/conglomerate/TemplateRow.java,allocate_objects,113-113,[                    if ( ! (o instanceof Storable))],,
CORRECTNESS,SIO_SUPERFLUOUS_INSTANCEOF,org/apache/derby/impl/store/access/conglomerate/TemplateRow.java,allocate_objects,113-113,[                    if ( ! (o instanceof Storable))],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/derby/impl/store/access/heap/D_HeapController.java,diag_tabulate,155-155,[            "\tminimum record size   = " + prop.getProperty(Page.DIAG_MINIMUM_REC_SIZE) + ".\n"         +],,diag_tabulate,163-163,[            out_summary(],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/derby/impl/store/access/heap/Heap.java,addColumn,422-422,[                    SanityManager.THROWASSERT(],,
PERFORMANCE,DM_BOXED_PRIMITIVE_TOSTRING,org/apache/derby/impl/store/access/heap/Heap.java,open,703-703,[                    new Long(id.getContainerId()).toString());],,
PERFORMANCE,DM_BOXED_PRIMITIVE_TOSTRING,org/apache/derby/impl/store/access/heap/Heap.java,purgeConglomerate,858-858,[                        new Long(id.getContainerId()).toString());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/Heap.java,addColumn,427-427,[                throw(StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/Heap.java,compressConglomerate,951-951,[                        new Long(id.getContainerId()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/Heap.java,defragmentConglomerate,1006-1006,[                    new Long(id.getContainerId()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/Heap.java,open,703-703,[                    new Long(id.getContainerId()).toString());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/Heap.java,openScan,774-774,[                    new Long(id.getContainerId()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/Heap.java,openStoreCost,1063-1063,[                    new Long(id.getContainerId()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/Heap.java,purgeConglomerate,823-823,[                        new Long(id.getContainerId()));],,purgeConglomerate,858-858,[                        new Long(id.getContainerId()).toString());],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/impl/store/access/heap/Heap.java,,197-1248,[    private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( Heap.class);,     private static final int CONTAINER_KEY_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( ContainerKey.class);, ,     public int estimateMemoryUsage(),     {,         int sz = BASE_MEMORY_USAGE;, ,         if( null != id),             sz += CONTAINER_KEY_MEMORY_USAGE;,         if( null != format_ids),             sz += format_ids.length*ClassSize.getIntSize();,         return sz;,     } // end of estimateMemoryUsage, , 	/*, 	** Methods of Heap., 	*/, ,     /* Constructors for This class: */, ,     /**,      * Zero arg constructor for Monitor to create empty object.,      **/,     public Heap(),     {,     }, ,     /* Private/Protected methods of This class: */, ,     /**,      * Create a heap conglomerate.,      * <p>,      * Create a heap conglomerate.  This method is called from the heap factory,      * to create a new instance of a heap.,      * <p>,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	protected void create(,     Transaction             rawtran,,     int                     segmentId,,     long                    input_containerid,,     DataValueDescriptor[]   template,,     ColumnOrdering[]        columnOrder,,     int[]                   collationIds,,     Properties              properties,,     int                     conglom_format_id,, 	int                     tmpFlag), 		throws StandardException, 	{, 		// Create a container for the heap table with, 		// default minimumRecordSize to be at least, 		// MINIMUM_RECORD_SIZE_DEFAULT (12),, 		// to guarantee there is enough room for updates, 		// of the row., 		// Here we only take care of the case that, 		// that the properties are set with the create, 		// statement.  For the case when properties are, 		// not set with the create statement, it is taken, 		// care of in fileContainer.java: createInfoFromProp()., 		if (properties != null) ,         {, 			String value = properties.getProperty(, 				RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER);, , 			int minimumRecordSize =, 				(value == null) ? ,                     RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT : ,                     Integer.parseInt(value);, , 			if (minimumRecordSize < RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT), 			{, 				properties.put(,                     RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,, 					Integer.toString(,                         RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT));, 			}, 		}, , 		// Create a container for the heap with default page size., 		long containerid = ,             rawtran.addContainer(,                 segmentId, input_containerid, ,                 ContainerHandle.MODE_DEFAULT, properties, tmpFlag);, , 		// Make sure the container was actually created., 		if (containerid < 0),         {,             throw StandardException.newException(,                     SQLState.HEAP_CANT_CREATE_CONTAINER);,         }, , 		// Keep track of what segment the container's in., 		id = new ContainerKey(segmentId, containerid);, , 		// Heap requires a template representing every column in the table.,         if ((template == null) || (template.length == 0)),         {,             throw StandardException.newException(,                     SQLState.HEAP_COULD_NOT_CREATE_CONGLOMERATE);,         }, ,         // get format id's from each column in template and store it in the,         // conglomerate state.,         this.format_ids = ConglomerateUtil.createFormatIds(template);, ,         // copy the format id of the conglomerate.,         this.conglom_format_id = conglom_format_id;, ,         // get collation ids from input collation ids, store it in the ,         // conglom state.,         collation_ids = ,             ConglomerateUtil.createCollationIds(,                 format_ids.length, collationIds);,         hasCollatedTypes = hasCollatedColumns(collation_ids);, ,         // need to open the container and insert the row.  Since we are,         // creating it no need to bother with locking since no one can get,         // to it until after we have created it and returned it's id.,         ContainerHandle container = null;,         Page            page      = null;, ,         try,         {,             container = ,                 rawtran.openContainer(,                     id, (LockingPolicy) null, ,                     ContainerHandle.MODE_FORUPDATE | ,                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));, ,             // row in slot 0 of heap page 1 which is just a single column with,             // the heap entry.,             DataValueDescriptor[] control_row = new DataValueDescriptor[1];,             control_row[0] = this;, ,             page =,                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);, ,             page.insertAtSlot(,                 Page.FIRST_SLOT_NUMBER,,                 control_row,,                 (FormatableBitSet) null,,                 (LogicalUndo) null, ,                 Page.INSERT_OVERFLOW,,                 AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);,             page.unlatch();,             page = null;, ,             // Don't include the control row in the estimated row count.,             container.setEstimatedRowCount(0, /* unused flag */ 0);,         },         finally,         {,             if (container != null),                 container.close();,             if (page !=null),                 page.unlatch();,         }, 	}, ,     /**,      * Create a heap conglomerate during the boot process.,      * <p>,      * Manufacture a Heap Conglomerate out of "thin" air, to boot strap,      * the system.  Create an in-memory Heap Conglomerate with the input,      * parameters, The caller will use this to open the conglomerate,      * conglomerate and read the "real" values from disk.  Conglom-conglom,      * is always on segment 0.,      *,      *,      * @param containerid The container id of the conglomerate.,      * @param template    Object array describing the columns of the heap.,      **/,     public void boot_create(,     long                    containerid,,     DataValueDescriptor[]   template),     {, 		id = new ContainerKey(0, containerid);,         this.format_ids = ConglomerateUtil.createFormatIds(template);,     }, , 	/*, 	** Methods of Conglomerate, 	*/, ,     /**,      * Add a column to the heap conglomerate.,      * <p>,      * This routine update's the in-memory object version of the Heap,      * Conglomerate to have one more column of the type described by the,      * input template column.  ,      * ,      * @param column_id        The column number to add this column at.,      * @param template_column  An instance of the column to be added to table.,      * @param collation_id     Collation id of the column added.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public void addColumn(, 	TransactionManager  xact_manager,,     int                 column_id,,     Storable            template_column,,     int                 collation_id),         throws StandardException,     {,         // need to open the container and update the row containing the ,         // serialized format of the heap.  ,         ContainerHandle container = null;,         Page            page      = null;,         Transaction     rawtran   = xact_manager.getRawStoreXact();, ,         try,         {,             container = ,                 rawtran.openContainer(,                     id, ,                     rawtran.newLockingPolicy(,                         LockingPolicy.MODE_CONTAINER,,                         TransactionController.ISOLATION_SERIALIZABLE, true),,                     ContainerHandle.MODE_FORUPDATE | ,                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));, ,             if (column_id != format_ids.length),             {,                 if (SanityManager.DEBUG),                     SanityManager.THROWASSERT(,                         "column_id = " + column_id +,                         "format_ids.length = " + format_ids.length +,                         "format_ids = " + format_ids);, ,                 throw(StandardException.newException(,                         SQLState.HEAP_TEMPLATE_MISMATCH,,                         new Long(column_id), ,                         new Long(this.format_ids.length)));,             }, ,             // create a new array, and copy old values to it.,             int[] old_format_ids = format_ids;,             format_ids              = new int[old_format_ids.length + 1];,             System.arraycopy(,                 old_format_ids, 0, format_ids, 0, old_format_ids.length);, ,             // add the new column,             format_ids[old_format_ids.length] = ,                 template_column.getTypeFormatId();, ,             // create a new collation array, and copy old values to it.,             int[] old_collation_ids = collation_ids;,             collation_ids           = new int[old_collation_ids.length + 1];,             System.arraycopy(,                 old_collation_ids, 0, collation_ids, 0, ,                 old_collation_ids.length);, ,             // add the new column's collation id.,             collation_ids[old_collation_ids.length] =  collation_id;,            ,             // row in slot 0 of heap page 1 which is just a single column with,             // the heap entry.,             DataValueDescriptor[] control_row = new DataValueDescriptor[1];,             control_row[0] = this;, ,             page =,                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);, ,             page.updateAtSlot(,                 Page.FIRST_SLOT_NUMBER,,                 control_row,,                 (FormatableBitSet) null);, ,             page.unlatch();,             page = null;,         },         finally,         {,             if (container != null),                 container.close();,             if (page !=null),                 page.unlatch();,         }, ,         return;,     }, , , 	/**, 	Drop this heap., 	@see Conglomerate#drop, , 	@exception StandardException Standard exception policy., 	**/, 	public void drop(TransactionManager xact_manager), 		throws StandardException, 	{,         xact_manager.getRawStoreXact().dropContainer(id);, 	}, ,     /**,      * Retrieve the maximum value row in an ordered conglomerate.,      * <p>,      * Returns true and fetches the rightmost row of an ordered conglomerate ,      * into "fetchRow" if there is at least one row in the conglomerate.  If,      * there are no rows in the conglomerate it returns false.,      * <p>,      * Non-ordered conglomerates will not implement this interface, calls,      * will generate a StandardException.,      * <p>,      * RESOLVE - this interface is temporary, long term equivalent (and more) ,      * functionality will be provided by the openBackwardScan() interface.  ,      *, 	 * @param conglomId       The identifier of the conglomerate, 	 *                        to open the scan for.,      *, 	 * @param open_mode       Specifiy flags to control opening of table.  ,      *                        OPENMODE_FORUPDATE - if set open the table for,      *                        update otherwise open table shared.,      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).,      *,      * @param isolation_level The isolation level to lock the conglomerate at.,      *                        One of (ISOLATION_READ_COMMITTED or ,      *                        ISOLATION_SERIALIZABLE).,      *, 	 * @param scanColumnList  A description of which columns to return from ,      *                        every fetch in the scan.  template, ,      *                        and scanColumnList work together,      *                        to describe the row to be returned by the scan - ,      *                        see RowUtil for description of how these three ,      *                        parameters work together to describe a "row".,      *,      * @param fetchRow        The row to retrieve the maximum value into.,      *, 	 * @return boolean indicating if a row was found and retrieved or not.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public boolean fetchMaxOnBTree(, 	TransactionManager      xact_manager,,     Transaction             rawtran,,     long                    conglomId,,     int                     open_mode,,     int                     lock_level,,     LockingPolicy           locking_policy,,     int                     isolation_level,,     FormatableBitSet                 scanColumnList,,     DataValueDescriptor[]   fetchRow),         throws StandardException,     {,         // no support for max on a heap table.,         throw(StandardException.newException(,                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));,     }, ,     /**,      * Get the id of the container of the conglomerate.,      * <p>,      * Will have to change when a conglomerate could have more than one ,      * container.  The ContainerKey is a combination of the container id,      * and segment id.,      *, 	 * @return The ContainerKey.,      **/,     public final ContainerKey getId(),     {,         return(id);,     }, , ,     public final long getContainerid(),     {,         return(id.getContainerId());,     }, ,     /**,      * Return dynamic information about the conglomerate to be dynamically ,      * reused in repeated execution of a statement.,      * <p>,      * The dynamic info is a set of variables to be used in a given ,      * ScanController or ConglomerateController.  It can only be used in one ,      * controller at a time.  It is up to the caller to insure the correct ,      * thread access to this info.  The type of info in this is a scratch ,      * template for btree traversal, other scratch variables for qualifier ,      * evaluation, ...,      * <p>,      *, 	 * @return The dynamic information.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo(), 		throws StandardException,     {,         return(new OpenConglomerateScratchSpace(,                 format_ids, collation_ids, hasCollatedTypes));,     }, ,     /**,      * Return static information about the conglomerate to be included in a,      * a compiled plan.,      * <p>,      * The static info would be valid until any ddl was executed on the ,      * conglomid, and would be up to the caller to throw away when that ,      * happened.  This ties in with what language already does for other ,      * invalidation of static info.  The type of info in this would be ,      * containerid and array of format id's from which templates can be created.,      * The info in this object is read only and can be shared among as many ,      * threads as necessary.,      * <p>,      *, 	 * @return The static compiled information.,      *,      * @param conglomId The identifier of the conglomerate to open.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(,     TransactionController   tc,,     long                    conglomId), 		throws StandardException,     {,         return(this);,     }, , ,     /**,      * Is this conglomerate temporary?,      * <p>,      *, 	 * @return whether conglomerate is temporary or not.,      **/,     public boolean isTemporary(),     {,         return(id.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);,     }, , ,     /**,      * Bulk load into the conglomerate.,      * <p>,      *,      * @see Conglomerate#load,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public long load(, 	TransactionManager      xact_manager,, 	boolean                 createConglom,, 	RowLocationRetRowSource rowSource), 		 throws StandardException, 	{,         long num_rows_loaded = 0;, , 		HeapController heapcontroller = new HeapController();, , 		try, 		{, 			num_rows_loaded = ,                 heapcontroller.load(,                     xact_manager,,                     this, ,                     createConglom,,                     rowSource);, 		}, 		finally, 		{, 			// Done with this heap controller., 			heapcontroller.close();, 		}, ,         return(num_rows_loaded);, 	}, ,     /**,      * Open a heap controller.,      * <p>,      *, 	 * @see Conglomerate#open,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public ConglomerateController open(,     TransactionManager              xact_manager,,     Transaction                     rawtran,,     boolean                         hold,,     int                             open_mode,,     int                             lock_level,,     LockingPolicy                   locking_policy,,     StaticCompiledOpenConglomInfo   static_info,,     DynamicCompiledOpenConglomInfo  dynamic_info), 		throws StandardException, 	{,         OpenConglomerate open_conglom = new OpenHeap();, ,         if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 xact_manager,,                 rawtran,,                 hold,,                 open_mode,,                 lock_level,,                 locking_policy,,                 dynamic_info) == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_CONTAINER_NOT_FOUND, ,                     new Long(id.getContainerId()).toString());,         }, , 		HeapController heapcontroller = new HeapController();, ,         heapcontroller.init(open_conglom);, , 		return(heapcontroller);, 	}, ,     /**,      * Open a heap scan controller.,      * <p>,      *,      * @see Conglomerate#openScan,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public ScanManager openScan(,     TransactionManager              xact_manager,,     Transaction                     rawtran,,     boolean                         hold,,     int                             open_mode,,     int                             lock_level,,     LockingPolicy                   locking_policy,,     int                             isolation_level,, 	FormatableBitSet				scanColumnList,,     DataValueDescriptor[]	        startKeyValue,,     int                             startSearchOperator,,     Qualifier                       qualifier[][],,     DataValueDescriptor[]	        stopKeyValue,,     int                             stopSearchOperator,,     StaticCompiledOpenConglomInfo   static_info,,     DynamicCompiledOpenConglomInfo  dynamic_info), 		throws StandardException, 	{,         if (SanityManager.DEBUG) {,             if ((open_mode &,                     TransactionController.OPENMODE_LOCK_ROW_NOWAIT) != 0) {,                 SanityManager.THROWASSERT(,                     "Bad open mode to Heap#openScan:" +,                     Integer.toHexString(open_mode));,             },         }, ,         // Heap scans do not suppport start and stop scan positions (these,         // only make sense for ordered storage structures)., 		if (!RowUtil.isRowEmpty(startKeyValue), 			|| !RowUtil.isRowEmpty(stopKeyValue)), 		{,             throw StandardException.newException(,                     SQLState.HEAP_UNIMPLEMENTED_FEATURE);, 		}, ,         OpenConglomerate open_conglom = new OpenHeap();, ,         if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 xact_manager,,                 rawtran,,                 hold,,                 open_mode,,                 lock_level,,                 locking_policy,,                 dynamic_info) == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_CONTAINER_NOT_FOUND, ,                     new Long(id.getContainerId()));,         }, , 		HeapScan heapscan = new HeapScan();, ,         heapscan.init(,             open_conglom,,             scanColumnList,,             startKeyValue,,             startSearchOperator,,             qualifier,,             stopKeyValue,,             stopSearchOperator);, , 		return(heapscan);, 	}, , 	public void purgeConglomerate(,     TransactionManager              xact_manager,,     Transaction                     rawtran),         throws StandardException,     {,         OpenConglomerate        open_for_ddl_lock   = null;,         HeapController          heapcontroller      = null;,         TransactionManager      nested_xact         = null;, ,         try,         {,             open_for_ddl_lock = new OpenHeap();, ,             // Open table in intended exclusive mode in the top level ,             // transaction, this will stop any ddl from happening until ,             // purge of whole table is finished., ,             if (open_for_ddl_lock.init(,                     (ContainerHandle) null,,                     this,,                     this.format_ids,,                     this.collation_ids,,                     xact_manager,,                     rawtran,,                     false,,                     TransactionController.OPENMODE_FORUPDATE,,                     TransactionController.MODE_RECORD,,                     null,,                     null) == null),             {,                 throw StandardException.newException(,                         SQLState.HEAP_CONTAINER_NOT_FOUND, ,                         new Long(id.getContainerId()));,             }, ,             // perform all the "real" work in a non-readonly nested user ,             // transaction, so that as work is completed on each page resources,             // can be released.  Must be careful as all locks obtained in nested,             // transaction will conflict with parent transaction - so this call,             // must be made only if parent transaction can have no conflicting,             // locks on the table, otherwise the purge will fail with a self,             // deadlock.,             nested_xact = (TransactionManager) ,                 xact_manager.startNestedUserTransaction(false, true);, ,             // now open the table in a nested user transaction so that each,             // page worth of work can be committed after it is done., ,             OpenConglomerate open_conglom = new OpenHeap();, ,             if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 nested_xact,,                 nested_xact.getRawStoreXact(),,                 true,,                 TransactionController.OPENMODE_FORUPDATE,,                 TransactionController.MODE_RECORD,,                 nested_xact.getRawStoreXact().newLockingPolicy(,                     LockingPolicy.MODE_RECORD,,                         TransactionController.ISOLATION_REPEATABLE_READ, true),,                 null) == null),             {,                 throw StandardException.newException(,                         SQLState.HEAP_CONTAINER_NOT_FOUND, ,                         new Long(id.getContainerId()).toString());,             }, ,             heapcontroller = new HeapController();, ,             heapcontroller.init(open_conglom);, ,             Page page   = open_conglom.getContainer().getFirstPage();, ,             boolean purgingDone = false;, ,             while (page != null),             {,                 long pageno = page.getPageNumber();,                 purgingDone = heapcontroller.purgeCommittedDeletes(page);, ,                 if (purgingDone),                 {,                     page = null;, ,                     // commit xact to free resouurces ASAP, commit will,                     // unlatch the page if it has not already been unlatched,                     // by a remove.,                     open_conglom.getXactMgr().commitNoSync(,                                 TransactionController.RELEASE_LOCKS);, ,                     // the commit closes the underlying container, so let,                     // the heapcontroller know this has happened.  Usually,                     // the transaction takes care of this, but this controller,                     // is internal, so the transaction does not know about it.,                     heapcontroller.closeForEndTransaction(false);,                     ,                     // the commit will close the underlying ,                     open_conglom.reopen();,                 },                 else,                 {,                     page.unlatch();,                     page = null;,                 }, ,                 page = open_conglom.getContainer().getNextPage(pageno);,             },         },         finally,         {,             if (open_for_ddl_lock != null),                 open_for_ddl_lock.close();,             if (heapcontroller != null),                 heapcontroller.close();,             if (nested_xact != null),             {,                 nested_xact.commitNoSync(TransactionController.RELEASE_LOCKS);,                 nested_xact.destroy();,             },         }, ,         return;,     }, , 	public void compressConglomerate(,     TransactionManager              xact_manager,,     Transaction                     rawtran),         throws StandardException,     {,         OpenConglomerate        open_conglom    = null;,         HeapController          heapcontroller  = null;, ,         try,         {,             open_conglom = new OpenHeap();, ,             // Open table in intended exclusive mode in the top level ,             // transaction, this will stop any ddl from happening until ,             // purge of whole table is finished., ,             if (open_conglom.init(,                     (ContainerHandle) null,,                     this,,                     this.format_ids,,                     this.collation_ids,,                     xact_manager,,                     rawtran,,                     false,,                     TransactionController.OPENMODE_FORUPDATE,,                     TransactionController.MODE_TABLE,,                     rawtran.newLockingPolicy(,                         LockingPolicy.MODE_CONTAINER,,                         TransactionController.ISOLATION_REPEATABLE_READ, true),,                     null) == null),             {,                 throw StandardException.newException(,                         SQLState.HEAP_CONTAINER_NOT_FOUND, ,                         new Long(id.getContainerId()));,             }, ,             heapcontroller = new HeapController();, ,             heapcontroller.init(open_conglom);, ,             open_conglom.getContainer().compressContainer();,         },         finally,         {,             if (open_conglom != null),                 open_conglom.close();,         }, ,         return;,     }, ,     /**,      * Open a heap compress scan.,      * <p>,      *,      * @see Conglomerate#defragmentConglomerate,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public ScanManager defragmentConglomerate(,     TransactionManager              xact_manager,,     Transaction                     rawtran,,     boolean                         hold,,     int                             open_mode,,     int                             lock_level,,     LockingPolicy                   locking_policy,,     int                             isolation_level), 		throws StandardException, 	{,         OpenConglomerate open_conglom = new OpenHeap();, ,         if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 xact_manager,,                 rawtran,,                 hold,,                 open_mode,,                 lock_level,,                 rawtran.newLockingPolicy(,                     LockingPolicy.MODE_RECORD,,                     TransactionController.ISOLATION_REPEATABLE_READ, true),,                 null) == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_CONTAINER_NOT_FOUND, ,                     new Long(id.getContainerId()));,         }, , 		HeapCompressScan heap_compress_scan = new HeapCompressScan();, ,         heap_compress_scan.init(,             open_conglom,,             null,,             null,,             0,,             null,,             null,,             0);, , 		return(heap_compress_scan);, 	}, , ,     /**,      * Return an open StoreCostController for the conglomerate.,      * <p>,      * Return an open StoreCostController which can be used to ask about ,      * the estimated row counts and costs of ScanController and ,      * ConglomerateController operations, on the given conglomerate.,      * <p>, 	 * @param xact_manager The TransactionController under which this ,      *                     operation takes place., 	 * @param rawtran  raw transaction context in which scan is managed.,      *, 	 * @return The open StoreCostController.,      *, 	 * @exception  StandardException  Standard exception policy.,      *,      * @see StoreCostController,      **/,     public StoreCostController openStoreCost(,     TransactionManager  xact_manager,,     Transaction         rawtran), 		throws StandardException,     {,         OpenHeap open_conglom = new OpenHeap();, ,         if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 xact_manager,,                 rawtran,,                 false,,                 ContainerHandle.MODE_READONLY,,                 TransactionController.MODE_TABLE,,                 (LockingPolicy) null,,                 (DynamicCompiledOpenConglomInfo) null) == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_CONTAINER_NOT_FOUND, ,                     new Long(id.getContainerId()));,         }, , ,         HeapCostController heapcost = new HeapCostController();, ,         heapcost.init(open_conglom);, , 		return(heapcost);,     }, , ,     /**,      * Print this heap.,      **/,     public String toString(),     {,         return (id == null) ? "null" : id.toString();,     }, ,     /**************************************************************************,      * Public Methods of StaticCompiledOpenConglomInfo Interface:,      **************************************************************************,      */, ,     /**,      * return the "Conglomerate".,      * <p>,      * For heap just return "this", which both implements Conglomerate and,      * StaticCompiledOpenConglomInfo.,      * <p>,      *, 	 * @return this,      **/,     public DataValueDescriptor getConglom(),     {,         return(this);,     }, , ,     /**************************************************************************, 	 * Methods of Storable (via Conglomerate), 	 * Storable interface, implies Externalizable, TypedFormat,      **************************************************************************,      */, ,     /**,      * Return my format identifier.,      *,      * @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId,      **/, 	public int getTypeFormatId(),     {, 		return StoredFormatIds.ACCESS_HEAP_V3_ID;, 	}, ,     /**,      * Return whether the value is null or not.,      *, 	 * @see org.apache.derby.iapi.services.io.Storable#isNull,      **/, 	public boolean isNull(), 	{, 		return id == null;, 	}, ,     /**,      * Restore the in-memory representation to the null value.,      *,      * @see org.apache.derby.iapi.services.io.Storable#restoreToNull,      *,      **/, 	public void restoreToNull(), 	{, 		id = null;, 	}, ,     /**,      * Store the stored representation of the column value in the stream.,      *,      **/, ,     /**,      * Store the 10.2 format stored representation of column value in stream.,      * <p>,      * This routine stores the 10.2 version the Heap, ie. the ACCESS_HEAP_V2_ID,      * format.  It is used by any database which has been created in ,      * 10.2 or a previous release and has not been hard upgraded to a ,      * version subsequent to 10.2.,      * <p>,      **/, 	protected void writeExternal_v10_2(ObjectOutput out) throws IOException,     {, ,         // write the format id of this conglomerate,         FormatIdUtil.writeFormatIdInteger(out, conglom_format_id);, , 		out.writeInt((int) id.getSegmentId());,         out.writeLong(id.getContainerId());, ,         // write number of columns in heap.,         out.writeInt(format_ids.length);, ,         // write out array of format id's,         ConglomerateUtil.writeFormatIdArray(format_ids, out);, 	}, ,     /**,      * Store the stored representation of column value in stream.,      * <p>,      * This routine uses the current database version to either store the,      * the 10.2 format (ACCESS_HEAP_V2_ID) or the current format ,      * (ACCESS_HEAP_V3_ID).  ,      * <p>,      **/, 	public void writeExternal(ObjectOutput out) throws IOException,     {,         writeExternal_v10_2(out);, ,         if (conglom_format_id == StoredFormatIds.ACCESS_HEAP_V3_ID),         {,             // Now append sparse array of collation ids,             ConglomerateUtil.writeCollationIdArray(collation_ids, out);,         }, 	}, ,     /**,      * Restore the in-memory representation from the stream.,      * <p>,      *,      * @exception ClassNotFoundException Thrown if the stored representation ,      *                                   is serialized and a class named in ,      *                                   the stream could not be found.,      *,      * @see java.io.Externalizable#readExternal,      **/,     public void readExternal(ObjectInput in), 		throws IOException, ClassNotFoundException, 	{, ,         // read the format id of this conglomerate.,         conglom_format_id = FormatIdUtil.readFormatIdInteger(in);, , 		int segmentid = in.readInt();,         long containerid = in.readLong();, , 		id = new ContainerKey(segmentid, containerid);, ,         // read the number of columns in the heap.,         int num_columns = in.readInt();, ,         // read the array of format ids.,         format_ids = ConglomerateUtil.readFormatIdArray(num_columns, in);, ,         // In memory maintain a collation id per column in the template.,         collation_ids = new int[format_ids.length];,         if (SanityManager.DEBUG) {,             SanityManager.ASSERT(!hasCollatedTypes);,         }, ,         // initialize all the entries to COLLATION_TYPE_UCS_BASIC, ,         // and then reset as necessary.  For version ACCESS_HEAP_V2_ID,,         // this is the default and no resetting is necessary.,         for (int i = 0; i < format_ids.length; i++),             collation_ids[i] = StringDataValue.COLLATION_TYPE_UCS_BASIC;, , 		if (conglom_format_id == StoredFormatIds.ACCESS_HEAP_V3_ID),         {,             // current format id, read collation info from disk, ,             hasCollatedTypes =,                     ConglomerateUtil.readCollationIdArray(collation_ids, in);,         },         else if (conglom_format_id != StoredFormatIds.ACCESS_HEAP_V2_ID),         {,             // Currently only V2 and V3 should be possible in a Derby DB.,             // Actual work for V2 is handled by default code above, so no,             // special work is necessary., ,             if (SanityManager.DEBUG),             {,                 SanityManager.THROWASSERT(,                     "Unexpected format id: " + conglom_format_id);,             },         },     }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/store/access/heap/Heap.java,,197-1248,[    private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( Heap.class);,     private static final int CONTAINER_KEY_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( ContainerKey.class);, ,     public int estimateMemoryUsage(),     {,         int sz = BASE_MEMORY_USAGE;, ,         if( null != id),             sz += CONTAINER_KEY_MEMORY_USAGE;,         if( null != format_ids),             sz += format_ids.length*ClassSize.getIntSize();,         return sz;,     } // end of estimateMemoryUsage, , 	/*, 	** Methods of Heap., 	*/, ,     /* Constructors for This class: */, ,     /**,      * Zero arg constructor for Monitor to create empty object.,      **/,     public Heap(),     {,     }, ,     /* Private/Protected methods of This class: */, ,     /**,      * Create a heap conglomerate.,      * <p>,      * Create a heap conglomerate.  This method is called from the heap factory,      * to create a new instance of a heap.,      * <p>,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	protected void create(,     Transaction             rawtran,,     int                     segmentId,,     long                    input_containerid,,     DataValueDescriptor[]   template,,     ColumnOrdering[]        columnOrder,,     int[]                   collationIds,,     Properties              properties,,     int                     conglom_format_id,, 	int                     tmpFlag), 		throws StandardException, 	{, 		// Create a container for the heap table with, 		// default minimumRecordSize to be at least, 		// MINIMUM_RECORD_SIZE_DEFAULT (12),, 		// to guarantee there is enough room for updates, 		// of the row., 		// Here we only take care of the case that, 		// that the properties are set with the create, 		// statement.  For the case when properties are, 		// not set with the create statement, it is taken, 		// care of in fileContainer.java: createInfoFromProp()., 		if (properties != null) ,         {, 			String value = properties.getProperty(, 				RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER);, , 			int minimumRecordSize =, 				(value == null) ? ,                     RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT : ,                     Integer.parseInt(value);, , 			if (minimumRecordSize < RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT), 			{, 				properties.put(,                     RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,, 					Integer.toString(,                         RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT));, 			}, 		}, , 		// Create a container for the heap with default page size., 		long containerid = ,             rawtran.addContainer(,                 segmentId, input_containerid, ,                 ContainerHandle.MODE_DEFAULT, properties, tmpFlag);, , 		// Make sure the container was actually created., 		if (containerid < 0),         {,             throw StandardException.newException(,                     SQLState.HEAP_CANT_CREATE_CONTAINER);,         }, , 		// Keep track of what segment the container's in., 		id = new ContainerKey(segmentId, containerid);, , 		// Heap requires a template representing every column in the table.,         if ((template == null) || (template.length == 0)),         {,             throw StandardException.newException(,                     SQLState.HEAP_COULD_NOT_CREATE_CONGLOMERATE);,         }, ,         // get format id's from each column in template and store it in the,         // conglomerate state.,         this.format_ids = ConglomerateUtil.createFormatIds(template);, ,         // copy the format id of the conglomerate.,         this.conglom_format_id = conglom_format_id;, ,         // get collation ids from input collation ids, store it in the ,         // conglom state.,         collation_ids = ,             ConglomerateUtil.createCollationIds(,                 format_ids.length, collationIds);,         hasCollatedTypes = hasCollatedColumns(collation_ids);, ,         // need to open the container and insert the row.  Since we are,         // creating it no need to bother with locking since no one can get,         // to it until after we have created it and returned it's id.,         ContainerHandle container = null;,         Page            page      = null;, ,         try,         {,             container = ,                 rawtran.openContainer(,                     id, (LockingPolicy) null, ,                     ContainerHandle.MODE_FORUPDATE | ,                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));, ,             // row in slot 0 of heap page 1 which is just a single column with,             // the heap entry.,             DataValueDescriptor[] control_row = new DataValueDescriptor[1];,             control_row[0] = this;, ,             page =,                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);, ,             page.insertAtSlot(,                 Page.FIRST_SLOT_NUMBER,,                 control_row,,                 (FormatableBitSet) null,,                 (LogicalUndo) null, ,                 Page.INSERT_OVERFLOW,,                 AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);,             page.unlatch();,             page = null;, ,             // Don't include the control row in the estimated row count.,             container.setEstimatedRowCount(0, /* unused flag */ 0);,         },         finally,         {,             if (container != null),                 container.close();,             if (page !=null),                 page.unlatch();,         }, 	}, ,     /**,      * Create a heap conglomerate during the boot process.,      * <p>,      * Manufacture a Heap Conglomerate out of "thin" air, to boot strap,      * the system.  Create an in-memory Heap Conglomerate with the input,      * parameters, The caller will use this to open the conglomerate,      * conglomerate and read the "real" values from disk.  Conglom-conglom,      * is always on segment 0.,      *,      *,      * @param containerid The container id of the conglomerate.,      * @param template    Object array describing the columns of the heap.,      **/,     public void boot_create(,     long                    containerid,,     DataValueDescriptor[]   template),     {, 		id = new ContainerKey(0, containerid);,         this.format_ids = ConglomerateUtil.createFormatIds(template);,     }, , 	/*, 	** Methods of Conglomerate, 	*/, ,     /**,      * Add a column to the heap conglomerate.,      * <p>,      * This routine update's the in-memory object version of the Heap,      * Conglomerate to have one more column of the type described by the,      * input template column.  ,      * ,      * @param column_id        The column number to add this column at.,      * @param template_column  An instance of the column to be added to table.,      * @param collation_id     Collation id of the column added.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public void addColumn(, 	TransactionManager  xact_manager,,     int                 column_id,,     Storable            template_column,,     int                 collation_id),         throws StandardException,     {,         // need to open the container and update the row containing the ,         // serialized format of the heap.  ,         ContainerHandle container = null;,         Page            page      = null;,         Transaction     rawtran   = xact_manager.getRawStoreXact();, ,         try,         {,             container = ,                 rawtran.openContainer(,                     id, ,                     rawtran.newLockingPolicy(,                         LockingPolicy.MODE_CONTAINER,,                         TransactionController.ISOLATION_SERIALIZABLE, true),,                     ContainerHandle.MODE_FORUPDATE | ,                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));, ,             if (column_id != format_ids.length),             {,                 if (SanityManager.DEBUG),                     SanityManager.THROWASSERT(,                         "column_id = " + column_id +,                         "format_ids.length = " + format_ids.length +,                         "format_ids = " + format_ids);, ,                 throw(StandardException.newException(,                         SQLState.HEAP_TEMPLATE_MISMATCH,,                         new Long(column_id), ,                         new Long(this.format_ids.length)));,             }, ,             // create a new array, and copy old values to it.,             int[] old_format_ids = format_ids;,             format_ids              = new int[old_format_ids.length + 1];,             System.arraycopy(,                 old_format_ids, 0, format_ids, 0, old_format_ids.length);, ,             // add the new column,             format_ids[old_format_ids.length] = ,                 template_column.getTypeFormatId();, ,             // create a new collation array, and copy old values to it.,             int[] old_collation_ids = collation_ids;,             collation_ids           = new int[old_collation_ids.length + 1];,             System.arraycopy(,                 old_collation_ids, 0, collation_ids, 0, ,                 old_collation_ids.length);, ,             // add the new column's collation id.,             collation_ids[old_collation_ids.length] =  collation_id;,            ,             // row in slot 0 of heap page 1 which is just a single column with,             // the heap entry.,             DataValueDescriptor[] control_row = new DataValueDescriptor[1];,             control_row[0] = this;, ,             page =,                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);, ,             page.updateAtSlot(,                 Page.FIRST_SLOT_NUMBER,,                 control_row,,                 (FormatableBitSet) null);, ,             page.unlatch();,             page = null;,         },         finally,         {,             if (container != null),                 container.close();,             if (page !=null),                 page.unlatch();,         }, ,         return;,     }, , , 	/**, 	Drop this heap., 	@see Conglomerate#drop, , 	@exception StandardException Standard exception policy., 	**/, 	public void drop(TransactionManager xact_manager), 		throws StandardException, 	{,         xact_manager.getRawStoreXact().dropContainer(id);, 	}, ,     /**,      * Retrieve the maximum value row in an ordered conglomerate.,      * <p>,      * Returns true and fetches the rightmost row of an ordered conglomerate ,      * into "fetchRow" if there is at least one row in the conglomerate.  If,      * there are no rows in the conglomerate it returns false.,      * <p>,      * Non-ordered conglomerates will not implement this interface, calls,      * will generate a StandardException.,      * <p>,      * RESOLVE - this interface is temporary, long term equivalent (and more) ,      * functionality will be provided by the openBackwardScan() interface.  ,      *, 	 * @param conglomId       The identifier of the conglomerate, 	 *                        to open the scan for.,      *, 	 * @param open_mode       Specifiy flags to control opening of table.  ,      *                        OPENMODE_FORUPDATE - if set open the table for,      *                        update otherwise open table shared.,      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).,      *,      * @param isolation_level The isolation level to lock the conglomerate at.,      *                        One of (ISOLATION_READ_COMMITTED or ,      *                        ISOLATION_SERIALIZABLE).,      *, 	 * @param scanColumnList  A description of which columns to return from ,      *                        every fetch in the scan.  template, ,      *                        and scanColumnList work together,      *                        to describe the row to be returned by the scan - ,      *                        see RowUtil for description of how these three ,      *                        parameters work together to describe a "row".,      *,      * @param fetchRow        The row to retrieve the maximum value into.,      *, 	 * @return boolean indicating if a row was found and retrieved or not.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public boolean fetchMaxOnBTree(, 	TransactionManager      xact_manager,,     Transaction             rawtran,,     long                    conglomId,,     int                     open_mode,,     int                     lock_level,,     LockingPolicy           locking_policy,,     int                     isolation_level,,     FormatableBitSet                 scanColumnList,,     DataValueDescriptor[]   fetchRow),         throws StandardException,     {,         // no support for max on a heap table.,         throw(StandardException.newException(,                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));,     }, ,     /**,      * Get the id of the container of the conglomerate.,      * <p>,      * Will have to change when a conglomerate could have more than one ,      * container.  The ContainerKey is a combination of the container id,      * and segment id.,      *, 	 * @return The ContainerKey.,      **/,     public final ContainerKey getId(),     {,         return(id);,     }, , ,     public final long getContainerid(),     {,         return(id.getContainerId());,     }, ,     /**,      * Return dynamic information about the conglomerate to be dynamically ,      * reused in repeated execution of a statement.,      * <p>,      * The dynamic info is a set of variables to be used in a given ,      * ScanController or ConglomerateController.  It can only be used in one ,      * controller at a time.  It is up to the caller to insure the correct ,      * thread access to this info.  The type of info in this is a scratch ,      * template for btree traversal, other scratch variables for qualifier ,      * evaluation, ...,      * <p>,      *, 	 * @return The dynamic information.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo(), 		throws StandardException,     {,         return(new OpenConglomerateScratchSpace(,                 format_ids, collation_ids, hasCollatedTypes));,     }, ,     /**,      * Return static information about the conglomerate to be included in a,      * a compiled plan.,      * <p>,      * The static info would be valid until any ddl was executed on the ,      * conglomid, and would be up to the caller to throw away when that ,      * happened.  This ties in with what language already does for other ,      * invalidation of static info.  The type of info in this would be ,      * containerid and array of format id's from which templates can be created.,      * The info in this object is read only and can be shared among as many ,      * threads as necessary.,      * <p>,      *, 	 * @return The static compiled information.,      *,      * @param conglomId The identifier of the conglomerate to open.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(,     TransactionController   tc,,     long                    conglomId), 		throws StandardException,     {,         return(this);,     }, , ,     /**,      * Is this conglomerate temporary?,      * <p>,      *, 	 * @return whether conglomerate is temporary or not.,      **/,     public boolean isTemporary(),     {,         return(id.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);,     }, , ,     /**,      * Bulk load into the conglomerate.,      * <p>,      *,      * @see Conglomerate#load,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public long load(, 	TransactionManager      xact_manager,, 	boolean                 createConglom,, 	RowLocationRetRowSource rowSource), 		 throws StandardException, 	{,         long num_rows_loaded = 0;, , 		HeapController heapcontroller = new HeapController();, , 		try, 		{, 			num_rows_loaded = ,                 heapcontroller.load(,                     xact_manager,,                     this, ,                     createConglom,,                     rowSource);, 		}, 		finally, 		{, 			// Done with this heap controller., 			heapcontroller.close();, 		}, ,         return(num_rows_loaded);, 	}, ,     /**,      * Open a heap controller.,      * <p>,      *, 	 * @see Conglomerate#open,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public ConglomerateController open(,     TransactionManager              xact_manager,,     Transaction                     rawtran,,     boolean                         hold,,     int                             open_mode,,     int                             lock_level,,     LockingPolicy                   locking_policy,,     StaticCompiledOpenConglomInfo   static_info,,     DynamicCompiledOpenConglomInfo  dynamic_info), 		throws StandardException, 	{,         OpenConglomerate open_conglom = new OpenHeap();, ,         if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 xact_manager,,                 rawtran,,                 hold,,                 open_mode,,                 lock_level,,                 locking_policy,,                 dynamic_info) == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_CONTAINER_NOT_FOUND, ,                     new Long(id.getContainerId()).toString());,         }, , 		HeapController heapcontroller = new HeapController();, ,         heapcontroller.init(open_conglom);, , 		return(heapcontroller);, 	}, ,     /**,      * Open a heap scan controller.,      * <p>,      *,      * @see Conglomerate#openScan,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public ScanManager openScan(,     TransactionManager              xact_manager,,     Transaction                     rawtran,,     boolean                         hold,,     int                             open_mode,,     int                             lock_level,,     LockingPolicy                   locking_policy,,     int                             isolation_level,, 	FormatableBitSet				scanColumnList,,     DataValueDescriptor[]	        startKeyValue,,     int                             startSearchOperator,,     Qualifier                       qualifier[][],,     DataValueDescriptor[]	        stopKeyValue,,     int                             stopSearchOperator,,     StaticCompiledOpenConglomInfo   static_info,,     DynamicCompiledOpenConglomInfo  dynamic_info), 		throws StandardException, 	{,         if (SanityManager.DEBUG) {,             if ((open_mode &,                     TransactionController.OPENMODE_LOCK_ROW_NOWAIT) != 0) {,                 SanityManager.THROWASSERT(,                     "Bad open mode to Heap#openScan:" +,                     Integer.toHexString(open_mode));,             },         }, ,         // Heap scans do not suppport start and stop scan positions (these,         // only make sense for ordered storage structures)., 		if (!RowUtil.isRowEmpty(startKeyValue), 			|| !RowUtil.isRowEmpty(stopKeyValue)), 		{,             throw StandardException.newException(,                     SQLState.HEAP_UNIMPLEMENTED_FEATURE);, 		}, ,         OpenConglomerate open_conglom = new OpenHeap();, ,         if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 xact_manager,,                 rawtran,,                 hold,,                 open_mode,,                 lock_level,,                 locking_policy,,                 dynamic_info) == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_CONTAINER_NOT_FOUND, ,                     new Long(id.getContainerId()));,         }, , 		HeapScan heapscan = new HeapScan();, ,         heapscan.init(,             open_conglom,,             scanColumnList,,             startKeyValue,,             startSearchOperator,,             qualifier,,             stopKeyValue,,             stopSearchOperator);, , 		return(heapscan);, 	}, , 	public void purgeConglomerate(,     TransactionManager              xact_manager,,     Transaction                     rawtran),         throws StandardException,     {,         OpenConglomerate        open_for_ddl_lock   = null;,         HeapController          heapcontroller      = null;,         TransactionManager      nested_xact         = null;, ,         try,         {,             open_for_ddl_lock = new OpenHeap();, ,             // Open table in intended exclusive mode in the top level ,             // transaction, this will stop any ddl from happening until ,             // purge of whole table is finished., ,             if (open_for_ddl_lock.init(,                     (ContainerHandle) null,,                     this,,                     this.format_ids,,                     this.collation_ids,,                     xact_manager,,                     rawtran,,                     false,,                     TransactionController.OPENMODE_FORUPDATE,,                     TransactionController.MODE_RECORD,,                     null,,                     null) == null),             {,                 throw StandardException.newException(,                         SQLState.HEAP_CONTAINER_NOT_FOUND, ,                         new Long(id.getContainerId()));,             }, ,             // perform all the "real" work in a non-readonly nested user ,             // transaction, so that as work is completed on each page resources,             // can be released.  Must be careful as all locks obtained in nested,             // transaction will conflict with parent transaction - so this call,             // must be made only if parent transaction can have no conflicting,             // locks on the table, otherwise the purge will fail with a self,             // deadlock.,             nested_xact = (TransactionManager) ,                 xact_manager.startNestedUserTransaction(false, true);, ,             // now open the table in a nested user transaction so that each,             // page worth of work can be committed after it is done., ,             OpenConglomerate open_conglom = new OpenHeap();, ,             if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 nested_xact,,                 nested_xact.getRawStoreXact(),,                 true,,                 TransactionController.OPENMODE_FORUPDATE,,                 TransactionController.MODE_RECORD,,                 nested_xact.getRawStoreXact().newLockingPolicy(,                     LockingPolicy.MODE_RECORD,,                         TransactionController.ISOLATION_REPEATABLE_READ, true),,                 null) == null),             {,                 throw StandardException.newException(,                         SQLState.HEAP_CONTAINER_NOT_FOUND, ,                         new Long(id.getContainerId()).toString());,             }, ,             heapcontroller = new HeapController();, ,             heapcontroller.init(open_conglom);, ,             Page page   = open_conglom.getContainer().getFirstPage();, ,             boolean purgingDone = false;, ,             while (page != null),             {,                 long pageno = page.getPageNumber();,                 purgingDone = heapcontroller.purgeCommittedDeletes(page);, ,                 if (purgingDone),                 {,                     page = null;, ,                     // commit xact to free resouurces ASAP, commit will,                     // unlatch the page if it has not already been unlatched,                     // by a remove.,                     open_conglom.getXactMgr().commitNoSync(,                                 TransactionController.RELEASE_LOCKS);, ,                     // the commit closes the underlying container, so let,                     // the heapcontroller know this has happened.  Usually,                     // the transaction takes care of this, but this controller,                     // is internal, so the transaction does not know about it.,                     heapcontroller.closeForEndTransaction(false);,                     ,                     // the commit will close the underlying ,                     open_conglom.reopen();,                 },                 else,                 {,                     page.unlatch();,                     page = null;,                 }, ,                 page = open_conglom.getContainer().getNextPage(pageno);,             },         },         finally,         {,             if (open_for_ddl_lock != null),                 open_for_ddl_lock.close();,             if (heapcontroller != null),                 heapcontroller.close();,             if (nested_xact != null),             {,                 nested_xact.commitNoSync(TransactionController.RELEASE_LOCKS);,                 nested_xact.destroy();,             },         }, ,         return;,     }, , 	public void compressConglomerate(,     TransactionManager              xact_manager,,     Transaction                     rawtran),         throws StandardException,     {,         OpenConglomerate        open_conglom    = null;,         HeapController          heapcontroller  = null;, ,         try,         {,             open_conglom = new OpenHeap();, ,             // Open table in intended exclusive mode in the top level ,             // transaction, this will stop any ddl from happening until ,             // purge of whole table is finished., ,             if (open_conglom.init(,                     (ContainerHandle) null,,                     this,,                     this.format_ids,,                     this.collation_ids,,                     xact_manager,,                     rawtran,,                     false,,                     TransactionController.OPENMODE_FORUPDATE,,                     TransactionController.MODE_TABLE,,                     rawtran.newLockingPolicy(,                         LockingPolicy.MODE_CONTAINER,,                         TransactionController.ISOLATION_REPEATABLE_READ, true),,                     null) == null),             {,                 throw StandardException.newException(,                         SQLState.HEAP_CONTAINER_NOT_FOUND, ,                         new Long(id.getContainerId()));,             }, ,             heapcontroller = new HeapController();, ,             heapcontroller.init(open_conglom);, ,             open_conglom.getContainer().compressContainer();,         },         finally,         {,             if (open_conglom != null),                 open_conglom.close();,         }, ,         return;,     }, ,     /**,      * Open a heap compress scan.,      * <p>,      *,      * @see Conglomerate#defragmentConglomerate,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	public ScanManager defragmentConglomerate(,     TransactionManager              xact_manager,,     Transaction                     rawtran,,     boolean                         hold,,     int                             open_mode,,     int                             lock_level,,     LockingPolicy                   locking_policy,,     int                             isolation_level), 		throws StandardException, 	{,         OpenConglomerate open_conglom = new OpenHeap();, ,         if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 xact_manager,,                 rawtran,,                 hold,,                 open_mode,,                 lock_level,,                 rawtran.newLockingPolicy(,                     LockingPolicy.MODE_RECORD,,                     TransactionController.ISOLATION_REPEATABLE_READ, true),,                 null) == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_CONTAINER_NOT_FOUND, ,                     new Long(id.getContainerId()));,         }, , 		HeapCompressScan heap_compress_scan = new HeapCompressScan();, ,         heap_compress_scan.init(,             open_conglom,,             null,,             null,,             0,,             null,,             null,,             0);, , 		return(heap_compress_scan);, 	}, , ,     /**,      * Return an open StoreCostController for the conglomerate.,      * <p>,      * Return an open StoreCostController which can be used to ask about ,      * the estimated row counts and costs of ScanController and ,      * ConglomerateController operations, on the given conglomerate.,      * <p>, 	 * @param xact_manager The TransactionController under which this ,      *                     operation takes place., 	 * @param rawtran  raw transaction context in which scan is managed.,      *, 	 * @return The open StoreCostController.,      *, 	 * @exception  StandardException  Standard exception policy.,      *,      * @see StoreCostController,      **/,     public StoreCostController openStoreCost(,     TransactionManager  xact_manager,,     Transaction         rawtran), 		throws StandardException,     {,         OpenHeap open_conglom = new OpenHeap();, ,         if (open_conglom.init(,                 (ContainerHandle) null,,                 this,,                 this.format_ids,,                 this.collation_ids,,                 xact_manager,,                 rawtran,,                 false,,                 ContainerHandle.MODE_READONLY,,                 TransactionController.MODE_TABLE,,                 (LockingPolicy) null,,                 (DynamicCompiledOpenConglomInfo) null) == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_CONTAINER_NOT_FOUND, ,                     new Long(id.getContainerId()));,         }, , ,         HeapCostController heapcost = new HeapCostController();, ,         heapcost.init(open_conglom);, , 		return(heapcost);,     }, , ,     /**,      * Print this heap.,      **/,     public String toString(),     {,         return (id == null) ? "null" : id.toString();,     }, ,     /**************************************************************************,      * Public Methods of StaticCompiledOpenConglomInfo Interface:,      **************************************************************************,      */, ,     /**,      * return the "Conglomerate".,      * <p>,      * For heap just return "this", which both implements Conglomerate and,      * StaticCompiledOpenConglomInfo.,      * <p>,      *, 	 * @return this,      **/,     public DataValueDescriptor getConglom(),     {,         return(this);,     }, , ,     /**************************************************************************, 	 * Methods of Storable (via Conglomerate), 	 * Storable interface, implies Externalizable, TypedFormat,      **************************************************************************,      */, ,     /**,      * Return my format identifier.,      *,      * @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId,      **/, 	public int getTypeFormatId(),     {, 		return StoredFormatIds.ACCESS_HEAP_V3_ID;, 	}, ,     /**,      * Return whether the value is null or not.,      *, 	 * @see org.apache.derby.iapi.services.io.Storable#isNull,      **/, 	public boolean isNull(), 	{, 		return id == null;, 	}, ,     /**,      * Restore the in-memory representation to the null value.,      *,      * @see org.apache.derby.iapi.services.io.Storable#restoreToNull,      *,      **/, 	public void restoreToNull(), 	{, 		id = null;, 	}, ,     /**,      * Store the stored representation of the column value in the stream.,      *,      **/, ,     /**,      * Store the 10.2 format stored representation of column value in stream.,      * <p>,      * This routine stores the 10.2 version the Heap, ie. the ACCESS_HEAP_V2_ID,      * format.  It is used by any database which has been created in ,      * 10.2 or a previous release and has not been hard upgraded to a ,      * version subsequent to 10.2.,      * <p>,      **/, 	protected void writeExternal_v10_2(ObjectOutput out) throws IOException,     {, ,         // write the format id of this conglomerate,         FormatIdUtil.writeFormatIdInteger(out, conglom_format_id);, , 		out.writeInt((int) id.getSegmentId());,         out.writeLong(id.getContainerId());, ,         // write number of columns in heap.,         out.writeInt(format_ids.length);, ,         // write out array of format id's,         ConglomerateUtil.writeFormatIdArray(format_ids, out);, 	}, ,     /**,      * Store the stored representation of column value in stream.,      * <p>,      * This routine uses the current database version to either store the,      * the 10.2 format (ACCESS_HEAP_V2_ID) or the current format ,      * (ACCESS_HEAP_V3_ID).  ,      * <p>,      **/, 	public void writeExternal(ObjectOutput out) throws IOException,     {,         writeExternal_v10_2(out);, ,         if (conglom_format_id == StoredFormatIds.ACCESS_HEAP_V3_ID),         {,             // Now append sparse array of collation ids,             ConglomerateUtil.writeCollationIdArray(collation_ids, out);,         }, 	}, ,     /**,      * Restore the in-memory representation from the stream.,      * <p>,      *,      * @exception ClassNotFoundException Thrown if the stored representation ,      *                                   is serialized and a class named in ,      *                                   the stream could not be found.,      *,      * @see java.io.Externalizable#readExternal,      **/,     public void readExternal(ObjectInput in), 		throws IOException, ClassNotFoundException, 	{, ,         // read the format id of this conglomerate.,         conglom_format_id = FormatIdUtil.readFormatIdInteger(in);, , 		int segmentid = in.readInt();,         long containerid = in.readLong();, , 		id = new ContainerKey(segmentid, containerid);, ,         // read the number of columns in the heap.,         int num_columns = in.readInt();, ,         // read the array of format ids.,         format_ids = ConglomerateUtil.readFormatIdArray(num_columns, in);, ,         // In memory maintain a collation id per column in the template.,         collation_ids = new int[format_ids.length];,         if (SanityManager.DEBUG) {,             SanityManager.ASSERT(!hasCollatedTypes);,         }, ,         // initialize all the entries to COLLATION_TYPE_UCS_BASIC, ,         // and then reset as necessary.  For version ACCESS_HEAP_V2_ID,,         // this is the default and no resetting is necessary.,         for (int i = 0; i < format_ids.length; i++),             collation_ids[i] = StringDataValue.COLLATION_TYPE_UCS_BASIC;, , 		if (conglom_format_id == StoredFormatIds.ACCESS_HEAP_V3_ID),         {,             // current format id, read collation info from disk, ,             hasCollatedTypes =,                     ConglomerateUtil.readCollationIdArray(collation_ids, in);,         },         else if (conglom_format_id != StoredFormatIds.ACCESS_HEAP_V2_ID),         {,             // Currently only V2 and V3 should be possible in a Derby DB.,             // Actual work for V2 is handled by default code above, so no,             // special work is necessary., ,             if (SanityManager.DEBUG),             {,                 SanityManager.THROWASSERT(,                     "Unexpected format id: " + conglom_format_id);,             },         },     }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/access/heap/HeapCompressScan.java,fetchRowsForCompress,232-232,[                    long[]         new_pageno = new long[1];],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/HeapConglomerateFactory.java,readConglomerate,256-256,[                    new Long(container_key.getContainerId()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/HeapController.java,doInsert,238-238,[                throw(StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/heap/HeapController.java,load,369-369,[                    new Long(heap.getId().getContainerId()));],,load,415-415,[                        throw(StandardException.newException(],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/store/access/heap/HeapController.java,,61-751,[public class HeapController ,     extends GenericConglomerateController ,     implements ConglomerateController, {,     /**************************************************************************,      * Fields of the class,      **************************************************************************,      */, ,     /**************************************************************************,      * Constructors for This class:,      **************************************************************************,      */, ,     /**************************************************************************,      * Protected concrete impl of abstract methods of ,      *     GenericConglomerateController class:,      **************************************************************************,      */,     protected final void getRowPositionFromRowLocation(,     RowLocation row_loc,,     RowPosition pos),         throws StandardException,     {,         if (SanityManager.DEBUG),         {,             SanityManager.ASSERT(row_loc instanceof HeapRowLocation);,         },         pos.current_rh = ,             ((HeapRowLocation) row_loc).getRecordHandle(,                 open_conglom.getContainer());,         pos.current_rh_qualified = true;,     }, ,     protected void queueDeletePostCommitWork(,     RowPosition pos),         throws StandardException,     {,         TransactionManager xact_mgr = open_conglom.getXactMgr();, ,         xact_mgr.addPostCommitWork(,             new HeapPostCommit(,                 xact_mgr.getAccessManager(), ,                 (Heap) open_conglom.getConglomerate(),,                 pos.current_page.getPageNumber()));,     }, ,     /**************************************************************************,      * Private/Protected methods of This class:,      **************************************************************************,      */, ,     /**,      * Check and purge committed deleted rows on a page.,      * <p>,      * , 	 * @return true, if no purging has been done on page, and thus latch,      *         can be released before end transaction.  Otherwise the latch,      *         on the page can not be released before commit.,      *,      * @param page   A non-null, latched page must be passed in.  If all,      *               rows on page are purged, then page will be removed and,      *               latch released.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     protected final boolean purgeCommittedDeletes(,     Page                page),         throws StandardException,     {,         boolean purgingDone = false;, ,         // The number records that can be reclaimed is:,         // total recs - recs_not_deleted,         int num_possible_commit_delete = ,             page.recordCount() - page.nonDeletedRecordCount();, ,         if (num_possible_commit_delete > 0),         {,             // loop backward so that purges which affect the slot table ,             // don't affect the loop (ie. they only move records we ,             // have already looked at).,             for (int slot_no = page.recordCount() - 1; ,                  slot_no >= 0; ,                  slot_no--) ,             {,                 boolean row_is_committed_delete = ,                     page.isDeletedAtSlot(slot_no);, ,                 if (row_is_committed_delete),                 {,                     // At this point we only know that the row is,                     // deleted, not whether it is committed., ,                     // see if we can purge the row, by getting an,                     // exclusive lock on the row.  If it is marked,                     // deleted and we can get this lock, then it,                     // must be a committed delete and we can purge ,                     // it., ,                     RecordHandle rh =,                         page.fetchFromSlot(,                             (RecordHandle) null,,                             slot_no,,                             RowUtil.EMPTY_ROW,,                             RowUtil.EMPTY_ROW_FETCH_DESCRIPTOR,,                             true);, ,                     row_is_committed_delete =,                         this.lockRowAtSlotNoWaitExclusive(rh);, ,                     if (row_is_committed_delete),                     {,                         purgingDone = true;, ,                         page.purgeAtSlot(slot_no, 1, false);,                     },                 },             },         },         if (page.recordCount() == 0),         {, ,             // Deallocate the current page with 0 rows on it.,             this.removePage(page);, ,             // removePage guarantees to unlatch the page even if an,             // exception is thrown. The page is protected against reuse,             // because removePage locks it with a dealloc lock, so it,             // is OK to release the latch even after a purgeAtSlot is,             // called.,             // @see ContainerHandle#removePage, ,             purgingDone = true;,         }, ,         return(purgingDone);,     }, ,     /**,      * Insert a new row into the heap.,      * <p>,      * Overflow policy:,      * The current heap access method implements an algorithm that optimizes,      * for fetch efficiency vs. space efficiency.  A row will not be over,      * flowed unless it is bigger than a page.  If it is bigger than a page,      * then it's initial part will be placed on a page and then subsequent,      * parts will be overflowed to other pages.,      * <p>,      *, 	 * @return The record handle of the inserted row.,      *,      * @param row           The row to insert.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/, 	private RecordHandle doInsert(DataValueDescriptor[] row), 		throws StandardException, 	{, 		Page page = null;,         byte  insert_mode;, 		,         RecordHandle rh;, ,         if (SanityManager.DEBUG),         {,             Heap heap = (Heap) open_conglom.getConglomerate();,             // Make sure valid columns are in the list.  The RowUtil,             // call is too expensive to make in a released system for,             // every insert., ,             int invalidColumn = ,                 RowUtil.columnOutOfRange(,                     row, null, heap.format_ids.length);, ,             if (invalidColumn >= 0),             {,                 throw(StandardException.newException(,                         SQLState.HEAP_TEMPLATE_MISMATCH,,                         new Long(invalidColumn), ,                         new Long(heap.format_ids.length)));,             },         }, ,         // Get the last page that was returned for insert or the last page,         // that was allocated.,         page = open_conglom.getContainer().getPageForInsert(0);, ,         if (page != null) {, ,             // if there are 0 rows on the page allow the insert to overflow.,             insert_mode = ,                 (page.recordCount() == 0) ? ,                     Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;, ,             // Check to see if there is enough space on the page,             // for the row.,             rh = page.insert(row, null, insert_mode,, 				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);,             page.unlatch();,             page = null;, ,             // If we have found a page with enough space for the row,,             // insert it and release exclusive access to the page.,             if (rh != null),             {,                 return rh;, ,             },         }, ,         // If the last inserted page is now full, or RawStore have,         // forgotten what it was, or the row cannot fit on the last,         // inserted page, try to have rawStore get a relatively unfilled,         // page., ,         page = ,             open_conglom.getContainer().getPageForInsert(,                 ContainerHandle.GET_PAGE_UNFILLED);, ,         if (page != null),         {,             // Do the insert all over again hoping that it will fit into,             // this page, and if not, allocate a new page., ,             // if there are 0 rows on the page allow the insert to overflow.,             insert_mode = ,                 (page.recordCount() == 0) ? ,                     Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;,             ,             rh = page.insert(row, null, insert_mode,, 				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);, ,             page.unlatch();,             page = null;, ,             // If we have found a page with enough space for the row,,             // insert it and release exclusive access to the page.,             if (rh != null),             {,                 return rh;,             },         }, ,         page = open_conglom.getContainer().addPage();, ,         // At this point with long rows the raw store will guarantee,         // that any size row will fit on an empty page., ,         rh = page.insert(row, null, Page.INSERT_OVERFLOW,, 			AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);,         page.unlatch();,         page = null;, ,         if (SanityManager.DEBUG),         {,             // a null will only be returned if this page is not empty,             SanityManager.ASSERT(rh != null);,         }, ,         return rh;, 	}, , 	protected long load(,     TransactionManager      xact_manager,,     Heap                    heap,,     boolean                 createConglom,,     RowLocationRetRowSource rowSource), 		 throws StandardException, 	{,         long    num_rows_loaded = 0;, , 		if (SanityManager.DEBUG),         {, 			SanityManager.ASSERT(open_conglom == null,, 				"load expects container handle to be closed on entry.");,         }, , 		// The individual rows that are inserted are not logged.  To use a, 		// logged interface, use insert.  RESOLVE: do we want to allow client, 		// to use the load interface even for logged insert?, 		int mode = ,             (ContainerHandle.MODE_FORUPDATE | ContainerHandle.MODE_UNLOGGED); , , 		// If the container is being created in the same operation, don't log, 		// page allocation.  , 		if (createConglom), 			mode |= ContainerHandle.MODE_CREATE_UNLOGGED;, ,         OpenConglomerate open_conglom = new OpenHeap();, ,         if (open_conglom.init(,                 (ContainerHandle) null,,                 heap,,                 heap.format_ids,,                 heap.collation_ids,,                 xact_manager,,                 xact_manager.getRawStoreXact(),,                 false,,                 mode,,                 TransactionController.MODE_TABLE,,                 xact_manager.getRawStoreXact().newLockingPolicy(,                     LockingPolicy.MODE_CONTAINER,,                     TransactionController.ISOLATION_SERIALIZABLE, true),,                 (DynamicCompiledOpenConglomInfo) null) == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_CONTAINER_NOT_FOUND, ,                     new Long(heap.getId().getContainerId()));,         }, ,         this.init(open_conglom);, , 		// For bulk loading, we always use only brand new page because the row, 		// insertion itself is not logged.  We cannot pollute pages with, 		// pre-existing data with unlogged rows because nobody is going to wipe, 		// out these rows if the transaction rolls back.  We are counting on, 		// the allocation page rollback to obliterate these rows if the, 		// transaction fails, or, in the CREAT_UNLOGGED case, the whole, 		// container to be removed., , 		Page page = open_conglom.getContainer().addPage();, , 		boolean callbackWithRowLocation = rowSource.needsRowLocation();, 		RecordHandle rh;, 		HeapRowLocation rowlocation;, ,         if (callbackWithRowLocation ||,             rowSource.needsRowLocationForDeferredCheckConstraints()), 			rowlocation = new HeapRowLocation();, 		else, 			rowlocation = null;, ,         FormatableBitSet validColumns = rowSource.getValidColumns();, , 		try, 		{,  			// get the next row and its valid columns from the rowSource, 			DataValueDescriptor[] row;,             while ((row = rowSource.getNextRowFromRowSource()) != null),             {,                 num_rows_loaded++;, ,                 if (SanityManager.DEBUG),                 {,                     // Make sure valid columns are in the list.  The RowUtil,                     // call is too expensive to make in a released system for ,                     // every insert.,                     int invalidColumn = ,                         RowUtil.columnOutOfRange(,                             row, validColumns, heap.format_ids.length);, ,                     if (invalidColumn >= 0),                     {,                         throw(StandardException.newException(,                                 SQLState.HEAP_TEMPLATE_MISMATCH,,                                 new Long(invalidColumn), ,                                 new Long(heap.format_ids.length)));,                     },                 }, , , 				// Insert it onto this page as long as it can fit more rows., 				if ((rh = page.insert(,                         row, validColumns, Page.INSERT_DEFAULT,, 						AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD)) ,                                 == null), 				{, 					// Insert faied, row did not fit.  Get a new page.  , , 					page.unlatch();, 					page = null;, , 					page = open_conglom.getContainer().addPage();, , 					// RESOLVE (mikem) - no long rows yet so the following code, 					// will get an exception from the raw store for a row that, 					// does not fit on a page., 					//, 					// Multi-thread considerations aside, the raw store will ,                     // guarantee that any size row will fit on an empty page., 					rh = page.insert(,                             row, validColumns, Page.INSERT_OVERFLOW,, 							AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);, , 				}, , 				// Else, the row fit.  If we are expected to call back with the, 				// row location, do so.  All the while keep the page latched, 				// and go for the next row., 				if (callbackWithRowLocation), 				{, 					rowlocation.setFrom(rh);, 					rowSource.rowLocation(rowlocation);, 				}, ,                 if (rowSource.needsRowLocationForDeferredCheckConstraints()) {,                     rowlocation.setFrom(rh);,                     rowSource.offendingRowLocation(rowlocation,,                                                    heap.getContainerid());,                 }, 			}, 			page.unlatch();, 			page = null;, , 			// Done with the container, now we need to flush it to disk since, 			// it is unlogged.,             if (!heap.isTemporary()),                 open_conglom.getContainer().flushContainer();, 		}, 		finally, 		{,             // If an error happened here, don't bother flushing the,             // container since the changes should be rolled back anyhow.,             close();, 		},         return(num_rows_loaded);, 	}, ,     protected boolean lockRow(,     RecordHandle    rh,,     int             lock_oper,,     boolean         wait,,     int             lock_duration),         throws StandardException,     {,         boolean ret_val;,         boolean forUpdate = ,             ((ConglomerateController.LOCK_UPD & lock_oper) != 0);,         boolean forUpdateLock = ,             ((ConglomerateController.LOCK_UPDATE_LOCKS & lock_oper) != 0);, ,         if (forUpdate && !forUpdateLock),         {,             boolean forInsert = ,                 ((ConglomerateController.LOCK_INS & lock_oper) != 0);,             boolean forInsertPrevKey = ,                 ((ConglomerateController.LOCK_INS_PREVKEY & lock_oper) != 0);, ,             if (SanityManager.DEBUG),             {,                 SanityManager.ASSERT(!(forInsertPrevKey && forInsert));,             }, ,             if (lock_duration == TransactionManager.LOCK_INSTANT_DURATION),             {,                 ret_val = ,                     open_conglom.getContainer().getLockingPolicy().,                         zeroDurationLockRecordForWrite(,                             open_conglom.getRawTran(), rh, forInsertPrevKey, wait);,             },             else,             {,                 ret_val = ,                     open_conglom.getContainer().getLockingPolicy().,                         lockRecordForWrite(,                             open_conglom.getRawTran(), rh, forInsert, wait);,             },         },         else,         {,             if (SanityManager.DEBUG),             {,                 SanityManager.ASSERT(,                     (ConglomerateController.LOCK_INS & lock_oper) == 0);,                 SanityManager.ASSERT(,                     (ConglomerateController.LOCK_INS_PREVKEY & lock_oper) == 0);,             }, ,             ret_val = ,                 open_conglom.getContainer().getLockingPolicy().lockRecordForRead(,                     open_conglom.getRawTran(), ,                     open_conglom.getContainer(), rh, wait, forUpdate);,         }, ,         return(ret_val);,     }, ,     protected Page getUserPageNoWait(long pageno),         throws StandardException,     {,         return(open_conglom.getContainer().getUserPageNoWait(pageno));,     },     protected Page getUserPageWait(long pageno),         throws StandardException,     {,         return(open_conglom.getContainer().getUserPageWait(pageno));,     },     protected boolean lockRowAtSlotNoWaitExclusive(RecordHandle rh),         throws StandardException,     {,         return(,             open_conglom.getContainer().getLockingPolicy().,                 lockRecordForWrite(,                     open_conglom.getRawTran(), rh, false, false));,     },     protected void removePage(Page page),         throws StandardException,     {,         open_conglom.getContainer().removePage(page);,     }, ,     /**************************************************************************,      * Public Methods of This class:,      **************************************************************************,      */, ,     public int insert(DataValueDescriptor[] row), 		throws StandardException, 	{, 		if (open_conglom.isClosed()),         {,             if (open_conglom.getHold()),             {,                 open_conglom.reopen();,             },             else,             {,                 throw(StandardException.newException(,                         SQLState.HEAP_IS_CLOSED, ,                         open_conglom.getConglomerate().getId()));,             } ,         }, , 		doInsert(row);, ,         return(0);, 	}, , 	public void insertAndFetchLocation(,     DataValueDescriptor[] row, ,     RowLocation           templateRowLocation), 		throws StandardException, 	{, 		if (open_conglom.isClosed()),         {,             if (open_conglom.getHold()),             {,                 open_conglom.reopen();,             },             else,             {,                 throw(StandardException.newException(,                         SQLState.HEAP_IS_CLOSED, ,                         open_conglom.getConglomerate().getId()));,             } ,         }, , 		RecordHandle rh = doInsert(row);,         if (SanityManager.DEBUG),         {,             SanityManager.ASSERT(,                 templateRowLocation instanceof HeapRowLocation);,         }, 		HeapRowLocation hrl = (HeapRowLocation) templateRowLocation;, 		hrl.setFrom(rh);, 	}, ,     /**,      * Lock the given row location.,      * <p>,      * Should only be called by access.,      * <p>,      * This call can be made on a ConglomerateController that was opened,      * for locking only.,      * <p>,      * RESOLVE (mikem) - move this call to ConglomerateManager so it is,      * obvious that non-access clients should not call this.,      *, 	 * @return true if lock was granted, only can be false if wait was false.,      *, 	 * @param loc       The "RowLocation" which describes the exact row to lock.,      * @param wait      Should the lock call wait to be granted?,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public boolean lockRow(,     RowLocation     loc,,     int             lock_operation,,     boolean         wait,,     int             lock_duration),         throws StandardException,     {,         RecordHandle rh = ,             ((HeapRowLocation) loc).getRecordHandle(,                 open_conglom.getContainer());, ,         return(lockRow(rh, lock_operation, wait, lock_duration));,     }, ,     /**,      * UnLock the given row location.,      * <p>,      * Should only be called by access.,      * <p>,      * This call can be made on a ConglomerateController that was opened,      * for locking only.,      * <p>,      * RESOLVE (mikem) - move this call to ConglomerateManager so it is,      * obvious that non-access clients should not call this.,      *, 	 * @param loc       The "RowLocation" which describes the row to unlock.,      * @param forUpdate Row was previously Locked the record for read or update.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public void unlockRowAfterRead(,     RowLocation     loc,,     boolean         forUpdate,,     boolean         row_qualified),         throws StandardException,     {, ,         RecordHandle rh = ,             ((HeapRowLocation) loc).getRecordHandle(,                 open_conglom.getContainer());, ,         open_conglom.getContainer().getLockingPolicy().,             unlockRecordAfterRead(,                 open_conglom.getRawTran(), ,                 open_conglom.getContainer(),,                 rh, ,                 open_conglom.isForUpdate(),,                 row_qualified);,     }, , ,     /**,      * Lock the given record id/page num pair.,      * <p>,      * Should only be called by access, to lock "special" locks formed from,      * the Recordhandle.* reserved constants for page specific locks.,      * <p>,      * This call can be made on a ConglomerateController that was opened,      * for locking only.,      * <p>,      * RESOLVE (mikem) - move this call to ConglomerateManager so it is,      * obvious that non-access clients should not call this.,      *, 	 * @return true if lock was granted, only can be false if wait was false.,      *,      * @param page_num          Page number of row to lock.,      * @param record_id         Record id of row on page_num to lock.,      * @param lock_operation    Desc of what to lock for, ie. update, insert ...,      * @param wait              Should the lock call wait to be granted?,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public boolean lockRow(,     long            page_num,,     int             record_id,,     int             lock_operation,,     boolean         wait,,     int             lock_duration),         throws StandardException,     {,         boolean ret_val;, ,         RecordHandle rh = ,             open_conglom.getContainer().makeRecordHandle(page_num, record_id);, ,         return(lockRow(rh, lock_operation, wait, lock_duration));,     }, , 	public RowLocation newRowLocationTemplate(), 		throws StandardException, 	{, 		if (open_conglom.isClosed()),         {,             if (open_conglom.getHold()),             {,                 open_conglom.reopen();,             },             else,             {,                 throw(StandardException.newException(,                         SQLState.HEAP_IS_CLOSED, ,                         open_conglom.getConglomerate().getId()));,             } ,         }, , 		return new HeapRowLocation();, 	}, , ,     /**************************************************************************,      * Public Methods of XXXX class:,      **************************************************************************,      */,     public OpenConglomerate getOpenConglomerate() {,         return open_conglom;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/store/access/heap/HeapCostController.java,,70-392,[public class HeapCostController ,     extends GenericCostController implements StoreCostController, {,     /**,      * Only lookup these estimates from raw store once.,      **/,     long    num_pages;,     long    num_rows;,     long    page_size;,     long    row_size;, ,     /* Private/Protected methods of This class: */, ,     /**,      * Initialize the cost controller.,      * <p>,      * Let super.init() do it's work and then get the initial stats about the,      * table from raw store.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public void init(,     OpenConglomerate    open_conglom),         throws StandardException,     {,         super.init(open_conglom);, ,         ContainerHandle container = open_conglom.getContainer();, ,         // look up costs from raw store.,         num_rows  = container.getEstimatedRowCount(/*unused flag*/ 0);, ,         // Don't use 0 rows (use 1 instead), as 0 rows often leads the ,         // optimizer to produce plans which don't use indexes because of the 0 ,         // row edge case.,         //,         // Eventually the plan is recompiled when rows are added, but we,         // have seen multiple customer cases of deadlocks and timeouts ,         // because of these 0 row based plans.  ,         if (num_rows == 0),             num_rows = 1;, ,         // eliminate the allocation page from the count.,         num_pages = container.getEstimatedPageCount(/* unused flag */ 0);, ,         Properties prop = new Properties();,         prop.put(Property.PAGE_SIZE_PARAMETER, "");,         container.getContainerProperties(prop);,         page_size = ,             Integer.parseInt(prop.getProperty(Property.PAGE_SIZE_PARAMETER));, ,         row_size = (num_pages * page_size / num_rows);, ,         return;,     }, ,     /* Public Methods of This class: */,     /* Public Methods of XXXX class: */, , ,     /**,      * Return the cost of calling ConglomerateController.fetch().,      * <p>,      * Return the estimated cost of calling ConglomerateController.fetch(),      * on the current conglomerate.  This gives the cost of finding a record,      * in the conglomerate given the exact RowLocation of the record in,      * question. ,      * <p>,      * The validColumns describes what kind of row is being fetched, ,      * ie. it may be cheaper to fetch a partial row than a complete row.,      * <p>,      *,      *, 	 * @param validColumns    A description of which columns to return from,      *                        row on the page into "templateRow."  templateRow,,      *                        and validColumns work together to,      *                        describe the row to be returned by the fetch - ,      *                        see RowUtil for description of how these three ,      *                        parameters work together to describe a fetched ,      *                        "row".,      *,      * @param access_type     Describe the type of access the query will be,      *                        performing to the ConglomerateController.  ,      *,      *                        STORECOST_CLUSTERED - The location of one fetch,      *                            is likely clustered "close" to the next ,      *                            fetch.  For instance if the query plan were,      *                            to sort the RowLocations of a heap and then,      *                            use those RowLocations sequentially to ,      *                            probe into the heap, then this flag should,      *                            be specified.  If this flag is not set then,      *                            access to the table is assumed to be,      *                            random - ie. the type of access one gets ,      *                            if you scan an index and probe each row,      *                            in turn into the base table is "random".,      *,      *, 	 * @return The cost of the fetch.,      *, 	 * @exception  StandardException  Standard exception policy.,      *, 	 * @see org.apache.derby.iapi.store.access.RowUtil,      **/,     public double getFetchFromRowLocationCost(,     FormatableBitSet      validColumns,,     int         access_type), 		throws StandardException,     {,         double ret_cost;, ,         // get "per-byte" cost of fetching a row from the page.,         ret_cost = row_size * BASE_ROW_PER_BYTECOST;, ,         long num_pages_per_row = (row_size / page_size) + 1;, ,         if ((access_type & StoreCostController.STORECOST_CLUSTERED) == 0),         {,             // this is the "base" unit case.,             ret_cost += (BASE_UNCACHED_ROW_FETCH_COST * num_pages_per_row);,         },         else,         {,             ret_cost += (BASE_CACHED_ROW_FETCH_COST * num_pages_per_row);,         }, ,         return(ret_cost);,     }, ,     /**,      * Calculate the cost of a scan.,      * <p>,      * Cause this object to calculate the cost of performing the described,      * scan.  The interface is setup such that first a call is made to,      * calcualteScanCost(), and then subsequent calls to accessor routines,      * are made to get various pieces of information about the cost of,      * the scan.,      * <p>,      * For the purposes of costing this routine is going to assume that ,      * a page will remain in cache between the time one next()/fetchNext(),      * call and a subsequent next()/fetchNext() call is made within a scan.,      * <p>,      * The result of costing the scan is placed in the "cost_result".  ,      * The cost of the scan is stored by calling ,      * cost_result.setEstimatedCost(cost).,      * The estimated row count is stored by calling ,      * cost_result.setEstimatedRowCount(row_count).,      * <p>,      * The estimated cost of the scan assumes the caller will ,      * execute a fetchNext() loop for every row that qualifies between,      * start and stop position.  Note that this cost is different than,      * execution a next(),fetch() loop; or if the scan is going to be,      * terminated by client prior to reaching the stop condition.,      * <p>,      * The estimated number of rows returned from the scan ,      * assumes the caller will execute a fetchNext() loop for every ,      * row that qualifies between start and stop position.,      * <p>,      *,      *,      * @param scan_type       The type of scan that will be executed.  There,      *                        are currently 2 types:,      *                        STORECOST_SCAN_NORMAL - scans will be executed,      *                        using the standard next/fetch, where each fetch,      *                        can retrieve 1 or many rows (if fetchNextGroup(),      *                        interface is used).,      *,      *                        STORECOST_SCAN_SET - The entire result set will,      *                        be retrieved using the the fetchSet() interface.,      *,      * @param row_count       Estimated total row count of the table.  The ,      *                        current system tracks row counts in heaps better,      *                        than btree's (btree's have "rows" which are not,      *                        user rows - branch rows, control rows), so ,      *                        if available the client should,      *                        pass in the base table's row count into this,      *                        routine to be used as the index's row count.,      *                        If the caller has no idea, pass in -1.,      *,      * @param group_size      The number of rows to be returned by a single,      *                        fetch call for STORECOST_SCAN_NORMAL scans.,      *, 	 * @param forUpdate       Should be true if the caller intends to update ,      *                        through the scan.,      * , 	 * @param scanColumnList  A description of which columns to return from ,      *                        every fetch in the scan.  template, ,      *                        and scanColumnList work together,      *                        to describe the row to be returned by the scan - ,      *                        see RowUtil for description of how these three ,      *                        parameters work together to describe a "row".,      * ,      * @param template        A prototypical row which the scan may use to, 	 *                        maintain its position in the conglomerate.  Not ,      *                        all access method scan types will require this, ,      *                        if they don't it's ok to pass in null.,      *                        In order to scan a conglomerate one must ,      *                        allocate 2 separate "row" templates.  The "row" ,      *                        template passed into openScan is for the private,      *                        use of the scan itself, and no access to it,      *                        should be made by the caller while the scan is ,      *                        still open.  Because of this the scanner must ,      *                        allocate another "row" template to hold the ,      *                        values returned from fetch().  Note that this ,      *                        template must be for the full row, whether a ,      *                        partial row scan is being executed or not.,      *, 	 * @param startKeyValue   An indexable row which holds a (partial) key ,      *                        value which, in combination with the ,      *                        startSearchOperator, defines the starting ,      *                        position of the scan.  If null, the starting,      *                        position of the scan is the first row of the ,      *                        conglomerate.  The startKeyValue must only,      *                        reference columns included in the scanColumnList.,      *, 	 * @param startSearchOperator ,      *                        an operator which defines how the startKeyValue,      *                        is to be searched for.  If startSearchOperation ,      *                        is ScanController.GE, the scan starts on the ,      *                        first row which is greater than or equal to the , 	 *                        startKeyValue.  If startSearchOperation is ,      *                        ScanController.GT, the scan starts on the first,      *                        row whose key is greater than startKeyValue.  The,      *                        startSearchOperation parameter is ignored if the,      *                        startKeyValue parameter is null.,      *, 	 * @param stopKeyValue    An indexable row which holds a (partial) key ,      *                        value which, in combination with the ,      *                        stopSearchOperator, defines the ending position,      *                        of the scan.  If null, the ending position of the,      *                        scan is the last row of the conglomerate.  The,      *                        stopKeyValue must only reference columns included,      *                        in the scanColumnList.,      *, 	 * @param stopSearchOperator,      *                        an operator which defines how the stopKeyValue,      *                        is used to determine the scan stopping position. ,      *                        If stopSearchOperation is ScanController.GE, the,      *                        scan stops just before the first row which is,      *                        greater than or equal to the stopKeyValue.  If ,      *                        stopSearchOperation is ScanController.GT, the ,      *                        scan stops just before the first row whose key ,      *                        is greater than startKeyValue.  The,      *                        stopSearchOperation parameter is ignored if the,      *                        stopKeyValue parameter is null.,      *,      *                        ,      * @param access_type     Describe the type of access the query will be,      *                        performing to the ScanController.  ,      *,      *                        STORECOST_CLUSTERED - The location of one scan,      *                            is likely clustered "close" to the previous ,      *                            scan.  For instance if the query plan were,      *                            to used repeated "reopenScan()'s" to probe,      *                            for the next key in an index, then this flag,      *                            should be be specified.  If this flag is not ,      *                            set then each scan will be costed independant,      *                            of any other predicted scan access.,      *,      *, 	 * @exception  StandardException  Standard exception policy.,      *, 	 * @see org.apache.derby.iapi.store.access.RowUtil,      **/, 	public void getScanCost(,     int                     scan_type,,     long                    row_count,,     int                     group_size,,     boolean                 forUpdate,,     FormatableBitSet        scanColumnList,,     DataValueDescriptor[]   template,,     DataValueDescriptor[]   startKeyValue,,     int                     startSearchOperator,,     DataValueDescriptor[]   stopKeyValue,,     int                     stopSearchOperator,,     boolean                 reopen_scan,,     int                     access_type,,     StoreCostResult         cost_result),         throws StandardException,     {,         if (SanityManager.DEBUG),         {,             SanityManager.ASSERT(,                 scan_type == StoreCostController.STORECOST_SCAN_NORMAL ||,                 scan_type == StoreCostController.STORECOST_SCAN_SET);,         }, ,         long estimated_row_count = ((row_count < 0) ?  num_rows : row_count);, ,         // This cost is if the caller has to go in and out of access for,         // every row in the table.  The cost will be significantly less if,         // group fetch is used, or if qualifiers, ,         // first the base cost of bringing each page in from cache:,         double cost = (num_pages * BASE_UNCACHED_ROW_FETCH_COST);, ,         // the cost associated with the number of bytes in each row:,         cost += (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST;, ,         // the base cost of getting each of the rows from a page assumed,         // to already be cached (by the scan fetch) - this is only for all,         // rows after the initial row on the page has been accounted for,         // under the BASE_UNCACHED_ROW_FETCH_COST cost.:,         long cached_row_count = estimated_row_count - num_pages;,         if (cached_row_count < 0),             cached_row_count = 0;, ,         if (scan_type == StoreCostController.STORECOST_SCAN_NORMAL),             cost += cached_row_count * BASE_GROUPSCAN_ROW_COST;,         else,             cost += cached_row_count * BASE_HASHSCAN_ROW_FETCH_COST;, ,         if (SanityManager.DEBUG),         {,             SanityManager.ASSERT(cost >= 0);,             SanityManager.ASSERT(estimated_row_count >= 0);,         }, ,         cost_result.setEstimatedCost(cost);, ,         // return that all rows will be scanned.,         cost_result.setEstimatedRowCount(estimated_row_count);, ,         return;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/impl/store/access/heap/HeapScan.java,,71-406,[    private DataValueDescriptor[][] fetchNext_one_slot_array = ,         new DataValueDescriptor[1][];, , ,     /**************************************************************************,      * Constructors for This class:,      **************************************************************************,      */, , 	/**, 	 ** The only constructor for a heap scan returns a scan in the, 	 ** closed state, the caller must call open., 	 **/, 	, 	public HeapScan(), 	{, 	}, ,     /**************************************************************************,      * Protected concrete impl of abstract methods of ,      *     GenericController class:,      **************************************************************************,      */,     protected void queueDeletePostCommitWork(,     RowPosition pos),         throws StandardException,     {,         TransactionManager xact_mgr = open_conglom.getXactMgr();, ,         xact_mgr.addPostCommitWork(,             new HeapPostCommit(,                 xact_mgr.getAccessManager(), ,                 (Heap) open_conglom.getConglomerate(),,                 pos.current_page.getPageNumber()));,     }, ,     /**************************************************************************,      * Private/Protected methods of This class:,      **************************************************************************,      */,     protected void setRowLocationArray(,     RowLocation[]   rowloc_array,,     int             index,,     RowPosition     pos),         throws StandardException,     {,         if (rowloc_array[index] == null),         {,             rowloc_array[index] = new HeapRowLocation(pos.current_rh);,         },         else,         {,             if (SanityManager.DEBUG),             {,                 SanityManager.ASSERT(,                     rowloc_array[index] instanceof HeapRowLocation);,             }, ,             ((HeapRowLocation)rowloc_array[index]).setFrom(pos.current_rh);,         },     }, ,     protected RowLocation makeRowLocation( RowPosition pos ),         throws StandardException,     {,         return new HeapRowLocation( pos.current_rh );,     }, ,     protected void setRowLocationArray(,     RowLocation[]   rowloc_array,,     int             index,,     RecordHandle    rh),         throws StandardException,     {,         if (rowloc_array[index] == null),         {,             rowloc_array[index] = new HeapRowLocation(rh);,         },         else,         {,             if (SanityManager.DEBUG),             {,                 SanityManager.ASSERT(,                     rowloc_array[index] instanceof HeapRowLocation);,             }, ,             ((HeapRowLocation)rowloc_array[index]).setFrom(rh);,         },     }, ,     /**,      * Reposition the current scan and sets the necessary locks.,      *,      * @param rh An existing RecordHandle within the conglomerate,,      * at which to position the start of the scan.  The scan will begin at this,      * location and continue forward until the end of the conglomerate.  ,      * Positioning at a non-existent RowLocation (ie. an invalid one or one that,      * had been deleted), will result in an exception being thrown when the ,      * first next operation is attempted.,      * @return true if the scan was successfully repositioned,      *,      * @exception StandardException Standard exception policy.,      */,     private boolean reopenScanByRecordHandleAndSetLocks (RecordHandle rh) ,             throws StandardException ,     {,         if (rh == null) ,         {,             return (false);,         },         ,         // Unlock current position,         if (scan_position.current_rh != null) ,         {,             open_conglom.unlockPositionAfterRead(scan_position);,         },         ,         // Position scan at new row,         scan_position.current_rh = rh;,         scan_position.current_rh_qualified = false;,         ,         // Latch page and reposition scan,         final boolean rowLocationDisappeared = ,             open_conglom.latchPageAndRepositionScan(scan_position);,         ,         if (!rowLocationDisappeared),         {,             setScanState(SCAN_INPROGRESS);,             open_conglom.lockPositionForRead,                 (scan_position, null, true, true);,         },         ,         // Unlatch page,         scan_position.unlatch();,         ,         return (!rowLocationDisappeared);,     }, ,     /**,     Fetch the row at the next position of the Scan., ,     If there is a valid next position in the scan then, 	the value in the template storable row is replaced, 	with the value of the row at the current scan, 	position.  The columns of the template row must, 	be of the same type as the actual columns in the, 	underlying conglomerate., ,     The resulting contents of templateRow after a fetchNext() ,     which returns false is undefined., ,     The result of calling fetchNext(row) is exactly logically,     equivalent to making a next() call followed by a fetch(row),     call.  This interface allows implementations to optimize ,     the 2 calls if possible., ,     @param fetch_row The template row into which the value, 	of the next position in the scan is to be stored., ,     @return True if there is a next position in the scan,, 	false if there isn't., , 	@exception StandardException Standard exception policy.,     **/,     public boolean fetchNext(DataValueDescriptor[] fetch_row), 		throws StandardException, 	{,         // Turn this call into a group fetch of a 1 element group.,         if (fetch_row == null),             fetchNext_one_slot_array[0] = RowUtil.EMPTY_ROW;,         else,             fetchNext_one_slot_array[0] = fetch_row;, ,         boolean ret_val = ,             fetchRows(,                 fetchNext_one_slot_array, ,                 (RowLocation[]) null,,                 (BackingStoreHashtable) null,,                 1,,                 (int[]) null) == 1;, ,         return(ret_val);,     }, , ,     /**, 	@see org.apache.derby.iapi.store.access.ScanController#next, 	**/,     public boolean next(), 		throws StandardException, 	{,         // if there is no row template from the caller, we need to,         // read the row into something, Use the scratch row.,         // We could optimize this, if there are no qualifiers and read,         // into a zero column row, but callers should be using fetchNext(),         // instead.,         fetchNext_one_slot_array[0] = ,             open_conglom.getRuntimeMem().get_scratch_row(,                     open_conglom.getRawTran());, ,         boolean ret_val = ,             fetchRows(,                 fetchNext_one_slot_array, ,                 (RowLocation[]) null,,                 (BackingStoreHashtable) null,,                 1,,                 (int[]) null) == 1;, ,         return(ret_val);, 	}, ,     /**,      * @see org.apache.derby.iapi.store.access.ScanController#positionAtRowLocation,      */,     public boolean positionAtRowLocation(RowLocation rl) throws StandardException {,         if (open_conglom.isClosed() && !rowLocationsInvalidated) ,         {,             reopenAfterEndTransaction();,         },         ,         if (rowLocationsInvalidated) ,         {,             return(false);,             ,         } else {,             return(reopenScanByRecordHandleAndSetLocks,                 (((HeapRowLocation)rl).,                  getRecordHandle(open_conglom.getContainer())));,         },     }, ,     /**************************************************************************,      * Public Methods of ScanController interface:,      **************************************************************************,      */, ,     /**, 	@see org.apache.derby.iapi.store.access.ScanController#fetchLocation, 	**/, 	public void fetchLocation(RowLocation templateLocation), 		throws StandardException, 	{, 		if (open_conglom.getContainer() == null  || ,             scan_position.current_rh == null),         {,             throw StandardException.newException(,                     SQLState.HEAP_SCAN_NOT_POSITIONED);,         }, 		HeapRowLocation hrl = (HeapRowLocation) templateLocation;, 		hrl.setFrom(scan_position.current_rh);, 	}, ,     public int fetchNextGroup(,     DataValueDescriptor[][] row_array,,     RowLocation[]           rowloc_array),         throws StandardException, 	{,         return(,             fetchRows(,                 row_array, ,                 rowloc_array,,                 (BackingStoreHashtable) null,,                 row_array.length,,                 (int[]) null));,     }, ,     public int fetchNextGroup(,     DataValueDescriptor[][] row_array,,     RowLocation[]           old_rowloc_array,,     RowLocation[]           new_rowloc_array),         throws StandardException, 	{,         throw(StandardException.newException(,                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));,     }, , ,     /**,      * Return ScanInfo object which describes performance of scan.,      * <p>,      * Return ScanInfo object which contains information about the current,      * scan.,      * <p>,      *,      * @see ScanInfo,      *, 	 * @return The ScanInfo object which contains info about current scan.,      *, 	 * @exception  StandardException  Standard exception policy.,      **/,     public ScanInfo getScanInfo(), 		throws StandardException,     {,         return(new HeapScanInfo(this));,     }, ,     /**,     Reposition the current scan.  This call is semantically the same as if,     the current scan had been closed and a openScan() had been called instead.,     The scan is reopened against the same conglomerate, and the scan,     is reopened with the same "scan column list", "hold" and "forUpdate",     parameters passed in the original openScan.  ,     <p>,     The statistics gathered by the scan are not reset to 0 by a reopenScan(),,     rather they continue to accumulate.,     <p>,     Note that this operation is currently only supported on Heap conglomerates.,     Also note that order of rows within are heap are not guaranteed, so for,     instance positioning at a RowLocation in the "middle" of a heap, then,     inserting more data, then continuing the scan is not guaranteed to see,     the new rows - they may be put in the "beginning" of the heap., , 	@param startRowLocation  An existing RowLocation within the conglomerate,,     at which to position the start of the scan.  The scan will begin at this,     location and continue forward until the end of the conglomerate.  ,     Positioning at a non-existent RowLocation (ie. an invalid one or one that,     had been deleted), will result in an exception being thrown when the ,     first next operation is attempted., , 	@param qualifier An array of qualifiers which, applied, 	to each key, restrict the rows returned by the scan.  Rows, 	for which any one of the qualifiers returns false are not, 	returned by the scan. If null, all rows are returned., , 	@exception StandardException Standard exception policy.,     **/, 	public void reopenScanByRowLocation(,     RowLocation startRowLocation,,     Qualifier qualifier[][]),         throws StandardException,     {,         reopenScanByRecordHandle(,             ((HeapRowLocation) startRowLocation).getRecordHandle(,                  open_conglom.getContainer()),,             qualifier);,     }],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/impl/store/access/heap/Heap_v10_2.java,,97-135,[        super();,     }, , ,     /**************************************************************************,      * Public Methods required by Storable interface, implies ,      *     Externalizable, TypedFormat:,      **************************************************************************,      */, ,     /**,      * Return my format identifier.,      * <p>,      * This identifier was used for Heap in all Derby versions prior to 10.3.,      * Databases hard upgraded to a version 10.3 and later will write the new ,      * format, see Heap.  Databases created in 10.3 and later will also write ,      * the new format, see Heap.,      *,      * @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId,      **/, 	public int getTypeFormatId() ,     {,         // return identifier used for Heap in all derby versions prior to 10.3, 		return StoredFormatIds.ACCESS_HEAP_V2_ID;, 	}, ,     /**,      * Store the stored representation of the column value in the,      * stream.,      * <p>,      * For more detailed description of the format see documentation,      * at top of file.,      *,      * @see java.io.Externalizable#writeExternal,      **/, 	public void writeExternal(ObjectOutput out) throws IOException ,     {, 		super.writeExternal_v10_2(out);, 	}],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/store/access/heap/D_HeapController.java,,45-45,[    public int num_overflow_pgs   = 0; // number of overflow pages heap.],,
PERFORMANCE,DM_GC,org/apache/derby/impl/store/access/sort/MergeInserter.java,initialize,275-275,[                jvm.gc();],,
PERFORMANCE,DM_GC,org/apache/derby/impl/store/access/sort/MergeInserter.java,insert,114-114,[                        jvm.gc();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/sort/MergeInserter.java,completedInserts,229-229,[            stat_mergeRunsSize.addElement(new Integer(stat_numRowsInput - totalRunSize));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/sort/MergeInserter.java,insert,199-199,[            stat_mergeRunsSize.addElement(new Integer(runSize));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/sort/MergeInserter.java,insert,192-192,[			mergeRuns.addElement(new Long(conglomid));],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/derby/impl/store/access/sort/MergeInserter.java,completedInserts,226-226,[        if (stat_sortType == "external")],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/access/sort/MergeScan.java,init,180-180,[		if (openScans == null)],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/access/sort/MergeSort.java,drop,369-369,[		dropMergeRuns((TransactionManager)tran);],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/sort/MergeSort.java,createMergeRun,769-769,[		rowSource = null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/sort/MergeSort.java,multiStageMerge,735-735,[			mergeRuns.addElement(new Long(id));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/sort/MergeSort.java,openSortRowSource,299-299,[			mergeRuns.addElement(new Long(containerId));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/access/sort/MergeSort.java,openSortScan,240-240,[			mergeRuns.addElement(new Long(containerId));],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/impl/store/access/sort/MergeSort.java,compare,507-507,[					return -r;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/store/access/sort/MergeSort.java,,540-540,[		this.alreadyInOrder = alreadyInOrder;],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/derby/impl/store/access/sort/MergeSortInfo.java,getAllSortInfo,136-136,[        if (this.stat_sortType == "external")],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/access/sort/NodeAllocator.java,init,161-161,[		if (array == null)],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/access/sort/SortBuffer.java,deleteLeftmost,460-460,[				dupNode = null;],,
BAD_PRACTICE,DM_EXIT,org/apache/derby/impl/store/access/sort/SortBuffer.java,check,644-644,[                System.exit(1);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/store/access/sort/SortBuffer.java,removeFirst,421-421,[			return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/store/access/sort/SortBufferRowSource.java,getNextRowFromRowSource,88-88,[			return null;],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/derby/impl/store/access/sort/UniqueWithDuplicateNullsMergeSort.java,compare,94-94,[                    return -r;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/RawStore.java,privCopyDirectory,2517-2517,[            throw (StandardException)pae.getCause();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/RawStore.java,privCopyFile,2585-2585,[            throw (StandardException)pae.getCause();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/RawStore.java,privFileWriter,2331-2331,[            throw (IOException) pae.getException();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/RawStore.java,privGetOutputStreamWriter,2384-2384,[            throw (IOException) pae.getException();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/RawStore.java,privMkdirs,2435-2435,[            throw (IOException) pae.getCause();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/RawStore.java,changeBootPassword,1519-1519,[		String changeString = (String)changePassword;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/RawStore.java,backup,719-719,[			StorageFile dbase           = storageFactory.newStorageFile(null); ],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/store/raw/RawStore.java,run,2688-2688,[            return new OutputStreamWriter( actionStorageFile.getOutputStream( actionAppend));],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/RawStore.java,,2688-2688,[            return new OutputStreamWriter( actionStorageFile.getOutputStream( actionAppend));],,,2326-2326,[        actionAppend = append;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/RawStore.java,,2724-2724,[            return ReuseFactory.getBoolean(FileUtil.copyDirectory(storageFactory,],,,2733-2733,[            return ReuseFactory.getBoolean(FileUtil.copyDirectory((WritableStorageFactory)storageFactory,],,,2507-2507,[        actionBuffer = buffer;],,,2523-2523,[            actionBuffer = null;],,,2534-2534,[        actionBuffer = buffer;],,,2547-2547,[            actionBuffer = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/RawStore.java,,2684-2684,[        switch(actionCode)],,,2463-2463,[        actionCode = REGULAR_FILE_REMOVE_DIRECTORY_ACTION;],,,2407-2407,[        actionCode = STORAGE_FILE_DELETE_ACTION;],,,2358-2358,[        actionCode = STORAGE_FILE_EXISTS_ACTION;],,,2324-2324,[        actionCode = FILE_WRITER_ACTION;],,,2504-2504,[        actionCode = COPY_STORAGE_DIRECTORY_TO_REGULAR_ACTION;],,,2480-2480,[        actionCode = REGULAR_FILE_RENAME_TO_ACTION;],,,2341-2341,[        actionCode = REGULAR_FILE_EXISTS_ACTION;],,,2635-2635,[        actionCode = STORAGE_FILE_GET_CANONICALPATH_ACTION;],,,2531-2531,[        actionCode = COPY_REGULAR_DIRECTORY_TO_STORAGE_ACTION;],,,2390-2390,[        actionCode = REGULAR_FILE_DELETE_ACTION;],,,2426-2426,[        actionCode = REGULAR_FILE_MKDIRS_ACTION;],,,2555-2555,[        actionCode = COPY_REGULAR_FILE_TO_STORAGE_ACTION;],,,2618-2618,[        actionCode = STORAGE_FILE_LIST_DIRECTORY_ACTION;],,,2598-2598,[        actionCode = COPY_STORAGE_FILE_TO_STORAGE_ACTION;],,,2575-2575,[        actionCode = COPY_STORAGE_FILE_TO_REGULAR_ACTION;],,,2659-2659,[        actionCode = REGULAR_FILE_GET_CANONICALPATH_ACTION;],,,2376-2376,[        actionCode = README_FILE_OUTPUTSTREAM_WRITER_ACTION;],,,2446-2446,[        actionCode = REGULAR_FILE_IS_DIRECTORY_ACTION;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/RawStore.java,,2724-2724,[            return ReuseFactory.getBoolean(FileUtil.copyDirectory(storageFactory,],,,2509-2509,[        actionCopySubDirs = copySubdirs;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/RawStore.java,,2724-2724,[            return ReuseFactory.getBoolean(FileUtil.copyDirectory(storageFactory,],,,2733-2733,[            return ReuseFactory.getBoolean(FileUtil.copyDirectory((WritableStorageFactory)storageFactory,],,,2508-2508,[        actionFilter = filter;],,,2524-2524,[            actionFilter = null;],,,2535-2535,[        actionFilter = filter;],,,2548-2548,[            actionFilter = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/RawStore.java,,2691-2691,[            return ReuseFactory.getBoolean(actionRegularFile.exists());],,,2697-2697,[            return ReuseFactory.getBoolean(actionRegularFile.delete());],,,2704-2704,[            boolean created = actionRegularFile.mkdirs();],,,2712-2712,[            return ReuseFactory.getBoolean(actionRegularFile.isDirectory());],,,2716-2716,[            return ReuseFactory.getBoolean(FileUtil.removeDirectory(actionRegularFile));],,,2720-2720,[            return ReuseFactory.getBoolean(actionRegularFile.renameTo(actionRegularFile2));],,,2724-2724,[            return ReuseFactory.getBoolean(FileUtil.copyDirectory(storageFactory,],,,2747-2747,[            return (String[])(actionRegularFile.list());],,,2770-2770,[            return (String)(actionRegularFile.getCanonicalPath());],,,2706-2706,[            FileUtil.limitAccessToOwner(actionRegularFile);],,,2733-2733,[            return ReuseFactory.getBoolean(FileUtil.copyDirectory((WritableStorageFactory)storageFactory,],,,2741-2741,[            return ReuseFactory.getBoolean(FileUtil.copyFile((WritableStorageFactory) storageFactory,],,,2755-2755,[            return ReuseFactory.getBoolean(FileUtil.copyFile(],,,2464-2464,[        actionRegularFile = file;],,,2474-2474,[            actionRegularFile = null;],,,2506-2506,[        actionRegularFile = to;],,,2522-2522,[            actionRegularFile = null;],,,2481-2481,[        actionRegularFile = file1;],,,2492-2492,[            actionRegularFile = null;],,,2342-2342,[        actionRegularFile = file;],,,2352-2352,[            actionRegularFile = null;],,,2533-2533,[        actionRegularFile = from;],,,2546-2546,[            actionRegularFile = null;],,,2391-2391,[        actionRegularFile = file;],,,2401-2401,[            actionRegularFile = null;],,,2427-2427,[        actionRegularFile = file;],,,2439-2439,[            actionRegularFile = null;],,,2557-2557,[        actionRegularFile = from;],,,2568-2568,[            actionRegularFile = null;],,,2577-2577,[        actionRegularFile = to;],,,2590-2590,[            actionRegularFile = null;],,,2660-2660,[        actionRegularFile = file;],,,2676-2676,[            actionRegularFile = null;],,,2447-2447,[        actionRegularFile = file;],,,2457-2457,[            actionRegularFile = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/RawStore.java,,2720-2720,[            return ReuseFactory.getBoolean(actionRegularFile.renameTo(actionRegularFile2));],,,2482-2482,[        actionRegularFile2 = file2;],,,2493-2493,[            actionRegularFile2 = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/RawStore.java,,2688-2688,[            return new OutputStreamWriter( actionStorageFile.getOutputStream( actionAppend));],,,2694-2694,[            return ReuseFactory.getBoolean(actionStorageFile.exists());],,,2724-2724,[            return ReuseFactory.getBoolean(FileUtil.copyDirectory(storageFactory,],,,2751-2751,[            return (String[])(actionStorageFile.list());],,,2774-2774,[            return (String)(actionStorageFile.getCanonicalPath());],,,2700-2700,[            return ReuseFactory.getBoolean(actionStorageFile.delete());],,,2776-2776,[        	return(new OutputStreamWriter(actionStorageFile.getOutputStream(),"UTF8"));],,,2733-2733,[            return ReuseFactory.getBoolean(FileUtil.copyDirectory((WritableStorageFactory)storageFactory,],,,2741-2741,[            return ReuseFactory.getBoolean(FileUtil.copyFile((WritableStorageFactory) storageFactory,],,,2755-2755,[            return ReuseFactory.getBoolean(FileUtil.copyFile(],,,2763-2763,[            return ReuseFactory.getBoolean(FileUtil.copyFile(],,,2408-2408,[        actionStorageFile = file;],,,2418-2418,[            actionStorageFile = null;],,,2359-2359,[        actionStorageFile = file;],,,2369-2369,[            actionStorageFile = null;],,,2325-2325,[        actionStorageFile = fileName;],,,2335-2335,[            actionStorageFile = null;],,,2505-2505,[        actionStorageFile = from;],,,2521-2521,[            actionStorageFile = null;],,,2636-2636,[        actionStorageFile = file;],,,2652-2652,[            actionStorageFile = null;],,,2532-2532,[        actionStorageFile = to;],,,2545-2545,[            actionStorageFile = null;],,,2556-2556,[        actionStorageFile = to;],,,2567-2567,[            actionStorageFile = null;],,,2619-2619,[        actionStorageFile = file;],,,2628-2628,[            actionStorageFile = null;],,,2599-2599,[        actionStorageFile = from;],,,2610-2610,[            actionStorageFile = null;],,,2576-2576,[        actionStorageFile = from;],,,2589-2589,[            actionStorageFile = null;],,,2377-2377,[        actionStorageFile = file;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/RawStore.java,,2763-2763,[            return ReuseFactory.getBoolean(FileUtil.copyFile(],,,2600-2600,[        actionToStorageFile = to;],,,2611-2611,[            actionToStorageFile = null;],,
CORRECTNESS,NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH,org/apache/derby/impl/store/raw/RawStore.java,backup,1014-1014,[						logHistory(historyFile,],,backup,1002-1002,[					logHistory(historyFile,],,backup,1019-1019,[					logHistory(historyFile,],,backup,711-711,[		OutputStreamWriter historyFile = null;],,backup,719-719,[			StorageFile dbase           = storageFactory.newStorageFile(null); ],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/store/raw/RawStore.java,boot,175-175,[        String slave = properties.getProperty(SlaveFactory.REPLICATION_MODE);],,boot,194-194,[		if (properties != null)],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/store/raw/data/AllocExtent.java,toDebugString,1038-1038,[				case ALLOCATED_PAGE: str += "valid, in use page\n"; break;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/store/raw/data/AllocExtent.java,toDebugString,1035-1038,[				switch(getPageStatus(i)), 				{, 				case FREE_PAGE: str += "free page\n"; break;, 				case ALLOCATED_PAGE: str += "valid, in use page\n"; break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/derby/impl/store/raw/data/AllocPage.java,setPageStatus,851-852,[			extent.deallocPage(pageNumber);, 			break;],,setPageStatus,854-854,[			extent.deallocPage(pageNumber);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/AllocPage.java,WriteContainerInfo,575-575,[				throw StandardException.newException(],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/store/raw/data/AllocPage.java,ReadContainerInfo,600-617,[		int N = (int)epage[BORROWED_SPACE_OFFSET];, , 		if (SanityManager.DEBUG), 		{, 			if (N != containerInfo.length), 				SanityManager.THROWASSERT("N not what is expected : " +  N);, , 			if (BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + N, 								 						>= MAX_BORROWED_SPACE),             {, 				SanityManager.THROWASSERT("exceed max borrowable space: " + N);,             }, 		}, , 		if (N != 0), 			System.arraycopy(epage, BORROWED_SPACE_OFFSET+BORROWED_SPACE_LEN,, 							 containerInfo, 0, N);, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/store/raw/data/AllocPage.java,WriteContainerInfo,534-586,[		int N = (containerInfo == null) ? 0 : containerInfo.length;, , 		if (SanityManager.DEBUG), 		{, 			if (create), 				SanityManager.ASSERT(,                     containerInfo != null, "containerInfo is null");, , 			SanityManager.ASSERT(epage != null, "page array is null");, ,             if (!((containerInfo == null) ||,                   ((containerInfo.length + BORROWED_SPACE_OFFSET + ,                       BORROWED_SPACE_LEN) < epage.length))) ,             {,                 SanityManager.THROWASSERT(,                     "containerInfo too big for page array: " + ,                     containerInfo.length);,             }, , 			if (BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + N >=, 															MAX_BORROWED_SPACE), 				SanityManager.THROWASSERT(, 								 "exceed max borrowable space: " + N);,         }, ,         if ((N + BORROWED_SPACE_LEN + BORROWED_SPACE_OFFSET) > epage.length),         {, 			if (SanityManager.DEBUG), 				SanityManager.THROWASSERT(, 				   "exceed max borrowable space on page: " + N);, 		}, , 		if (create), 		{, 			epage[BORROWED_SPACE_OFFSET] = (byte)N;, 		}, 		else, 		{, 			int oldN = (int)epage[BORROWED_SPACE_OFFSET];, 			if (oldN != N),             {, 				throw StandardException.newException(,                         SQLState.DATA_CHANGING_CONTAINER_INFO, ,                         new Long(oldN), ,                         new Long(N));,             }, 		}, , 		if (N != 0), 			System.arraycopy(containerInfo, 0, epage,, 							 BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN,, 							 N);, 	}],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/store/raw/data/AllocPage.java,setPageStatus,845-854,[		switch(newStatus), 		{, 		case AllocExtent.ALLOCATED_PAGE:, 			extent.allocPage(pageNumber);, 			break;, 		case AllocExtent.DEALLOCATED_PAGE:, 			extent.deallocPage(pageNumber);, 			break;, 		case AllocExtent.FREE_PAGE:, 			extent.deallocPage(pageNumber);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/BaseContainer.java,addPage,302-302,[                    new Long(getSegmentId()), ],,addPage,303-303,[                    new Long(getContainerId()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/BaseContainer.java,compressContainer,212-212,[                    new Long(getSegmentId()), ],,compressContainer,213-213,[                    new Long(getContainerId()));],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,reclaimSpace,1300-1300,[		return ReclaimSpaceHelper.reclaimSpace(this, (RawTransaction)tran,],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,getJBMSLockOnDB,1822-1822,[                throw (StandardException) pae.getException(); ],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,restoreDataDirectory,2617-2617,[                throw (StandardException) pae.getException();],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,boot,402-402,[		uf = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,,305-305,[        actionCode = BOOT_ACTION;],,,2716-2716,[        switch( actionCode)],,,2735-2735,[            if( actionCode == GET_CONTAINER_PATH_ACTION)],,,2272-2272,[            actionCode = GET_PATH_ACTION;],,,2515-2515,[        actionCode = GET_CONTAINER_NAMES_ACTION;],,,1543-1543,[        actionCode = code;],,,1811-1811,[            actionCode = GET_LOCK_ON_DB_ACTION;],,,2311-2311,[                actionCode = POST_RECOVERY_REMOVE_ACTION;],,,2608-2608,[            actionCode = RESTORE_DATA_DIRECTORY_ACTION;],,,1594-1594,[            actionCode = REMOVE_STUBS_ACTION;],,,1669-1669,[                            actionCode = DELETE_IF_EXISTS_ACTION;],,,2024-2024,[            actionCode = RELEASE_LOCK_ON_DB_ACTION;],,,1712-1712,[        actionCode = FIND_MAX_CONTAINER_ID_ACTION;],,,1486-1486,[            actionCode = REMOVE_TEMP_DIRECTORY_ACTION;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,,2835-2835,[            boolean ret = actionFile.exists() && actionFile.delete();],,,2842-2842,[            String path = actionFile.getPath();],,,2843-2843,[            actionFile = null;],,,2836-2836,[            actionFile = null;],,,2273-2273,[            actionFile = file;],,,2284-2284,[                actionFile = null;],,,1668-1668,[                            actionFile = (StorageFile)removeInfo[0];],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,,2661-2661,[                File bsegdir1 = new java.io.File(backupRoot, bfilelist[i]);],,,2681-2681,[                File        fromFile = new File(backupRoot,bfilelist[i]);],,,2609-2609,[            this.backupRoot = backupRoot;],,,2621-2621,[                this.backupRoot = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,,2733-2733,[            sb.append(containerId.getSegmentId());],,,2744-2744,[                sb.append(Long.toHexString(containerId.getContainerId()));],,,2738-2738,[                sb.append(Long.toHexString(containerId.getContainerId()));],,,1546-1546,[            this.containerId = containerId;],,,1560-1560,[            this.containerId = null; ],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,,1896-1896,[            UUID checkUUID = uuidFactory.recreateUUID(fileLockOnDB.readUTF());],,,1813-1813,[            this.uuidFactory = uuidFactory;],,,1827-1827,[                this.uuidFactory = null;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,boot,321-321,[                (value != null ? value.trim() : value)).booleanValue();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,getContainerNames,2519-2519,[        catch( PrivilegedActionException pae){ return null;}],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,,2553-2555,[                                            new PrivilegedAction<String[]>() {,                                                 public String[] run() {,                                                     return backupRoot.list();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,,2570-2572,[                                new PrivilegedAction<Boolean>() {,                                     public Boolean run() {,                                         return Boolean.valueOf(bsegdir.exists());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,,2579-2581,[                            new PrivilegedAction<Boolean>() {,                                 public Boolean run() {,                                     return Boolean.valueOf(bsegdir.isDirectory());],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/raw/data/BasePage.java,insertLongColumn,964-964,[			curPage = null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/BasePage.java,MakeRecordHandle,332-332,[			throw StandardException.newException(],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/store/raw/data/BasePage.java,MakeRecordHandle,330-337,[		if (recordHandleConstant >= RecordHandle.FIRST_RECORD_ID),         {, 			throw StandardException.newException(,                 SQLState.DATA_CANNOT_MAKE_RECORD_HANDLE, ,                 new Long(recordHandleConstant));,         }, , 		return new RecordId(pkey, recordHandleConstant);],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/store/raw/data/BasePage.java,insertLongColumn,927-927,[				SanityManager.ASSERT(curPage.isLatched());],,insertLongColumn,962-962,[		if (curPage != null) {],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/store/raw/data/BasePage.java,slotTableToString,2842-2842,[                str += "\n";],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/CachedPage.java,readPage,697-697,[					StandardException se = ],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/CachedPage.java,,485-485,[		if (isDirty && !isOverflowPage() &&],,,448-448,[			if (!isDirty)],,,148-148,[		isDirty             = false;],,,435-435,[			return isDirty;],,,844-844,[			isDirty     = false;],,,419-419,[			return isDirty || preDirty;],,,463-463,[			isDirty  = true;],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/apache/derby/impl/store/raw/data/CachedPage.java,setPageArray,866-866,[			pageData = new byte[pageSize];],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/store/raw/data/ContainerOperation.java,toString,283-289,[			switch(operation), 			{, 			case CREATE: str += " CREATE container " + containerId;, 				break;, 			case DROP: str += " DROP container " + containerId;, 				break;, 			case REMOVE: str += " REMOVE container " + containerId;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/store/raw/data/ContainerOperation.java,undoMe,224-242,[		switch(operation), 		{, 		case DROP:, 			if (SanityManager.DEBUG) {, 				SanityManager.ASSERT(hdl != null, "container handle is null");, 				SanityManager.ASSERT(hdl.getContainerStatus() != RawContainerHandle.COMMITTED_DROP,, 									 "Undoing a drop but the container status is not dropped");, 			}, 			hdl.dropContainer(CLRInstant, false); // not dropped, 			break;, , 		case CREATE: , 			// remove the container, 			hdl.removeContainer(CLRInstant);, 			break;, , 		case REMOVE:, 			if (SanityManager.DEBUG) {, 				SanityManager.THROWASSERT("cannot undo REMOVE, should not have generated a CLR in the first place");],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/store/raw/data/CopyRowsOperation.java,toString,312-312,[				str += " (recordId=" + recordIds[i] + ")";],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/derby/impl/store/raw/data/DecryptInputStream.java,fillByteHolder,76-76,[				in.read(ciphertext, 0, encryptedLen);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/DirectAllocActions.java,actionAllocatePage,58-58,[		((AllocPage)allocPage).setPageStatus((LogInstant)null, pageNumber, doStatus);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/DirectAllocActions.java,actionChainAllocPage,76-76,[		((AllocPage)allocPage).chainNextAllocPage((LogInstant)null, pageNumber,],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/DirectAllocActions.java,actionCompressSpaceOperation,112-112,[		((AllocPage)allocPage).compressSpace(],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/DropOnCommit.java,update,84-84,[			RawTransaction xact = (RawTransaction) obj;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/EncryptOrDecryptData.java,,406-406,[        switch(actionCode)],,,380-380,[        actionCode = STORAGE_FILE_DELETE_ACTION;],,,391-391,[        actionCode = STORAGE_FILE_RENAME_ACTION;],,,369-369,[        actionCode = STORAGE_FILE_EXISTS_ACTION;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/EncryptOrDecryptData.java,,413-413,[            return ReuseFactory.getBoolean(],,,393-393,[        actionDestStorageFile = destFile;],,,396-396,[        actionDestStorageFile = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/EncryptOrDecryptData.java,,409-409,[            return ReuseFactory.getBoolean(actionStorageFile.exists());],,,411-411,[            return ReuseFactory.getBoolean(actionStorageFile.delete());],,,413-413,[            return ReuseFactory.getBoolean(],,,381-381,[        actionStorageFile = file;],,,383-383,[        actionStorageFile = null;],,,392-392,[        actionStorageFile = fromFile;],,,395-395,[        actionStorageFile = null;],,,370-370,[        actionStorageFile = file;],,,372-372,[        actionStorageFile = null;],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/derby/impl/store/raw/data/EncryptOrDecryptData.java,run,417-417,[        return null;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/FileContainer.java,readHeaderFromArray,814-814,[		long spare3 = inStream.readLong();	// read spare long],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/FileContainer.java,compressContainer,1440-1440,[                        prev_alloc_page.getNextAllocPageOffset();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/FileContainer.java,findAllocPageForAdd,2193-2193,[					long nextAllocPageOffset = allocPage.getNextAllocPageOffset();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/FileContainer.java,findLastAllocPage,2283-2283,[				long nextAllocPageOffset = allocPage.getNextAllocPageOffset();],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/store/raw/data/FileContainer.java,createInfoFromProp,1230-1230,[				Boolean reusableRecordId = new Boolean(reusableRecordIdParameter);],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/store/raw/data/FileContainer.java,getContainerProperties,683-683,[			Boolean bool = new Boolean(isReusableRecordId());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/FileContainer.java,createInfoFromLog,1105-1105,[                    getIdentity(), new Long(fid));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/FileContainer.java,readHeaderFromArray,794-794,[                SQLState.DATA_UNKNOWN_CONTAINER_FORMAT, getIdentity(), ],,readHeaderFromArray,838-838,[                    new Long(checksum.getValue()), ],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/FileContainer.java,,3325-3325,[        if (encryptionBuffer == null || encryptionBuffer.length < pageSize)],,,3326-3326,[			encryptionBuffer = new byte[pageSize];],,,3327-3327,[        return encryptionBuffer;],,,3269-3269,[			if (encryptionBuffer == null || encryptionBuffer.length < pageSize)],,,3270-3270,[				encryptionBuffer = new byte[pageSize];],,,3272-3272,[			int len = dataFactory.decrypt(pageData, 0, pageSize,],,,3280-3280,[			System.arraycopy(encryptionBuffer, 8, pageData, 0, pageSize-8);],,,3281-3281,[			System.arraycopy(encryptionBuffer, 0, pageData, pageSize-8, 8);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/store/raw/data/FileContainer.java,findLastAllocPage,2293-2293,[			if (allocPage != null)],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/store/raw/data/FileContainer.java,createInfoFromLog,1091-1091,[		ArrayInputStream inStream = new ArrayInputStream(array);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/store/raw/data/FileContainer.java,readHeaderFromArray,787-787,[		ArrayInputStream inStream = new ArrayInputStream(a);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/store/raw/data/FileContainer.java,writeHeaderToArray,1004-1004,[		FormatIdOutputStream outStream = new FormatIdOutputStream(a_out);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/impl/store/raw/data/FileContainer.java,findLastAllocPage,2293-2293,[			if (allocPage != null)],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/store/raw/data/FileContainer.java,findAllocPageForAdd,1691-1691,[					allocCache.invalidate(allocPage, allocPage.getPageNumber());],,findAllocPageForAdd,1696-1696,[					if (allocPage == null)],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/store/raw/data/FileContainer.java,newPage,1974-1974,[                SanityManager.ASSERT(page.isLatched());],,newPage,2010-2010,[		if (!isOverflow && page != null)],,
MT_CORRECTNESS,SWL_SLEEP_WITH_LOCK_HELD,org/apache/derby/impl/store/raw/data/FileContainer.java,newPage,1675-1675,[                                Thread.sleep(],,
MT_CORRECTNESS,SWL_SLEEP_WITH_LOCK_HELD,org/apache/derby/impl/store/raw/data/FileContainer.java,pageValid,2097-2097,[                            Thread.sleep(InterruptStatus.INTERRUPT_RETRY_SLEEP);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/store/raw/data/FileContainer.java,switchToMultiInsertPageMode,3438-3452,[        if (lastInsertedPage.length == 1),         {,             long last = lastInsertedPage[0];, ,             lastInsertedPage = new long[4];,             lastInsertedPage[0] = last;, ,             for (int i = 3; i > 0; i--),             {,                 Page page = addPage(handle, false);,                 lastInsertedPage[i] = page.getPageNumber();,                 page.unlatch();,             },         },     }],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/store/raw/data/InputStreamContainer.java,openContainer,106-106,[				} catch (IOException ioe) {}],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/store/raw/data/InputStreamContainer.java,getInputStream,238-238,[        return containerPath.getInputStream();],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/LoggableAllocActions.java,actionAllocatePage,56-56,[		Loggable lop = new AllocPageOperation((AllocPage)allocPage, pageNumber, doStatus, undoStatus);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/LoggableAllocActions.java,actionChainAllocPage,81-81,[		Loggable lop = new ChainAllocPageOperation((AllocPage)allocPage, pageNumber, pageOffset);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/LoggableAllocActions.java,actionCompressSpaceOperation,141-141,[            lop = new CompressSpacePageOperation10_2(],,actionCompressSpaceOperation,135-135,[            lop = ],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/derby/iapi/services/io/DynamicByteArrayOutputStream.java,,38-247,[	private static int INITIAL_SIZE = 4096;, , 	private byte[] buf;, 	private int		position;, 	private int		used;		// how many bytes are used, 	private int		beginPosition;, , 	public DynamicByteArrayOutputStream() {, 		this(INITIAL_SIZE);, 	}, , 	public DynamicByteArrayOutputStream(int size) {, 		super();, , 		buf = new byte[size];, 	}, , 	public DynamicByteArrayOutputStream(byte[] data) {, 		super();, , 		buf = data;, 	}, , 	public DynamicByteArrayOutputStream(DynamicByteArrayOutputStream toBeCloned) {, , 		byte[] cbuf = toBeCloned.getByteArray();, 		buf = new byte[cbuf.length];, , 		write(cbuf, 0, cbuf.length);, 		position = toBeCloned.getPosition();, 		used = toBeCloned.getUsed();, 		beginPosition = toBeCloned.getBeginPosition();, 	}, , 	/*, 	 *	OutputStream methods, 	 */, 	public void write(int b) , 	{, 		if (position >= buf.length), 			expandBuffer(INITIAL_SIZE);, , 		buf[position++] = (byte) b;, , 		if (position > used), 			used = position;, 	}, 	, 	public void write(byte[] b, int off, int len) , 	{, 		if ((position+len) > buf.length), 			expandBuffer(len);, , 		System.arraycopy(b, off, buf, position, len);, 		position += len;, , 		if (position > used), 			used = position;, 	}, , 	void writeCompleteStream(InputStream dataIn, int len) throws IOException, 	{, 		if ((position+len) > buf.length), 			expandBuffer(len);, , 		org.apache.derby.iapi.services.io.InputStreamUtil.readFully(dataIn, buf, position, len);, 		position += len;, , 		if (position > used), 			used = position;, 	}, , 	public void close(), 	{, 		buf = null;, 		reset();, 	}, , 	/*, 	 *	Specific methods, 	 */, , 	/**, 		Reset the stream for reuse, 	*/, 	public void reset(), 	{, 		position = 0;, 		beginPosition = 0;, 		used = 0;, 	}, , 	/**, 		Get a reference to the byte array stored in the byte array output, 		stream. Note that the byte array may be longer that getPosition()., 		Bytes beyond and including the current poistion are invalid., 	*/, 	public byte[] getByteArray(), 	{, 		return buf;, 	}, , 	/**, 		Get the number of bytes that was used., 	*/, 	public int getUsed(), 	{, 		return used;, 	}, , 	/**, 		Get the current position in the stream, 	*/, 	public int getPosition(), 	{, 		return position;, 	}, , 	/**, 		Get the current position in the stream, 	*/, 	public int getBeginPosition(), 	{, 		return beginPosition;, 	}, , 	/**, 		Set the position of the stream pointer., 		It is up to the caller to make sure the stream has no gap of garbage in, 		it or useful information is not left out at the end because the stream, 		does not remember anything about the previous position., 	*/, 	public void setPosition(int newPosition), 	{, 		if (newPosition > position), 		{, 			if (newPosition > buf.length), 				expandBuffer(newPosition - buf.length);, 		}, , 		position = newPosition;, , 		if (position > used), 			used = position;, , 		return ;, 	}, , 	/**, 		Set the begin position of the stream pointer., 		If the newBeginPosition is larger than the stream itself,, 		then, the begin position is not set., 	*/, 	public void setBeginPosition(int newBeginPosition), 	{, , 		if (newBeginPosition > buf.length), 			return;, , 		beginPosition = newBeginPosition;, 	}, , 	/**, 		Shrink the buffer left by the amount given. Ie., 		bytes from 0 to amountToShrinkBy are thrown away, 	*/, 	public void discardLeft(int amountToShrinkBy) {, , 		System.arraycopy(buf, amountToShrinkBy, buf, 0,, 			used - amountToShrinkBy);, , 		position -= amountToShrinkBy;, 		used -= amountToShrinkBy;, 	}, , 	/**, 		Expand the buffer by at least the number of bytes requested in minExtension., , 		To optimize performance and reduce memory copies and allocation, we have a staged buffer, 		expansion., , 		<UL>, 		<LI> buf.length < 128k - increase by 4k, 		<LI> buf.length < 1Mb - increase by 128k, 		<LI> otherwise increase by 1Mb., 		</UL>, , 		In all cases, if minExpansion is greater than the value about then the buffer will, 		be increased by minExtension., 	*/, 	private void expandBuffer(int minExtension), 	{, 		if (buf.length < (128 * 1024)) {, 			if (minExtension < INITIAL_SIZE), 				minExtension = INITIAL_SIZE;, 		} else if (buf.length < (1024 * 1024)) {, , 			if (minExtension < (128 * 1024)), 				minExtension = (128 * 1024);, 		} else {, 			if (minExtension < (1024 * 1024)), 				minExtension = 1024 * 1024;, 		}, , 		int newsize = buf.length + minExtension;, , 		byte[] newbuf = new byte[newsize];, 		System.arraycopy(buf, 0, newbuf, 0, buf.length);, 		buf = newbuf;, 	}],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/raw/data/OverflowInputStream.java,fillByteHolder,157-157,[                    columnOverflowPage = null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/PageBasicOperation.java,needsRedo,165-165,[			throw StandardException.newException(],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/store/raw/data/PurgeOperation.java,toString,289-289,[				str += " (recordId=" + recordIds[i] + ")";],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/RAFContainer.java,createContainer,823-823,[        catch( PrivilegedActionException pae){ throw (StandardException) pae.getException();}],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/RAFContainer.java,getFileName,746-746,[         catch( PrivilegedActionException pae){ throw (StandardException) pae.getException();}],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/RAFContainer.java,getRandomAccessFile,1355-1355,[            throw (StandardException) pae.getException();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/RAFContainer.java,openContainer,914-914,[            throw (StandardException) pae.getException();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/RAFContainer.java,removeFile,880-880,[        catch( PrivilegedActionException pae){ throw (StandardException) pae.getException();}],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/RAFContainer.java,reopenContainer,943-943,[            throw (StandardException) pae.getException();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/RAFContainer.java,stubbify,1013-1013,[        catch( PrivilegedActionException pae){ throw (StandardException) pae.getException();}],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/RAFContainer.java,,1365-1365,[         switch( actionCode)],,,1348-1348,[        actionCode = GET_RANDOM_ACCESS_FILE_ACTION;],,,817-817,[        actionCode = CREATE_CONTAINER_ACTION;],,,874-874,[        actionCode = REMOVE_FILE_ACTION;],,,906-906,[        actionCode = OPEN_CONTAINER_ACTION;],,,1008-1008,[        actionCode = STUBBIFY_ACTION;],,,737-737,[         actionCode = GET_FILE_NAME_ACTION;],,,936-936,[        actionCode = REOPEN_CONTAINER_ACTION;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/RAFContainer.java,,1368-1368,[             return privGetFileName( actionIdentity, actionStub, actionErrorOK, actionTryAlternatePath);],,,740-740,[         actionErrorOK = errorOK;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/RAFContainer.java,,1466-1466,[             return privRemoveFile( actionFile) ? this : null;],,,1707-1707,[                 boolean exists = actionFile.exists();],,,1708-1708,[                 Object result = actionFile.getRandomAccessFile("rw");],,,1718-1718,[                 throw StandardException.newException(],,,1711-1711,[                     actionFile.limitAccessToOwner();],,,1349-1349,[        actionFile = file;],,,1357-1357,[        finally{ actionFile = null; }],,,875-875,[        actionFile = file;],,,881-881,[        finally{ actionFile = null; }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/RAFContainer.java,,1368-1368,[             return privGetFileName( actionIdentity, actionStub, actionErrorOK, actionTryAlternatePath);],,,1372-1372,[             StorageFile file = privGetFileName( actionIdentity, false, false, false);],,,1472-1472,[             StorageFile file = privGetFileName( actionIdentity, false, true, true);],,,1608-1608,[             StorageFile file = privGetFileName( actionIdentity, false, false, true);],,,1582-1582,[             StorageFile file =],,,1609-1609,[             StorageFile stub = privGetFileName( actionIdentity, true, false, false);],,,1480-1480,[                     file = privGetFileName( actionIdentity, true, true, true);],,,1635-1635,[                     writeRAFHeader(],,,1430-1430,[                 writeRAFHeader(],,,1528-1528,[                 StorageFile stub = ],,,818-818,[        actionIdentity = newIdentity;],,,824-824,[        finally{ actionIdentity = null; }],,,907-907,[        actionIdentity = newIdentity;],,,922-922,[            actionIdentity = null;],,,1006-1006,[		actionIdentity = (ContainerKey)getIdentity();],,,1016-1016,[            actionIdentity = null;],,,738-738,[         actionIdentity = identity;],,,747-747,[         finally{ actionIdentity = null; }],,,937-937,[        actionIdentity = currentIdentity;],,,948-948,[            actionIdentity = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/RAFContainer.java,,1650-1650,[                 dataFactory.flush(actionInstant);],,,1700-1700,[             dataFactory.stubFileToRemoveAfterCheckPoint(stub,actionInstant, getIdentity());],,,1007-1007,[        actionInstant = instant;],,,1017-1017,[            actionInstant = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/RAFContainer.java,,1368-1368,[             return privGetFileName( actionIdentity, actionStub, actionErrorOK, actionTryAlternatePath);],,,739-739,[         actionStub = stub;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/RAFContainer.java,,1368-1368,[             return privGetFileName( actionIdentity, actionStub, actionErrorOK, actionTryAlternatePath);],,,741-741,[         actionTryAlternatePath = tryAlternatePath;],,
MT_CORRECTNESS,SWL_SLEEP_WITH_LOCK_HELD,org/apache/derby/impl/store/raw/data/RAFContainer.java,clean,518-518,[                                Thread.sleep(],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/store/raw/data/RAFContainer.java,,858-861,[            new PrivilegedAction<Boolean>() {,                 public Boolean run() {,                     return ReuseFactory.getBoolean(,                             !file.exists() || file.delete());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/store/raw/data/RAFContainer.java,,1330-1337,[                new PrivilegedExceptionAction<RandomAccessFile>() {,                     public RandomAccessFile run() throws IOException {,                         boolean preExisting = file.exists();,                         RandomAccessFile raf = new RandomAccessFile(file, "rw");,                         if (!preExisting) {,                             FileUtil.limitAccessToOwner(file);,                         },                         return raf;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/RAFContainer4.java,,1104-1104,[        ourChannel = ioChannel;],,,161-161,[        if (ourChannel == null) {],,,164-164,[        return ourChannel;],,,162-162,[            ourChannel = getChannel(fileData);],,,215-215,[            SanityManager.ASSERT(!ourChannel.isOpen());],,,217-217,[        ourChannel = null;],,,201-201,[            SanityManager.ASSERT(ourChannel == null, "ourChannel isn't null");],,,896-896,[                        SanityManager.ASSERT(ourChannel != null,],,,898-898,[                        SanityManager.ASSERT(!ourChannel.isOpen(),],,,235-235,[        if(ourChannel != null) {],,,237-237,[                ourChannel.close();],,,241-241,[                ourChannel=null;],,,183-183,[            SanityManager.ASSERT(ourChannel == null, "ourChannel isn't null");],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/data/RAFContainer4.java,awaitRestoreChannel,711-711,[            threadsInPageIO--;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/data/RAFContainer4.java,awaitRestoreChannel,749-749,[                threadsInPageIO++;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/data/RAFContainer4.java,awaitRestoreChannel,763-763,[                threadsInPageIO--;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/data/RAFContainer4.java,readPage,348-348,[                threadsInPageIO++;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/data/RAFContainer4.java,readPage,388-388,[                threadsInPageIO--;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/data/RAFContainer4.java,recoverContainerAfterInterrupt,848-848,[                threadsInPageIO--;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/data/RAFContainer4.java,recoverContainerAfterInterrupt,931-931,[                    threadsInPageIO++;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/data/RAFContainer4.java,writePage,523-523,[                threadsInPageIO++;],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/data/RAFContainer4.java,writePage,561-561,[                threadsInPageIO--;],,
BAD_PRACTICE,NP_TOSTRING_COULD_RETURN_NULL,org/apache/derby/impl/store/raw/data/ReclaimSpace.java,toString,236-236,[		return null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/RecordId.java,lockAttributes,288-288,[					   new Long(pageId.getContainerId().getContainerId()));],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/RFResource.java,performWork,264-264,[            throw (StandardException) (e.getException());],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StoredPage.java,addSlotEntry,2471-2471,[            newSlotOffset = getSlotOffset(slot); ],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StoredPage.java,createSpaceForUpdate,7773-7773,[        int remainingLength = shiftRemainingData(slot, offset, oldLength, newLength);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StoredPage.java,getNextColumnPiece,3316-3316,[                (lrdi, fieldStatus, slotFieldSize);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StoredPage.java,isColumnOrphaned,3219-3219,[                (lrdi, fieldStatus, slotFieldSize);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StoredPage.java,logLongColumn,6074-6074,[        int beginPosition = out.getPosition();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StoredPage.java,restorePortionLongColumn,5941-5941,[                StoredFieldHeader.readFieldDataLength(],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StoredPage.java,logColumn,6311-6311,[                    int bytesShifted = bufferedIn.shiftToFront();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StoredPage.java,logRow,3893-3893,[            int lastSpaceAvailable              = spaceAvailable;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StoredPage.java,readPageHeader,1915-1915,[        spare           =   lrdi.readLong();],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/raw/data/StoredPage.java,logRecord,6681-6681,[            newRecordHeader = null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/data/StoredPage.java,validateChecksum,920-920,[                    new Long(checksum.getValue()), ],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/store/raw/data/StoredPage.java,doUpdateAtSlot,8669-8669,[            owner.getActionSet().actionUpdate(],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/raw/data/StoredPage.java,logRow,3882-3882,[                    if ((validColumns != null) && ],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/raw/data/StoredPage.java,doUpdateAtSlot,9045-9045,[                    if (!rowHasReservedSpace    && ],,doUpdateAtSlot,8945-8945,[                    if (!rowHasReservedSpace && headRowHandle != null &&],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/store/raw/data/StoredPage.java,toString,8112-8112,[                str += recordToString(s);],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/store/raw/data/StoredPage.java,getOverflowPage,8329-8329,[        if (overflowPage == null) {],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/store/raw/data/StoredPage.java,logColumn,6351-6351,[            boolean isNull = (columnFlag == COLUMN_CREATE_NULL) || sColumn.isNull();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/store/raw/data/StoredPage.java,logOverflowField,6620-6645,[                StoredFieldHeader.setInitial(), true);, ,         int fieldSizeOnPage = ,             CompressedNumber.sizeLong(overflowPage) + ,             CompressedNumber.sizeInt(overflowId);, ,         int fieldDataLength = fieldSizeOnPage;, ,         fieldSizeOnPage += ,             StoredFieldHeader.size(fieldStatus, fieldDataLength, slotFieldSize);, ,         // need to check that we have room on the page for this.,         spaceAvailable -= fieldSizeOnPage;, ,         // what if there is not enough room for the overflow pointer?,         if (spaceAvailable < 0),             throw new NoSpaceOnPage(isOverflowPage());, ,         // write the field to the page:,         StoredFieldHeader.write(,             logicalDataOut, fieldStatus, fieldDataLength, slotFieldSize);,         CompressedNumber.writeLong(out, overflowPage);,         CompressedNumber.writeInt(out, overflowId);, ,         // return the available bytes,         return(spaceAvailable);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/store/raw/data/StoredPage.java,,314-314,[    ByteHolder bh = null;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/StreamFileContainer.java,privGetInputStream,1169-1169,[            throw (FileNotFoundException)pae.getException();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/StreamFileContainer.java,privGetOutputStream,1149-1149,[            throw (FileNotFoundException)pae.getException();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/data/StreamFileContainer.java,privMkdirs,1108-1108,[            throw (IOException) pae.getCause();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/data/StreamFileContainer.java,load,504-504,[			int rhLen = recordHeader.write(out);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/StreamFileContainer.java,,1181-1181,[        switch(actionCode)],,,1097-1097,[        actionCode = STORAGE_FILE_MKDIRS_ACTION;],,,1119-1119,[        actionCode = STORAGE_FILE_DELETE_ACTION;],,,1161-1161,[        actionCode = STORAGE_FILE_GET_INPUT_STREAM_ACTION;],,,1075-1075,[        actionCode = STORAGE_FILE_EXISTS_ACTION;],,,1141-1141,[        actionCode = STORAGE_FILE_GET_OUTPUT_STREAM_ACTION;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/data/StreamFileContainer.java,,1184-1184,[            return ReuseFactory.getBoolean(actionStorageFile.exists());],,,1186-1186,[            return ReuseFactory.getBoolean(actionStorageFile.delete());],,,1188-1188,[            boolean created = actionStorageFile.mkdirs();],,,1192-1192,[            return actionStorageFile.getOutputStream();],,,1194-1194,[            return actionStorageFile.getInputStream();],,,1189-1189,[            actionStorageFile.limitAccessToOwner();],,,1098-1098,[        actionStorageFile = file;],,,1112-1112,[            actionStorageFile = null;],,,1120-1120,[        actionStorageFile = file;],,,1134-1134,[            actionStorageFile = null;],,,1162-1162,[        actionStorageFile = file;],,,1173-1173,[            actionStorageFile = null;],,,1076-1076,[        actionStorageFile = file;],,,1090-1090,[            actionStorageFile = null;],,,1142-1142,[        actionStorageFile = file;],,,1153-1153,[            actionStorageFile = null;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/derby/impl/store/raw/data/StreamFileContainer.java,,105-105,[	protected static int formatIdInteger = ],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/store/raw/data/StreamFileContainer.java,,105-105,[	protected static int formatIdInteger = ],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/store/raw/data/StreamFileContainerHandle.java,,110-110,[		this.rawStoreId = rawStoreId;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/SyncOnCommit.java,update,64-64,[			openContainerAndDoIt((RawTransaction) obj);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/impl/store/raw/data/TruncateOnCommit.java,update,76-76,[			openContainerAndDoIt((RawTransaction) obj);],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/derby/impl/store/raw/data/TruncateOnCommit.java,equals,97-106,[		if (other instanceof TruncateOnCommit) {, , 			if (((TruncateOnCommit) other).commitAsWell, 				!= commitAsWell), 				return false;, , 			return super.equals(other);, 		}, 		else, 			return false;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/log/CheckpointOperation.java,readExternal,101-101,[		int tsize = CompressedNumber.readInt(in); // is there any truncationLWM?],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/log/FileLogger.java,,488-488,[				if (encryptionBuffer == null || ],,,490-490,[					encryptionBuffer = new byte[encryptedLength];],,,492-492,[				System.arraycopy(logOutputBuffer.getByteArray(), 0, ],,,496-496,[				int len = ],,,504-504,[				instant = logFactory.],,,306-306,[					if (encryptionBuffer == null || ],,,364-364,[						instant = logFactory.],,,338-338,[							instant = logFactory.],,,308-308,[						encryptionBuffer = new byte[encryptedLength];],,,310-310,[					System.arraycopy(logOutputBuffer.getByteArray(), 0, ],,,319-319,[					int len = ],,,314-314,[						System.arraycopy(preparedLog, optionalDataOffset, ],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/raw/log/FileLogger.java,reprepare,752-752,[				if (lop != null)],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/store/raw/log/LogAccessFileBuffer.java,,57-57,[        next        = null;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/store/raw/log/LogAccessFileBuffer.java,,56-56,[        prev        = null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/impl/store/raw/log/LogRecord.java,skipLoggable,237-237,[			if (op == null)],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/store/raw/log/LogRecord.java,skipLoggable,235-235,[				xactId = (TransactionId)input.readObject();	// get rid of the transactionId],,skipLoggable,238-238,[				op = (Loggable)input.readObject();	// get rid of the loggable],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/log/LogToFile.java,privCopyFile,5767-5767,[                throw (StandardException)pae.getCause();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/log/LogToFile.java,privGetOutputStreamWriter,5703-5703,[            throw (IOException) pae.getException();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/log/LogToFile.java,privMkdirs,5719-5719,[            throw (IOException) pae.getCause();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/store/raw/log/LogToFile.java,privRandomAccessFile,5688-5688,[            throw (IOException) pae.getException();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/store/raw/log/LogToFile.java,boot,3171-3171,[			} catch (MalformedURLException ex) {}],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/log/LogToFile.java,readControlFile,2579-2579,[				int dbBuildNumber = dais.readInt();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/log/LogToFile.java,readControlFile,2562-2562,[				int obsoleteVersion = dais.readInt();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/log/LogToFile.java,verifyLogFormat,1921-1921,[			int obsoleteLogVersion = log.readInt(); // this value is useless, for],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/store/raw/log/LogToFile.java,switchLogFile,2188-2188,[					newLogFile = null;],,switchLogFile,2158-2158,[					newLogFile = null;],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/impl/store/raw/log/LogToFile.java,recover,768-768,[                                Long.valueOf(beginLogFileNumber).longValue();],,recover,800-800,[                                    Long.valueOf(checkpointStartLogStr).longValue(),],,recover,801-801,[                                    Long.valueOf(checkpointStartOffsetStr).longValue());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/log/LogToFile.java,appendLogRecord,3859-3859,[						throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/log/LogToFile.java,recover,1132-1132,[							Monitor.logTextMessage(MessageId.LOG_INCOMPLETE_LOG_RECORD,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/log/LogToFile.java,switchLogFile,2045-2045,[				throw StandardException.newException(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/log/LogToFile.java,appendLogRecord,3770-3907,[        if (inReplicationSlavePreMode) {,             // Return the *current* end of log without adding the log,             // record to the log file. Effectively, this call to,             // appendLogRecord does not do anything,             return LogCounter.makeLogInstantAsLong(logFileNumber, endPosition);,         }, , 		long instant;, 		boolean testIncompleteLogWrite = false;, , 		if (ReadOnlyDB),         {, 			throw StandardException.newException(,                 SQLState.LOG_READ_ONLY_DB_UPDATE);,         }, , 		if (length <= 0),         {,             throw StandardException.newException(,                     SQLState.LOG_ZERO_LENGTH_LOG_RECORD);,         }, , 		// RESOLVE: calculate checksum here, 		if (SanityManager.DEBUG), 		{, 			if (SanityManager.DEBUG_ON(TEST_LOG_INCOMPLETE_LOG_WRITE)), 			{, 				/// /// /// /// /// /// /// /// /// /// , 				//, 				// go into this alternate route instead, 				//, 				/// /// /// /// /// /// /// /// /// /// , 				return logtest_appendPartialLogRecord(data, offset, length,, 													  optionalData,, 													  optionalDataOffset,, 													  optionalDataLength);, , 			}, , 		}, , 		try, 		{, 			if (SanityManager.DEBUG), 			{, 				if (SanityManager.DEBUG_ON(TEST_LOG_FULL)), 					testLogFull();	// if log is 'full' this routine will throw an, 								// exception , 			}, , 			synchronized (this), 			{, 				// has someone else found a problem in the raw store?, 				if (corrupt != null),                 {, 					throw StandardException.newException(,                             SQLState.LOG_STORE_CORRUPT, corrupt);,                 }, , 				if (logOut == null),                 {, 					throw StandardException.newException(SQLState.LOG_NULL);,                 }, , 				/*, 				 * NOTE!!, 				 *, 				 * subclass which logs special record to the stream depends on, 				 * the EXACT byte sequence of the following segment of code.  , 				 * If you change this, not only will you need to write upgrade, 				 * code for this class, you also need to find all the subclass, 				 * which write log record to log stream directly to make sure , 				 * they are OK, 				 */, , 				// see if the log file is too big, if it is, switch to the next, 				// log file. account for an extra INT_LENGTH because switchLogFile(),                 // writes an extra 0 at the end of the log. in addition, a checksum log record,                 // may need to be written (see DERBY-2254).,                 int     checksumLogRecordSize = logOut.getChecksumLogRecordSize();, 				if ( (endPosition + LOG_RECORD_OVERHEAD + length + INT_LENGTH + checksumLogRecordSize) >=,                      LogCounter.MAX_LOGFILE_SIZE), 				{, 					switchLogFile();, , 					// still too big??  Giant log record?,                     if ( (endPosition + LOG_RECORD_OVERHEAD + length + INT_LENGTH + checksumLogRecordSize) >=,                          LogCounter.MAX_LOGFILE_SIZE),                     {, 						throw StandardException.newException(,                                 SQLState.LOG_EXCEED_MAX_LOG_FILE_SIZE, ,                                 new Long(logFileNumber), ,                                 new Long(endPosition), ,                                 new Long(length), ,                                 new Long(LogCounter.MAX_LOGFILE_SIZE));,                     }, 				}, , 				//reserve the space for the checksum log record, 				setEndPosition( endPosition + logOut.reserveSpaceForChecksum(length, logFileNumber,endPosition) );, , 				// don't call currentInstant since we are already in a, 				// synchronzied block , 				instant = ,                     LogCounter.makeLogInstantAsLong(logFileNumber, endPosition);, ,                 logOut.writeLogRecord(,                     length, instant, data, offset, ,                     optionalData, optionalDataOffset, optionalDataLength);, , 				if (optionalDataLength != 0) ,                 {, 					if (SanityManager.DEBUG), 					{, 						if (optionalData == null), 							SanityManager.THROWASSERT(, 							"optionalDataLength = " + optionalDataLength +, 							" with null Optional data");, , 						if (optionalData.length <, 											 (optionalDataOffset+optionalDataLength)), 							SanityManager.THROWASSERT(, 							"optionalDataLength = " + optionalDataLength +, 							" optionalDataOffset = " + optionalDataOffset + , 							" optionalData.length = " + optionalData.length);, 					}, 				}, , 				setEndPosition( endPosition + (length + LOG_RECORD_OVERHEAD) );, 			}, 		}, 		catch (IOException ioe), 		{, 			throw markCorrupt(StandardException.newException(,                     SQLState.LOG_FULL, ioe));, 		}, , 		return instant;],,<init>,947-949,[],,valueOf,837-840,[],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/log/LogToFile.java,,5821-5821,[		switch (action) {],,,5714-5714,[        this.action = 4;],,,5725-5725,[		action = 8;],,,5679-5679,[		action = 2;],,,5695-5695,[        action = 10;],,,5796-5796,[		this.action = action;],,,5776-5776,[		action = 9;],,,5740-5740,[		action = 5;],,,5757-5757,[		action = 6;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/log/LogToFile.java,,5832-5832,[            Object result = activeFile.getRandomAccessFile(activePerms);],,,5681-5681,[        activePerms = perms;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/log/LogToFile.java,,4214-4214,[			if (potentialLastFlush > logSwitchInterval &&],,,4191-4191,[		if ((logWrittenFromLastCheckPoint + potentialLastFlush) > checkpointInterval &&],,,4223-4223,[					if (potentialLastFlush > logSwitchInterval &&],,,4226-4226,[						inLogSwitch = true;],,,4200-4200,[				if ((logWrittenFromLastCheckPoint + potentialLastFlush) > checkpointInterval &&],,,2165-2165,[				inLogSwitch = false;],,,2098-2098,[					inLogSwitch = true; ],,,2208-2208,[			inLogSwitch = false;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/log/LogToFile.java,,4119-4119,[				SanityManager.ASSERT(logBeingFlushed, ],,,4044-4044,[					if (logBeingFlushed)],,,4084-4084,[						logBeingFlushed = true;	],,,4173-4173,[				logBeingFlushed = false; // done flushing],,,2016-2016,[			while(logBeingFlushed | isFrozen)],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/log/LogToFile.java,,5230-5230,[        if(logOut != null) {],,,5231-5231,[            logOut.stopReplicationMasterRole();],,,4139-4139,[				logOut.flushDirtyBuffers();],,,4144-4144,[				    logOut.syncLogAccessFile();],,,683-683,[			logOut = new LogAccessFile(this, firstLog, logBufferSize);],,,942-942,[						logOut = null; ],,,1170-1170,[                    if (logOut != null)],,,1174-1174,[                        logOut.close();],,,1176-1176,[					logOut = new LogAccessFile(this, theLog, logBufferSize);],,,3454-3454,[					logOut = null;],,,1535-1535,[		if (logOut == null)],,,5361-5361,[            logOut = new LogAccessFile(this, logFile, logBufferSize);],,,4707-4707,[					setEndPosition( endPosition +],,,4736-4736,[							logOut.writeInt(length);],,,4729-4729,[									logOut.write((byte)((length >>> 8*shift) & 0xFF));],,,4751-4751,[							logOut.writeLong(instant);],,,4744-4744,[									logOut.write((byte)((instant >>> 8*shift) & 0xFF));],,,4770-4770,[							logOut.write(data, offset, length - optionalDataLength);],,,4761-4761,[									logOut.write(data, offset, dataLength);],,,4758-4758,[									logOut.write(data, offset,bytesToWrite);],,,4773-4773,[								logOut.write(optionalData, optionalDataOffset, optionalDataLength);],,,4789-4789,[							logOut.writeInt(length);],,,4764-4764,[										logOut.write(optionalData, optionalDataOffset, bytesToWrite);],,,4782-4782,[									logOut.write((byte)((length >>> 8*shift) & 0xFF));],,,2913-2913,[			logOut.flushLogAccessFile();],,,4077-4077,[							logOut.switchLogBuffer();],,,4072-4072,[							logOut.flushLogAccessFile();],,,3531-3531,[			if (logOut != null) {],,,3533-3533,[					logOut.flushLogAccessFile();],,,3534-3534,[					logOut.close();],,,3538-3538,[				logOut = null;],,,2962-2962,[				if (logOut != null)],,,2964-2964,[					logOut.flushLogAccessFile();],,,2093-2093,[					logOut.writeEndMarker(0);],,,2193-2193,[					logOut = null; // limit any damage],,,2111-2111,[					logOut.close();		// close the old log file],,,2127-2127,[					logOut = new LogAccessFile(this, newLog, logBufferSize);],,,585-585,[				if (logOut != null)],,,598-598,[				logOut = null;],,,589-589,[						logOut.corrupt(); // get rid of open file descriptor],,,3829-3829,[				if (logOut == null)],,,3849-3849,[                int     checksumLogRecordSize = logOut.getChecksumLogRecordSize();],,,3869-3869,[				setEndPosition( endPosition + logOut.reserveSpaceForChecksum(length, logFileNumber,endPosition) );],,,3876-3876,[                logOut.writeLogRecord(],,,2249-2249,[			logOut.flushLogAccessFile();],,,5218-5218,[            logOut.setReplicationMasterRole(masterFactory);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/log/LogToFile.java,,3484-3484,[			maxLogFileNumber = LogCounter.DERBY_10_0_MAX_LOGFILE_NUMBER;],,,2043-2043,[			if (logFileNumber+1 >= maxLogFileNumber)],,,2045-2045,[				throw StandardException.newException(],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/log/LogToFile.java,,5249-5249,[        if (!stopped) {],,,5378-5378,[        if (!stopped) {],,,3529-3529,[			stopped = true;],,,583-583,[				stopped = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/raw/log/LogToFile.java,,5856-5856,[			return ReuseFactory.getBoolean(FileUtil.copyFile(logStorageFactory, activeFile, toFile));],,,5863-5863,[            return toFile.list();],,,5865-5865,[            return ReuseFactory.getBoolean(FileUtil.copyFile( logStorageFactory, toFile, activeFile));],,,5726-5726,[        toFile = file;],,,5778-5778,[		toFile = from;],,,5759-5759,[		toFile = to;],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/raw/log/LogToFile.java,failoverSlave,5387-5387,[            slaveRecoveryMonitor.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/raw/log/LogToFile.java,stopReplicationSlaveRole,5257-5257,[            slaveRecoveryMonitor.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/raw/log/LogToFile.java,switchLogFile,2205-2205,[                    slaveRecoveryMonitor.notify();],,
CORRECTNESS,NP_ALWAYS_NULL_EXCEPTION,org/apache/derby/impl/store/raw/log/LogToFile.java,truncateLog,2319-2319,[											  + uselessLogFile.getPath(), se);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/store/raw/log/LogToFile.java,recover,832-832,[					if (transactionTable != null)],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/store/raw/log/LogToFile.java,truncateLog,2318-2318,[					SanityManager.THROWASSERT("error opening log segment while deleting "],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/store/raw/log/LogToFile.java,privList,5734-5734,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/store/raw/log/LogToFile.java,privList,5749-5749,[            return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/impl/store/raw/log/LogToFile.java,recover,832-832,[					if (transactionTable != null)],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/store/raw/log/LogToFile.java,privRandomAccessFile,2524-2524,[		long controlFilelength = logControlFile.length();],,privRandomAccessFile,2662-2662,[			if (logControlFile != null)],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/store/raw/log/LogToFile.java,switchLogFile,2172-2172,[                    newLogFile.getPath(),],,switchLogFile,2185-2185,[                if (newLogFile != null && privExists(newLogFile))],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/store/raw/log/LogToFile.java,readControlFile,2538-2538,[			}else if (controlFilelength > 16)],,
MT_CORRECTNESS,VO_VOLATILE_INCREMENT,org/apache/derby/impl/store/raw/log/LogToFile.java,backupLogFiles,5074-5074,[			logFileToBackup++;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/log/Scan.java,getNextRecordBackward,376-376,[					throw logFactory.markCorrupt(],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/raw/log/Scan.java,getNextRecordForward,955-955,[						throw logFactory.markCorrupt],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/store/raw/log/Scan.java,<init>,134-168,[		switch(direction), 		{, 		case FORWARD:, 			scan =  logFactory.getLogFileAtPosition(startAt);, 			scanDirection = FORWARD;, , 			if (SanityManager.DEBUG), 				if (scan == null), 					SanityManager.THROWASSERT(, 						"scan null at " + LogCounter.toDebugString(startAt));, , 			// NOTE: just get the length of the file without syncing., 			// this only works because the only place forward scan is used, 			// right now is on recovery redo and nothing is being added to , 			// the current log file.  When the forward scan is used for some, 			// other purpose, need to sync access to the end of the log, 			currentLogFileLength = scan.length();, 			break;, , 		case BACKWARD:, 			// startAt is at the front of the log record, for backward, 			// scan we need to be positioned at the end of the log record, 			scan =  logFactory.getLogFileAtPosition(startAt);, 			int logsize = scan.readInt();, , 			// skip forward over the log record and all the overhead, but remember, 			// we just read an int off the overhead, 			scan.seek(scan.getFilePointer() + logsize + LogToFile.LOG_RECORD_OVERHEAD - 4);, 			scanDirection = BACKWARD;, 			break;, , 		case BACKWARD_FROM_LOG_END:, 			// startAt is at the end of the log, no need to skip the log record, 			scan =  logFactory.getLogFileAtPosition(startAt);, 			scanDirection = BACKWARD;],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/derby/impl/store/raw/xact/GlobalXactId.java,readExternal,112-112,[            in.read(global_id);],,readExternal,124-124,[            in.read(branch_id);],,
CORRECTNESS,IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN,org/apache/derby/impl/store/raw/xact/RowLocking3Escalate.java,lockContainer,79-79,[		forUpdate = false;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/xact/TransactionTable.java,getMostRecentPreparedRecoveredXact,816-816,[                    trans.remove(tran.getId());],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/xact/TransactionTable.java,getMostRecentPreparedRecoveredXact,781-781,[						gid       = ent.getGid();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/store/raw/xact/TransactionTable.java,getMostRecentRollbackFirstTransaction,639-639,[			return findAndAssumeTransaction(id, tran);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/store/raw/xact/TransactionTable.java,getTransactionInfo,907-907,[			return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/raw/xact/Xact.java,postTermination,2132-2132,[					if (postCommitWorks != null)],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/store/raw/xact/XactFactory.java,pushTransactionContext,762-762,[		XactContext xc = new XactContext(cm, contextName, xact, abortAll, rsf);],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/store/raw/xact/XactFactory.java,rollbackAllTransactions,562-562,[			if (rbcount > 0 || irbcount > 0)],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/derby/impl/store/raw/xact/XactId.java,equals,107-119,[		if (other == this), 			return true;, , 		// assume cast will be successful rather than waste time doing an, 		// instanceof first.  Catch the exception if it failed., 		try, 		{, 			XactId oxid = (XactId)other;, 			return (id == oxid.id);, 		}, 		catch (ClassCastException cce), 		{, 			return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/store/raw/xact/XactXAResourceManager.java,,250-263,[                    new TransactionTable.EntryVisitor() {,                 public boolean visit(TransactionTableEntry entry) {,                     Xact xact = entry.getXact();,                     if (xact.isPrepared()),                     {,                         GlobalXactId xa_id = (GlobalXactId) xact.getGlobalId();, ,                         xid_list.add(,                             new XAXactId(,                                 xa_id.getFormat_Id(), ,                                 xa_id.getGlobalTransactionId(), ,                                 xa_id.getBranchQualifier()));,                     },                     return true; // scan the entire transaction table],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/replication/master/AsynchronousLogShipper.java,,392-392,[                (System.currentTimeMillis() - lastShippingTime) >],,,278-278,[                lastShippingTime = System.currentTimeMillis();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/replication/master/AsynchronousLogShipper.java,,229-229,[                transmitter = masterController.handleExceptions(ioe);],,,232-232,[                if (transmitter != null) {],,,264-264,[                transmitter.sendMessage(failedChunk);],,,276-276,[                transmitter.sendMessage(mesg);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/replication/master/AsynchronousLogShipper.java,,347-347,[        return highestShippedInstant;],,,265-265,[                highestShippedInstant = failedChunkHighestInstant;],,,277-277,[                highestShippedInstant = logBuffer.getLastInstant();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/replication/master/AsynchronousLogShipper.java,forceFlush,331-331,[                objLSTSync.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/replication/master/AsynchronousLogShipper.java,run,214-214,[                    forceFlushSemaphore.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/replication/master/AsynchronousLogShipper.java,workToDo,395-395,[                objLSTSync.notify();],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/store/replication/master/AsynchronousLogShipper.java,calculateSIfromFI,422-422,[        } else if (fi > FI_LOW && fi < FI_HIGH) {],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/derby/impl/store/replication/master/AsynchronousLogShipper.java,run,221-221,[                        objLSTSync.wait(shippingInterval);],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/derby/impl/store/replication/master/AsynchronousLogShipper.java,forceFlush,335-335,[                forceFlushSemaphore.wait(DEFAULT_FORCEFLUSH_TIMEOUT);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/store/replication/master/MasterController.java,startFailover,327-327,[        if (ack == null) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/store/replication/master/MasterController.java,,217-217,[        dataFactory = dataFac;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/store/replication/net/ReplicationMessage.java,readExternal,183-186,[        switch ((int)in.readLong()) {,             case 1: {,                 type = in.readInt();,                 message = in.readObject();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/replication/net/ReplicationMessageReceive.java,,436-436,[                connectionConfirmed = true;],,,475-475,[            connectionConfirmed = false;],,,501-501,[                if (!connectionConfirmed && nextWait > 0) {],,,509-509,[        return connectionConfirmed;],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/replication/net/ReplicationMessageReceive.java,isConnectedToMaster,484-484,[                sendPingSemaphore.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/replication/net/ReplicationMessageReceive.java,readMessage,437-437,[                receivePongSemaphore.notify();],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/replication/net/ReplicationMessageReceive.java,tearDown,224-224,[            sendPingSemaphore.notify();],,
MT_CORRECTNESS,TLW_TWO_LOCK_WAIT,org/apache/derby/impl/store/replication/net/ReplicationMessageReceive.java,isConnectedToMaster,494-494,[                    receivePongSemaphore.wait(nextWait);],,isConnectedToMaster,484-484,[                sendPingSemaphore.notify();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/store/replication/net/ReplicationMessageReceive.java,readMessage,431-431,[        ReplicationMessage msg = (ReplicationMessage)socketConn.readMessage();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/store/replication/net/ReplicationMessageReceive.java,sendMessage,408-408,[        socketConn.writeMessage(message);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java,brokerConnection,259-259,[        ReplicationMessage initiatorMsg = ],,brokerConnection,267-267,[        initiatorMsg =],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java,,358-358,[                            receivedMsg = message;],,,202-202,[        receivedMsg = null;],,,208-208,[        while (receivedMsg == null &&],,,224-224,[        if (receivedMsg == null) {],,,229-229,[        return receivedMsg;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java,,47-47,[    private final int DEFAULT_MESSAGE_RESPONSE_TIMEOUT = 30000;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java,sendMessage,178-178,[        socketConn.writeMessage(message);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java,sendMessageWaitForReply,204-204,[        socketConn.writeMessage(message);],,
CORRECTNESS,UWF_UNWRITTEN_FIELD,org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java,,144-144,[        startMessageReceiverThread(dbname);],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java,sendMessageWaitForReply,213-213,[                    receiveSemaphore.wait(],,
MT_CORRECTNESS,NO_NOTIFY_NOT_NOTIFYALL,org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java,run,359-359,[                            receiveSemaphore.notify();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/store/replication/slave/ReplicationLogScan.java,getData,286-286,[            return null;],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/impl/store/replication/slave/SlaveController.java,boot,141-141,[                slavePort = (new Integer(port)).intValue();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/store/replication/slave/SlaveController.java,,220-220,[        rawStoreFactory = rawStore;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/storeless/EmptyDictionary.java,computeAutoincRowLocations,751-751,[		return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/storeless/EmptyDictionary.java,getConglomerateDescriptors,594-594,[		return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/storeless/EmptyDictionary.java,getConglomerateDescriptors,582-582,[		return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/storeless/EmptyDictionary.java,getSPSParams,472-472,[		return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/storeless/NoOpTransaction.java,getCacheStats,262-262,[        return null;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Alias.java,doSynonyms,233-233,[		ResultSet rs = stmt.executeQuery("SELECT ALIAS, SCHEMAID, " +],,doSynonyms,236-236,[		boolean firstTime = true;],,doSynonyms,237-237,[		while (rs.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Alias.java,doSynonyms,232-232,[		Statement stmt = conn.createStatement();],,doSynonyms,233-233,[		ResultSet rs = stmt.executeQuery("SELECT ALIAS, SCHEMAID, " +],,doSynonyms,236-236,[		boolean firstTime = true;],,doSynonyms,237-237,[		while (rs.next()) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/tools/dblook/DB_Alias.java,createPFAUString,174-179,[        switch( aliasType ),         {,         case UDT_TYPE: alias.append( "TYPE " ); break;,         case PROCEDURE_TYPE: alias.append("PROCEDURE "); break;,         case FUNCTION_TYPE: alias.append("FUNCTION "); break;,         case AGGREGATE_TYPE: alias.append("DERBY AGGREGATE "); break;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/tools/dblook/DB_Alias.java,generateDDL,131-136,[                switch( aliasType ),                 {,                 case UDT_TYPE: Logs.reportMessage( "DBLOOK_UDTHeader" ); break;,                 case PROCEDURE_TYPE: Logs.reportMessage( "DBLOOK_StoredProcHeader" ); break;,                 case FUNCTION_TYPE: Logs.reportMessage( "DBLOOK_FunctionHeader" ); break;,                 case AGGREGATE_TYPE: Logs.reportMessage( "DBLOOK_AggregateHeader" ); break;],,
STYLE,UC_USELESS_CONDITION,org/apache/derby/impl/tools/dblook/DB_Alias.java,createPFAUString,211-211,[        else if ( aliasType != AGGREGATE_TYPE )],,
I18N,DM_CONVERT_CASE,org/apache/derby/impl/tools/dblook/DB_GrantRevoke.java,columnPrivStatement,315-315,[		String privType = rs.getString(4).toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/derby/impl/tools/dblook/DB_GrantRevoke.java,tablePrivStatement,147-147,[		if (rs.getString(4).toUpperCase().equals("Y")) ],,tablePrivStatement,153-153,[		if (rs.getString(5).toUpperCase().equals("Y"))],,tablePrivStatement,159-159,[		if (rs.getString(6).toUpperCase().equals("Y"))],,tablePrivStatement,165-165,[		if (rs.getString(7).toUpperCase().equals("Y"))],,tablePrivStatement,171-171,[		if (rs.getString(8).toUpperCase().equals("Y"))],,tablePrivStatement,177-177,[		if (rs.getString(9).toUpperCase().equals("Y"))],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_GrantRevoke.java,doAuthorizations,46-46,[		Statement stmt = conn.createStatement();],,doAuthorizations,49-49,[        if ( at10_6 )],,doAuthorizations,70-70,[        rs = stmt.executeQuery("SELECT GRANTEE, SCHEMANAME, TABLENAME, SELECTPRIV, " +],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_GrantRevoke.java,generateColumnPrivs,199-199,[        PreparedStatement columnStmt = conn.prepareStatement(],,generateColumnPrivs,206-206,[		boolean firstTime = true;],,generateColumnPrivs,207-207,[		while (rs.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Index.java,doIndexes,50-50,[		ResultSet rs = stmt.executeQuery("SELECT TABLEID, CONGLOMERATENAME, " +],,doIndexes,54-54,[		boolean firstTime = true;],,doIndexes,55-55,[		while (rs.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Index.java,doIndexes,49-49,[		Statement stmt = conn.createStatement();],,doIndexes,50-50,[		ResultSet rs = stmt.executeQuery("SELECT TABLEID, CONGLOMERATENAME, " +],,doIndexes,54-54,[		boolean firstTime = true;],,doIndexes,55-55,[		while (rs.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Jar.java,doCopy,202-202,[        FileInputStream oldJarFile = new FileInputStream(oldJarFileName);],,doCopy,203-203,[        FileOutputStream newJarFile = new FileOutputStream(newJarFileName);],,doCopy,205-205,[            if (oldJarFile.available() == 0)],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Jar.java,doCopy,203-203,[        FileOutputStream newJarFile = new FileOutputStream(newJarFileName);],,doCopy,205-205,[            if (oldJarFile.available() == 0)],,doCopy,206-206,[                break;],,doCopy,212-212,[        oldJarFile.close();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Jar.java,doJars,53-53,[        ResultSet rs = stmt.executeQuery(],,doJars,57-57,[		boolean firstTime = true;],,doJars,58-58,[		while (rs.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Jar.java,doJars,52-52,[		Statement stmt = conn.createStatement();],,doJars,53-53,[        ResultSet rs = stmt.executeQuery(],,doJars,57-57,[		boolean firstTime = true;],,doJars,58-58,[		while (rs.next()) {],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derby/impl/tools/dblook/DB_Jar.java,doCopy,202-202,[        FileInputStream oldJarFile = new FileInputStream(oldJarFileName);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derby/impl/tools/dblook/DB_Jar.java,doCopy,203-203,[        FileOutputStream newJarFile = new FileOutputStream(newJarFileName);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/derby/impl/tools/dblook/DB_Jar.java,doCopy,208-208,[            oldJarFile.read(bAr);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/derby/impl/tools/dblook/DB_Jar.java,doJars,99-99,[                    jarDir.mkdirs();],,doJars,153-153,[                    jarDir.mkdirs();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Key.java,doKeys,61-61,[		Statement stmt = conn.createStatement();],,doKeys,62-62,[		ResultSet rs = stmt.executeQuery("SELECT CS.CONSTRAINTNAME, CS.TYPE, " +],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Key.java,makeFKReferenceClause,217-217,[		ResultSet colsRS = getReferenceCols.executeQuery();],,makeFKReferenceClause,218-218,[		colsRS.next();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/dblook/DB_Roles.java,generateRoleGrants,136-136,[                (dblook.expandDoubleQuotes(rs.getString(3))); // always DBO],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Roles.java,doRoles,46-46,[        Statement stmt = conn.createStatement();],,doRoles,47-47,[        ResultSet rs = stmt.executeQuery],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Schema.java,doSchemas,51-51,[		ResultSet rs = stmt.executeQuery("SELECT SCHEMANAME, SCHEMAID " +],,doSchemas,54-54,[		boolean firstTime = true;],,doSchemas,55-55,[		while (rs.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Schema.java,doSchemas,50-50,[		Statement stmt = conn.createStatement();],,doSchemas,51-51,[		ResultSet rs = stmt.executeQuery("SELECT SCHEMANAME, SCHEMAID " +],,doSchemas,54-54,[		boolean firstTime = true;],,doSchemas,55-55,[		while (rs.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Sequence.java,doSequences,69-69,[        ResultSet rs = ps.executeQuery();],,doSequences,71-71,[		boolean firstTime = true;],,doSequences,72-72,[		while (rs.next())],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Sequence.java,doSequences,65-65,[            (],,doSequences,69-69,[        ResultSet rs = ps.executeQuery();],,doSequences,71-71,[		boolean firstTime = true;],,doSequences,72-72,[		while (rs.next())],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/dblook/DB_Table.java,reinstateAutoIncrement,188-188,[			long start = autoIncCols.getLong(1);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/impl/tools/dblook/DB_Table.java,reinstateAutoIncrement,185-185,[		ResultSet autoIncCols = getAutoIncStmt.executeQuery();],,reinstateAutoIncrement,186-186,[		if (autoIncCols.next()) {],,reinstateAutoIncrement,202-202,[		return false;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Table.java,createColumn,144-144,[		ResultSet rs = getColumnTypeStmt.executeQuery();],,createColumn,145-145,[		StringBuffer colDef = new StringBuffer();],,createColumn,146-146,[		if (rs.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_Table.java,doTables,101-101,[			ResultSet columnRS = getColumnInfoStmt.executeQuery();],,doTables,102-102,[			while (columnRS.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_View.java,doViews,47-47,[		ResultSet rs = stmt.executeQuery("SELECT V.VIEWDEFINITION, " +],,doViews,51-51,[		boolean firstTime = true;],,doViews,52-52,[		while (rs.next()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/dblook/DB_View.java,doViews,46-46,[		Statement stmt = conn.createStatement();],,doViews,47-47,[		ResultSet rs = stmt.executeQuery("SELECT V.VIEWDEFINITION, " +],,doViews,51-51,[		boolean firstTime = true;],,doViews,52-52,[		while (rs.next()) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/tools/dblook/Logs.java,initLogs,67-67,[			logFile = new PrintWriter(new FileOutputStream(logFileName, appendLogs));],,initLogs,68-68,[			ddlFile = (ddlFileName == null) ? null],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/impl/tools/ij/AsyncStatement.java,run,55-55,[		aStatement = null;],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/impl/tools/ij/AsyncStatement.java,run,43-43,[			aStatement.execute(stmt);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/tools/ij/ConnectionEnv.java,installConnection,192-192,[			} catch (Exception e) {],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/derby/impl/tools/ij/ConnectionEnv.java,installConnection,195-195,[			DriverManager.getDriver(value);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/tools/ij/ConnectionEnv.java,,69-71,[            Properties p = AccessController.doPrivileged(new PrivilegedAction<Properties>() {,             	public Properties run() {,                 	return System.getProperties();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/ij/Main.java,mainCore,98-98,[		gotProp = util.getPropertyArg(args);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/impl/tools/ij/Main.java,mainCore,185-185,[		in.close(); out.close();],,mainCore,81-81,[		LocalizedInput in = null;],,mainCore,125-125,[                        if (in1 != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/tools/ij/Main.java,mainCore,110-110,[			if (in == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/tools/ij/Main.java,mainCore,156-156,[			if (out == null)],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/tools/ij/ParseException.java,getMessage,129-129,[        expected += tokenImage[expectedTokenSequences[i][j]] + " ";],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/derby/impl/tools/ij/Token.java,,8-77,[public class Token {, ,   /**,    * An integer that describes the kind of this token.  This numbering,    * system is determined by JavaCCParser, and a table of these numbers is,    * stored in the file ...Constants.java.,    */,   public int kind;, ,   /**,    * beginLine and beginColumn describe the position of the first character,    * of this token; endLine and endColumn describe the position of the,    * last character of this token.,    */,   public int beginLine, beginColumn, endLine, endColumn;, ,   /**,    * The string image of the token.,    */,   public String image;, ,   /**,    * A reference to the next regular (non-special) token from the input,    * stream.  If this is the last token from the input stream, or if the,    * token manager has not read tokens beyond this one, this field is,    * set to null.  This is true only if this token is also a regular,    * token.  Otherwise, see below for a description of the contents of,    * this field.,    */,   public Token next;, ,   /**,    * This field is used to access special tokens that occur prior to this,    * token, but after the immediately preceding regular (non-special) token.,    * If there are no such special tokens, this field is set to null.,    * When there are more than one such special token, this field refers,    * to the last of these special tokens, which in turn refers to the next,    * previous special token through its specialToken field, and so on,    * until the first special token (whose specialToken field is null).,    * The next fields of special tokens refer to other special tokens that,    * immediately follow it (without an intervening regular token).  If there,    * is no such token, this field is null.,    */,   public Token specialToken;, ,   /**,    * Returns the image.,    */,   public String toString(),   {,      return image;,   }, ,   /**,    * Returns a new Token object, by default. However, if you want, you,    * can create and return subclass objects based on the value of ofKind.,    * Simply add the cases to the switch for all those special cases.,    * For example, if you have a subclass of Token called IDToken that,    * you want to create if ofKind is ID, simlpy add something like :,    *,    *    case MyParserConstants.ID : return new IDToken();,    *,    * to the following switch statement. Then you can cast matchedToken,    * variable to the appropriate type and use it in your lexical actions.,    */,   public static final Token newToken(int ofKind),   {,      switch(ofKind),      {,        default : return new Token();],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/tools/ij/SimpleCharStream.java,<init>,303-303,[     this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/tools/ij/SimpleCharStream.java,<init>,297-297,[     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,337-337,[     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,331-331,[     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,BeginToken,133-137,[     tokenBegin = -1;,      char c = readChar();,      tokenBegin = bufpos;, ,      return c;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,Done,386-389,[     buffer = null;,      bufline = null;,      bufcolumn = null;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ExpandBuff,38-84,[     char[] newbuffer = new char[bufsize + 2048];,      int newbufline[] = new int[bufsize + 2048];,      int newbufcolumn[] = new int[bufsize + 2048];, ,      try,      {,         if (wrapAround),         {,            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);,            System.arraycopy(buffer, 0, newbuffer,,                                              bufsize - tokenBegin, bufpos);,            buffer = newbuffer;, ,            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);,            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);,            bufline = newbufline;, ,            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);,            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);,            bufcolumn = newbufcolumn;, ,            maxNextCharInd = (bufpos += (bufsize - tokenBegin));,         },         else,         {,            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);,            buffer = newbuffer;, ,            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);,            bufline = newbufline;, ,            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);,            bufcolumn = newbufcolumn;, ,            maxNextCharInd = (bufpos -= tokenBegin);,         },      },      catch (Throwable t),      {,         throw new Error(t.getMessage());,      }, , ,      bufsize += 2048;,      available = bufsize;,      tokenBegin = 0;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,FillBuff,88-127,[     if (maxNextCharInd == available),      {,         if (available == bufsize),         {,            if (tokenBegin > 2048),            {,               bufpos = maxNextCharInd = 0;,               available = tokenBegin;,            },            else if (tokenBegin < 0),               bufpos = maxNextCharInd = 0;,            else,               ExpandBuff(false);,         },         else if (available > tokenBegin),            available = bufsize;,         else if ((tokenBegin - available) < 2048),            ExpandBuff(true);,         else,            available = tokenBegin;,      }, ,      int i;,      try {,         if ((i = inputStream.read(buffer, maxNextCharInd,,                                     available - maxNextCharInd)) == -1),         {,            inputStream.close();,            throw new java.io.IOException();,         },         else,            maxNextCharInd += i;,         return;,      },      catch(java.io.IOException e) {,         --bufpos;,         backup(0);,         if (tokenBegin == -1),            tokenBegin = bufpos;,         throw e;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,GetImage,361-364,[     if (bufpos >= tokenBegin),         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);,      else,         return new String(buffer, tokenBegin, bufsize - tokenBegin) +],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,GetSuffix,370-381,[     char[] ret = new char[len];, ,      if ((bufpos + 1) >= len),         System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);,      else,      {,         System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,,                                                           len - bufpos - 1);,         System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);,      }, ,      return ret;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,347-348,[     ReInit(dstream, 1, 1, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,357-358,[     ReInit(dstream, startline, startcolumn, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,337-338,[     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,342-343,[     ReInit(dstream, encoding, 1, 1, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,352-353,[     ReInit(dstream, encoding, startline, startcolumn, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,331-332,[     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,292-293,[     ReInit(dstream, 1, 1, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,287-288,[     ReInit(dstream, startline, startcolumn, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,ReInit,268-282,[    inputStream = dstream;,     line = startline;,     column = startcolumn - 1;, ,     if (buffer == null || buffersize != buffer.length),     {,       available = bufsize = buffersize;,       buffer = new char[buffersize];,       bufline = new int[buffersize];,       bufcolumn = new int[buffersize];,     },     prevCharIsLF = prevCharIsCR = false;,     tokenBegin = inBuf = maxNextCharInd = 0;,     bufpos = -1;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/SimpleCharStream.java,UpdateLineColumn,142-178,[     column++;, ,      if (prevCharIsLF),      {,         prevCharIsLF = false;,         line += (column = 1);,      },      else if (prevCharIsCR),      {,         prevCharIsCR = false;,         if (c == '\n'),         {,            prevCharIsLF = true;,         },         else,            line += (column = 1);,      }, ,      switch (c),      {,         case '\r' :,            prevCharIsCR = true;,            break;,         case '\n' :,            prevCharIsLF = true;,            break;,         case '\t' :,            column--;,            column += (tabSize - (column % tabSize));,            break;,         default :,            break;,      }, ,      bufline[bufpos] = line;,      bufcolumn[bufpos] = column;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/StatementFinder.java,ReInit,120-134,[			source.close();, 		} catch (IOException ioe) {, 			// just be quiet if it is already gone, 		}, 		source = s;, 		state = IN_STATEMENT;, 		atEOF = false;, 		peekEOF = false;, 		peeked = false;, 		if(s.isStandardInput() && promptwriter != null) {, 			doPrompt = true;, 		} else {, 			doPrompt = false;, 		}, 	}],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/tools/ij/StatementFinder.java,nextStatement,183-207,[			switch(nextChar) {, 				case MINUS:, 					readSingleLineComment(nextChar);, 					break;, 				case SLASH:, 				    readBracketedComment();, 				    break;, 				case SINGLEQUOTE:, 				case DOUBLEQUOTE:, 					readString(nextChar);, 					break;, 				case SEMICOLON:, 					haveSemi = true;, 					state = END_OF_STATEMENT;, 					continuedStatement=false;, 					break;, 				case NEWLINE:, 				case RETURN:, 					if(doPrompt) {, 						utilMain.doPrompt(false, promptwriter, "");, 						/* If the next character is a newline as well,, 						   we swallow it to avoid double prompting on, 						   Windows. */, 						if(nextChar == RETURN && peekChar() == NEWLINE) {, 							readChar();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/tools/ij/ijTokenManager.java,,2232-2232,[   t.endColumn = input_stream.getEndColumn();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/tools/ij/ijTokenManager.java,,2231-2231,[   t.endLine = input_stream.getEndLine();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/tools/ij/ijTokenManager.java,,2261-2261,[      matchedToken.specialToken = specialToken;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/derby/impl/tools/ij/ij.java,identifier,2824-2824,[                {if (true) return (t.image.toUpperCase(Locale.ENGLISH));}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/TokenMgrError.java,LexicalError,98-102,[      return("Lexical error at line " +,            errorLine + ", column " +,            errorColumn + ".  Encountered: " +,            (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +,            "after : \"" + addEscapes(errorAfter) + "\"");],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/tools/ij/UCode_CharStream.java,<init>,316-316,[     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/tools/ij/UCode_CharStream.java,ReInit,328-328,[     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,BeginToken,145-149,[     tokenBegin = -1;,      char c = readChar();,      tokenBegin = bufpos;, ,      return c;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,Done,363-367,[     nextCharBuf = null;,      buffer = null;,      bufline = null;,      bufcolumn = null;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,ExpandBuff,55-99,[     char[] newbuffer = new char[bufsize + 2048];,      int newbufline[] = new int[bufsize + 2048];,      int newbufcolumn[] = new int[bufsize + 2048];, ,      try,      {,         if (wrapAround),         {,            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);,            System.arraycopy(buffer, 0, newbuffer,,                                              bufsize - tokenBegin, bufpos);,            buffer = newbuffer;, ,            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);,            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);,            bufline = newbufline;, ,            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);,            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);,            bufcolumn = newbufcolumn;, ,            bufpos += (bufsize - tokenBegin);,         },         else,         {,            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);,            buffer = newbuffer;, ,            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);,            bufline = newbufline;, ,            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);,            bufcolumn = newbufcolumn;, ,            bufpos -= tokenBegin;,         },      },      catch (Throwable t),      {,         throw new Error(t.getMessage());,      }, ,      available = (bufsize += 2048);,      tokenBegin = 0;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,FillBuff,103-131,[     if (maxNextCharInd == 4096),         maxNextCharInd = nextCharInd = 0;, ,      int i;,      try {,         if ((i = inputStream.read(nextCharBuf, maxNextCharInd,,                                             4096 - maxNextCharInd)) == -1),         {,            inputStream.close();,            throw new java.io.IOException();,         },         else,            maxNextCharInd += i;,         return;,      },      catch(java.io.IOException e) {,         if (bufpos != 0),         {,            --bufpos;,            backup(0);,         },         else,         {,            bufline[bufpos] = line;,            bufcolumn[bufpos] = column;,         },         if (tokenBegin == -1),            tokenBegin = bufpos;,         throw e;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,GetImage,338-341,[     if (bufpos >= tokenBegin),         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);,      else,         return new String(buffer, tokenBegin, bufsize - tokenBegin) +],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,GetSuffix,347-358,[     char[] ret = new char[len];, ,      if ((bufpos + 1) >= len),         System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);,      else,      {,         System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,,                                                           len - bufpos - 1);,         System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);,      }, ,      return ret;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,ReInit,333-334,[     ReInit(dstream, startline, startcolumn, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,ReInit,328-329,[     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,ReInit,311-312,[     ReInit(dstream, startline, startcolumn, 4096);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,ReInit,292-306,[    inputStream = dstream;,     line = startline;,     column = startcolumn - 1;, ,     if (buffer == null || buffersize != buffer.length),     {,       available = bufsize = buffersize;,       buffer = new char[buffersize];,       nextCharBuf = new char[buffersize];,       bufline = new int[buffersize];,       bufcolumn = new int[buffersize];,     },   	tokenBegin = inBuf = maxNextCharInd = 0; , 	nextCharInd = bufpos = -1; ,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,ReadChar,137-140,[     if (++nextCharInd >= maxNextCharInd),         FillBuff();, ,      return nextCharBuf[nextCharInd];],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/UCode_CharStream.java,UpdateLineColumn,154-187,[     column++;, ,      if (prevCharIsLF),      {,         prevCharIsLF = false;,         line += (column = 1);,      },      else if (prevCharIsCR),      {,         prevCharIsCR = false;,         if (c == '\n'),         {,            prevCharIsLF = true;,         },         else,            line += (column = 1);,      }, ,      switch (c),      {,         case '\r' :,            prevCharIsCR = true;,            break;,         case '\n' :,            prevCharIsLF = true;,            break;,         case '\t' :,            column--;,            column += (8 - (column & 07));,            break;,         default :,            break;,      },   }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/ij/URLCheck.java,<init>,57-57,[      Properties props = getAttributes(anURL, new Properties());],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/impl/tools/ij/URLCheck.java,getValidDerbyProps,156-171,[        if( validDerbyProps == null),         {,             try,             {,                 Vector<String> props = new Vector<String>();,                 Class att = Attribute.class;,                 //Use reflection to get the list of valid keys from the Attribute class.,                 //The Attribute class is an interface and therefore all the field,                 //for it are public.,                 Field[] fields = att.getFields();,                 for (int i = 0; i < fields.length; i++),                 {,                     Field aField = (Field)fields[i];,                     props.addElement( (String) aField.get(att));,                 },                 validDerbyProps = props;],,
MT_CORRECTNESS,LI_LAZY_INIT_UPDATE_STATIC,org/apache/derby/impl/tools/ij/URLCheck.java,getBooleanAttributes,143-144,[    if (booleanAttributes == null) {,       booleanAttributes = new Vector<String>();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/tools/ij/URLCheck.java,getValidDerbyProps,173-173,[            catch (Exception ex)],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/tools/ij/ij.java,initFromEnvironment,125-125,[                        } catch (Exception e) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/ij/ij.java,ExecuteStatement,2387-2387,[                                warns = appendWarnings(warns, psUsing.getWarnings());],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/ij/ij.java,ExecuteStatement,2405-2405,[                                int numCols = rsmdUsing.getColumnCount();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/ij/ij.java,GetCursorStatement,2062-2062,[      scrolling = jj_consume_token(SCROLL);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/ij/ij.java,GetCursorStatement,2071-2071,[      withtoken = jj_consume_token(WITH);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/ij/ij.java,PrepareStatement,2017-2017,[      t = jj_consume_token(STRING);],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/ij/ij.java,jj_3R_56,4826-4826,[    xsp = jj_scanpos;],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,,74-5449,[        boolean                 elapsedTime = false;, ,         Connection theConnection = null;,         ConnectionEnv currentConnEnv = null;,         String urlCheck = null;, ,         xaAbstractHelper xahelper = null;,         boolean exit = false;, ,         utilMain utilInstance = null;,         Hashtable ignoreErrors = null;,         String protocol = null;         // the (single) unnamed protocol,         Hashtable<String,String> namedProtocols;, , , ,         /**, 	 * A constructor that understands the local state that needs to be, 	 * initialized., 	 *, 	 * @param tm			The token manager to use, 	 * @param utilInstance	The util to use, 	 */,         ij(ijTokenManager tm, utilMain utilInstance) {,                 this(tm);,                 this.utilInstance = utilInstance;,         }, ,         /**, 	   Initialize this parser from the environment, 	   (system properties). Used when ij is being run, 	   as a command line program., 	*/,         void initFromEnvironment() {, ,                 // load all protocols specified via properties,                 //,         Properties p = AccessController.doPrivileged(new PrivilegedAction<Properties>() {,                 public Properties run() {,                 return System.getProperties();,             },         });,         urlCheck = p.getProperty(URLCHECK_PROPERTY);,                 protocol = p.getProperty(PROTOCOL_PROPERTY);,                 String framework_property = p.getProperty(FRAMEWORK_PROPERTY);, ,        if (ij.JDBC20X() && ij.JTA()),                 {,                         try {,                                 xahelper = (xaAbstractHelper) Class.forName("org.apache.derby.impl.tools.ij.xaHelper").newInstance();,                                 xahelper.setFramework(framework_property);,                         } catch (Exception e) {,                         }, ,                 }, , ,                 namedProtocols = new Hashtable<String,String>();,                 String prefix = PROTOCOL_PROPERTY + ".";,                 for (Enumeration<?> e = p.propertyNames(); e.hasMoreElements(); ),                 {,                         String key = (String) e.nextElement();,                         if (key.startsWith(prefix)) {,                                 String name = key.substring(prefix.length());,                                 installProtocol(name.toUpperCase(Locale.ENGLISH), p.getProperty(key));,                         },                 },         },         /**, 	 * Return whether or not JDBC 2.0 (and greater) extension classes can be loaded, 	 *, 	 * @return true if JDBC 2.0 (and greater) extension classes can be loaded, 	 */,         private static boolean JDBC20X(),         {,                 try,                 {,                         Class.forName("javax.sql.DataSource");,                         Class.forName("javax.sql.ConnectionPoolDataSource");,                         Class.forName("javax.sql.PooledConnection");,                         Class.forName("javax.sql.XAConnection");,                         Class.forName("javax.sql.XADataSource");,                 },                 catch(ClassNotFoundException cnfe),                 {,                         return false;,                 },                 return true;,         },         /**, 	 * Return whether or not JTA classes can be loaded, 	 *, 	 * @return true if JTA classes can be loaded, 	 */,         private static boolean JTA(),         {,                 try,                 {,                         Class.forName("javax.transaction.xa.Xid");,                         Class.forName("javax.transaction.xa.XAResource");,                         Class.forName("javax.transaction.xa.XAException");,                 },                 catch(ClassNotFoundException cnfe),                 {,                         return false;,                 },                 return true;,         }, ,         /**, 	 * Return whether or not JNDI extension classes can be loaded, 	 *, 	 * @return true if JNDI extension classes can be loaded, 	 */,    public static boolean JNDI(),         {,                 try,                 {,                         Class.forName("javax.naming.spi.Resolver");,                         Class.forName("javax.naming.Referenceable");,                         Class.forName("javax.naming.directory.Attribute");,                 },                 catch(ClassNotFoundException cnfe),                 {,                         return false;,                 },                 return true;,         }, // FIXME: caller has to deal with ignoreErrors and handleSQLException behavior, ,         /**, 		Add the warnings of wTail to the end of those of wHead., 	 */,         SQLWarning appendWarnings(SQLWarning wHead, SQLWarning wTail) {,                 if (wHead == null) return wTail;, ,                 if (wHead.getNextException() == null) {,                         wHead.setNextException(wTail);,                 } else {,                         appendWarnings(wHead.getNextWarning(), wTail);,                 },                 return wHead;,         }, ,         /**, 	 * Get the "elapsedTime state"., 	 */,         boolean getElapsedTimeState(),         {,                 return elapsedTime;,         }, ,         /**, 	   this removes the outside quotes from the string., 	   it will also swizzle the special characters, 	   into their actual characters, like '' for ', etc., 	 */,         String stringValue(String s) {,                 String result = s.substring(1,s.length()-1);,                 char quotes = '\'';,                 int             index;, ,                 /* Find the first occurrence of adjacent quotes. */,                 index = result.indexOf(quotes);, ,                 /* Replace each occurrence with a single quote and begin the, 		 * search for the next occurrence from where we left off., 		 */,                 while (index != -1),                 {,                         result = result.substring(0, index + 1) + result.substring(index + 2);, ,                         index = result.indexOf(quotes, index + 1);,                 }, ,                 return result;,         }, ,         void installProtocol(String name, String value) {,             try {,                         // `value' is a JDBC protocol;,                         // we load the "driver" in the prototypical,                         // manner, it will register itself with,                         // the DriverManager.,                         util.loadDriverIfKnown(value);,             } catch (ClassNotFoundException e) {,                         throw ijException.classNotFoundForProtocol(value);,             } catch (IllegalArgumentException e) {,                         throw ijException.classNotFoundForProtocol(value);,             } catch (IllegalAccessException e) {,                         throw ijException.classNotFoundForProtocol(value);,             } catch (InstantiationException e) {,                         throw ijException.classNotFoundForProtocol(value);,             },                 if (name == null),                         protocol = value;,                 else,                         namedProtocols.put(name, value);,         }, ,         void haveConnection() {,                 JDBCDisplayUtil.checkNotNull(theConnection, "connection");,         }, ,         /**, 		Find a session by its name. Throws an exception if the session does , 		not exists., 	*/,         Session findSession(String name) {,                 Session session = currentConnEnv.getSession(name);, ,                 if (session == null),                         throw ijException.noSuchConnection(name);, ,                 return session;,         }, ,         /**, 		Find a prepared statement. Throws an exception if the session does , 		not exists or the prepared statement can't be found., 	*/,         PreparedStatement findPreparedStatement(QualifiedIdentifier qi) {,                 Session session = findSession(qi.getSessionName());,                 PreparedStatement ps = session.getPreparedStatement(qi.getLocalName());, ,                 JDBCDisplayUtil.checkNotNull(ps, "prepared statement " + qi);, ,                 return ps;,         }, ,         /**, 		Find a cursor. Throws an exception if the session does not exits or, 		it deosn't have the correspondig cursor., 	*/,         ResultSet findCursor(QualifiedIdentifier qi) {,                 Session         session = findSession(qi.getSessionName());,                 ResultSet       c               = session.getCursor(qi.getLocalName());, ,                 JDBCDisplayUtil.checkNotNull(c, "cursor " + qi);, ,                 return c;,         }, ,         /**, 		We do not reuse statement objects at all, because, 		some systems require you to close the object to release, 		resources (JBMS), while others will not let you reuse, 		the statement object once it is closed (WebLogic)., , 		If you want to reuse statement objects, you need to, 		use the ij PREPARE and EXECUTE statements., , 		@param stmt the statement, , 	 **/,         ijResult executeImmediate(String stmt) throws SQLException {,                 Statement aStatement = null;,                 try {,                         long    beginTime = 0;,                         long    endTime = 0;,                         boolean cleanUpStmt = false;, ,                         haveConnection();,                         aStatement = theConnection.createStatement();, ,                         // for JCC - remove comments at the beginning of the statement,                         // and trim; do the same for Derby Clients that have versions,                         // earlier than 10.2.,                         if (currentConnEnv != null) {,                                 boolean trimForDNC = currentConnEnv.getSession().getIsDNC();,                                 if (trimForDNC) {,                                 // we're using the Derby Client, but we only want to trim,                                 // if the version is earlier than 10.2.,                                         DatabaseMetaData dbmd = theConnection.getMetaData();,                                         int majorVersion = dbmd.getDriverMajorVersion();,                                         if ((majorVersion > 10) || ((majorVersion == 10) &&,                                                 (dbmd.getDriverMinorVersion() > 1))),                                         { // 10.2 or later, so don't trim/remove comments.,                                                 trimForDNC = false;,                                         },                                 },                                 if (currentConnEnv.getSession().getIsJCC() || trimForDNC) {,                                 // remove comments and trim.,                                         int nextline;,                                         while(stmt.startsWith("--")),                                         {,                                                 nextline = stmt.indexOf('\n')+1;,                                                 stmt = stmt.substring(nextline);,                                         },                                         stmt = stmt.trim();,                                 },                         }, ,                         aStatement.execute(stmt);, ,                         // FIXME: display results. return start time.,                         return new ijStatementResult(aStatement,true);, ,                 } catch (SQLException e) {,             try {,                             if (aStatement!=null)  // free the resource,                                     aStatement.close();,             } catch (SQLException se) {,             },                         throw e;,                 },         }, ,         ijResult quit() throws SQLException {,                 exit = true;,                 currentConnEnv.removeAllSessions();,                 theConnection = null;,                 return null;,         }, ,         /**, 		Async execution wants to return results off-cycle., 		We want to control their output, and so will hold it, 		up until it is requested with a WAIT FOR asyncName, 		statement.  WAIT FOR will return the results of, 		the async statement once they are ready.  Note that using, 		a select only waits for the execute to complete; the, 		logic to step through the result set is in the caller., 	 **/,         ijResult executeAsync(String stmt, QualifiedIdentifier qi) {,                 Session sn = findSession(qi.getSessionName());,                 AsyncStatement as = new AsyncStatement(sn.getConnection(), stmt);, ,                 sn.addAsyncStatement(qi.getLocalName(),as);, ,                 as.start();, ,                 return null;,         }, , , ,         void setConnection(ConnectionEnv connEnv, boolean multipleEnvironments) {,                 Connection conn = connEnv.getConnection();, ,                 if (connEnv != currentConnEnv) // single connenv is common case,                         currentConnEnv = connEnv;, ,                 if (theConnection == conn) return; // not changed., ,                 if ((theConnection == null) || multipleEnvironments) {,                         // must have switched env's (could check),                         theConnection = conn;,                 } else {,                         throw ijException.needToDisconnect();,                 },         }, ,         private ijResult        addSession,         (,                 Connection      newConnection,,                 String          name,         ),                 throws SQLException,         {,                 if (currentConnEnv.haveSession(name)) {,                         throw ijException.alreadyHaveConnectionNamed(name);,                 }, ,                 currentConnEnv.addSession( newConnection, name );,                 return new ijConnectionResult( newConnection );,         }, ,         private String[] sortConnectionNames(),         {,                 int size = 100;,                 int count = 0;,                 String[] array = new String[size];,                 String key;, ,                 Hashtable ss = currentConnEnv.getSessions();,                 // Calculate the number of connections in the sessions list and,                 // build an array of all the connection names.,                 for (Enumeration connectionNames = ss.keys(); connectionNames.hasMoreElements();) {,                     if (count == size) {,                        // need to expand the array,                        size = size*2;,                        String[] expandedArray = new String[size];,                        System.arraycopy(array, 0, expandedArray, 0, count);,                        array = expandedArray;,                     },                     key = (String)connectionNames.nextElement();,                     array[ count++ ] = key;,                 }, ,                 java.util.Arrays.sort(array, 0, count);, ,         return array;,         }, ,             /**, 	  This is used at the ij startup time to see if there are already some, 	      connections made and if so, show connections made so far., 	  Following also gets executed when user types show connections command, 	      in ij. In the former case, ignore0Rows is set whereas in the later cas, 	  it's set to false. The reason for this is, at ij startup time, if there, 	  are no connections made so far, we don't want to show anything. Only if, 	  there are connections made, we show the connections. Whereas in show, 	  connection command case, we want to show the connection status either way, 	  ie if there are no connections, we say no connections. Otherwise we list, 	  all the connections made so far., 	    */,         public ijResult showConnectionsMethod(boolean ignore0Rows) throws SQLException {,                 Hashtable ss = currentConnEnv.getSessions();,                 Vector<Object> v = new Vector<Object>();,                 SQLWarning w = null;,         if (ss == null || ss.size() == 0) {,                 if (!ignore0Rows),                 v.addElement(LocalizedResource.getMessage("IJ_NoConneAvail"));,         },         else {,                 boolean haveCurrent=false;,                         int count = 0;,                         for (Enumeration connectionNames = ss.keys(); connectionNames.hasMoreElements();,                                                 connectionNames.nextElement()),                         count++;,             String[] array = sortConnectionNames();,                     for ( int ictr = 0; ictr < count; ictr++ ) {,                                 String connectionName = array[ ictr ];,                 Session s = (Session)ss.get(connectionName);,                 if (s.getConnection().isClosed()) {,                         if (currentConnEnv.getSession() != null &&,                                         connectionName.equals(currentConnEnv.getSession().getName())) {,                                 currentConnEnv.removeCurrentSession();,                                 theConnection = null;,                         },                         else,                         currentConnEnv.removeSession(connectionName);,                 },                 else {,                         StringBuffer row = new StringBuffer();,                         row.append(connectionName);,                         if (currentConnEnv.getSession() != null &&,                                 connectionName.equals(currentConnEnv.getSession().getName())) {,                                 row.append('*');,                                 haveCurrent=true;,                         }, ,                                 //If ij.dataSource property is set, show only connection names.,                                 //In this case, URL is not used to get connection, so do not append URL,                                 String dsName = util.getSystemProperty("ij.dataSource");,                                         if(dsName == null){,                                 row.append(" - \u0009");,                                 row.append(s.getConnection().getMetaData().getURL());,                                 },                         // save the warnings from these connections,                         w = appendWarnings(w,s.getConnection().getWarnings());,                         s.getConnection().clearWarnings();,                         v.addElement(row.toString());,                 },                 },                 if (haveCurrent),                 v.addElement(LocalizedResource.getMessage("IJ_CurreConne"));,                     else,                 v.addElement(LocalizedResource.getMessage("IJ_NoCurreConne"));,                 },                 return new ijVectorResult(v,w);,         }, ,         /**, 	   Returns a subset of the input integer array, 	   , 	   @param input The input integer array, 	   @param start Starting index, inclusive, 	   @param end   Ending index, exclusive, 	 */,         public static int[] intArraySubset(final int[] input, int start, int end) {,                 int[] res = new int[end-start];,                 System.arraycopy(input, start, res, 0, end-start);,                 return res;,         }, ,         /**, 	   Verify that a table exists within a schema. Throws an exception, 	   if table does not exist., 	   , 	   @param schema Schema for the table, 	   @param table  Name of table to check for existence of, 	 */,         public void verifyTableExists(String schema, String table),         throws SQLException {,                 if(schema == null),                         return;, ,                 ResultSet rs = null;,                 try {,                         DatabaseMetaData dbmd = theConnection.getMetaData();,                         rs = dbmd.getTables(null,schema,table,null);,                         if(!rs.next()),                                 throw ijException.noSuchTable(table);,                 } finally {,                         try {,                             if(rs!=null),                                     rs.close();,             } catch (SQLException e) {,             },                 },         }, ,         /**, 	   Return a resultset of tables (or views, procs...) in the given schema. , , 	   @param schema  Schema to get tables for, or null for search , 	                  in all schemas., 	   @param tableType Types of tables to return, see, 	                  {@link java.sql.DatabaseMetaData#getTableTypes}, 	 */,         public ijResult showTables(String schema, String[] tableType) throws SQLException {,                 ResultSet rs = null;,                 try {,                         haveConnection();, ,                         DatabaseMetaData dbmd = theConnection.getMetaData();,                         rs = dbmd.getTables(null,schema,null,tableType);, ,                         int[] displayColumns = new int[] {,                                 rs.findColumn("TABLE_SCHEM"),,                                 rs.findColumn("TABLE_NAME"),,                                 rs.findColumn("REMARKS"),,                         };,                         int[] columnWidths = new int[] {,                                 20,,                                 30,,                                 20,,                         };, ,                         return new ijResultSetResult(rs, displayColumns, columnWidths);,                 } catch (SQLException e) {,                         try {,                             if(rs!=null),                                     rs.close();,             } catch (SQLException se) {,             },                         throw e;,                 },         }, ,         /**, 	   Return a resultset of indexes for the given table or schema, , 	   @param schema  schema to find indexes for, 	   @param table the exact name of the table to find indexes for, 	*/,     private ResultSet getIndexInfoForTable(String schema, String table),       throws SQLException {, ,         haveConnection();,         verifyTableExists(schema, table);, ,         DatabaseMetaData dbmd = theConnection.getMetaData();,         return dbmd.getIndexInfo(null, schema, table, false, true);,     }, ,     /**,      * Used by showIndexes to get columns in correct order,      */,     private int[] getDisplayColumnsForIndex(String schema, ResultSet rs),         throws SQLException{,         int[] displayColumns = new int[] {,             rs.findColumn("TABLE_SCHEM"),,             rs.findColumn("TABLE_NAME"),,             rs.findColumn("COLUMN_NAME"),,             rs.findColumn("NON_UNIQUE"),,             rs.findColumn("TYPE"),,             rs.findColumn("ASC_OR_DESC"),,             rs.findColumn("CARDINALITY"),,             rs.findColumn("PAGES"),,         };,         if(schema!=null) {,             displayColumns = intArraySubset(displayColumns, 1,,                                             displayColumns.length);,         },         return displayColumns;,     }, ,     /**,      * Used by showIndexes to get correct column widths,      */,     private int[] getColumnWidthsForIndex(String schema){,         int[] columnWidths = new int[] {,             20,,             20,,             20,,             6,,             4,,             4,,             8,,             8,,         };,         if(schema!=null) {,             columnWidths = intArraySubset(columnWidths, 1,,                                             columnWidths.length);,         },         return columnWidths;,     }, ,     /**,      * Used to show all indices.,      *,      * @param schema the schema indices are shown from. ,      * @param table the table name to show indices for. If <code>null</code>,,      *      all indices of the schema are returned.,      */,     public ijResult showIndexes(String schema, String table),             throws SQLException {, ,         ijResult result = null;, ,         int[] displayColumns = null;,         int[] columnWidths = null;, ,         try {,             if (table != null) {,                 ResultSet rs = getIndexInfoForTable(schema, table);,                 displayColumns = getDisplayColumnsForIndex(schema, rs);,                 columnWidths = getColumnWidthsForIndex(schema);,                 result = new ijResultSetResult(rs, displayColumns,,                                                columnWidths);,             },             else {,                 /* DatabaseMetaData#getIndexInfo requires exact table names.,                  * If table is null, we must first get all table names in,                  * the appropriate schema, and then get all indices for each,                  * of these. ,                  */,                 haveConnection();,                 verifyTableExists(schema, table);, ,                 DatabaseMetaData dbmd = theConnection.getMetaData();,                 ResultSet tablers = dbmd.getTables(null,schema,null,null);, ,                 List<ResultSet> resultSets = new ArrayList<ResultSet>();,                 boolean firstIteration = true;,                 ResultSet current_rs = null;,                 while (tablers.next()){,                     String tableName = tablers.getString("TABLE_NAME");,                     current_rs = getIndexInfoForTable(schema, tableName);,                     resultSets.add(current_rs);, ,                     if (firstIteration) {,                         displayColumns = getDisplayColumnsForIndex(schema,,                                                                    current_rs);,                         columnWidths = getColumnWidthsForIndex(schema);,                         firstIteration = false;,                     },                 },                 result = new ijMultipleResultSetResult(resultSets,,                                                        displayColumns,,                                                        columnWidths);,             },             return result;,         } catch (SQLException e) {,             try {,                 if(result!=null),                     result.closeStatement();,             } catch (SQLException se) {,             },             throw e;,         },     }, ,         /**, 	   Return a resultset of procedures from database metadata, 	 */,         public ijResult showProcedures(String schema) throws SQLException {,                 ResultSet rs = null;,                 try {,                         haveConnection();, ,                         DatabaseMetaData dbmd = theConnection.getMetaData();,                         rs = dbmd.getProcedures(null,schema,null);, ,                         int[] displayColumns = new int[] {,                                 rs.findColumn("PROCEDURE_SCHEM"),,                                 rs.findColumn("PROCEDURE_NAME"),,                                 rs.findColumn("REMARKS"),,                         };,                         int[] columnWidths = new int[] {,                                 20,,                                 30,,                                 20,,                         };, ,                         return new ijResultSetResult(rs, displayColumns, columnWidths);,                 } catch (SQLException e) {,             try {,                             if(rs!=null),                                     rs.close();,             } catch (SQLException se) {,             },                         throw e;,                 },         }, ,     /**,        Return a resultset of functions from database metadata., ,        JDBC4.0 has a method in DatabaseMetaData called getFunctions().,        Since this method is implemented in Derby's JDBC3.0 driver,        we can use it. But only through Java reflection.,      */,     public ijResult showFunctions(String schema) throws SQLException {,         ResultSet rs = null;, ,         try {,             haveConnection();, ,             DatabaseMetaData dbmd = theConnection.getMetaData();,             Method getFunctions;,             try {,                 getFunctions = dbmd.getClass().getMethod("getFunctions",,                                                     new Class[] { String.class,,                                                                String.class,,                                                                String.class});,                 rs = (ResultSet)getFunctions.invoke(dbmd, new Object[] { null, schema, null});,             } catch(NoSuchMethodException nsme) {,                 throw ijException.notAvailableForDriver(dbmd.getDriverName());,             } catch(IllegalAccessException iae) {,                 throw ijException.notAvailableForDriver(dbmd.getDriverName());,             } catch(AbstractMethodError ame) {,                 // According to http://bugs.sun.com/view_bug.do?bug_id=6531596,                 // invoke() may throw AbstractMethodError instead of,                 // InvocationTargetException on some JREs,                 throw ijException.notAvailableForDriver(dbmd.getDriverName());,             } catch(InvocationTargetException ite) {,                 Throwable cause = ite.getCause();,                 // 'cause' *must* be an SQLException if the method is,                 // *actually* called. But may be AbstractMethodError in some,                 // cases, if the driver implements an older version of the,                 // JDBC spec (pre-JDBC 4.0). See issue DERBY-3809.,                 if (cause instanceof SQLException),                     throw (SQLException)cause;, ,                 // else,                 throw ijException.notAvailableForDriver(dbmd.getDriverName());,             }, ,             int[] displayColumns = new int[] {,                     rs.findColumn("FUNCTION_SCHEM"),,                     rs.findColumn("FUNCTION_NAME"),,                     rs.findColumn("REMARKS"),             };,             int[] columnWidths = new int[] {,                     14,,                     28,,                     35,             };, ,             return new ijResultSetResult(rs, displayColumns, columnWidths);,         } catch (SQLException e) {,             try {,                 if(rs!=null),                     rs.close();,             } catch (SQLException se) {,             },             throw e;,         },     }, ,         /**, 	   Return a resultset of schemas from database metadata, 	 */,         public ijResult showSchemas() throws SQLException {,                 ResultSet rs = null;,                 try {,                         haveConnection();, ,                         DatabaseMetaData dbmd = theConnection.getMetaData();,                         rs = dbmd.getSchemas();, ,                         int[] displayColumns = new int[] {,                                 rs.findColumn("TABLE_SCHEM"),                         };,                         int[] columnWidths = new int[] {,                                 30,                         };, ,                         return new ijResultSetResult(rs, displayColumns, columnWidths);,                 } catch (SQLException e) {,             try {,                             if(rs!=null),                                     rs.close();,             } catch (SQLException se) {,             },                         throw e;,                 },         }, ,         /**, 	   Return a resultset of roles. No database metadata, 	   available, so select from SYS.SYSROLES directly. This has, 	   the side effect of starting a transaction if one is not, 	   already active, so we should perhaps give warning when not, 	   in autocommit mode., 	*/,         public ijResult showRoles() throws SQLException {,                 ResultSet rs = null;,                 try {,                         haveConnection();, ,                         if (currentConnEnv.getSession().getIsDNC() ||,                                 currentConnEnv.getSession().getIsEmbeddedDerby()) {,                                 rs = theConnection.createStatement().executeQuery,                                         ("SELECT ROLEID FROM SYS.SYSROLES WHERE ISDEF='Y' " +,                                          "ORDER BY ROLEID ASC");, ,                                 int[] displayColumns = new int[] {,                                         rs.findColumn("ROLEID"),                                 };,                                 int[] columnWidths = new int[] {,                                         30,                                 };, ,                                 return new ijResultSetResult(rs, displayColumns, columnWidths);,                         } else {,                                 throw ijException.notAvailableForDriver(,                                         theConnection.getMetaData().getDriverName());,                         },                 } catch (SQLException e) {,             try {,                             if(rs!=null),                                     rs.close();,             } catch (SQLException se) {,             },                         throw e;,                 },         }, ,         /**, 	 * Return a resultset of enabled roles, sorted on ROLEID. No information, 	 * schema is available, we select from VTI SYSCS_DIAG.CONTAINED_ROLES, 	 * instead., 	 */,         public ijResult showEnabledRoles() throws SQLException {,                 ResultSet rs = null;,                 try {,                         haveConnection();, ,                         if (currentConnEnv.getSession().getIsDNC() ||,                                 currentConnEnv.getSession().getIsEmbeddedDerby()) {,                                 rs = theConnection.createStatement().executeQuery,                                         ("SELECT * FROM" +,                                         "\u0009 TABLE(" +,                                         "\u0009   SYSCS_DIAG.CONTAINED_ROLES(CURRENT_ROLE)) T " +,                                         "ORDER BY ROLEID");, ,                                 int[] displayColumns = new int[] {,                                         rs.findColumn("ROLEID"),                                 };,                                 int[] columnWidths = new int[] {,                                         30,                                 };, ,                                 return new ijResultSetResult(rs, displayColumns, columnWidths);,                         } else {,                                 throw ijException.notAvailableForDriver(,                                         theConnection.getMetaData().getDriverName());,                         },                 } catch (SQLException e) {,             try {,                             if(rs!=null),                                     rs.close();,             } catch (SQLException se) {,             },                         throw e;,                 },         }, , ,         /**, 	 * Return a resultset of settable roles, sorted on ROLEID.  This has the, 	 * side effect of starting a transaction if one is not already active, so, 	 * we should perhaps give warning when not in autocommit mode., 	 */,         public ijResult showSettableRoles() throws SQLException {,                 ResultSet rs = null;,                 final String query  =,                         // Ordinary user is restricted to roles explicitly granted:,                         "select distinct * from (" +,                         "  select roleid from sys.sysroles s" +,                         "    where s.grantee = current_user or s.grantee = 'PUBLIC'" +,                         "  union" +,                         // Data base owner can set all roles:,                         "  select roleid from sys.sysroles s" +,                         "    where s.isdef='Y' and current_user in" +,                         "        (select authorizationid from sys.sysschemas" +,                         "             where schemaname = 'SYS')) t " +,                         "order by roleid";, ,                 try {,                         haveConnection();, ,                         if (currentConnEnv.getSession().getIsDNC() ||,                                 currentConnEnv.getSession().getIsEmbeddedDerby()) {,                                 rs = theConnection.createStatement().executeQuery(query);, ,                                 int[] displayColumns = new int[] {,                                         rs.findColumn("ROLEID"),                                 };,                                 int[] columnWidths = new int[] {,                                         30,                                 };, ,                                 return new ijResultSetResult(rs, displayColumns, columnWidths);,                         } else {,                                 throw ijException.notAvailableForDriver(,                                         theConnection.getMetaData().getDriverName());,                         },                 } catch (SQLException e) {,             try {,                             if(rs!=null),                                     rs.close();,             } catch (SQLException se) {,             },                         throw e;,                 },         }, , , , ,         /**, 	   Outputs the names of all fields of given table. Outputs field, 	   names and data type., 	 */,         public ijResult describeTable(String schema, String table) throws SQLException {,                 ResultSet rs = null;,                 try {,                         haveConnection();,                         verifyTableExists(schema,table);, ,                         DatabaseMetaData dbmd = theConnection.getMetaData();,                         rs = dbmd.getColumns(null,schema,table,null);, ,                         int[] displayColumns = new int[] {,                                 rs.findColumn("TABLE_SCHEM"),,                                 rs.findColumn("TABLE_NAME"),,                                 rs.findColumn("COLUMN_NAME"),,                                 rs.findColumn("TYPE_NAME"),,                                 rs.findColumn("DECIMAL_DIGITS"),,                                 rs.findColumn("NUM_PREC_RADIX"),,                                 rs.findColumn("COLUMN_SIZE"),,                                 rs.findColumn("COLUMN_DEF"),,                                 rs.findColumn("CHAR_OCTET_LENGTH"),,                                 rs.findColumn("IS_NULLABLE"),,                         };,                         int[] columnWidths = new int[] {,                                 20,,                                 20,,                                 20,,                                 9,,                                 4,,                                 4,,                                 6,,                                 10,,                                 10,,                                 8,                         };, ,                         //,                         // If schema is specified (if util.getSelectedSchema in,                         // DescTableStatement() returns correct value), then we,                         // don't need to output schema and table names.,                         if(schema!=null && table != null) {,                                 displayColumns = intArraySubset(displayColumns, 2,,                                                                                                 displayColumns.length);,                                 columnWidths   = intArraySubset(columnWidths, 2,,                                                                                                 columnWidths.length);,                         }, ,                         return new ijResultSetResult(rs, displayColumns, columnWidths);,                 } catch (SQLException e) {,             try {,                             if(rs!=null),                                     rs.close();,             } catch (SQLException se) {,             },                         throw e;,                 },         }, ,         private Object makeXid(int xid),         {,                 return null;,         }, , //, // start of BNF rules, //,   final public ijResult ijStatement() throws ParseException, SQLException {,         ijResult r = null;,     if (jj_2_1(1)) {,       if (getToken(1).kind == ROLLBACK &&,                               (!(getToken(3).kind == TO || getToken(3).kind == SAVEPOINT))) {,         r = RollbackStatement();,       } else {,         switch (jj_nt.kind) {,         case ABSOLUTE:,           r = AbsoluteStatement();,           break;,         case AFTER:,           r = AfterLastStatement();,           break;,         case AUTOCOMMIT:,           r = AutocommitStatement();,           break;,         case ASYNC:,           r = AsyncStatement();,           break;,         case BANG:,           r = Bang();,           break;,         case BEFORE:,           r = BeforeFirstStatement();,           break;,         case CLOSE:,           r = CloseStatement();,           break;,         case COMMIT:,           r = CommitStatement();,           break;,         case CONNECT:,           r = ConnectStatement();,           break;,         case DESCRIBE:,           r = DescTableStatement();,           break;,         case DISCONNECT:,           r = DisconnectStatement();,           break;,         case DRIVER:,           r = DriverStatement();,           break;,         case ELAPSEDTIME:,           r = ElapsedTimeStatement();,           break;,         case EXECUTE:,           r = ExecuteStatement();,           break;,         case FIRST:,           r = FirstStatement();,           break;,         case EXIT:,         case QUIT:,           r = ExitStatement();,           break;,         case GET:,           r = GetCursorStatement();,           break;,         case GETCURRENTROWNUMBER:,           r = GetCurrentRowNumber();,           break;,         case HELP:,           r = HelpStatement();,           break;,         case LAST:,           r = LastStatement();,           break;,         case LOCALIZEDDISPLAY:,           r = LocalizedDisplay();,           break;,         case MAXIMUMDISPLAYWIDTH:,           r = MaximumDisplayWidthStatement();,           break;,         case NEXT:,           r = NextStatement();,           break;,         case NOHOLDFORCONNECTION:,           r = NoHoldForConnectionStatement();,           break;,         case PREPARE:,           r = PrepareStatement();,           break;,         case PREVIOUS:,           r = PreviousStatement();,           break;,         case PROTOCOL:,           r = ProtocolStatement();,           break;,         case READONLY:,           r = ReadOnlyStatement();,           break;,         case RELATIVE:,           r = RelativeStatement();,           break;,         case REMOVE:,           r = RemoveStatement();,           break;,         case RUN:,           r = RunStatement();,           break;,         case SET:,           r = SetConnectionStatement();,           break;,         case SHOW:,           r = ShowStatement();,           break;,         case WAIT:,           r = WaitForStatement();,           break;,         case XA_DATASOURCE:,           r = XA_DataSourceStatement();,           break;,         case XA_CONNECT:,           r = XA_ConnectStatement();,           break;,         case XA_COMMIT:,           r = XA_CommitStatement();,           break;,         case XA_DISCONNECT:,           r = XA_DisconnectStatement();,           break;,         case XA_GETCONNECTION:,           r = XA_GetConnectionStatement();,           break;,         case XA_END:,           r = XA_EndStatement();,           break;,         case XA_FORGET:,           r = XA_ForgetStatement();,           break;,         case XA_PREPARE:,           r = XA_PrepareStatement();,           break;,         case XA_RECOVER:,           r = XA_RecoverStatement();,           break;,         case XA_ROLLBACK:,           r = XA_RollbackStatement();,           break;,         case XA_START:,           r = XA_StartStatement();,           break;,         case DATASOURCE:,           r = DataSourceStatement();,           break;,         case CP_DATASOURCE:,           r = CP_DataSourceStatement();,           break;,         case CP_CONNECT:,           r = CP_ConnectStatement();,           break;,         case CP_GETCONNECTION:,           r = CP_GetConnectionStatement();,           break;,         case CP_DISCONNECT:,           r = CP_DisconnectStatement();,           break;,         default:,           jj_la1[0] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },       },     } else {,       ;,     },     jj_consume_token(0);,                 {if (true) return r;},     throw new Error("Missing return statement in function");,   }, , /**,  * ProtocolStatement is PROTOCOL 'JDBC protocol' where,  * the protocol is used to prefix any connect request that,  * cannot find a driver.  We will take a stab at loading,  * a driver as each protocol comes in -- we only know about,  * two.,  */,   final public ijResult ProtocolStatement() throws ParseException, SQLException {,         Token t;,         String n = null;,     jj_consume_token(PROTOCOL);,     t = jj_consume_token(STRING);,     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       n = identifier();,       break;,     default:,       jj_la1[1] = jj_gen;,       ;,     },                 installProtocol(n, stringValue(t.image));,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * DriverStatement is DRIVER 'class' where class is the,  * name of a class that is a JDBC driver. It is loaded,  * into the DriverManager with a Class.forName call.,  * <p>,  * You can load as many drivers as you want, the idea is,  * to load up the appropriate one(s) for the connect(s),  * that you will be issuing.,  */,   final public ijResult DriverStatement() throws ParseException, SQLException {,         Token t;,         String sVal = null;,     jj_consume_token(DRIVER);,     t = jj_consume_token(STRING);,             try {,                 // t.image is a class name;,                 // we load the "driver" in the prototypical,                 // manner, it will register itself with,                 // the DriverManager.,                         sVal = stringValue(t.image);,                         util.loadDriver(sVal);,             } catch (ClassNotFoundException e) {,                         {if (true) throw ijException.classNotFound(sVal);},             } catch (IllegalArgumentException e) {,                         {if (true) throw ijException.driverNotClassName(sVal);},             } catch (IllegalAccessException e) {,                         {if (true) throw ijException.classNotFound(sVal);},             } catch (InstantiationException e) {,                         {if (true) throw ijException.classNotFound(sVal);},             },                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult ConnectStatement() throws ParseException, SQLException {,         ijResult        result;,     jj_consume_token(CONNECT);,     switch (jj_nt.kind) {,     case TO:,       jj_consume_token(TO);,       result = dynamicConnection(true);,       break;,     case IDENTIFIER:,     case STRING:,       switch (jj_nt.kind) {,       case STRING:,         result = dynamicConnection(false);,         break;,       case IDENTIFIER:,         result = staticConnection();,         break;,       default:,         jj_la1[2] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[3] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return result;},     throw new Error("Missing return statement in function");,   }, , /**,  * ConnectStatement is CONNECT 'url' [ PROTOCOL proto ] , 	[ USER 	String PASSWORD String ] , 	[ATTRIBUTES attributeName = value [, attributeName = value]* ], 	[ AS ident ], where url is the,  * url for the database, i.e. jdbc:protocol:dbname etc.,  * Attributes are connection attributes to ,  * <p>,  * There can only be one connection at a time; if there,  * is already one, it is put on hold and this one takes its place.,  * <p>,  * if a driver can't be found, the current protocol will,  * be added at the front.,  * <p>,  * the as ident part is used for set connection.  If you don't,  * specify a name, we create one that is CONNECTION# for the #,  * of open connections that now exists. If the name duplicates,,  * an error results.,  */,   final public ijResult dynamicConnection(boolean simplifiedPath) throws ParseException, SQLException {,         Token t;,         Token userT = null;,         Token passwordT = null;,         String n = null, p = null, sVal;,     String userS =  util.getSystemProperty(USER_PROPERTY);,     String passwordS = util.getSystemProperty(PASSWORD_PROPERTY);,         Properties connInfo = new Properties();,     t = jj_consume_token(STRING);,     switch (jj_nt.kind) {,     case PROTOCOL:,       jj_consume_token(PROTOCOL);,       p = identifier();,       break;,     default:,       jj_la1[4] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case USER:,       jj_consume_token(USER);,       userT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[5] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case PASSWORD:,       jj_consume_token(PASSWORD);,       passwordT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[6] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case ATTRIBUTES:,       jj_consume_token(ATTRIBUTES);,       if (jj_2_2(1)) {,         attributeList(connInfo);,       } else {,         ;,       },       break;,     default:,       jj_la1[7] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       n = identifier();,       break;,     default:,       jj_la1[8] = jj_gen;,       ;,     },                 // t.image is a database URL,                 // we get the connection and salt it away,                 // for use with other statements.,                 //,                 // FUTURE: we could have the syntax be,                 // CONNECT <STRING> AS <IDENTIFIER>,                 // and have a SET CONNECTION string to,                 // re-activate a named connection.,                 // Or not, and wait for SQL-J to support that,                 // statement... although then we will have to,                 // figure out if we will allow that SQL-J through,                 // JDBC or not.,                 // get the value of the string,                 // n.b. at some point this will have to deal with ''s,                 if (userT != null),                 userS = stringValue(userT.image);, ,         if (passwordT != null),                 passwordS = stringValue(passwordT.image);, ,         //If ij.dataSource property is set,use DataSource to get the connection,                 String dsName = util.getSystemProperty("ij.dataSource");,                 if (dsName != null){,                 //Check that t.image does not start with jdbc:,                 //If it starts with jdbc:, do not use DataSource to get connection,                 sVal = stringValue(t.image);,                 if(!sVal.startsWith("jdbc:") ){,                         theConnection = util.getDataSourceConnection(dsName,userS,passwordS,sVal,false);,                         {if (true) return addSession( theConnection, n );},                 },         }, ,                 if (simplifiedPath),                         // url for the database W/O 'jdbc:protocol:', i.e. just a dbname,                         // For example,,                         //		CONNECT TO 'test',                         // is equivalent to,                         // 		CONNECT TO 'jdbc:derby:test',                         sVal = "jdbc:derby:" + stringValue(t.image);,                 else,                         sVal = stringValue(t.image);, ,                 // add named protocol if it was specified,                 if (p != null) {,                         String protocol = namedProtocols.get(p);,                         if (protocol == null) { {if (true) throw ijException.noSuchProtocol(p);} },                         sVal = protocol + sVal;,                 }, ,                 // add protocol if no driver matches url,                 boolean noDriver = false;,                         // if we have a full URL, make sure it's loaded first,                         try {,                                 if (sVal.startsWith("jdbc:")),                                         util.loadDriverIfKnown(sVal);,                         } catch (Exception e) {,                                 // want to continue with the attempt,                         },                         // By default perform extra checking on the URL attributes.,                         // This checking does not change the processing.,                         if (urlCheck == null || Boolean.valueOf(urlCheck).booleanValue()) {,                           URLCheck aCheck = new URLCheck(sVal);,                         },                 if (!sVal.startsWith("jdbc:") && (p == null) && (protocol != null)) {,                         sVal = protocol + sVal;,                 }, , ,                 // If no ATTRIBUTES on the connection get them from the,                 // defaults,                 connInfo = util.updateConnInfo(userS,passwordS, connInfo);, , ,                 theConnection = DriverManager.getConnection(sVal,connInfo);, ,                 {if (true) return addSession( theConnection, n );},     throw new Error("Missing return statement in function");,   }, , /**,  * Handles DESCRIBE table,  */,   final public ijResult DescTableStatement() throws ParseException, SQLException {,         String i = null;,         String i2 = null;,         Token  s = null;,         String schema;,         String table;,     jj_consume_token(DESCRIBE);,     switch (jj_nt.kind) {,     case ABSOLUTE:,     case AFTER:,     case ALIASES:,     case ALL:,     case AS:,     case ASYNC:,     case ATTRIBUTES:,     case AUTOCOMMIT:,     case BANG:,     case BEFORE:,     case CLOSE:,     case COMMIT:,     case CONNECT:,     case CONNECTION:,     case CONNECTIONS:,     case CURRENT:,     case CURSOR:,     case DESCRIBE:,     case DISCONNECT:,     case DRIVER:,     case ELAPSEDTIME:,     case END:,     case EXECUTE:,     case EXIT:,     case FAIL:,     case FIRST:,     case FOR:,     case FROM:,     case GET:,     case GETCURRENTROWNUMBER:,     case HOLD:,     case HELP:,     case IN:,     case INDEXES:,     case INSENSITIVE:,     case INTO:,     case LAST:,     case LOCALIZEDDISPLAY:,     case MAXIMUMDISPLAYWIDTH:,     case NAME:,     case NEXT:,     case NOHOLD:,     case NOHOLDFORCONNECTION:,     case OFF:,     case ON:,     case PASSWORD:,     case PERIOD:,     case PREPARE:,     case PREVIOUS:,     case PROCEDURE:,     case PROCEDURES:,     case PROPERTIES:,     case PROTOCOL:,     case QUIT:,     case READONLY:,     case RELATIVE:,     case REMOVE:,     case RESOURCE:,     case ROLLBACK:,     case RUN:,     case TO:,     case SCHEMAS:,     case SCROLL:,     case SENSITIVE:,     case SET:,     case SHOW:,     case SHUTDOWN:,     case STATEMENT:,     case SYNONYMS:,     case TABLES:,     case USER:,     case USING:,     case VIEWS:,     case WAIT:,     case WITH:,     case XA_1PHASE:,     case XA_2PHASE:,     case XA_DATASOURCE:,     case XA_CONNECT:,     case XA_COMMIT:,     case XA_DISCONNECT:,     case XA_END:,     case XA_ENDRSCAN:,     case XA_FAIL:,     case XA_FORGET:,     case XA_GETCONNECTION:,     case XA_JOIN:,     case XA_NOFLAGS:,     case XA_PREPARE:,     case XA_RECOVER:,     case XA_RESUME:,     case XA_ROLLBACK:,     case XA_START:,     case XA_STARTRSCAN:,     case XA_SUCCESS:,     case XA_SUSPEND:,     case DATASOURCE:,     case CP_DATASOURCE:,     case CP_CONNECT:,     case CP_GETCONNECTION:,     case CP_DISCONNECT:,     case WORK:,     case IDENTIFIER:,       i = caIdentifier();,       switch (jj_nt.kind) {,       case PERIOD:,         jj_consume_token(PERIOD);,         i2 = caIdentifier();,         break;,       default:,         jj_la1[9] = jj_gen;,         ;,       },                         if (i2 == null) {,                                 schema = null;,                                 table = i;,                         } else {,                                 schema = i;,                                 table = i2;,                         },       break;,     case STRING:,       s = jj_consume_token(STRING);,                         i2 = stringValue(s.image);, ,                         if (i2.length() == 0),                                 {if (true) throw ijException.noSuchTable("(missing)");}, ,                         int dotPosition = i2.indexOf('.');,                         if(dotPosition!=-1) {,                                 i = i2.substring(0,dotPosition);,                                 i2 = i2.substring(dotPosition+1);,                         },                         if ("*".equals(i2)),                                 i2 = null;, ,                         schema = i;,                         table = i2;,       break;,     default:,       jj_la1[10] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 if (schema == null) {,                         schema = util.getSelectedSchema(theConnection);,                 }, ,                 {if (true) return describeTable(schema, table);},     throw new Error("Missing return statement in function");,   }, , /**,   * Handles CONNECT yadda.yadda.foo( stringArg, ... stringArg ) AS connectionName,   */,   final public ijResult staticConnection() throws ParseException, SQLException {,         String                  name = null;,         Vector<String>                  idList;,         int                             idx = 0;,         int                             lastID = 0;,         StringBuffer    buffer;,         String                  className;,         String                  methodName;,         Class<?>                classC;,         Method                  method;,         int                             argCount;,         String[]                args;,         Class                   stringClass;,         Class[]                 argTypes;,         ijResult                result = null;,     idList = staticMethodName();,     args = staticMethodArgs();,     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       name = identifier();,       break;,     default:,       jj_la1[11] = jj_gen;,       ;,     },                 lastID = idList.size() - 1;,                 buffer = new StringBuffer();, ,                 for ( ; idx < lastID; idx++ ),                 {,                         if ( idx > 0 ) { buffer.append( "." ); },                         buffer.append( (String) idList.elementAt( idx ) );,                 },                 methodName = (String) idList.elementAt( idx );,                 className = buffer.toString();, ,                 try {,                         argCount = args.length;,                         argTypes = new Class[ argCount ];,                         stringClass = Class.forName( "java.lang.String" );,                         for ( idx = 0; idx < argCount; idx++ ) { argTypes[ idx ] = stringClass; }, ,                         classC = Class.forName( className );,                         method = classC.getMethod( methodName, argTypes );,                         theConnection = (Connection) method.invoke( null, args );,                         result = addSession( theConnection, name );, ,                 },                 catch (java.lang.reflect.InvocationTargetException ite) {,                         Throwable t = ite.getTargetException();,                         if (t instanceof SQLException),                                 {if (true) throw (SQLException) t;}, ,                         {if (true) throw new SQLException( t.toString() );},                 },                 catch (Exception e) { {if (true) throw new SQLException( e.toString() );} }, ,                 {if (true) return result;},     throw new Error("Missing return statement in function");,   }, , /**,  * SetConnectionStatement is SET CONNECTION ident,  * <p>,  * Moves to the named session, if it exists. If it doesn't,  * exist, remains on the current session and returns an error.,  */,   final public ijResult SetConnectionStatement() throws ParseException, SQLException {,         String t;,     jj_consume_token(SET);,     jj_consume_token(CONNECTION);,     t = identifier();,                 if (!currentConnEnv.haveSession(t)) {,                         {if (true) throw ijException.noSuchConnection(t);},                 },                 currentConnEnv.setCurrentSession(t);,                 theConnection = currentConnEnv.getConnection();,                 {if (true) return new ijConnectionResult(theConnection);},     throw new Error("Missing return statement in function");,   }, , /**,  * Handles showing current connections for the current environment, and,  * SHOW TABLES/VIEWS/... commands.,  */,   final public ijResult ShowStatement() throws ParseException, SQLException {,         String schema  = null;,         String tblname = null;,         String str     = null;,         String[] types = null;,         Token t = null;,         Token v = null;,     jj_consume_token(SHOW);,     switch (jj_nt.kind) {,     case CONNECTIONS:,       jj_consume_token(CONNECTIONS);,                 {if (true) return showConnectionsMethod(false);},       break;,     case ALIASES:,     case SYNONYMS:,     case TABLES:,     case VIEWS:,       switch (jj_nt.kind) {,       case TABLES:,         t = jj_consume_token(TABLES);,         break;,       case VIEWS:,         v = jj_consume_token(VIEWS);,         break;,       case SYNONYMS:,         jj_consume_token(SYNONYMS);,         break;,       case ALIASES:,         jj_consume_token(ALIASES);,         break;,       default:,         jj_la1[12] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch (jj_nt.kind) {,       case IN:,         jj_consume_token(IN);,         schema = caIdentifier();,         break;,       default:,         jj_la1[13] = jj_gen;,         ;,       },                 if(t!=null) {,                     types = new String[] { "TABLE", "SYSTEM TABLE" };,                 },                 else if(v!=null),                         types = new String[] { "VIEW" };,                 else,                         types = new String[] { "SYNONYM" };,                 {if (true) return showTables(schema, types);},       break;,     case INDEXES:,       jj_consume_token(INDEXES);,       switch (jj_nt.kind) {,       case FROM:,       case IN:,         switch (jj_nt.kind) {,         case IN:,           jj_consume_token(IN);,           schema = caIdentifier();,           break;,         case FROM:,           jj_consume_token(FROM);,           tblname = caIdentifier();,           switch (jj_nt.kind) {,           case PERIOD:,             jj_consume_token(PERIOD);,             str = caIdentifier();,             break;,           default:,             jj_la1[14] = jj_gen;,             ;,           },           break;,         default:,           jj_la1[15] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         break;,       default:,         jj_la1[16] = jj_gen;,         ;,       },                 if(str != null) {,                         // if absolute table reference given,                         schema = tblname;,                         tblname = str;,                 }, ,                 // If user specifies a table name, then assume schema is,                 // current schema. Note that getSelectedSchema may return,                 // null for some DBMSes.,                 if(schema == null && tblname != null),                         schema = util.getSelectedSchema(theConnection);,                 {if (true) return showIndexes(schema,tblname);},       break;,     case PROCEDURES:,       jj_consume_token(PROCEDURES);,       switch (jj_nt.kind) {,       case IN:,         jj_consume_token(IN);,         schema = caIdentifier();,         break;,       default:,         jj_la1[17] = jj_gen;,         ;,       },                 {if (true) return showProcedures(schema);},       break;,     case FUNCTIONS:,       jj_consume_token(FUNCTIONS);,       switch (jj_nt.kind) {,       case IN:,         jj_consume_token(IN);,         schema = caIdentifier();,         break;,       default:,         jj_la1[18] = jj_gen;,         ;,       },                 {if (true) return showFunctions(schema);},       break;,     case SCHEMAS:,       jj_consume_token(SCHEMAS);,                 {if (true) return showSchemas();},       break;,     case ROLES:,       jj_consume_token(ROLES);,             {if (true) return showRoles();},       break;,     case ENABLED_ROLES:,       jj_consume_token(ENABLED_ROLES);,             {if (true) return showEnabledRoles();},       break;,     case SETTABLE_ROLES:,       jj_consume_token(SETTABLE_ROLES);,             {if (true) return showSettableRoles();},       break;,     default:,       jj_la1[19] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /**,  * CommitStatement is simply COMMIT.,  * It commits the current transation.,  */,   final public ijResult CommitStatement() throws ParseException, SQLException {,     jj_consume_token(COMMIT);,     switch (jj_nt.kind) {,     case WORK:,       jj_consume_token(WORK);,       break;,     default:,       jj_la1[20] = jj_gen;,       ;,     },                 haveConnection();,                 theConnection.commit();,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * RollbackStatement is simply ROLLBACK.,  * It undoes the current transation.,  */,   final public ijResult RollbackStatement() throws ParseException, SQLException {,     jj_consume_token(ROLLBACK);,     switch (jj_nt.kind) {,     case WORK:,       jj_consume_token(WORK);,       break;,     default:,       jj_la1[21] = jj_gen;,       ;,     },                 haveConnection();,                 theConnection.rollback();,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * DisconnectStatement is simply DISCONNECT [ ALL | CURRENT | connectionName ],  * it ends the specified connection(s) and,  * releases its statement resource.,  * <p>,  * If ALL is specified, it disconnects all available sessions,  * in the current environment.,  */,   final public ijResult DisconnectStatement() throws ParseException, SQLException {,         Token a = null;,         String n = null;,     jj_consume_token(DISCONNECT);,     switch (jj_nt.kind) {,     case ALL:,     case CURRENT:,     case IDENTIFIER:,       switch (jj_nt.kind) {,       case CURRENT:,         jj_consume_token(CURRENT);,         break;,       case ALL:,         a = jj_consume_token(ALL);,         break;,       case IDENTIFIER:,         n = identifier();,         break;,       default:,         jj_la1[22] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[23] = jj_gen;,       ;,     },                 if ( a == null ) {,                         if (n == null) {,                         // only remove the current session,                             haveConnection();,                             // Also need to release the session object,                             currentConnEnv.removeCurrentSession();,                             theConnection = null;,                         },                         else {,                             if (! currentConnEnv.haveSession(n)),                                     {if (true) throw ijException.noSuchConnection(n);},                                 currentConnEnv.removeSession(n);,                             if (currentConnEnv.getSession() == null),                                     theConnection = null;,                         },                 } else {,                         currentConnEnv.removeAllSessions();,                         theConnection = null;,                 },                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult ExitStatement() throws ParseException, SQLException {,     switch (jj_nt.kind) {,     case EXIT:,       jj_consume_token(EXIT);,                 {if (true) return quit();},       break;,     case QUIT:,       jj_consume_token(QUIT);,                 {if (true) return quit();},       break;,     default:,       jj_la1[24] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ijResult PrepareStatement() throws ParseException, SQLException {,         Token t;,         QualifiedIdentifier qi;,         PreparedStatement ps;,         String sVal;,     jj_consume_token(PREPARE);,     switch (jj_nt.kind) {,     case PROCEDURE:,       jj_consume_token(PROCEDURE);,       jj_consume_token(AS);,       t = jj_consume_token(STRING);,                 // "procedure" is not allowed as a statement name. This is,                 // because "execute procedure" is a valid Foundation2000,                 // command.,                 {if (true) throw ijException.illegalStatementName( "procedure" );},       break;,     case IDENTIFIER:,       qi = qualifiedIdentifier();,       jj_consume_token(AS);,       t = jj_consume_token(STRING);,                 Session session = findSession(qi.getSessionName());, ,                 sVal = stringValue(t.image);,                 ps = session.getConnection().prepareStatement(sVal);,                 JDBCDisplayUtil.checkNotNull(ps,"prepared statement");,                 session.addPreparedStatement(qi.getLocalName(),ps);, ,                 // all we want callers to see are the warnings.,                 SQLWarning w = ps.getWarnings();,                 ps.clearWarnings();,                 {if (true) return new ijWarningResult(w);},       break;,     default:,       jj_la1[25] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ijResult GetCursorStatement() throws ParseException, SQLException {,         haveConnection();,         int scrollType = ResultSet.TYPE_FORWARD_ONLY;,         Token s;,         Token scrolling = null;,         Token withtoken = null;,         int holdType = theConnection.getHoldability();,         QualifiedIdentifier qi;,         Statement st = null;,         String sVal;,         ResultSet rs = null;,         SQLWarning warns;,     jj_consume_token(GET);,     switch (jj_nt.kind) {,     case SCROLL:,       scrolling = jj_consume_token(SCROLL);,       scrollType = scrollType();,       break;,     default:,       jj_la1[26] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case WITH:,       withtoken = jj_consume_token(WITH);,       holdType = holdType();,       break;,     default:,       jj_la1[27] = jj_gen;,       ;,     },     jj_consume_token(CURSOR);,     qi = qualifiedIdentifier();,     jj_consume_token(AS);,     s = jj_consume_token(STRING);,                 sVal = stringValue(s.image);,                 try {,                         Session sn = findSession(qi.getSessionName());, ,                         st = sn.getConnection().createStatement(,                                 scrollType, ResultSet.CONCUR_READ_ONLY, holdType);,                         JDBCDisplayUtil.checkNotNull(st,"cursor");,                         st.setCursorName(qi.getLocalName());,                         rs = st.executeQuery(sVal);,                         JDBCDisplayUtil.checkNotNull(rs,"cursor");,                         sn.addCursorStatement(qi.getLocalName(),st);,                         sn.addCursor(qi.getLocalName(),rs);,                 } catch (SQLException e) {,             try {,                             if (rs!=null) rs.close();,             } catch (SQLException se) {,             },             try {,                         if (st!=null) st.close();,             } catch (SQLException se) {,             },                         {if (true) throw e;},                 }, ,                 // all we want callers to see are the warnings.,                 SQLWarning w1 = theConnection.getWarnings();,                 SQLWarning w2 = st.getWarnings();,                 SQLWarning w3 = rs.getWarnings();,                 theConnection.clearWarnings();,                 st.clearWarnings();,                 rs.clearWarnings();,                 warns = appendWarnings(w1,w2);,                 {if (true) return new ijWarningResult(appendWarnings(warns,w3));},     throw new Error("Missing return statement in function");,   }, ,   final public int scrollType() throws ParseException, SQLException {,     switch (jj_nt.kind) {,     case INSENSITIVE:,       jj_consume_token(INSENSITIVE);,                 {if (true) return ResultSet.TYPE_SCROLL_INSENSITIVE;},       break;,     case SENSITIVE:,       jj_consume_token(SENSITIVE);,                 {if (true) return ResultSet.TYPE_SCROLL_SENSITIVE;},       break;,     default:,       jj_la1[28] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public int holdType() throws ParseException, SQLException {,     switch (jj_nt.kind) {,     case HOLD:,       jj_consume_token(HOLD);,                 {if (true) return ResultSet.HOLD_CURSORS_OVER_COMMIT;},       break;,     case NOHOLD:,       jj_consume_token(NOHOLD);,                 {if (true) return ResultSet.CLOSE_CURSORS_AT_COMMIT;},       break;,     default:,       jj_la1[29] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public ijResult AbsoluteStatement() throws ParseException, SQLException {,         int row;,         QualifiedIdentifier qi;,     jj_consume_token(ABSOLUTE);,     row = intLiteral();,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.absolute(rs, row);},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult RelativeStatement() throws ParseException, SQLException {,         int row;,         QualifiedIdentifier qi;,     jj_consume_token(RELATIVE);,     row = intLiteral();,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.relative(rs, row);},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult BeforeFirstStatement() throws ParseException, SQLException {,         QualifiedIdentifier qi;,     jj_consume_token(BEFORE);,     jj_consume_token(FIRST);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.beforeFirst(rs);},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult FirstStatement() throws ParseException, SQLException {,         QualifiedIdentifier qi;,     jj_consume_token(FIRST);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.first(rs);},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult NextStatement() throws ParseException, SQLException {,         QualifiedIdentifier qi;,     jj_consume_token(NEXT);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return new ijRowResult(rs, rs.next());},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult AfterLastStatement() throws ParseException, SQLException {,         QualifiedIdentifier qi;,     jj_consume_token(AFTER);,     jj_consume_token(LAST);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.afterLast(rs);},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult LastStatement() throws ParseException, SQLException {,         QualifiedIdentifier qi;,     jj_consume_token(LAST);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.last(rs);},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult PreviousStatement() throws ParseException, SQLException {,         QualifiedIdentifier qi;,     jj_consume_token(PREVIOUS);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.previous(rs);},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult GetCurrentRowNumber() throws ParseException, SQLException {,         QualifiedIdentifier qi;,     jj_consume_token(GETCURRENTROWNUMBER);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return new ijVectorResult(utilInstance.getCurrentRowNumber(rs), null);},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult CloseStatement() throws ParseException, SQLException {,         QualifiedIdentifier qi;,         Statement s;,     jj_consume_token(CLOSE);,     qi = qualifiedIdentifier();,                 Session sn = findSession(qi.getSessionName());, ,                 ResultSet rs = sn.getCursor(qi.getLocalName());,                 JDBCDisplayUtil.checkNotNull(rs,"cursor " + qi);,                 s = (Statement) sn.getCursorStatement(qi.getLocalName());,                 JDBCDisplayUtil.checkNotNull(s,"cursor" + qi);,                 rs.close();,                 s.close();,                 sn.removeCursor(qi.getLocalName());,                 sn.removeCursorStatement(qi.getLocalName());, ,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * Two forms of execute: immediate, with a string,  * and prepared, with the id of a prepared statement.,  * We expect the latter form will,  * eventually support a USING clause to supply,  * parameter values (that will be constants).,  * No parameters yet, however.,  * <p>,  * Syntax:,  *   EXECUTE statementSource [ USING statementSource] ;,  *,  *	 statementSource is an identifier of a previously prepared statement,  *	 or a string containing SQL-J text.,  */,   final public ijResult ExecuteStatement() throws ParseException, SQLException {,         QualifiedIdentifier qi = null;,         Token s = null;,         PreparedStatement ps;,         String sVal = null;, ,         QualifiedIdentifier qiUsing = null;,         Token sUsing = null;,         Token   usingObject = null;,     jj_consume_token(EXECUTE);,     switch (jj_nt.kind) {,     case STATEMENT:,       jj_consume_token(STATEMENT);,       s = jj_consume_token(STRING);,                 {if (true) return executeImmediate(stringValue(s.image));},       break;,     case PROCEDURE:,       jj_consume_token(PROCEDURE);,       s = jj_consume_token(STRING);,                 haveConnection();, ,                 Statement       aStatement = theConnection.createStatement();,                 String          text = "execute procedure " + s;, ,                 aStatement.execute( text );, ,                 {if (true) return new ijStatementResult( aStatement,true );},       break;,     case IDENTIFIER:,     case STRING:,       switch (jj_nt.kind) {,       case IDENTIFIER:,         qi = qualifiedIdentifier();,         break;,       case STRING:,         s = jj_consume_token(STRING);,         break;,       default:,         jj_la1[30] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch (jj_nt.kind) {,       case USING:,         jj_consume_token(USING);,         switch (jj_nt.kind) {,         case IDENTIFIER:,           qiUsing = qualifiedIdentifier();,           break;,         case STRING:,           sUsing = jj_consume_token(STRING);,           break;,         default:,           jj_la1[31] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         break;,       default:,         jj_la1[32] = jj_gen;,         ;,       },             if (qiUsing!=null || sUsing!=null) { // parameters in use,                         String sUsingVal = null;,                         PreparedStatement psUsing;,                         SQLWarning warns = null;, ,                         // haveConnection();, ,                         /*, 				Steps:, 				1. find or prepare the statement, 				2. execute the using statement, 				3. push the row of the using statement into the parameters, 				4. execute the statement against those parameters, 				5. clear the parameters, 			 */,                         /*, 				get the prepared statement, 			 */,                         boolean closeWhenDone = false; // will we close the ps when done?,                 if (qi!=null) {,                         ps = findPreparedStatement(qi);,                 },                 else { // (s!=null),                                 sVal = stringValue(s.image);,                                 ps = theConnection.prepareStatement(sVal);,                                 closeWhenDone = true;,                                 JDBCDisplayUtil.checkNotNull(ps,"prepared statement");,                                 warns = appendWarnings(warns, ps.getWarnings());,                                 ps.clearWarnings();,                 }, ,                         /*, 				execute the using statement, 			 */,                 if (qiUsing!=null) {,                         psUsing = findPreparedStatement(qiUsing);,                 },                 else { // (sUsing!=null),                                 sUsingVal = stringValue(sUsing.image);,                                 psUsing = theConnection.prepareStatement(sUsingVal);,                                 JDBCDisplayUtil.checkNotNull(psUsing,"prepared statement");,                                 warns = appendWarnings(warns, psUsing.getWarnings());,                                 psUsing.clearWarnings();,                 }, ,                         ResultSet rsUsing;,                         /*, 				If the USING statement is not a query, we, 				will not execute the statement; the number of, 				rows controls the execution., 			 */,                         if (psUsing.execute()) {,                                 rsUsing = psUsing.getResultSet();, ,                                 /*, 					push the row of the using statement into the parameters, 				 */, ,                                 ResultSetMetaData rsmdUsing = rsUsing.getMetaData();,                                 int numCols = rsmdUsing.getColumnCount();, ,                                 /*, 					Insufficient or too many parameters will, 					be caught at the JDBC level, and halt execution., 				 */,                                 boolean exec = false;, ,                                 /* Only do 1 next on rsUsing if autocommit is on,, 				 * since rsUsing will be closed when ps is closed., 				 */,                             boolean autoCommited = false;,                                 ijMultiResult result = new ijMultiResult(ps,rsUsing,closeWhenDone);, , //				while (! autoCommited && rsUsing.next()) {, //					// note the first time through, //					if (!exec) {, //						exec = true;, //, //						// send a warning if additional results may be lost, //						if (theConnection.getAutoCommit()) {, //							// FIXME: currOut.println("IJ WARNING: Autocommit may close using result set");, //							autoCommited = true;, //						}, //					}, //					for (int c=1; c<=numCols; c++) {, //						if (usingObject == null), //						{, //							ps.setObject(c,rsUsing.getObject(c),, //								rsmdUsing.getColumnType(c));, //						} , //						else, //						{, //							ps.setObject(c,rsUsing.getObject(c));, //						}, //					}, //, //					/*, //						4. execute the statement against those parameters, //					 */, //, //					ps.execute();, //					result.addStatementResult(ps);, //, //					/*, //						5. clear the parameters, //					 */, //					ps.clearParameters();, //, //				}, //				if (!exec) {, //					throw ijException.noUsingResults();, //				}, //, //				if (! theConnection.getAutoCommit()), //				{, //					rsUsing.close();, //				}, //				// REMIND: any way to look for more rsUsing rows if autoCommit?, //				// perhaps just document the behavior... , ,                                 {if (true) return result;},                         },                         else,                                 {if (true) throw ijException.noUsingResults();},                 },                 else { // no parameters in use,                 if (qi!=null) {,                                 haveConnection();,                                 ps = findPreparedStatement(qi);,                                 ps.execute();, ,                                 {if (true) return new ijStatementResult(ps,false);},                 },                 else { // (s!=null),                             {if (true) return executeImmediate(stringValue(s.image));},                 },             },       break;,     default:,       jj_la1[33] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /**,  * Async: like execute immediate, without using,,  * but runs the statement in a separate thread, against,  * the current connection.,  * <p>,  * Syntax:,  *   ASYNC asyncName statementSource ,  *,  *	 statementSource is a string containing SQL-J text.,  */,   final public ijResult AsyncStatement() throws ParseException, SQLException {,         Token s = null;,         QualifiedIdentifier qi;,     jj_consume_token(ASYNC);,     qi = qualifiedIdentifier();,     s = jj_consume_token(STRING);,             {if (true) return executeAsync(stringValue(s.image), qi);},     throw new Error("Missing return statement in function");,   }, , /**,  * Wait for: the second half of Async, waits for completion,  * if needed and then supplies the result.  Only execute is done,,  * not row fetching.,  * <p>,  * Syntax:,  *   WAIT FOR asyncName ,  *,  *	 asyncName is a name used in an ASYNC statement previously,  */,   final public ijResult WaitForStatement() throws ParseException, SQLException {,         Token s = null;,         QualifiedIdentifier qi;,     jj_consume_token(WAIT);,     jj_consume_token(FOR);,     qi = qualifiedIdentifier();,                 Session sn = findSession(qi.getSessionName());,                 AsyncStatement as = sn.getAsyncStatement(qi.getLocalName());,                 if (as == null) {if (true) throw ijException.noSuchAsyncStatement(qi.toString());},                 try {,                     as.join(); // we wait for it to finish.,                 } catch (InterruptedException ie) {,                         {if (true) throw ijException.waitInterrupted(ie);},                 },                 {if (true) return as.getResult();},     throw new Error("Missing return statement in function");,   }, , /**,  * RemoveStatement is REMOVE identifier. It identifies,  * a previously prepared statement.  We would prefer a DROP,  * syntax, but SQL-J is using that word and I want to point out,  * that special processing will be needed to give that parser,  * this parser's input for unrecognized text.,  */,   final public ijResult RemoveStatement() throws ParseException, SQLException {,         QualifiedIdentifier qi;,         PreparedStatement ps;,     jj_consume_token(REMOVE);,     qi = qualifiedIdentifier();,                 Session s = findSession(qi.getSessionName());,                 ps = (PreparedStatement) s.getPreparedStatement(qi.getLocalName());,                 JDBCDisplayUtil.checkNotNull(ps,"prepared statement "+qi);,                 ps.close();,                 s.removePreparedStatement(qi.getLocalName());, ,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, ,   final public ijResult RunStatement() throws ParseException, SQLException {,         Token i;,     Token r = null;,         PreparedStatement ps;,     jj_consume_token(RUN);,     switch (jj_nt.kind) {,     case RESOURCE:,       r = jj_consume_token(RESOURCE);,       break;,     default:,       jj_la1[34] = jj_gen;,       ;,     },     i = jj_consume_token(STRING);,                 if (utilInstance==null) {if (true) return null;},             if (r == null),                         utilInstance.newInput(stringValue(i.image));,                 else,             utilInstance.newResourceInput(stringValue(i.image));,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * Autocommit lets you control this aspect of the connection.,  * REMIND: should have a general way to set all connection attributes,,  * this is a shortcut for immediate needs.,  * <p>,  * Syntax:,  *   AUTOCOMMIT [ ON | OFF ] ;,  */,   final public ijResult AutocommitStatement() throws ParseException, SQLException {,         Token on=null;,     jj_consume_token(AUTOCOMMIT);,     switch (jj_nt.kind) {,     case ON:,       on = jj_consume_token(ON);,       break;,     case OFF:,       jj_consume_token(OFF);,       break;,     default:,       jj_la1[35] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 haveConnection();,                 // REMIND: want to warn if unchanged?,                 theConnection.setAutoCommit((on==null?false:true));, ,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * By default, holdability is set to true for Connection objects. This syntax NOHOLDFORCONNECTION lets you set it to close cursors at commit.,  * Syntax:,  *   NOHOLDFORCONNECTION ;,  */,   final public ijResult NoHoldForConnectionStatement() throws ParseException, SQLException {,         Token on=null;,     jj_consume_token(NOHOLDFORCONNECTION);,                 haveConnection();,                 theConnection.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * Localizeddisplay controls locale sensitive data representayion,  * <p>,  * Syntax:,  *   LOCALIZEDDISPLAY [ ON | OFF ] ;,  */,   final public ijResult LocalizedDisplay() throws ParseException {,         Token on=null;,     jj_consume_token(LOCALIZEDDISPLAY);,     switch (jj_nt.kind) {,     case ON:,       on = jj_consume_token(ON);,       break;,     case OFF:,       jj_consume_token(OFF);,       break;,     default:,       jj_la1[36] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 LocalizedResource.enableLocalization((on==null?false:true));,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * ReadOnly lets you control this aspect of the connection.,  * REMIND: should have a general way to set all connection attributes,,  * this is a shortcut for immediate needs.,  * <p>,  * Syntax:,  *   READONLY [ ON | OFF ] ;,  */,   final public ijResult ReadOnlyStatement() throws ParseException, SQLException {,         Token on=null;,     jj_consume_token(READONLY);,     switch (jj_nt.kind) {,     case ON:,       on = jj_consume_token(ON);,       break;,     case OFF:,       jj_consume_token(OFF);,       break;,     default:,       jj_la1[37] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 haveConnection();,                 theConnection.setReadOnly((on==null?false:true));,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * Elapsedtime on causes ij to dump out the elapsed time it takes,  * to run a user statement at the end of that statement.,  * <p>,  * Syntax:,  *   ELAPSEDTIME [ ON | OFF ] ;,  */,   final public ijResult ElapsedTimeStatement() throws ParseException {,         Token on=null;,     jj_consume_token(ELAPSEDTIME);,     switch (jj_nt.kind) {,     case ON:,       on = jj_consume_token(ON);,       break;,     case OFF:,       jj_consume_token(OFF);,       break;,     default:,       jj_la1[38] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 elapsedTime = (on != null);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * MaximumDisplayWidth EXACT_NUMERIC changes the maximum display width for,  * java.lang.String to the specified EXACT_NUMERIC.,  * This is only used by the console view.,  * <p>,  * Syntax:,  *   MAXIMUMDISPLAYWIDTH INTEGER ;,  */,   final public ijResult MaximumDisplayWidthStatement() throws ParseException {,         int       maxWidth;,     jj_consume_token(MAXIMUMDISPLAYWIDTH);,     maxWidth = intValue();,                 JDBCDisplayUtil.setMaxDisplayWidth(maxWidth);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, ,   final public int intValue() throws ParseException {,         Token t;,     t = jj_consume_token(INTEGER);,                 {if (true) return Integer.parseInt(t.image);},     throw new Error("Missing return statement in function");,   }, , /**,  * Bang lets you issue a system command using System.exec.,  * <p>,  * Syntax:,  *   ! 'command to issue' ;,  */,   final public ijResult Bang() throws ParseException {,         Token cmd=null;,     jj_consume_token(BANG);,     cmd = jj_consume_token(STRING);,           ijResult result = null;,           try {,                 Process p = Runtime.getRuntime().exec(stringValue(cmd.image));,                 LocalizedInput in = new LocalizedInput(p.getInputStream());,                 int c;,                 Vector<Object> v = new Vector<Object>();,                 StringBuffer output = new StringBuffer();,                 // echo output,                 while ((c = in.read()) != -1) {,                         output.append((char)c);,                 },                 in.close();,                 // echo errors,                 in = new LocalizedInput(p.getErrorStream());,                 // echo output,                 while ((c = in.read()) != -1) {,                         output.append((char)c);,                 },                 in.close();,                 v.addElement(output);,                 result = new ijVectorResult(v,null);,                 // wait for completion,                 try {,                         p.waitFor();,                 } catch (InterruptedException e) {,                         {if (true) throw ijException.bangException(e);},                 },           } catch (IOException ioe) {,                 {if (true) throw ijException.bangException(ioe);},           },           {if (true) return result;},     throw new Error("Missing return statement in function");,   }, ,   final public void StringList(Vector<Token> v) throws ParseException {,     StringItem(v);,     label_1:,     while (true) {,       switch (jj_nt.kind) {,       case STRING:,         ;,         break;,       default:,         jj_la1[39] = jj_gen;,         break label_1;,       },       StringItem(v);,     },   }, ,   final public void StringItem(Vector<Token> v) throws ParseException {,         Token s;,     s = jj_consume_token(STRING);,                 v.addElement(s);,   }, , /**, 	Haven't included: ASYNC, !, EXPECT, 	Don't include: XA_*,  **/,   final public ijResult HelpStatement() throws ParseException {,     jj_consume_token(HELP);,                 Vector<Object> v = new Vector<Object>();, ,                 StringTokenizer st = new StringTokenizer(LocalizedResource.getMessage("IJ_HelpText"), "\n");,                 while (st.hasMoreTokens()) {,                     v.addElement(st.nextToken());,                 }, ,                 {if (true) return new ijVectorResult(v,null);},     throw new Error("Missing return statement in function");,   }, ,   final public String identifier() throws ParseException {,         Token t;,     t = jj_consume_token(IDENTIFIER);,                 // identifiers are case insensitive, so we map them up.,                 // ij doesn't recognize any use of delimited identifiers in its syntax.,                 {if (true) return (t.image.toUpperCase(Locale.ENGLISH));},     throw new Error("Missing return statement in function");,   }, , /**, 	A qualified identifier is localName [ <AT> sessionName ], */,   final public QualifiedIdentifier qualifiedIdentifier() throws ParseException {,         String  sn      = null;,         String  ln      = null;,     ln = identifier();,     switch (jj_nt.kind) {,     case AT:,       jj_consume_token(AT);,       sn = identifier();,       break;,     default:,       jj_la1[40] = jj_gen;,       ;,     },                 if (sn == null) {,                         haveConnection();,                         sn = currentConnEnv.getSession().getName();,                 }, ,                 {if (true) return new QualifiedIdentifier(sn, ln);},     throw new Error("Missing return statement in function");,   }, , /**,     A case/connection respectful identifier., ,     Like an ordinary identifier(), but require a connection in order,     to extract the case policy from database meta data., */,   final public String caIdentifier() throws ParseException, SQLException {,     Token t = null;,     String i = null;,     switch (jj_nt.kind) {,     case ABSOLUTE:,     case AFTER:,     case ALIASES:,     case ALL:,     case AS:,     case ASYNC:,     case ATTRIBUTES:,     case AUTOCOMMIT:,     case BANG:,     case BEFORE:,     case CLOSE:,     case COMMIT:,     case CONNECT:,     case CONNECTION:,     case CONNECTIONS:,     case CURRENT:,     case CURSOR:,     case DESCRIBE:,     case DISCONNECT:,     case DRIVER:,     case ELAPSEDTIME:,     case END:,     case EXECUTE:,     case EXIT:,     case FAIL:,     case FIRST:,     case FOR:,     case FROM:,     case GET:,     case GETCURRENTROWNUMBER:,     case HOLD:,     case HELP:,     case IN:,     case INDEXES:,     case INSENSITIVE:,     case INTO:,     case LAST:,     case LOCALIZEDDISPLAY:,     case MAXIMUMDISPLAYWIDTH:,     case NAME:,     case NEXT:,     case NOHOLD:,     case NOHOLDFORCONNECTION:,     case OFF:,     case ON:,     case PASSWORD:,     case PERIOD:,     case PREPARE:,     case PREVIOUS:,     case PROCEDURE:,     case PROCEDURES:,     case PROPERTIES:,     case PROTOCOL:,     case QUIT:,     case READONLY:,     case RELATIVE:,     case REMOVE:,     case RESOURCE:,     case ROLLBACK:,     case RUN:,     case TO:,     case SCHEMAS:,     case SCROLL:,     case SENSITIVE:,     case SET:,     case SHOW:,     case SHUTDOWN:,     case STATEMENT:,     case SYNONYMS:,     case TABLES:,     case USER:,     case USING:,     case VIEWS:,     case WAIT:,     case WITH:,     case XA_1PHASE:,     case XA_2PHASE:,     case XA_DATASOURCE:,     case XA_CONNECT:,     case XA_COMMIT:,     case XA_DISCONNECT:,     case XA_END:,     case XA_ENDRSCAN:,     case XA_FAIL:,     case XA_FORGET:,     case XA_GETCONNECTION:,     case XA_JOIN:,     case XA_NOFLAGS:,     case XA_PREPARE:,     case XA_RECOVER:,     case XA_RESUME:,     case XA_ROLLBACK:,     case XA_START:,     case XA_STARTRSCAN:,     case XA_SUCCESS:,     case XA_SUSPEND:,     case DATASOURCE:,     case CP_DATASOURCE:,     case CP_CONNECT:,     case CP_GETCONNECTION:,     case CP_DISCONNECT:,     case WORK:,       i = keyword();,       break;,     case IDENTIFIER:,       t = jj_consume_token(IDENTIFIER);,       break;,     default:,       jj_la1[41] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },         haveConnection();,         DatabaseMetaData dbmd = theConnection.getMetaData();,         String identifier = i;, ,         if(t!=null),             identifier = t.image;,         if (dbmd.storesLowerCaseIdentifiers()),             identifier = identifier.toLowerCase(Locale.ENGLISH);,         else if (dbmd.storesUpperCaseIdentifiers()),             identifier = identifier.toUpperCase(Locale.ENGLISH);, ,         {if (true) return identifier;},     throw new Error("Missing return statement in function");,   }, ,   final public int intLiteral() throws ParseException, SQLException {,         String  sign = "";,         Token   tok;,     switch (jj_nt.kind) {,     case MINUS_SIGN:,     case PLUS_SIGN:,       sign = sign();,       break;,     default:,       jj_la1[42] = jj_gen;,       ;,     },     tok = jj_consume_token(INTEGER);,                 /*, 		** The various java parse utilities can't handle leading +,, 		** so only concatenate leading -., 		*/, ,                 String num = tok.image;, ,                 if (sign.equals("-")),                 {,                         num = sign.concat(num);,                 }, ,                 {if (true) return Integer.parseInt(num);},     throw new Error("Missing return statement in function");,   }, ,   final public Vector<String> staticMethodName() throws ParseException, SQLException {,         Vector<String>  list = new Vector<String>();,     methodLeg(list);,     label_2:,     while (true) {,       jj_consume_token(PERIOD);,       methodLeg(list);,       switch (jj_nt.kind) {,       case PERIOD:,         ;,         break;,       default:,         jj_la1[43] = jj_gen;,         break label_2;,       },     },                 {if (true) return list;},     throw new Error("Missing return statement in function");,   }, ,   final public void methodLeg(Vector<String> list) throws ParseException, SQLException {,         Token   id;,     id = jj_consume_token(IDENTIFIER);,                 list.addElement( id.image );,   }, ,   final public String[] staticMethodArgs() throws ParseException, SQLException {,         Vector<String>          list = new Vector<String>();,         String[]        args;,     jj_consume_token(LEFT_PAREN);,     switch (jj_nt.kind) {,     case STRING:,       oneStaticArg(list);,       label_3:,       while (true) {,         switch (jj_nt.kind) {,         case COMMA:,           ;,           break;,         default:,           jj_la1[44] = jj_gen;,           break label_3;,         },         jj_consume_token(COMMA);,         oneStaticArg(list);,       },       break;,     default:,       jj_la1[45] = jj_gen;,       ;,     },     jj_consume_token(RIGHT_PAREN);,                 args = new String[ list.size() ];,                 list.copyInto( args );, ,                 {if (true) return args;},     throw new Error("Missing return statement in function");,   }, ,   final public void oneStaticArg(Vector<String> list) throws ParseException, SQLException {,         Token   tok;,     tok = jj_consume_token(STRING);,                 list.addElement( stringValue( tok.image ) );,   }, , /*,  * <A NAME="sign">sign</A>,  */,   final public String sign() throws ParseException, SQLException {,         Token   s;,     switch (jj_nt.kind) {,     case PLUS_SIGN:,       s = jj_consume_token(PLUS_SIGN);,                 {if (true) return s.image;},       break;,     case MINUS_SIGN:,       s = jj_consume_token(MINUS_SIGN);,                 {if (true) return s.image;},       break;,     default:,       jj_la1[46] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /**, 	Undocumented commands to help XA testing., , 	This is the grammer for the XA commands, , 	&lt;XA_DATASOURCE&gt; 'dbname' ( &lt;CREATE&gt; | shutdown ) , 		 - get a XADataSource whose database name is dbname and make that, 		XADataSource the current XADataSource, , 	&lt;XA_CONNECT&gt; 	[ &lt;USER&gt; 'user' ], 			[ &lt;PASSWORD&gt; 'password' ], 			[ &lt;AS&gt; xaconnid ] , 		- make an XAConnection using the current XADataSource and make, 		that XAConnection the current XAConnection.  If xaconnid is , 		given, then associate xaconnid with the XAConnection.  , 		(xaconnid not implemeneted), , , 	&lt;XA_COMMIT&gt;  ( &lt;XA_1PHASE&gt; | &lt;XA_2PHASE&gt; ) xid, 		- commit a global transaction xid, , , 	&lt;XA_DISCONNECT&gt; [ xaconnid = identifier() ] , 		- disconnect an XAConnection.  If xaconnid is given, then, 		disconnect the XAConnection with the given xaconnid. , 		(xaconnid not implemeneted), , , 	&lt;XA_END&gt; ( &lt;XA_SUSPEND&gt; | &lt;XA_SUCCESS&gt; | &lt;XA_FAIL&gt; ) xid, 		- dissociate a transaction from the current XAConnection or end, 		an already suspened one , , 	&lt;XA_FORGET&gt; xid		- forget about a global transaction, , 	&lt;XA_GETCONNECTION&gt;  [ &lt;AS&gt; connid ] , 		- get a Connection object from the current XAConnection., 		If connid is given, then associate connid with the connection., 		(connid not implemented), , 	&lt;XA_PREPARE&gt; xid	- prepare a global transaction, , 	&lt;XA_RECOVER&gt; ( &lt;XA_NOFLAGS&gt; | &lt;XA_STARTRSCAN&gt; | &lt;XA_ENDRSCAN&gt; ), 	 	- return the list of in-doubt transactions, , 	&lt;XA_ROLLBACK&gt; xid	- rollback a global transaction, , 	&lt;XA_START&gt; ( &lt;XA_NOFLAGS&gt; | &lt;XA_JOIN&gt; | &lt;XA_RESUME&gt; ) xid, 		- associate a transaction or start a new global, 		transaction with the current XAConnection., , 	The following is for testing other JDBC2.0 ext interface, DataSource, 	and ConnectionPoolDataSource.  Strictly speaking, these are not xa, but, 	their functionality will be lumped into xaHelper because these are here, 	only for testing purposes., , 	&lt;DATASOURCE&gt; 'dbname'	[ &lt;PROTOCOL&gt; 'protocol' ], 				[ &lt;USER&gt; 'user' ], 				[ &lt;PASSWORD&gt; 'password' ], 				[ &lt;AS&gt; n=identifier() ], 		- get a data source whose database name is dbname and make that, 		DataSource the current DataSource.  If &lt;PROTOCOL&gt; is specified,, 		the DataSource may be remote.   Get a connection from that, 		dataSource and use the user/password if specified., , 	&lt;CP_DATASOURCE&gt; 'dbname' [ &lt;PROTOCOL&gt; 'protocol' ], 		- get a connection pool data source whose database name is, 		dbname and make that DataSource the current CPDataSource.  , 		If &lt;PROTOCOL&gt; is specified, the DataSource may be, 		remote., , 	&lt;CP_CONNECT&gt;	[ &lt;USER&gt; 'user' ], 			[ &lt;PASSWORD&gt; 'password' ], 			[ &lt;AS&gt; cpconnid ], 		- make a PooledConnection using the current CPDataSource and, 		make that PooledConnection the current PooledConnection., 		If cpconnid is given, then associate cpconnid with the, 		PooledConnection. (cpconnid not implemented)., , 	&lt;CP_GETCONNECTION&gt; [ &lt;AS&gt; connid ], 		- get a Connection object from the current PooledConnection., 		If connid is given, the associate connid with the connection., 		(connid not implemented), , 	&lt;CP_DISCONNECT&gt; [  cpconnid = identifier() ] , 		- disconnect a PooledConnection.  If cpconnid is given, then, 		disconnect the PooledConnection with the given cpconnid. , 		(cpconnid not implemented), , */, , , /**,  * XA_DataSourceStatement is XA_DataSource 'dbname' ( create | shutdown ),  * We new'ed an instance of XADataSource as the current DataSource and set its,  * database name to dbname.,  */,   final public ijResult XA_DataSourceStatement() throws ParseException, SQLException {,         Token dbname = null;,         Token shut = null;,         String create = null;,     jj_consume_token(XA_DATASOURCE);,     dbname = jj_consume_token(STRING);,     switch (jj_nt.kind) {,     case SHUTDOWN:,     case IDENTIFIER:,       switch (jj_nt.kind) {,       case SHUTDOWN:,         shut = jj_consume_token(SHUTDOWN);,         break;,       case IDENTIFIER:,         create = identifier();,         break;,       default:,         jj_la1[47] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[48] = jj_gen;,       ;,     },                 xahelper.XADataSourceStatement(this, dbname, shut, create);, ,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_ConnectStatement is XA_CONNECT (&lt;AS&gt; connid),  * make a XAConnection using the currentXADataSource and make that XAConnection,  * the current XAConnection.  If connid is given, then associate connid with,  * the XAConnection.  This connid is not th xid.,  */,   final public ijResult XA_ConnectStatement() throws ParseException, SQLException {,         Token userT = null;,         Token passwordT = null;,         String n = null;,     jj_consume_token(XA_CONNECT);,     switch (jj_nt.kind) {,     case USER:,       jj_consume_token(USER);,       userT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[49] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case PASSWORD:,       jj_consume_token(PASSWORD);,       passwordT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[50] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       n = identifier();,       break;,     default:,       jj_la1[51] = jj_gen;,       ;,     },                 xahelper.XAConnectStatement(this, userT, passwordT, n);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_DisconnectStatement is XA_DISCONNECT [xaconnid = identifier()],  * disconnect the current XAConnection ,  * If xaconnid is given, then disconnect XAConnection with xaconnid (xaconnid,  *	not implemented).,  * ,  */,   final public ijResult XA_DisconnectStatement() throws ParseException, SQLException {,         String n = null;,     jj_consume_token(XA_DISCONNECT);,     switch (jj_nt.kind) {,     case IDENTIFIER:,       n = identifier();,       break;,     default:,       jj_la1[52] = jj_gen;,       ;,     },                 xahelper.XADisconnectStatement(this, n);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_CommitStatement is XA_COMMIT [ XA_1PHASE | XA_2PHASE ] xid,  * commits a global transaction xid,  */,   final public ijResult XA_CommitStatement() throws ParseException, SQLException {,         Token onePhase=null;,         Token twoPhase=null;,         int xid = 0;,     jj_consume_token(XA_COMMIT);,     switch (jj_nt.kind) {,     case XA_1PHASE:,       onePhase = jj_consume_token(XA_1PHASE);,       break;,     case XA_2PHASE:,       twoPhase = jj_consume_token(XA_2PHASE);,       break;,     default:,       jj_la1[53] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     xid = intValue();,                 xahelper.CommitStatement(this, onePhase, twoPhase, xid);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_EndStatement is XA_END [ XA_SUSPEND | XA_SUCCESS | XA_FAIL] xid,  * dissociates a transaction from the current XAConnection or end an already,  * suspended one,  */,   final public ijResult XA_EndStatement() throws ParseException, SQLException {,         int flag = 0;,         int xid = 0;,     jj_consume_token(XA_END);,     flag = xatmflag();,     xid = intValue();,                 xahelper.EndStatement(this, flag, xid);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_ForgetStatement is XA_FORGET xid,  * forgets about a heuristically completed transaction,  */,   final public ijResult XA_ForgetStatement() throws ParseException, SQLException {,         int xid = 0;,     jj_consume_token(XA_FORGET);,     xid = intValue();,                 xahelper.ForgetStatement(this, xid);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_GetConnectionStatement is XA_GETCONNECTION,  * it gets a Connection from the currentXAConnection and uses that as the,  * current connection ,  */,   final public ijResult XA_GetConnectionStatement() throws ParseException, SQLException {,         String n = "XA";,     jj_consume_token(XA_GETCONNECTION);,     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       n = identifier();,       break;,     default:,       jj_la1[54] = jj_gen;,       ;,     },                 theConnection = xahelper.XAGetConnectionStatement(this, n);,                 currentConnEnv.addSession(theConnection, n);, ,                 {if (true) return new ijConnectionResult(theConnection);},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_PrepareStatement is XA_PREPARE xid,  * prepares a global transaction,  */,   final public ijResult XA_PrepareStatement() throws ParseException, SQLException {,         int xid = 0;,     jj_consume_token(XA_PREPARE);,     xid = intValue();,                 xahelper.PrepareStatement(this, xid);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_RecoverStatement is XA_RECOVER flag,  * displays the list of prepared transactions,  */,   final public ijResult XA_RecoverStatement() throws ParseException, SQLException {,         int flag = 0;,     jj_consume_token(XA_RECOVER);,     flag = xatmflag();,                 {if (true) return xahelper.RecoverStatement(this, flag);},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_RollbackStatement is XA_Rollback xid,  * rolls back a global transaction,  */,   final public ijResult XA_RollbackStatement() throws ParseException, SQLException {,         int xid = 0;,     jj_consume_token(XA_ROLLBACK);,     xid = intValue();,                 xahelper.RollbackStatement(this, xid);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * XA_StartStatement is XA_START [ XA_NOFLAGS | XA_JOIN | XA_RESUME ] xid,  * start or associates a transaction with the current XAConnection,  */,   final public ijResult XA_StartStatement() throws ParseException, SQLException {,         int flag = 0;,         int xid = 0;,     jj_consume_token(XA_START);,     flag = xatmflag();,     xid = intValue();,                 xahelper.StartStatement(this, flag, xid);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, ,   final public int xatmflag() throws ParseException, SQLException {,     switch (jj_nt.kind) {,     case XA_ENDRSCAN:,       jj_consume_token(XA_ENDRSCAN);,                 {if (true) return XAResource.TMENDRSCAN;},       break;,     case XA_FAIL:,       jj_consume_token(XA_FAIL);,                 {if (true) return XAResource.TMFAIL;},       break;,     case XA_JOIN:,       jj_consume_token(XA_JOIN);,                 {if (true) return XAResource.TMJOIN;},       break;,     case XA_NOFLAGS:,       jj_consume_token(XA_NOFLAGS);,                 {if (true) return XAResource.TMNOFLAGS;},       break;,     case XA_RESUME:,       jj_consume_token(XA_RESUME);,                 {if (true) return XAResource.TMRESUME;},       break;,     case XA_STARTRSCAN:,       jj_consume_token(XA_STARTRSCAN);,                 {if (true) return XAResource.TMSTARTRSCAN;},       break;,     case XA_SUCCESS:,       jj_consume_token(XA_SUCCESS);,                 {if (true) return XAResource.TMSUCCESS;},       break;,     case XA_SUSPEND:,       jj_consume_token(XA_SUSPEND);,                 {if (true) return XAResource.TMSUSPEND;},       break;,     default:,       jj_la1[55] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /**,  * DataSourceStatement is ,  *	DataSource 'dbname' ,  *		[ &lt;PROTCOL&gt; 'protocol'],  *		[ &lt;USER&gt; 'user' ],  *		[ &lt;PASSWORD&gt; 'password' ],  *		[ &lt;AS&gt; n=identifier() ],  *,  * We new'ed an instance of DataSource as the current DataSource and set its,  * database name to dbname.  Also get a connection,  */,   final public ijResult DataSourceStatement() throws ParseException, SQLException {,         Token dbname = null;,         Token protocol = null;,         Token userT = null;,         Token passwordT = null;,         String n = null;,     jj_consume_token(DATASOURCE);,     dbname = jj_consume_token(STRING);,     switch (jj_nt.kind) {,     case PROTOCOL:,       jj_consume_token(PROTOCOL);,       protocol = jj_consume_token(STRING);,       break;,     default:,       jj_la1[56] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case USER:,       jj_consume_token(USER);,       userT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[57] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case PASSWORD:,       jj_consume_token(PASSWORD);,       passwordT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[58] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       n = identifier();,       break;,     default:,       jj_la1[59] = jj_gen;,       ;,     },                 theConnection = xahelper.DataSourceStatement(this, dbname, protocol,,                         userT, passwordT, n);, ,                 {if (true) return addSession( theConnection, n );},     throw new Error("Missing return statement in function");,   }, , /**,  * CP_DataSourceStatement is,  *	CP_DataSource 'dbname' [ &lt;PROTOCOL&gt; 'protocol' ],  *		- get a connection pool data source whose database name is,  *		dbname and make that DataSource the current CPDataSource.  ,  *		If &lt;PROTOCOL&gt; is specified, the DataSource may be,  *		remote.,  */,   final public ijResult CP_DataSourceStatement() throws ParseException, SQLException {,         Token dbname = null;,         Token protocol = null;,     jj_consume_token(CP_DATASOURCE);,     dbname = jj_consume_token(STRING);,     switch (jj_nt.kind) {,     case PROTOCOL:,       jj_consume_token(PROTOCOL);,       protocol = jj_consume_token(STRING);,       break;,     default:,       jj_la1[60] = jj_gen;,       ;,     },                 xahelper.CPDataSourceStatement(this, dbname, protocol);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * CP_ConnectStatement is,  *	&lt;CP_CONNECT&gt;	[ &lt;USER&gt; 'user' ],  *			[ &lt;PASSWORD&gt; 'password' ],  *			[ &lt;AS&gt; cpconnid ],  * make a PooledConnection using the current CPDataSource and,  * make that PooledConnection the current PooledConnection.,  * If cpconnid is given, then associate cpconnid with the,  * PooledConnection. (cpconnid not implemented).,  */,   final public ijResult CP_ConnectStatement() throws ParseException, SQLException {,         Token userT = null;,         Token passwordT = null;,         String n = null;,     jj_consume_token(CP_CONNECT);,     switch (jj_nt.kind) {,     case USER:,       jj_consume_token(USER);,       userT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[61] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case PASSWORD:,       jj_consume_token(PASSWORD);,       passwordT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[62] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       n = identifier();,       break;,     default:,       jj_la1[63] = jj_gen;,       ;,     },                 xahelper.CPConnectStatement(this, userT, passwordT, n);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, , /**,  * CP_GetConnectionStatement is,  *	&lt;CP_GETCONNECTION&gt; [ &lt;AS&gt; connid ],  * get a Connection object from the current PooledConnection.,  * If connid is given, the associate connid with the connection.,  * (connid not implemented),  */,   final public ijResult CP_GetConnectionStatement() throws ParseException, SQLException {,         String n = "Pooled";,     jj_consume_token(CP_GETCONNECTION);,     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       n = identifier();,       break;,     default:,       jj_la1[64] = jj_gen;,       ;,     },                 theConnection = xahelper.CPGetConnectionStatement(this, n);,                 currentConnEnv.addSession(theConnection, n);,                 {if (true) return new ijConnectionResult(theConnection);},     throw new Error("Missing return statement in function");,   }, , /**,  * CP_DisconnectStatement is,  *	&lt;CP_DISCONNECT&gt; [ cpconnid = identifier() ],  * disconnect a PooledConnection.  If cpconnid is given, then,  * disconnect the PooledConnection with the given cpconnid. ,  * (cpconnid not implemented),  */,   final public ijResult CP_DisconnectStatement() throws ParseException, SQLException {,         String n = null;,     jj_consume_token(CP_DISCONNECT);,     switch (jj_nt.kind) {,     case IDENTIFIER:,       n = identifier();,       break;,     default:,       jj_la1[65] = jj_gen;,       ;,     },                 xahelper.CPDisconnectStatement(this, n);,                 {if (true) return null;},     throw new Error("Missing return statement in function");,   }, ,   final public void attributeList(Properties properties) throws ParseException {,         Token tok;,         String value;,     if (getToken(2).kind == EQUALS_OPERATOR) {, ,     } else {,       jj_consume_token(-1);,       throw new ParseException();,     },     property(properties);,     label_4:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[66] = jj_gen;,         break label_4;,       },       jj_consume_token(COMMA);,       property(properties);,     }, ,   }, ,   final public void property(Properties properties) throws ParseException {,         String key;,         String value;,     key = caseSensitiveIdentifierOrKeyword();,     jj_consume_token(EQUALS_OPERATOR);,     value = caseSensitiveIdentifierOrKeyword();,                 properties.put(key, value);,   }, ,   final public String caseSensitiveIdentifierOrKeyword() throws ParseException {,         String value=null;,         Token tok;,     switch (jj_nt.kind) {,     case ABSOLUTE:,     case AFTER:,     case ALIASES:,     case ALL:,     case AS:,     case ASYNC:,     case ATTRIBUTES:,     case AUTOCOMMIT:,     case BANG:,     case BEFORE:,     case CLOSE:,     case COMMIT:,     case CONNECT:,     case CONNECTION:,     case CONNECTIONS:,     case CURRENT:,     case CURSOR:,     case DESCRIBE:,     case DISCONNECT:,     case DRIVER:,     case ELAPSEDTIME:,     case END:,     case EXECUTE:,     case EXIT:,     case FAIL:,     case FIRST:,     case FOR:,     case FROM:,     case GET:,     case GETCURRENTROWNUMBER:,     case HOLD:,     case HELP:,     case IN:,     case INDEXES:,     case INSENSITIVE:,     case INTO:,     case LAST:,     case LOCALIZEDDISPLAY:,     case MAXIMUMDISPLAYWIDTH:,     case NAME:,     case NEXT:,     case NOHOLD:,     case NOHOLDFORCONNECTION:,     case OFF:,     case ON:,     case PASSWORD:,     case PERIOD:,     case PREPARE:,     case PREVIOUS:,     case PROCEDURE:,     case PROCEDURES:,     case PROPERTIES:,     case PROTOCOL:,     case QUIT:,     case READONLY:,     case RELATIVE:,     case REMOVE:,     case RESOURCE:,     case ROLLBACK:,     case RUN:,     case TO:,     case SCHEMAS:,     case SCROLL:,     case SENSITIVE:,     case SET:,     case SHOW:,     case SHUTDOWN:,     case STATEMENT:,     case SYNONYMS:,     case TABLES:,     case USER:,     case USING:,     case VIEWS:,     case WAIT:,     case WITH:,     case XA_1PHASE:,     case XA_2PHASE:,     case XA_DATASOURCE:,     case XA_CONNECT:,     case XA_COMMIT:,     case XA_DISCONNECT:,     case XA_END:,     case XA_ENDRSCAN:,     case XA_FAIL:,     case XA_FORGET:,     case XA_GETCONNECTION:,     case XA_JOIN:,     case XA_NOFLAGS:,     case XA_PREPARE:,     case XA_RECOVER:,     case XA_RESUME:,     case XA_ROLLBACK:,     case XA_START:,     case XA_STARTRSCAN:,     case XA_SUCCESS:,     case XA_SUSPEND:,     case DATASOURCE:,     case CP_DATASOURCE:,     case CP_CONNECT:,     case CP_GETCONNECTION:,     case CP_DISCONNECT:,     case WORK:,       value = keyword();,                 {if (true) return value;},       break;,     case IDENTIFIER:,       tok = jj_consume_token(IDENTIFIER);,                 {if (true) return tok.image;},       break;,     default:,       jj_la1[67] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, ,   final public String caseSensitiveIdentifier() throws ParseException {,         Token tok;,     tok = jj_consume_token(IDENTIFIER);,                 {if (true) return tok.image;},     throw new Error("Missing return statement in function");,   }, ,   final public String keyword() throws ParseException {,         Token tok;,         String value= null;,     switch (jj_nt.kind) {,     case ABSOLUTE:,       tok = jj_consume_token(ABSOLUTE);,       break;,     case AFTER:,       tok = jj_consume_token(AFTER);,       break;,     case ALIASES:,       tok = jj_consume_token(ALIASES);,       break;,     case ALL:,       tok = jj_consume_token(ALL);,       break;,     case AS:,       tok = jj_consume_token(AS);,       break;,     case ASYNC:,       tok = jj_consume_token(ASYNC);,       break;,     case ATTRIBUTES:,       tok = jj_consume_token(ATTRIBUTES);,       break;,     case AUTOCOMMIT:,       tok = jj_consume_token(AUTOCOMMIT);,       break;,     case BANG:,       tok = jj_consume_token(BANG);,       break;,     case BEFORE:,       tok = jj_consume_token(BEFORE);,       break;,     case CLOSE:,       tok = jj_consume_token(CLOSE);,       break;,     case COMMIT:,       tok = jj_consume_token(COMMIT);,       break;,     case CONNECT:,       tok = jj_consume_token(CONNECT);,       break;,     case CONNECTION:,       tok = jj_consume_token(CONNECTION);,       break;,     case CONNECTIONS:,       tok = jj_consume_token(CONNECTIONS);,       break;,     case CURRENT:,       tok = jj_consume_token(CURRENT);,       break;,     case CURSOR:,       tok = jj_consume_token(CURSOR);,       break;,     case DESCRIBE:,       tok = jj_consume_token(DESCRIBE);,       break;,     case DISCONNECT:,       tok = jj_consume_token(DISCONNECT);,       break;,     case DRIVER:,       tok = jj_consume_token(DRIVER);,       break;,     case ELAPSEDTIME:,       tok = jj_consume_token(ELAPSEDTIME);,       break;,     case END:,       tok = jj_consume_token(END);,       break;,     case EXECUTE:,       tok = jj_consume_token(EXECUTE);,       break;,     case EXIT:,       tok = jj_consume_token(EXIT);,       break;,     case FAIL:,       tok = jj_consume_token(FAIL);,       break;,     case FIRST:,       tok = jj_consume_token(FIRST);,       break;,     case FOR:,       tok = jj_consume_token(FOR);,       break;,     case FROM:,       tok = jj_consume_token(FROM);,       break;,     case GET:,       tok = jj_consume_token(GET);,       break;,     case GETCURRENTROWNUMBER:,       tok = jj_consume_token(GETCURRENTROWNUMBER);,       break;,     case HOLD:,       tok = jj_consume_token(HOLD);,       break;,     case HELP:,       tok = jj_consume_token(HELP);,       break;,     case IN:,       tok = jj_consume_token(IN);,       break;,     case INDEXES:,       tok = jj_consume_token(INDEXES);,       break;,     case INSENSITIVE:,       tok = jj_consume_token(INSENSITIVE);,       break;,     case INTO:,       tok = jj_consume_token(INTO);,       break;,     case LAST:,       tok = jj_consume_token(LAST);,       break;,     case LOCALIZEDDISPLAY:,       tok = jj_consume_token(LOCALIZEDDISPLAY);,       break;,     case MAXIMUMDISPLAYWIDTH:,       tok = jj_consume_token(MAXIMUMDISPLAYWIDTH);,       break;,     case NAME:,       tok = jj_consume_token(NAME);,       break;,     case NEXT:,       tok = jj_consume_token(NEXT);,       break;,     case NOHOLD:,       tok = jj_consume_token(NOHOLD);,       break;,     case NOHOLDFORCONNECTION:,       tok = jj_consume_token(NOHOLDFORCONNECTION);,       break;,     case OFF:,       tok = jj_consume_token(OFF);,       break;,     case ON:,       tok = jj_consume_token(ON);,       break;,     case PASSWORD:,       tok = jj_consume_token(PASSWORD);,       break;,     case PERIOD:,       tok = jj_consume_token(PERIOD);,       break;,     case PREPARE:,       tok = jj_consume_token(PREPARE);,       break;,     case PREVIOUS:,       tok = jj_consume_token(PREVIOUS);,       break;,     case PROCEDURE:,       tok = jj_consume_token(PROCEDURE);,       break;,     case PROCEDURES:,       tok = jj_consume_token(PROCEDURES);,       break;,     case PROPERTIES:,       tok = jj_consume_token(PROPERTIES);,       break;,     case PROTOCOL:,       tok = jj_consume_token(PROTOCOL);,       break;,     case QUIT:,       tok = jj_consume_token(QUIT);,       break;,     case READONLY:,       tok = jj_consume_token(READONLY);,       break;,     case RELATIVE:,       tok = jj_consume_token(RELATIVE);,       break;,     case REMOVE:,       tok = jj_consume_token(REMOVE);,       break;,     case RESOURCE:,       tok = jj_consume_token(RESOURCE);,       break;,     case ROLLBACK:,       tok = jj_consume_token(ROLLBACK);,       break;,     case RUN:,       tok = jj_consume_token(RUN);,       break;,     case TO:,       tok = jj_consume_token(TO);,       break;,     case SCHEMAS:,       tok = jj_consume_token(SCHEMAS);,       break;,     case SCROLL:,       tok = jj_consume_token(SCROLL);,       break;,     case SENSITIVE:,       tok = jj_consume_token(SENSITIVE);,       break;,     case SET:,       tok = jj_consume_token(SET);,       break;,     case SHOW:,       tok = jj_consume_token(SHOW);,       break;,     case SHUTDOWN:,       tok = jj_consume_token(SHUTDOWN);,       break;,     case STATEMENT:,       tok = jj_consume_token(STATEMENT);,       break;,     case SYNONYMS:,       tok = jj_consume_token(SYNONYMS);,       break;,     case TABLES:,       tok = jj_consume_token(TABLES);,       break;,     case USER:,       tok = jj_consume_token(USER);,       break;,     case USING:,       tok = jj_consume_token(USING);,       break;,     case VIEWS:,       tok = jj_consume_token(VIEWS);,       break;,     case WAIT:,       tok = jj_consume_token(WAIT);,       break;,     case WITH:,       tok = jj_consume_token(WITH);,       break;,     case XA_1PHASE:,       tok = jj_consume_token(XA_1PHASE);,       break;,     case XA_2PHASE:,       tok = jj_consume_token(XA_2PHASE);,       break;,     case XA_DATASOURCE:,       tok = jj_consume_token(XA_DATASOURCE);,       break;,     case XA_CONNECT:,       tok = jj_consume_token(XA_CONNECT);,       break;,     case XA_COMMIT:,       tok = jj_consume_token(XA_COMMIT);,       break;,     case XA_DISCONNECT:,       tok = jj_consume_token(XA_DISCONNECT);,       break;,     case XA_END:,       tok = jj_consume_token(XA_END);,       break;,     case XA_ENDRSCAN:,       tok = jj_consume_token(XA_ENDRSCAN);,       break;,     case XA_FAIL:,       tok = jj_consume_token(XA_FAIL);,       break;,     case XA_FORGET:,       tok = jj_consume_token(XA_FORGET);,       break;,     case XA_GETCONNECTION:,       tok = jj_consume_token(XA_GETCONNECTION);,       break;,     case XA_JOIN:,       tok = jj_consume_token(XA_JOIN);,       break;,     case XA_NOFLAGS:,       tok = jj_consume_token(XA_NOFLAGS);,       break;,     case XA_PREPARE:,       tok = jj_consume_token(XA_PREPARE);,       break;,     case XA_RECOVER:,       tok = jj_consume_token(XA_RECOVER);,       break;,     case XA_RESUME:,       tok = jj_consume_token(XA_RESUME);,       break;,     case XA_ROLLBACK:,       tok = jj_consume_token(XA_ROLLBACK);,       break;,     case XA_START:,       tok = jj_consume_token(XA_START);,       break;,     case XA_STARTRSCAN:,       tok = jj_consume_token(XA_STARTRSCAN);,       break;,     case XA_SUCCESS:,       tok = jj_consume_token(XA_SUCCESS);,       break;,     case XA_SUSPEND:,       tok = jj_consume_token(XA_SUSPEND);,       break;,     case DATASOURCE:,       tok = jj_consume_token(DATASOURCE);,       break;,     case CP_DATASOURCE:,       tok = jj_consume_token(CP_DATASOURCE);,       break;,     case CP_CONNECT:,       tok = jj_consume_token(CP_CONNECT);,       break;,     case CP_GETCONNECTION:,       tok = jj_consume_token(CP_GETCONNECTION);,       break;,     case CP_DISCONNECT:,       tok = jj_consume_token(CP_DISCONNECT);,       break;,     case WORK:,       tok = jj_consume_token(WORK);,       break;,     default:,       jj_la1[68] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return tok.image;},     throw new Error("Missing return statement in function");,   }, ,   final private boolean jj_2_1(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_1(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(0, xla); },   }, ,   final private boolean jj_2_2(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_2(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(1, xla); },   }, ,   final private boolean jj_3R_85() {,     if (jj_scan_token(READONLY)) return true;,     return false;,   }, ,   final private boolean jj_3R_57() {,     if (jj_scan_token(ROLLBACK)) return true;,     return false;,   }, ,   final private boolean jj_3R_96() {,     if (jj_scan_token(XA_GETCONNECTION)) return true;,     return false;,   }, ,   final private boolean jj_3R_66() {,     if (jj_scan_token(CONNECT)) return true;,     return false;,   }, ,   final private boolean jj_3R_104() {,     if (jj_scan_token(CP_DATASOURCE)) return true;,     return false;,   }, ,   final private boolean jj_3R_78() {,     if (jj_scan_token(LOCALIZEDDISPLAY)) return true;,     return false;,   }, ,   final private boolean jj_3R_65() {,     if (jj_scan_token(COMMIT)) return true;,     return false;,   }, ,   final private boolean jj_3R_98() {,     if (jj_scan_token(XA_FORGET)) return true;,     return false;,   }, ,   final private boolean jj_3R_64() {,     if (jj_scan_token(CLOSE)) return true;,     return false;,   }, ,   final private boolean jj_3R_69() {,     if (jj_scan_token(DRIVER)) return true;,     return false;,   }, ,   final private boolean jj_3R_81() {,     if (jj_scan_token(NOHOLDFORCONNECTION)) return true;,     return false;,   }, ,   final private boolean jj_3R_76() {,     if (jj_scan_token(HELP)) return true;,     return false;,   }, ,   final private boolean jj_3R_103() {,     if (jj_scan_token(DATASOURCE)) return true;,     return false;,   }, ,   final private boolean jj_3R_97() {,     if (jj_scan_token(XA_END)) return true;,     return false;,   }, ,   final private boolean jj_3R_75() {,     if (jj_scan_token(GETCURRENTROWNUMBER)) return true;,     return false;,   }, ,   final private boolean jj_3R_67() {,     if (jj_scan_token(DESCRIBE)) return true;,     return false;,   }, ,   final private boolean jj_3R_115() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_scan_token(14)) {,     jj_scanpos = xsp;,     if (jj_scan_token(15)) {,     jj_scanpos = xsp;,     if (jj_scan_token(16)) {,     jj_scanpos = xsp;,     if (jj_scan_token(17)) {,     jj_scanpos = xsp;,     if (jj_scan_token(18)) {,     jj_scanpos = xsp;,     if (jj_scan_token(19)) {,     jj_scanpos = xsp;,     if (jj_scan_token(20)) {,     jj_scanpos = xsp;,     if (jj_scan_token(21)) {,     jj_scanpos = xsp;,     if (jj_scan_token(22)) {,     jj_scanpos = xsp;,     if (jj_scan_token(23)) {,     jj_scanpos = xsp;,     if (jj_scan_token(24)) {,     jj_scanpos = xsp;,     if (jj_scan_token(25)) {,     jj_scanpos = xsp;,     if (jj_scan_token(26)) {,     jj_scanpos = xsp;,     if (jj_scan_token(27)) {,     jj_scanpos = xsp;,     if (jj_scan_token(28)) {,     jj_scanpos = xsp;,     if (jj_scan_token(29)) {,     jj_scanpos = xsp;,     if (jj_scan_token(30)) {,     jj_scanpos = xsp;,     if (jj_scan_token(31)) {,     jj_scanpos = xsp;,     if (jj_scan_token(32)) {,     jj_scanpos = xsp;,     if (jj_scan_token(33)) {,     jj_scanpos = xsp;,     if (jj_scan_token(34)) {,     jj_scanpos = xsp;,     if (jj_scan_token(36)) {,     jj_scanpos = xsp;,     if (jj_scan_token(38)) {,     jj_scanpos = xsp;,     if (jj_scan_token(39)) {,     jj_scanpos = xsp;,     if (jj_scan_token(40)) {,     jj_scanpos = xsp;,     if (jj_scan_token(41)) {,     jj_scanpos = xsp;,     if (jj_scan_token(42)) {,     jj_scanpos = xsp;,     if (jj_scan_token(43)) {,     jj_scanpos = xsp;,     if (jj_scan_token(45)) {,     jj_scanpos = xsp;,     if (jj_scan_token(46)) {,     jj_scanpos = xsp;,     if (jj_scan_token(47)) {,     jj_scanpos = xsp;,     if (jj_scan_token(48)) {,     jj_scanpos = xsp;,     if (jj_scan_token(49)) {,     jj_scanpos = xsp;,     if (jj_scan_token(50)) {,     jj_scanpos = xsp;,     if (jj_scan_token(51)) {,     jj_scanpos = xsp;,     if (jj_scan_token(52)) {,     jj_scanpos = xsp;,     if (jj_scan_token(53)) {,     jj_scanpos = xsp;,     if (jj_scan_token(54)) {,     jj_scanpos = xsp;,     if (jj_scan_token(55)) {,     jj_scanpos = xsp;,     if (jj_scan_token(56)) {,     jj_scanpos = xsp;,     if (jj_scan_token(57)) {,     jj_scanpos = xsp;,     if (jj_scan_token(58)) {,     jj_scanpos = xsp;,     if (jj_scan_token(59)) {,     jj_scanpos = xsp;,     if (jj_scan_token(60)) {,     jj_scanpos = xsp;,     if (jj_scan_token(61)) {,     jj_scanpos = xsp;,     if (jj_scan_token(62)) {,     jj_scanpos = xsp;,     if (jj_scan_token(63)) {,     jj_scanpos = xsp;,     if (jj_scan_token(64)) {,     jj_scanpos = xsp;,     if (jj_scan_token(65)) {,     jj_scanpos = xsp;,     if (jj_scan_token(66)) {,     jj_scanpos = xsp;,     if (jj_scan_token(67)) {,     jj_scanpos = xsp;,     if (jj_scan_token(68)) {,     jj_scanpos = xsp;,     if (jj_scan_token(69)) {,     jj_scanpos = xsp;,     if (jj_scan_token(70)) {,     jj_scanpos = xsp;,     if (jj_scan_token(71)) {,     jj_scanpos = xsp;,     if (jj_scan_token(72)) {,     jj_scanpos = xsp;,     if (jj_scan_token(73)) {,     jj_scanpos = xsp;,     if (jj_scan_token(74)) {,     jj_scanpos = xsp;,     if (jj_scan_token(76)) {,     jj_scanpos = xsp;,     if (jj_scan_token(77)) {,     jj_scanpos = xsp;,     if (jj_scan_token(78)) {,     jj_scanpos = xsp;,     if (jj_scan_token(80)) {,     jj_scanpos = xsp;,     if (jj_scan_token(81)) {,     jj_scanpos = xsp;,     if (jj_scan_token(82)) {,     jj_scanpos = xsp;,     if (jj_scan_token(83)) {,     jj_scanpos = xsp;,     if (jj_scan_token(85)) {,     jj_scanpos = xsp;,     if (jj_scan_token(86)) {,     jj_scanpos = xsp;,     if (jj_scan_token(87)) {,     jj_scanpos = xsp;,     if (jj_scan_token(88)) {,     jj_scanpos = xsp;,     if (jj_scan_token(89)) {,     jj_scanpos = xsp;,     if (jj_scan_token(90)) {,     jj_scanpos = xsp;,     if (jj_scan_token(91)) {,     jj_scanpos = xsp;,     if (jj_scan_token(92)) {,     jj_scanpos = xsp;,     if (jj_scan_token(93)) {,     jj_scanpos = xsp;,     if (jj_scan_token(94)) {,     jj_scanpos = xsp;,     if (jj_scan_token(95)) {,     jj_scanpos = xsp;,     if (jj_scan_token(96)) {,     jj_scanpos = xsp;,     if (jj_scan_token(97)) {,     jj_scanpos = xsp;,     if (jj_scan_token(98)) {,     jj_scanpos = xsp;,     if (jj_scan_token(99)) {,     jj_scanpos = xsp;,     if (jj_scan_token(100)) {,     jj_scanpos = xsp;,     if (jj_scan_token(101)) {,     jj_scanpos = xsp;,     if (jj_scan_token(102)) {,     jj_scanpos = xsp;,     if (jj_scan_token(103)) {,     jj_scanpos = xsp;,     if (jj_scan_token(104)) {,     jj_scanpos = xsp;,     if (jj_scan_token(105)) {,     jj_scanpos = xsp;,     if (jj_scan_token(106)) {,     jj_scanpos = xsp;,     if (jj_scan_token(107)) {,     jj_scanpos = xsp;,     if (jj_scan_token(108)) {,     jj_scanpos = xsp;,     if (jj_scan_token(109)) {,     jj_scanpos = xsp;,     if (jj_scan_token(110)) {,     jj_scanpos = xsp;,     if (jj_scan_token(111)) {,     jj_scanpos = xsp;,     if (jj_scan_token(112)) {,     jj_scanpos = xsp;,     if (jj_scan_token(113)) {,     jj_scanpos = xsp;,     if (jj_scan_token(114)) {,     jj_scanpos = xsp;,     if (jj_scan_token(115)) {,     jj_scanpos = xsp;,     if (jj_scan_token(116)) {,     jj_scanpos = xsp;,     if (jj_scan_token(117)) {,     jj_scanpos = xsp;,     if (jj_scan_token(118)) {,     jj_scanpos = xsp;,     if (jj_scan_token(119)) {,     jj_scanpos = xsp;,     if (jj_scan_token(120)) {,     jj_scanpos = xsp;,     if (jj_scan_token(121)) return true;,     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_83() {,     if (jj_scan_token(PREVIOUS)) return true;,     return false;,   }, ,   final private boolean jj_3R_84() {,     if (jj_scan_token(PROTOCOL)) return true;,     return false;,   }, ,   final private boolean jj_3R_60() {,     if (jj_scan_token(AUTOCOMMIT)) return true;,     return false;,   }, ,   final private boolean jj_3R_94() {,     if (jj_scan_token(XA_COMMIT)) return true;,     return false;,   }, ,   final private boolean jj_3R_74() {,     if (jj_scan_token(GET)) return true;,     return false;,   }, ,   final private boolean jj_3R_77() {,     if (jj_scan_token(LAST)) return true;,     return false;,   }, ,   final private boolean jj_3R_114() {,     if (jj_scan_token(IDENTIFIER)) return true;,     return false;,   }, ,   final private boolean jj_3R_55() {,     if (jj_3R_107()) return true;,     return false;,   }, ,   final private boolean jj_3R_54() {,     if (jj_3R_106()) return true;,     return false;,   }, ,   final private boolean jj_3R_95() {,     if (jj_scan_token(XA_DISCONNECT)) return true;,     return false;,   }, ,   final private boolean jj_3R_53() {,     if (jj_3R_105()) return true;,     return false;,   }, ,   final private boolean jj_3R_113() {,     if (jj_3R_115()) return true;,     return false;,   }, ,   final private boolean jj_3R_112() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_113()) {,     jj_scanpos = xsp;,     if (jj_3R_114()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_52() {,     if (jj_3R_104()) return true;,     return false;,   }, ,   final private boolean jj_3R_51() {,     if (jj_3R_103()) return true;,     return false;,   }, ,   final private boolean jj_3R_50() {,     if (jj_3R_102()) return true;,     return false;,   }, ,   final private boolean jj_3R_49() {,     if (jj_3R_101()) return true;,     return false;,   }, ,   final private boolean jj_3R_88() {,     if (jj_scan_token(RUN)) return true;,     return false;,   }, ,   final private boolean jj_3R_48() {,     if (jj_3R_100()) return true;,     return false;,   }, ,   final private boolean jj_3R_47() {,     if (jj_3R_99()) return true;,     return false;,   }, ,   final private boolean jj_3R_59() {,     if (jj_scan_token(AFTER)) return true;,     return false;,   }, ,   final private boolean jj_3R_46() {,     if (jj_3R_98()) return true;,     return false;,   }, ,   final private boolean jj_3R_45() {,     if (jj_3R_97()) return true;,     return false;,   }, ,   final private boolean jj_3R_90() {,     if (jj_scan_token(SHOW)) return true;,     return false;,   }, ,   final private boolean jj_3R_44() {,     if (jj_3R_96()) return true;,     return false;,   }, ,   final private boolean jj_3R_43() {,     if (jj_3R_95()) return true;,     return false;,   }, ,   final private boolean jj_3R_42() {,     if (jj_3R_94()) return true;,     return false;,   }, ,   final private boolean jj_3R_41() {,     if (jj_3R_93()) return true;,     return false;,   }, ,   final private boolean jj_3R_40() {,     if (jj_3R_92()) return true;,     return false;,   }, ,   final private boolean jj_3R_39() {,     if (jj_3R_91()) return true;,     return false;,   }, ,   final private boolean jj_3R_38() {,     if (jj_3R_90()) return true;,     return false;,   }, ,   final private boolean jj_3R_109() {,     if (jj_3R_112()) return true;,     return false;,   }, ,   final private boolean jj_3R_37() {,     if (jj_3R_89()) return true;,     return false;,   }, ,   final private boolean jj_3R_36() {,     if (jj_3R_88()) return true;,     return false;,   }, ,   final private boolean jj_3R_35() {,     if (jj_3R_87()) return true;,     return false;,   }, ,   final private boolean jj_3R_62() {,     if (jj_scan_token(BANG)) return true;,     return false;,   }, ,   final private boolean jj_3R_34() {,     if (jj_3R_86()) return true;,     return false;,   }, ,   final private boolean jj_3R_33() {,     if (jj_3R_85()) return true;,     return false;,   }, ,   final private boolean jj_3R_108() {,     return false;,   }, ,   final private boolean jj_3R_32() {,     if (jj_3R_84()) return true;,     return false;,   }, ,   final private boolean jj_3R_80() {,     if (jj_scan_token(NEXT)) return true;,     return false;,   }, ,   final private boolean jj_3R_31() {,     if (jj_3R_83()) return true;,     return false;,   }, ,   final private boolean jj_3R_30() {,     if (jj_3R_82()) return true;,     return false;,   }, ,   final private boolean jj_3_2() {,     if (jj_3R_56()) return true;,     return false;,   }, ,   final private boolean jj_3R_93() {,     if (jj_scan_token(XA_CONNECT)) return true;,     return false;,   }, ,   final private boolean jj_3R_29() {,     if (jj_3R_81()) return true;,     return false;,   }, ,   final private boolean jj_3R_28() {,     if (jj_3R_80()) return true;,     return false;,   }, ,   final private boolean jj_3R_27() {,     if (jj_3R_79()) return true;,     return false;,   }, ,   final private boolean jj_3R_87() {,     if (jj_scan_token(REMOVE)) return true;,     return false;,   }, ,   final private boolean jj_3R_82() {,     if (jj_scan_token(PREPARE)) return true;,     return false;,   }, ,   final private boolean jj_3R_26() {,     if (jj_3R_78()) return true;,     return false;,   }, ,   final private boolean jj_3R_25() {,     if (jj_3R_77()) return true;,     return false;,   }, ,   final private boolean jj_3R_24() {,     if (jj_3R_76()) return true;,     return false;,   }, ,   final private boolean jj_3R_23() {,     if (jj_3R_75()) return true;,     return false;,   }, ,   final private boolean jj_3R_22() {,     if (jj_3R_74()) return true;,     return false;,   }, ,   final private boolean jj_3R_56() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(2).kind == EQUALS_OPERATOR;,     lookingAhead = false;,     if (!jj_semLA || jj_3R_108()) return true;,     if (jj_3R_109()) return true;,     return false;,   }, ,   final private boolean jj_3R_102() {,     if (jj_scan_token(XA_START)) return true;,     return false;,   }, ,   final private boolean jj_3R_21() {,     if (jj_3R_73()) return true;,     return false;,   }, ,   final private boolean jj_3R_20() {,     if (jj_3R_72()) return true;,     return false;,   }, ,   final private boolean jj_3R_19() {,     if (jj_3R_71()) return true;,     return false;,   }, ,   final private boolean jj_3R_18() {,     if (jj_3R_70()) return true;,     return false;,   }, ,   final private boolean jj_3R_17() {,     if (jj_3R_69()) return true;,     return false;,   }, ,   final private boolean jj_3R_89() {,     if (jj_scan_token(SET)) return true;,     return false;,   }, ,   final private boolean jj_3R_16() {,     if (jj_3R_68()) return true;,     return false;,   }, ,   final private boolean jj_3R_15() {,     if (jj_3R_67()) return true;,     return false;,   }, ,   final private boolean jj_3R_72() {,     if (jj_scan_token(FIRST)) return true;,     return false;,   }, ,   final private boolean jj_3R_14() {,     if (jj_3R_66()) return true;,     return false;,   }, ,   final private boolean jj_3R_13() {,     if (jj_3R_65()) return true;,     return false;,   }, ,   final private boolean jj_3R_12() {,     if (jj_3R_64()) return true;,     return false;,   }, ,   final private boolean jj_3R_11() {,     if (jj_3R_63()) return true;,     return false;,   }, ,   final private boolean jj_3R_10() {,     if (jj_3R_62()) return true;,     return false;,   }, ,   final private boolean jj_3R_111() {,     if (jj_scan_token(QUIT)) return true;,     return false;,   }, ,   final private boolean jj_3R_9() {,     if (jj_3R_61()) return true;,     return false;,   }, ,   final private boolean jj_3R_8() {,     if (jj_3R_60()) return true;,     return false;,   }, ,   final private boolean jj_3R_7() {,     if (jj_3R_59()) return true;,     return false;,   }, ,   final private boolean jj_3R_6() {,     if (jj_3R_58()) return true;,     return false;,   }, ,   final private boolean jj_3R_110() {,     if (jj_scan_token(EXIT)) return true;,     return false;,   }, ,   final private boolean jj_3R_107() {,     if (jj_scan_token(CP_DISCONNECT)) return true;,     return false;,   }, ,   final private boolean jj_3R_73() {,     Token xsp;,     xsp = jj_scanpos;,     if (jj_3R_110()) {,     jj_scanpos = xsp;,     if (jj_3R_111()) return true;,     },     return false;,   }, ,   final private boolean jj_3R_79() {,     if (jj_scan_token(MAXIMUMDISPLAYWIDTH)) return true;,     return false;,   }, ,   final private boolean jj_3R_92() {,     if (jj_scan_token(XA_DATASOURCE)) return true;,     return false;,   }, ,   final private boolean jj_3R_101() {,     if (jj_scan_token(XA_ROLLBACK)) return true;,     return false;,   }, ,   final private boolean jj_3R_5() {,     if (jj_3R_57()) return true;,     return false;,   }, ,   final private boolean jj_3_1() {,     Token xsp;,     xsp = jj_scanpos;,     lookingAhead = true;,     jj_semLA = getToken(1).kind == ROLLBACK &&,                         (!(getToken(3).kind == TO || getToken(3).kind == SAVEPOINT));,     lookingAhead = false;,     if (!jj_semLA || jj_3R_5()) {,     jj_scanpos = xsp;,     if (jj_3R_6()) {,     jj_scanpos = xsp;,     if (jj_3R_7()) {,     jj_scanpos = xsp;,     if (jj_3R_8()) {,     jj_scanpos = xsp;,     if (jj_3R_9()) {,     jj_scanpos = xsp;,     if (jj_3R_10()) {,     jj_scanpos = xsp;,     if (jj_3R_11()) {,     jj_scanpos = xsp;,     if (jj_3R_12()) {,     jj_scanpos = xsp;,     if (jj_3R_13()) {,     jj_scanpos = xsp;,     if (jj_3R_14()) {,     jj_scanpos = xsp;,     if (jj_3R_15()) {,     jj_scanpos = xsp;,     if (jj_3R_16()) {,     jj_scanpos = xsp;,     if (jj_3R_17()) {,     jj_scanpos = xsp;,     if (jj_3R_18()) {,     jj_scanpos = xsp;,     if (jj_3R_19()) {,     jj_scanpos = xsp;,     if (jj_3R_20()) {,     jj_scanpos = xsp;,     if (jj_3R_21()) {,     jj_scanpos = xsp;,     if (jj_3R_22()) {,     jj_scanpos = xsp;,     if (jj_3R_23()) {,     jj_scanpos = xsp;,     if (jj_3R_24()) {,     jj_scanpos = xsp;,     if (jj_3R_25()) {,     jj_scanpos = xsp;,     if (jj_3R_26()) {,     jj_scanpos = xsp;,     if (jj_3R_27()) {,     jj_scanpos = xsp;,     if (jj_3R_28()) {,     jj_scanpos = xsp;,     if (jj_3R_29()) {,     jj_scanpos = xsp;,     if (jj_3R_30()) {,     jj_scanpos = xsp;,     if (jj_3R_31()) {,     jj_scanpos = xsp;,     if (jj_3R_32()) {,     jj_scanpos = xsp;,     if (jj_3R_33()) {,     jj_scanpos = xsp;,     if (jj_3R_34()) {,     jj_scanpos = xsp;,     if (jj_3R_35()) {,     jj_scanpos = xsp;,     if (jj_3R_36()) {,     jj_scanpos = xsp;,     if (jj_3R_37()) {,     jj_scanpos = xsp;,     if (jj_3R_38()) {,     jj_scanpos = xsp;,     if (jj_3R_39()) {,     jj_scanpos = xsp;,     if (jj_3R_40()) {,     jj_scanpos = xsp;,     if (jj_3R_41()) {,     jj_scanpos = xsp;,     if (jj_3R_42()) {,     jj_scanpos = xsp;,     if (jj_3R_43()) {,     jj_scanpos = xsp;,     if (jj_3R_44()) {,     jj_scanpos = xsp;,     if (jj_3R_45()) {,     jj_scanpos = xsp;,     if (jj_3R_46()) {,     jj_scanpos = xsp;,     if (jj_3R_47()) {,     jj_scanpos = xsp;,     if (jj_3R_48()) {,     jj_scanpos = xsp;,     if (jj_3R_49()) {,     jj_scanpos = xsp;,     if (jj_3R_50()) {,     jj_scanpos = xsp;,     if (jj_3R_51()) {,     jj_scanpos = xsp;,     if (jj_3R_52()) {,     jj_scanpos = xsp;,     if (jj_3R_53()) {,     jj_scanpos = xsp;,     if (jj_3R_54()) {,     jj_scanpos = xsp;,     if (jj_3R_55()) return true;,     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     },     return false;,   }, ,   final private boolean jj_3R_63() {,     if (jj_scan_token(BEFORE)) return true;,     return false;,   }, ,   final private boolean jj_3R_91() {,     if (jj_scan_token(WAIT)) return true;,     return false;,   }, ,   final private boolean jj_3R_106() {,     if (jj_scan_token(CP_GETCONNECTION)) return true;,     return false;,   }, ,   final private boolean jj_3R_100() {,     if (jj_scan_token(XA_RECOVER)) return true;,     return false;,   }, ,   final private boolean jj_3R_86() {,     if (jj_scan_token(RELATIVE)) return true;,     return false;,   }, ,   final private boolean jj_3R_70() {,     if (jj_scan_token(ELAPSEDTIME)) return true;,     return false;,   }, ,   final private boolean jj_3R_68() {,     if (jj_scan_token(DISCONNECT)) return true;,     return false;,   }, ,   final private boolean jj_3R_61() {,     if (jj_scan_token(ASYNC)) return true;,     return false;,   }, ,   final private boolean jj_3R_71() {,     if (jj_scan_token(EXECUTE)) return true;,     return false;,   }, ,   final private boolean jj_3R_58() {,     if (jj_scan_token(ABSOLUTE)) return true;,     return false;,   }, ,   final private boolean jj_3R_99() {,     if (jj_scan_token(XA_PREPARE)) return true;,     return false;,   }, ,   final private boolean jj_3R_105() {,     if (jj_scan_token(CP_CONNECT)) return true;,     return false;,   }, ,   public ijTokenManager token_source;,   public Token token, jj_nt;,   private Token jj_scanpos, jj_lastpos;,   private int jj_la;,   public boolean lookingAhead = false;,   private boolean jj_semLA;,   private int jj_gen;,   final private int[] jj_la1 = new int[69];,   static private int[] jj_la1_0;,   static private int[] jj_la1_1;,   static private int[] jj_la1_2;,   static private int[] jj_la1_3;,   static private int[] jj_la1_4;,   static {,       jj_la1_0();,       jj_la1_1();,       jj_la1_2();,       jj_la1_3();,       jj_la1_4();,    },    private static void jj_la1_0() {,       jj_la1_0 = new int[] {0x87e8c000,0x40000,0x0,0x0,0x0,0x0,0x0,0x100000,0x40000,0x0,0xffffc000,0x40000,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x10010000,0x0,0x0,0x20020000,0x20020000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffc000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x40000,0x40000,0x0,0x0,0xffffc000,0xffffc000,};,    },    private static void jj_la1_1() {,       jj_la1_1 = new int[] {0xae162c7,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x80000000,0xffffefd7,0x0,0x0,0x20000,0x80000000,0x20800,0x20800,0x20000,0x20000,0x41008,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x80000,0x4008000,0x0,0x0,0x0,0x0,0x0,0x30000000,0x30000000,0x30000000,0x30000000,0x0,0x0,0xffffefd7,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0xffffefd7,0xffffefd7,};,    },    private static void jj_la1_2() {,       jj_la1_2 = new int[] {0x202823e3,0x0,0x0,0x4000,0x20,0x4000000,0x0,0x0,0x0,0x0,0xffef77ff,0x0,0x13000000,0x0,0x0,0x0,0x0,0x0,0x0,0x13110808,0x0,0x0,0x0,0x0,0x40,0x4,0x20000,0x40000000,0x40000,0x0,0x0,0x0,0x8000000,0x800004,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0xffef77ff,0x0,0x0,0x0,0x0,0x0,0x400000,0x400000,0x4000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x20,0x4000000,0x0,0x0,0x20,0x4000000,0x0,0x0,0x0,0x0,0x0,0xffef77ff,0xffef77ff,};,    },    private static void jj_la1_3() {,       jj_la1_3 = new int[] {0x1f1b33e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x3ffffff,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0xe4cc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x3ffffff,0x3ffffff,};,    },    private static void jj_la1_4() {,       jj_la1_4 = new int[] {0x0,0x0,0x44,0x44,0x0,0x0,0x0,0x0,0x0,0x0,0x44,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x4,0x0,0x0,0x0,0x0,0x44,0x44,0x0,0x44,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x4,0x3,0x0,0x0,0x40,0x3,0x4,0x4,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x4,0x0,};,    },   final private JJCalls[] jj_2_rtns = new JJCalls[2];,   private boolean jj_rescan = false;,   private int jj_gc = 0;, ,   public ij(CharStream stream) {,     token_source = new ijTokenManager(stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 69; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public void ReInit(CharStream stream) {,     token_source.ReInit(stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 69; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public ij(ijTokenManager tm) {,     token_source = tm;,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 69; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public void ReInit(ijTokenManager tm) {,     token_source = tm;,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 69; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   final private Token jj_consume_token(int kind) throws ParseException {,     Token oldToken = token;,     if ((token = jj_nt).next != null) jj_nt = jj_nt.next;,     else jj_nt = jj_nt.next = token_source.getNextToken();,     if (token.kind == kind) {,       jj_gen++;,       if (++jj_gc > 100) {,         jj_gc = 0;,         for (int i = 0; i < jj_2_rtns.length; i++) {,           JJCalls c = jj_2_rtns[i];,           while (c != null) {,             if (c.gen < jj_gen) c.first = null;,             c = c.next;,           },         },       },       return token;,     },     jj_nt = token;,     token = oldToken;,     jj_kind = kind;,     throw generateParseException();,   }, ,   static private final class LookaheadSuccess extends java.lang.Error { },   final private LookaheadSuccess jj_ls = new LookaheadSuccess();,   final private boolean jj_scan_token(int kind) {,     if (jj_scanpos == jj_lastpos) {,       jj_la--;,       if (jj_scanpos.next == null) {,         jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();,       } else {,         jj_lastpos = jj_scanpos = jj_scanpos.next;,       },     } else {,       jj_scanpos = jj_scanpos.next;,     },     if (jj_rescan) {,       int i = 0; Token tok = token;,       while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; },       if (tok != null) jj_add_error_token(kind, i);,     },     if (jj_scanpos.kind != kind) return true;,     if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;,     return false;,   }, ,   final public Token getNextToken() {,     if ((token = jj_nt).next != null) jj_nt = jj_nt.next;,     else jj_nt = jj_nt.next = token_source.getNextToken();,     jj_gen++;,     return token;,   }, ,   final public Token getToken(int index) {,     Token t = lookingAhead ? jj_scanpos : token;,     for (int i = 0; i < index; i++) {,       if (t.next != null) t = t.next;,       else t = t.next = token_source.getNextToken();,     },     return t;,   }, ,   private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();,   private int[] jj_expentry;,   private int jj_kind = -1;,   private int[] jj_lasttokens = new int[100];,   private int jj_endpos;, ,   private void jj_add_error_token(int kind, int pos) {,     if (pos >= 100) return;,     if (pos == jj_endpos + 1) {,       jj_lasttokens[jj_endpos++] = kind;,     } else if (jj_endpos != 0) {,       jj_expentry = new int[jj_endpos];,       for (int i = 0; i < jj_endpos; i++) {,         jj_expentry[i] = jj_lasttokens[i];,       },       boolean exists = false;,       for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {,         int[] oldentry = (int[])(e.nextElement());,         if (oldentry.length == jj_expentry.length) {,           exists = true;,           for (int i = 0; i < jj_expentry.length; i++) {,             if (oldentry[i] != jj_expentry[i]) {,               exists = false;,               break;,             },           },           if (exists) break;,         },       },       if (!exists) jj_expentries.addElement(jj_expentry);,       if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;,     },   }, ,   public ParseException generateParseException() {,     jj_expentries.removeAllElements();,     boolean[] la1tokens = new boolean[135];,     for (int i = 0; i < 135; i++) {,       la1tokens[i] = false;,     },     if (jj_kind >= 0) {,       la1tokens[jj_kind] = true;,       jj_kind = -1;,     },     for (int i = 0; i < 69; i++) {,       if (jj_la1[i] == jj_gen) {,         for (int j = 0; j < 32; j++) {,           if ((jj_la1_0[i] & (1<<j)) != 0) {,             la1tokens[j] = true;,           },           if ((jj_la1_1[i] & (1<<j)) != 0) {,             la1tokens[32+j] = true;,           },           if ((jj_la1_2[i] & (1<<j)) != 0) {,             la1tokens[64+j] = true;,           },           if ((jj_la1_3[i] & (1<<j)) != 0) {,             la1tokens[96+j] = true;,           },           if ((jj_la1_4[i] & (1<<j)) != 0) {,             la1tokens[128+j] = true;,           },         },       },     },     for (int i = 0; i < 135; i++) {,       if (la1tokens[i]) {,         jj_expentry = new int[1];,         jj_expentry[0] = i;,         jj_expentries.addElement(jj_expentry);,       },     },     jj_endpos = 0;,     jj_rescan_token();,     jj_add_error_token(0, 0);,     int[][] exptokseq = new int[jj_expentries.size()][];,     for (int i = 0; i < jj_expentries.size(); i++) {,       exptokseq[i] = (int[])jj_expentries.elementAt(i);,     },     return new ParseException(token, exptokseq, ijConstants.tokenImage);,   }, ,   final public void enable_tracing() {,   }, ,   final public void disable_tracing() {,   }, ,   final private void jj_rescan_token() {,     jj_rescan = true;,     for (int i = 0; i < 2; i++) {,     try {,       JJCalls p = jj_2_rtns[i];,       do {,         if (p.gen > jj_gen) {,           jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;,           switch (i) {,             case 0: jj_3_1(); break;,             case 1: jj_3_2(); break;,           },         },         p = p.next;,       } while (p != null);,       } catch(LookaheadSuccess ls) { },     },     jj_rescan = false;,   }, ,   final private void jj_save(int index, int xla) {,     JJCalls p = jj_2_rtns[index];,     while (p.gen > jj_gen) {,       if (p.next == null) { p = p.next = new JJCalls(); break; },       p = p.next;,     },     p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,AbsoluteStatement,2157-2162,[    jj_consume_token(ABSOLUTE);,     row = intLiteral();,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.absolute(rs, row);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,AfterLastStatement,2211-2216,[    jj_consume_token(AFTER);,     jj_consume_token(LAST);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.afterLast(rs);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,AsyncStatement,2503-2508,[        Token s = null;,         QualifiedIdentifier qi;,     jj_consume_token(ASYNC);,     qi = qualifiedIdentifier();,     s = jj_consume_token(STRING);,             {if (true) return executeAsync(stringValue(s.image), qi);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,AutocommitStatement,2594-2612,[        Token on=null;,     jj_consume_token(AUTOCOMMIT);,     switch (jj_nt.kind) {,     case ON:,       on = jj_consume_token(ON);,       break;,     case OFF:,       jj_consume_token(OFF);,       break;,     default:,       jj_la1[35] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 haveConnection();,                 // REMIND: want to warn if unchanged?,                 theConnection.setAutoCommit((on==null?false:true));, ,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,Bang,2743-2776,[        Token cmd=null;,     jj_consume_token(BANG);,     cmd = jj_consume_token(STRING);,           ijResult result = null;,           try {,                 Process p = Runtime.getRuntime().exec(stringValue(cmd.image));,                 LocalizedInput in = new LocalizedInput(p.getInputStream());,                 int c;,                 Vector<Object> v = new Vector<Object>();,                 StringBuffer output = new StringBuffer();,                 // echo output,                 while ((c = in.read()) != -1) {,                         output.append((char)c);,                 },                 in.close();,                 // echo errors,                 in = new LocalizedInput(p.getErrorStream());,                 // echo output,                 while ((c = in.read()) != -1) {,                         output.append((char)c);,                 },                 in.close();,                 v.addElement(output);,                 result = new ijVectorResult(v,null);,                 // wait for completion,                 try {,                         p.waitFor();,                 } catch (InterruptedException e) {,                         {if (true) throw ijException.bangException(e);},                 },           } catch (IOException ioe) {,                 {if (true) throw ijException.bangException(ioe);},           },           {if (true) return result;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,BeforeFirstStatement,2180-2185,[    jj_consume_token(BEFORE);,     jj_consume_token(FIRST);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.beforeFirst(rs);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,CloseStatement,2253-2266,[    jj_consume_token(CLOSE);,     qi = qualifiedIdentifier();,                 Session sn = findSession(qi.getSessionName());, ,                 ResultSet rs = sn.getCursor(qi.getLocalName());,                 JDBCDisplayUtil.checkNotNull(rs,"cursor " + qi);,                 s = (Statement) sn.getCursorStatement(qi.getLocalName());,                 JDBCDisplayUtil.checkNotNull(s,"cursor" + qi);,                 rs.close();,                 s.close();,                 sn.removeCursor(qi.getLocalName());,                 sn.removeCursorStatement(qi.getLocalName());, ,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,CommitStatement,1895-1906,[    jj_consume_token(COMMIT);,     switch (jj_nt.kind) {,     case WORK:,       jj_consume_token(WORK);,       break;,     default:,       jj_la1[20] = jj_gen;,       ;,     },                 haveConnection();,                 theConnection.commit();,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,ConnectStatement,1303-1329,[    jj_consume_token(CONNECT);,     switch (jj_nt.kind) {,     case TO:,       jj_consume_token(TO);,       result = dynamicConnection(true);,       break;,     case IDENTIFIER:,     case STRING:,       switch (jj_nt.kind) {,       case STRING:,         result = dynamicConnection(false);,         break;,       case IDENTIFIER:,         result = staticConnection();,         break;,       default:,         jj_la1[2] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[3] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 {if (true) return result;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,DataSourceStatement,3487-3533,[        Token dbname = null;,         Token protocol = null;,         Token userT = null;,         Token passwordT = null;,         String n = null;,     jj_consume_token(DATASOURCE);,     dbname = jj_consume_token(STRING);,     switch (jj_nt.kind) {,     case PROTOCOL:,       jj_consume_token(PROTOCOL);,       protocol = jj_consume_token(STRING);,       break;,     default:,       jj_la1[56] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case USER:,       jj_consume_token(USER);,       userT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[57] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case PASSWORD:,       jj_consume_token(PASSWORD);,       passwordT = jj_consume_token(STRING);,       break;,     default:,       jj_la1[58] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       n = identifier();,       break;,     default:,       jj_la1[59] = jj_gen;,       ;,     },                 theConnection = xahelper.DataSourceStatement(this, dbname, protocol,,                         userT, passwordT, n);, ,                 {if (true) return addSession( theConnection, n );}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,DescTableStatement,1493-1648,[        String i = null;,         String i2 = null;,         Token  s = null;,         String schema;,         String table;,     jj_consume_token(DESCRIBE);,     switch (jj_nt.kind) {,     case ABSOLUTE:,     case AFTER:,     case ALIASES:,     case ALL:,     case AS:,     case ASYNC:,     case ATTRIBUTES:,     case AUTOCOMMIT:,     case BANG:,     case BEFORE:,     case CLOSE:,     case COMMIT:,     case CONNECT:,     case CONNECTION:,     case CONNECTIONS:,     case CURRENT:,     case CURSOR:,     case DESCRIBE:,     case DISCONNECT:,     case DRIVER:,     case ELAPSEDTIME:,     case END:,     case EXECUTE:,     case EXIT:,     case FAIL:,     case FIRST:,     case FOR:,     case FROM:,     case GET:,     case GETCURRENTROWNUMBER:,     case HOLD:,     case HELP:,     case IN:,     case INDEXES:,     case INSENSITIVE:,     case INTO:,     case LAST:,     case LOCALIZEDDISPLAY:,     case MAXIMUMDISPLAYWIDTH:,     case NAME:,     case NEXT:,     case NOHOLD:,     case NOHOLDFORCONNECTION:,     case OFF:,     case ON:,     case PASSWORD:,     case PERIOD:,     case PREPARE:,     case PREVIOUS:,     case PROCEDURE:,     case PROCEDURES:,     case PROPERTIES:,     case PROTOCOL:,     case QUIT:,     case READONLY:,     case RELATIVE:,     case REMOVE:,     case RESOURCE:,     case ROLLBACK:,     case RUN:,     case TO:,     case SCHEMAS:,     case SCROLL:,     case SENSITIVE:,     case SET:,     case SHOW:,     case SHUTDOWN:,     case STATEMENT:,     case SYNONYMS:,     case TABLES:,     case USER:,     case USING:,     case VIEWS:,     case WAIT:,     case WITH:,     case XA_1PHASE:,     case XA_2PHASE:,     case XA_DATASOURCE:,     case XA_CONNECT:,     case XA_COMMIT:,     case XA_DISCONNECT:,     case XA_END:,     case XA_ENDRSCAN:,     case XA_FAIL:,     case XA_FORGET:,     case XA_GETCONNECTION:,     case XA_JOIN:,     case XA_NOFLAGS:,     case XA_PREPARE:,     case XA_RECOVER:,     case XA_RESUME:,     case XA_ROLLBACK:,     case XA_START:,     case XA_STARTRSCAN:,     case XA_SUCCESS:,     case XA_SUSPEND:,     case DATASOURCE:,     case CP_DATASOURCE:,     case CP_CONNECT:,     case CP_GETCONNECTION:,     case CP_DISCONNECT:,     case WORK:,     case IDENTIFIER:,       i = caIdentifier();,       switch (jj_nt.kind) {,       case PERIOD:,         jj_consume_token(PERIOD);,         i2 = caIdentifier();,         break;,       default:,         jj_la1[9] = jj_gen;,         ;,       },                         if (i2 == null) {,                                 schema = null;,                                 table = i;,                         } else {,                                 schema = i;,                                 table = i2;,                         },       break;,     case STRING:,       s = jj_consume_token(STRING);,                         i2 = stringValue(s.image);, ,                         if (i2.length() == 0),                                 {if (true) throw ijException.noSuchTable("(missing)");}, ,                         int dotPosition = i2.indexOf('.');,                         if(dotPosition!=-1) {,                                 i = i2.substring(0,dotPosition);,                                 i2 = i2.substring(dotPosition+1);,                         },                         if ("*".equals(i2)),                                 i2 = null;, ,                         schema = i;,                         table = i2;,       break;,     default:,       jj_la1[10] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 if (schema == null) {,                         schema = util.getSelectedSchema(theConnection);,                 }, ,                 {if (true) return describeTable(schema, table);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,DisconnectStatement,1939-1985,[        Token a = null;,         String n = null;,     jj_consume_token(DISCONNECT);,     switch (jj_nt.kind) {,     case ALL:,     case CURRENT:,     case IDENTIFIER:,       switch (jj_nt.kind) {,       case CURRENT:,         jj_consume_token(CURRENT);,         break;,       case ALL:,         a = jj_consume_token(ALL);,         break;,       case IDENTIFIER:,         n = identifier();,         break;,       default:,         jj_la1[22] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       break;,     default:,       jj_la1[23] = jj_gen;,       ;,     },                 if ( a == null ) {,                         if (n == null) {,                         // only remove the current session,                             haveConnection();,                             // Also need to release the session object,                             currentConnEnv.removeCurrentSession();,                             theConnection = null;,                         },                         else {,                             if (! currentConnEnv.haveSession(n)),                                     {if (true) throw ijException.noSuchConnection(n);},                                 currentConnEnv.removeSession(n);,                             if (currentConnEnv.getSession() == null),                                     theConnection = null;,                         },                 } else {,                         currentConnEnv.removeAllSessions();,                         theConnection = null;,                 },                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,DriverStatement,1278-1297,[        String sVal = null;,     jj_consume_token(DRIVER);,     t = jj_consume_token(STRING);,             try {,                 // t.image is a class name;,                 // we load the "driver" in the prototypical,                 // manner, it will register itself with,                 // the DriverManager.,                         sVal = stringValue(t.image);,                         util.loadDriver(sVal);,             } catch (ClassNotFoundException e) {,                         {if (true) throw ijException.classNotFound(sVal);},             } catch (IllegalArgumentException e) {,                         {if (true) throw ijException.driverNotClassName(sVal);},             } catch (IllegalAccessException e) {,                         {if (true) throw ijException.classNotFound(sVal);},             } catch (InstantiationException e) {,                         {if (true) throw ijException.classNotFound(sVal);},             },                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,ElapsedTimeStatement,2693-2708,[        Token on=null;,     jj_consume_token(ELAPSEDTIME);,     switch (jj_nt.kind) {,     case ON:,       on = jj_consume_token(ON);,       break;,     case OFF:,       jj_consume_token(OFF);,       break;,     default:,       jj_la1[38] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 elapsedTime = (on != null);,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,ExecuteStatement,2285-2487,[        QualifiedIdentifier qi = null;,         Token s = null;,         PreparedStatement ps;,         String sVal = null;, ,         QualifiedIdentifier qiUsing = null;,         Token sUsing = null;,         Token   usingObject = null;,     jj_consume_token(EXECUTE);,     switch (jj_nt.kind) {,     case STATEMENT:,       jj_consume_token(STATEMENT);,       s = jj_consume_token(STRING);,                 {if (true) return executeImmediate(stringValue(s.image));},       break;,     case PROCEDURE:,       jj_consume_token(PROCEDURE);,       s = jj_consume_token(STRING);,                 haveConnection();, ,                 Statement       aStatement = theConnection.createStatement();,                 String          text = "execute procedure " + s;, ,                 aStatement.execute( text );, ,                 {if (true) return new ijStatementResult( aStatement,true );},       break;,     case IDENTIFIER:,     case STRING:,       switch (jj_nt.kind) {,       case IDENTIFIER:,         qi = qualifiedIdentifier();,         break;,       case STRING:,         s = jj_consume_token(STRING);,         break;,       default:,         jj_la1[30] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch (jj_nt.kind) {,       case USING:,         jj_consume_token(USING);,         switch (jj_nt.kind) {,         case IDENTIFIER:,           qiUsing = qualifiedIdentifier();,           break;,         case STRING:,           sUsing = jj_consume_token(STRING);,           break;,         default:,           jj_la1[31] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         break;,       default:,         jj_la1[32] = jj_gen;,         ;,       },             if (qiUsing!=null || sUsing!=null) { // parameters in use,                         String sUsingVal = null;,                         PreparedStatement psUsing;,                         SQLWarning warns = null;, ,                         // haveConnection();, ,                         /*, 				Steps:, 				1. find or prepare the statement, 				2. execute the using statement, 				3. push the row of the using statement into the parameters, 				4. execute the statement against those parameters, 				5. clear the parameters, 			 */,                         /*, 				get the prepared statement, 			 */,                         boolean closeWhenDone = false; // will we close the ps when done?,                 if (qi!=null) {,                         ps = findPreparedStatement(qi);,                 },                 else { // (s!=null),                                 sVal = stringValue(s.image);,                                 ps = theConnection.prepareStatement(sVal);,                                 closeWhenDone = true;,                                 JDBCDisplayUtil.checkNotNull(ps,"prepared statement");,                                 warns = appendWarnings(warns, ps.getWarnings());,                                 ps.clearWarnings();,                 }, ,                         /*, 				execute the using statement, 			 */,                 if (qiUsing!=null) {,                         psUsing = findPreparedStatement(qiUsing);,                 },                 else { // (sUsing!=null),                                 sUsingVal = stringValue(sUsing.image);,                                 psUsing = theConnection.prepareStatement(sUsingVal);,                                 JDBCDisplayUtil.checkNotNull(psUsing,"prepared statement");,                                 warns = appendWarnings(warns, psUsing.getWarnings());,                                 psUsing.clearWarnings();,                 }, ,                         ResultSet rsUsing;,                         /*, 				If the USING statement is not a query, we, 				will not execute the statement; the number of, 				rows controls the execution., 			 */,                         if (psUsing.execute()) {,                                 rsUsing = psUsing.getResultSet();, ,                                 /*, 					push the row of the using statement into the parameters, 				 */, ,                                 ResultSetMetaData rsmdUsing = rsUsing.getMetaData();,                                 int numCols = rsmdUsing.getColumnCount();, ,                                 /*, 					Insufficient or too many parameters will, 					be caught at the JDBC level, and halt execution., 				 */,                                 boolean exec = false;, ,                                 /* Only do 1 next on rsUsing if autocommit is on,, 				 * since rsUsing will be closed when ps is closed., 				 */,                             boolean autoCommited = false;,                                 ijMultiResult result = new ijMultiResult(ps,rsUsing,closeWhenDone);, , //				while (! autoCommited && rsUsing.next()) {, //					// note the first time through, //					if (!exec) {, //						exec = true;, //, //						// send a warning if additional results may be lost, //						if (theConnection.getAutoCommit()) {, //							// FIXME: currOut.println("IJ WARNING: Autocommit may close using result set");, //							autoCommited = true;, //						}, //					}, //					for (int c=1; c<=numCols; c++) {, //						if (usingObject == null), //						{, //							ps.setObject(c,rsUsing.getObject(c),, //								rsmdUsing.getColumnType(c));, //						} , //						else, //						{, //							ps.setObject(c,rsUsing.getObject(c));, //						}, //					}, //, //					/*, //						4. execute the statement against those parameters, //					 */, //, //					ps.execute();, //					result.addStatementResult(ps);, //, //					/*, //						5. clear the parameters, //					 */, //					ps.clearParameters();, //, //				}, //				if (!exec) {, //					throw ijException.noUsingResults();, //				}, //, //				if (! theConnection.getAutoCommit()), //				{, //					rsUsing.close();, //				}, //				// REMIND: any way to look for more rsUsing rows if autoCommit?, //				// perhaps just document the behavior... , ,                                 {if (true) return result;},                         },                         else,                                 {if (true) throw ijException.noUsingResults();},                 },                 else { // no parameters in use,                 if (qi!=null) {,                                 haveConnection();,                                 ps = findPreparedStatement(qi);,                                 ps.execute();, ,                                 {if (true) return new ijStatementResult(ps,false);},                 },                 else { // (s!=null),                             {if (true) return executeImmediate(stringValue(s.image));},                 },             },       break;,     default:,       jj_la1[33] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,ExitStatement,1990-2002,[    switch (jj_nt.kind) {,     case EXIT:,       jj_consume_token(EXIT);,                 {if (true) return quit();},       break;,     case QUIT:,       jj_consume_token(QUIT);,                 {if (true) return quit();},       break;,     default:,       jj_la1[24] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,FirstStatement,2191-2195,[    jj_consume_token(FIRST);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.first(rs);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,GetCurrentRowNumber,2242-2246,[    jj_consume_token(GETCURRENTROWNUMBER);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return new ijVectorResult(utilInstance.getCurrentRowNumber(rs), null);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,GetCursorStatement,2048-2114,[        haveConnection();,         int scrollType = ResultSet.TYPE_FORWARD_ONLY;,         Token s;,         Token scrolling = null;,         Token withtoken = null;,         int holdType = theConnection.getHoldability();,         QualifiedIdentifier qi;,         Statement st = null;,         String sVal;,         ResultSet rs = null;,         SQLWarning warns;,     jj_consume_token(GET);,     switch (jj_nt.kind) {,     case SCROLL:,       scrolling = jj_consume_token(SCROLL);,       scrollType = scrollType();,       break;,     default:,       jj_la1[26] = jj_gen;,       ;,     },     switch (jj_nt.kind) {,     case WITH:,       withtoken = jj_consume_token(WITH);,       holdType = holdType();,       break;,     default:,       jj_la1[27] = jj_gen;,       ;,     },     jj_consume_token(CURSOR);,     qi = qualifiedIdentifier();,     jj_consume_token(AS);,     s = jj_consume_token(STRING);,                 sVal = stringValue(s.image);,                 try {,                         Session sn = findSession(qi.getSessionName());, ,                         st = sn.getConnection().createStatement(,                                 scrollType, ResultSet.CONCUR_READ_ONLY, holdType);,                         JDBCDisplayUtil.checkNotNull(st,"cursor");,                         st.setCursorName(qi.getLocalName());,                         rs = st.executeQuery(sVal);,                         JDBCDisplayUtil.checkNotNull(rs,"cursor");,                         sn.addCursorStatement(qi.getLocalName(),st);,                         sn.addCursor(qi.getLocalName(),rs);,                 } catch (SQLException e) {,             try {,                             if (rs!=null) rs.close();,             } catch (SQLException se) {,             },             try {,                         if (st!=null) st.close();,             } catch (SQLException se) {,             },                         {if (true) throw e;},                 }, ,                 // all we want callers to see are the warnings.,                 SQLWarning w1 = theConnection.getWarnings();,                 SQLWarning w2 = st.getWarnings();,                 SQLWarning w3 = rs.getWarnings();,                 theConnection.clearWarnings();,                 st.clearWarnings();,                 rs.clearWarnings();,                 warns = appendWarnings(w1,w2);,                 {if (true) return new ijWarningResult(appendWarnings(warns,w3));}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,HelpStatement,2807-2815,[    jj_consume_token(HELP);,                 Vector<Object> v = new Vector<Object>();, ,                 StringTokenizer st = new StringTokenizer(LocalizedResource.getMessage("IJ_HelpText"), "\n");,                 while (st.hasMoreTokens()) {,                     v.addElement(st.nextToken());,                 }, ,                 {if (true) return new ijVectorResult(v,null);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,LastStatement,2222-2226,[    jj_consume_token(LAST);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.last(rs);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,LocalizedDisplay,2637-2652,[        Token on=null;,     jj_consume_token(LOCALIZEDDISPLAY);,     switch (jj_nt.kind) {,     case ON:,       on = jj_consume_token(ON);,       break;,     case OFF:,       jj_consume_token(OFF);,       break;,     default:,       jj_la1[36] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 LocalizedResource.enableLocalization((on==null?false:true));,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,MaximumDisplayWidthStatement,2722-2725,[    jj_consume_token(MAXIMUMDISPLAYWIDTH);,     maxWidth = intValue();,                 JDBCDisplayUtil.setMaxDisplayWidth(maxWidth);,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,NextStatement,2201-2205,[    jj_consume_token(NEXT);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return new ijRowResult(rs, rs.next());}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,NoHoldForConnectionStatement,2622-2626,[        Token on=null;,     jj_consume_token(NOHOLDFORCONNECTION);,                 haveConnection();,                 theConnection.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,PrepareStatement,2012-2042,[    jj_consume_token(PREPARE);,     switch (jj_nt.kind) {,     case PROCEDURE:,       jj_consume_token(PROCEDURE);,       jj_consume_token(AS);,       t = jj_consume_token(STRING);,                 // "procedure" is not allowed as a statement name. This is,                 // because "execute procedure" is a valid Foundation2000,                 // command.,                 {if (true) throw ijException.illegalStatementName( "procedure" );},       break;,     case IDENTIFIER:,       qi = qualifiedIdentifier();,       jj_consume_token(AS);,       t = jj_consume_token(STRING);,                 Session session = findSession(qi.getSessionName());, ,                 sVal = stringValue(t.image);,                 ps = session.getConnection().prepareStatement(sVal);,                 JDBCDisplayUtil.checkNotNull(ps,"prepared statement");,                 session.addPreparedStatement(qi.getLocalName(),ps);, ,                 // all we want callers to see are the warnings.,                 SQLWarning w = ps.getWarnings();,                 ps.clearWarnings();,                 {if (true) return new ijWarningResult(w);},       break;,     default:,       jj_la1[25] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,PreviousStatement,2232-2236,[    jj_consume_token(PREVIOUS);,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.previous(rs);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,ProtocolStatement,1250-1263,[        String n = null;,     jj_consume_token(PROTOCOL);,     t = jj_consume_token(STRING);,     switch (jj_nt.kind) {,     case AS:,       jj_consume_token(AS);,       n = identifier();,       break;,     default:,       jj_la1[1] = jj_gen;,       ;,     },                 installProtocol(n, stringValue(t.image));,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,ReInit,5245-5251,[    token_source.ReInit(stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 69; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,ReInit,5263-5269,[    token_source = tm;,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 69; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,ReadOnlyStatement,2665-2681,[        Token on=null;,     jj_consume_token(READONLY);,     switch (jj_nt.kind) {,     case ON:,       on = jj_consume_token(ON);,       break;,     case OFF:,       jj_consume_token(OFF);,       break;,     default:,       jj_la1[37] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },                 haveConnection();,                 theConnection.setReadOnly((on==null?false:true));,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,RelativeStatement,2169-2174,[    jj_consume_token(RELATIVE);,     row = intLiteral();,     qi = qualifiedIdentifier();,                 // Verify that we have JDBC 2.0,                 ResultSet rs = findCursor(qi);,                 {if (true) return utilInstance.relative(rs, row);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,RemoveStatement,2550-2558,[    jj_consume_token(REMOVE);,     qi = qualifiedIdentifier();,                 Session s = findSession(qi.getSessionName());,                 ps = (PreparedStatement) s.getPreparedStatement(qi.getLocalName());,                 JDBCDisplayUtil.checkNotNull(ps,"prepared statement "+qi);,                 ps.close();,                 s.removePreparedStatement(qi.getLocalName());, ,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,RollbackStatement,1915-1926,[    jj_consume_token(ROLLBACK);,     switch (jj_nt.kind) {,     case WORK:,       jj_consume_token(WORK);,       break;,     default:,       jj_la1[21] = jj_gen;,       ;,     },                 haveConnection();,                 theConnection.rollback();,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,RunStatement,2564-2581,[    Token r = null;,         PreparedStatement ps;,     jj_consume_token(RUN);,     switch (jj_nt.kind) {,     case RESOURCE:,       r = jj_consume_token(RESOURCE);,       break;,     default:,       jj_la1[34] = jj_gen;,       ;,     },     i = jj_consume_token(STRING);,                 if (utilInstance==null) {if (true) return null;},             if (r == null),                         utilInstance.newInput(stringValue(i.image));,                 else,             utilInstance.newResourceInput(stringValue(i.image));,                 {if (true) return null;}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,SetConnectionStatement,1725-1733,[    jj_consume_token(SET);,     jj_consume_token(CONNECTION);,     t = identifier();,                 if (!currentConnEnv.haveSession(t)) {,                         {if (true) throw ijException.noSuchConnection(t);},                 },                 currentConnEnv.setCurrentSession(t);,                 theConnection = currentConnEnv.getConnection();,                 {if (true) return new ijConnectionResult(theConnection);}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,ShowStatement,1742-1885,[        String schema  = null;,         String tblname = null;,         String str     = null;,         String[] types = null;,         Token t = null;,         Token v = null;,     jj_consume_token(SHOW);,     switch (jj_nt.kind) {,     case CONNECTIONS:,       jj_consume_token(CONNECTIONS);,                 {if (true) return showConnectionsMethod(false);},       break;,     case ALIASES:,     case SYNONYMS:,     case TABLES:,     case VIEWS:,       switch (jj_nt.kind) {,       case TABLES:,         t = jj_consume_token(TABLES);,         break;,       case VIEWS:,         v = jj_consume_token(VIEWS);,         break;,       case SYNONYMS:,         jj_consume_token(SYNONYMS);,         break;,       case ALIASES:,         jj_consume_token(ALIASES);,         break;,       default:,         jj_la1[12] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },       switch (jj_nt.kind) {,       case IN:,         jj_consume_token(IN);,         schema = caIdentifier();,         break;,       default:,         jj_la1[13] = jj_gen;,         ;,       },                 if(t!=null) {,                     types = new String[] { "TABLE", "SYSTEM TABLE" };,                 },                 else if(v!=null),                         types = new String[] { "VIEW" };,                 else,                         types = new String[] { "SYNONYM" };,                 {if (true) return showTables(schema, types);},       break;,     case INDEXES:,       jj_consume_token(INDEXES);,       switch (jj_nt.kind) {,       case FROM:,       case IN:,         switch (jj_nt.kind) {,         case IN:,           jj_consume_token(IN);,           schema = caIdentifier();,           break;,         case FROM:,           jj_consume_token(FROM);,           tblname = caIdentifier();,           switch (jj_nt.kind) {,           case PERIOD:,             jj_consume_token(PERIOD);,             str = caIdentifier();,             break;,           default:,             jj_la1[14] = jj_gen;,             ;,           },           break;,         default:,           jj_la1[15] = jj_gen;,           jj_consume_token(-1);,           throw new ParseException();,         },         break;,       default:,         jj_la1[16] = jj_gen;,         ;,       },                 if(str != null) {,                         // if absolute table reference given,                         schema = tblname;,                         tblname = str;,                 }, ,                 // If user specifies a table name, then assume schema is,                 // current schema. Note that getSelectedSchema may return,                 // null for some DBMSes.,                 if(schema == null && tblname != null),                         schema = util.getSelectedSchema(theConnection);,                 {if (true) return showIndexes(schema,tblname);},       break;,     case PROCEDURES:,       jj_consume_token(PROCEDURES);,       switch (jj_nt.kind) {,       case IN:,         jj_consume_token(IN);,         schema = caIdentifier();,         break;,       default:,         jj_la1[17] = jj_gen;,         ;,       },                 {if (true) return showProcedures(schema);},       break;,     case FUNCTIONS:,       jj_consume_token(FUNCTIONS);,       switch (jj_nt.kind) {,       case IN:,         jj_consume_token(IN);,         schema = caIdentifier();,         break;,       default:,         jj_la1[18] = jj_gen;,         ;,       },                 {if (true) return showFunctions(schema);},       break;,     case SCHEMAS:,       jj_consume_token(SCHEMAS);,                 {if (true) return showSchemas();},       break;,     case ROLES:,       jj_consume_token(ROLES);,             {if (true) return showRoles();},       break;,     case ENABLED_ROLES:,       jj_consume_token(ENABLED_ROLES);,             {if (true) return showEnabledRoles();},       break;,     case SETTABLE_ROLES:,       jj_consume_token(SETTABLE_ROLES);,             {if (true) return showSettableRoles();},       break;,     default:,       jj_la1[19] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,StringItem,2798-2800,[    s = jj_consume_token(STRING);,                 v.addElement(s);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,StringList,2781-2794,[    StringItem(v);,     label_1:,     while (true) {,       switch (jj_nt.kind) {,       case STRING:,         ;,         break;,       default:,         jj_la1[39] = jj_gen;,         break label_1;,       },       StringItem(v);,     },   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ij.java,WaitForStatement,2523-2536,[        Token s = null;,         QualifiedIdentifier qi;,     jj_consume_token(WAIT);,     jj_consume_token(FOR);,     qi = qualifiedIdentifier();,                 Session sn = findSession(qi.getSessionName());,                 AsyncStatement as = sn.getAsyncStatement(qi.getLocalName());,                 if (as == null) {if (true) throw ijException.noSuchAsyncStatement(qi.toString());},                 try {,                     as.join(); // we wait for it to finish.,                 } catch (InterruptedException ie) {,                         {if (true) throw ijException.waitInterrupted(ie);},                 },                 {if (true) return as.getResult();}],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/tools/ij/ij.java,showIndexes,705-705,[                verifyTableExists(schema, table);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/tools/ij/ij.java,ExecuteStatement,2373-2373,[                                warns = appendWarnings(warns, ps.getWarnings());],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/tools/ij/ij.java,GetCursorStatement,2096-2096,[                            if (rs!=null) rs.close();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/tools/ij/ij.java,showIndexes,732-732,[                if(result!=null)],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/impl/tools/ij/ij.java,ExecuteStatement,2370-2370,[                                ps = theConnection.prepareStatement(sVal);],,ExecuteStatement,2371-2371,[                                closeWhenDone = true;],,ExecuteStatement,2372-2372,[                                JDBCDisplayUtil.checkNotNull(ps,"prepared statement");],,ExecuteStatement,2373-2373,[                                warns = appendWarnings(warns, ps.getWarnings());],,ExecuteStatement,2374-2374,[                                ps.clearWarnings();],,ExecuteStatement,2380-2380,[                if (qiUsing!=null) {],,ExecuteStatement,2384-2384,[                                sUsingVal = stringValue(sUsing.image);],,ExecuteStatement,2385-2385,[                                psUsing = theConnection.prepareStatement(sUsingVal);],,ExecuteStatement,2386-2386,[                                JDBCDisplayUtil.checkNotNull(psUsing,"prepared statement");],,ExecuteStatement,2387-2387,[                                warns = appendWarnings(warns, psUsing.getWarnings());],,ExecuteStatement,2388-2388,[                                psUsing.clearWarnings();],,ExecuteStatement,2397-2397,[                        if (psUsing.execute()) {],,ExecuteStatement,2398-2398,[                                rsUsing = psUsing.getResultSet();],,ExecuteStatement,2404-2404,[                                ResultSetMetaData rsmdUsing = rsUsing.getMetaData();],,ExecuteStatement,2405-2405,[                                int numCols = rsmdUsing.getColumnCount();],,ExecuteStatement,2411-2411,[                                boolean exec = false;],,ExecuteStatement,2416-2416,[                            boolean autoCommited = false;],,ExecuteStatement,2417-2417,[                                ijMultiResult result = new ijMultiResult(ps,rsUsing,closeWhenDone);],,ExecuteStatement,2466-2466,[                                {if (true) return result;}],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/impl/tools/ij/ij.java,GetCursorStatement,2090-2090,[                        rs = st.executeQuery(sVal);],,GetCursorStatement,2091-2091,[                        JDBCDisplayUtil.checkNotNull(rs,"cursor");],,GetCursorStatement,2092-2092,[                        sn.addCursorStatement(qi.getLocalName(),st);],,GetCursorStatement,2093-2093,[                        sn.addCursor(qi.getLocalName(),rs);],,GetCursorStatement,2104-2104,[                }],,GetCursorStatement,2107-2107,[                SQLWarning w1 = theConnection.getWarnings();],,GetCursorStatement,2108-2108,[                SQLWarning w2 = st.getWarnings();],,GetCursorStatement,2109-2109,[                SQLWarning w3 = rs.getWarnings();],,GetCursorStatement,2110-2110,[                theConnection.clearWarnings();],,GetCursorStatement,2111-2111,[                st.clearWarnings();],,GetCursorStatement,2112-2112,[                rs.clearWarnings();],,GetCursorStatement,2113-2113,[                warns = appendWarnings(w1,w2);],,GetCursorStatement,2114-2114,[                {if (true) return new ijWarningResult(appendWarnings(warns,w3));}],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/impl/tools/ij/ij.java,GetCursorStatement,2086-2086,[                        st = sn.getConnection().createStatement(],,GetCursorStatement,2088-2088,[                        JDBCDisplayUtil.checkNotNull(st,"cursor");],,GetCursorStatement,2089-2089,[                        st.setCursorName(qi.getLocalName());],,GetCursorStatement,2090-2090,[                        rs = st.executeQuery(sVal);],,GetCursorStatement,2091-2091,[                        JDBCDisplayUtil.checkNotNull(rs,"cursor");],,GetCursorStatement,2092-2092,[                        sn.addCursorStatement(qi.getLocalName(),st);],,GetCursorStatement,2093-2093,[                        sn.addCursor(qi.getLocalName(),rs);],,GetCursorStatement,2104-2104,[                }],,GetCursorStatement,2107-2107,[                SQLWarning w1 = theConnection.getWarnings();],,GetCursorStatement,2108-2108,[                SQLWarning w2 = st.getWarnings();],,GetCursorStatement,2109-2109,[                SQLWarning w3 = rs.getWarnings();],,GetCursorStatement,2110-2110,[                theConnection.clearWarnings();],,GetCursorStatement,2111-2111,[                st.clearWarnings();],,GetCursorStatement,2112-2112,[                rs.clearWarnings();],,GetCursorStatement,2113-2113,[                warns = appendWarnings(w1,w2);],,GetCursorStatement,2114-2114,[                {if (true) return new ijWarningResult(appendWarnings(warns,w3));}],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/impl/tools/ij/ij.java,PrepareStatement,2030-2030,[                ps = session.getConnection().prepareStatement(sVal);],,PrepareStatement,2031-2031,[                JDBCDisplayUtil.checkNotNull(ps,"prepared statement");],,PrepareStatement,2032-2032,[                session.addPreparedStatement(qi.getLocalName(),ps);],,PrepareStatement,2035-2035,[                SQLWarning w = ps.getWarnings();],,PrepareStatement,2036-2036,[                ps.clearWarnings();],,PrepareStatement,2037-2037,[                {if (true) return new ijWarningResult(w);}],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/impl/tools/ij/ij.java,showEnabledRoles,919-919,[                                rs = theConnection.createStatement().executeQuery],,showEnabledRoles,920-920,[                                        ("SELECT * FROM" +],,showEnabledRoles,925-925,[                                int[] displayColumns = new int[] {],,showEnabledRoles,926-926,[                                        rs.findColumn("ROLEID")],,showEnabledRoles,928-928,[                                int[] columnWidths = new int[] {],,showEnabledRoles,932-932,[                                return new ijResultSetResult(rs, displayColumns, columnWidths);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/impl/tools/ij/ij.java,showRoles,881-881,[                                rs = theConnection.createStatement().executeQuery],,showRoles,882-882,[                                        ("SELECT ROLEID FROM SYS.SYSROLES WHERE ISDEF='Y' " +],,showRoles,885-885,[                                int[] displayColumns = new int[] {],,showRoles,886-886,[                                        rs.findColumn("ROLEID")],,showRoles,888-888,[                                int[] columnWidths = new int[] {],,showRoles,892-892,[                                return new ijResultSetResult(rs, displayColumns, columnWidths);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/impl/tools/ij/ij.java,showSettableRoles,973-973,[                                rs = theConnection.createStatement().executeQuery(query);],,showSettableRoles,975-975,[                                int[] displayColumns = new int[] {],,showSettableRoles,976-976,[                                        rs.findColumn("ROLEID")],,showSettableRoles,978-978,[                                int[] columnWidths = new int[] {],,showSettableRoles,982-982,[                                return new ijResultSetResult(rs, displayColumns, columnWidths);],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE,org/apache/derby/impl/tools/ij/ij.java,showEnabledRoles,919-919,[                                rs = theConnection.createStatement().executeQuery],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE,org/apache/derby/impl/tools/ij/ij.java,showRoles,881-881,[                                rs = theConnection.createStatement().executeQuery],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE,org/apache/derby/impl/tools/ij/ij.java,showSettableRoles,973-973,[                                rs = theConnection.createStatement().executeQuery(query);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derby/impl/tools/ij/ij.java,Bang,2749-2749,[                LocalizedInput in = new LocalizedInput(p.getInputStream());],,Bang,2759-2759,[                in = new LocalizedInput(p.getErrorStream());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/impl/tools/ij/ij.java,GetCursorStatement,2096-2096,[                            if (rs!=null) rs.close();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/derby/impl/tools/ij/ij.java,showIndexes,732-732,[                if(result!=null)],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/tools/ij/ij.java,dynamicConnection,1465-1465,[                        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/tools/ij/ij.java,initFromEnvironment,125-125,[                        } catch (Exception e) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/tools/ij/ij.java,jj_rescan_token,5430-5432,[          switch (i) {,             case 0: jj_3_1(); break;,             case 1: jj_3_2(); break;],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/impl/tools/ij/ij.java,ExecuteStatement,2308-2308,[                aStatement.execute( text );],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/impl/tools/ij/ij.java,GetCursorStatement,2090-2090,[                        rs = st.executeQuery(sVal);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/derby/impl/tools/ij/ij.java,executeImmediate,367-367,[                        aStatement.execute(stmt);],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/ij/ij.java,ExecuteStatement,2370-2370,[                                ps = theConnection.prepareStatement(sVal);],,ExecuteStatement,2385-2385,[                                psUsing = theConnection.prepareStatement(sUsingVal);],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/ij/ij.java,PrepareStatement,2030-2030,[                ps = session.getConnection().prepareStatement(sVal);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/tools/ij/ij.java,makeXid,1062-1062,[                return null;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/tools/ij/ij.java,,84-84,[        Hashtable ignoreErrors = null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/tools/ij/ij.java,,111-113,[        Properties p = AccessController.doPrivileged(new PrivilegedAction<Properties>() {,                 public Properties run() {,                 return System.getProperties();],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijConnectionResult.java,,34-43,[	ijConnectionResult(Connection c) {, 		conn = c;, 	}, , 	public boolean isConnection() { return true; }, , 	public Connection getConnection() { return conn; }, , 	public SQLWarning getSQLWarnings() throws SQLException { return conn.getWarnings(); }, 	public void clearSQLWarnings() throws SQLException { conn.clearWarnings(); }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijException.java,,67-151,[		super(message);, 	}, , 	static ijException notYetImplemented() {, 		return new ijException(LocalizedResource.getMessage(NotYetImplemented));, 	}, , 	static ijException illegalStatementName(String n) {, 		return new ijException(LocalizedResource.getMessage(IllegalStatementName, n));, 	}, 	static ijException alreadyHaveConnectionNamed(String n) {, 		return new ijException(LocalizedResource.getMessage(AlreadyHaveConnectionNamed, n));, 	}, 	static ijException bangException(Throwable t) {, 		return new ijException(LocalizedResource.getMessage(BangException, t.toString()));, 	}, 	static ijException classNotFoundForProtocol(String p) {, 		return new ijException(LocalizedResource.getMessage(ClassNotFoundForProtocol, p));, 	}, 	static ijException classNotFound(String c) {, 		return new ijException(LocalizedResource.getMessage(ClassNotFound, c));, 	}, 	static ijException connectionGetWarningsFailed() {, 		return new ijException(LocalizedResource.getMessage(ConnectionGetWarningsFailed));, 	}, 	static ijException disconnectFailed() {, 		return new ijException(LocalizedResource.getMessage(DisconnectFailed));, 	}, 	static ijException driverNotClassName(String c) {, 		return new ijException(LocalizedResource.getMessage(DriverNotClassName, c));, 	}, 	static ijException fileNotFound() {, 		return new ijException(LocalizedResource.getMessage(FileNotFound));, 	}, 	static public ijException forwardOnlyCursor(String operation) {, 		return new ijException(LocalizedResource.getMessage(ForwardOnlyCursor, operation));, 	}, 	static ijException resourceNotFound() {, 		return new ijException(LocalizedResource.getMessage(ResourceNotFound));, 	}, 	static ijException getConnectionFailed() {, 		return new ijException(LocalizedResource.getMessage(GetConnectionFailed));, 	}, 	static ijException iOException(IOException t) {, 		return new ijException(LocalizedResource.getMessage(IOException, t.getMessage()));, 	}, 	static ijException needToDisconnect() {, 		return new ijException(LocalizedResource.getMessage(NeedToDisconnect));, 	}, 	static ijException noSuchAsyncStatement(String c) {, 		return new ijException(LocalizedResource.getMessage(NoSuchAsyncStatement, c));, 	}, 	static ijException noSuchConnection(String c) {, 		return new ijException(LocalizedResource.getMessage(NoSuchConnection, c));, 	}, 	static ijException noSuchProtocol(String c) {, 		return new ijException(LocalizedResource.getMessage(NoSuchProtocol, c));, 	}, 	static ijException noSuchTable(String c) {, 		return new ijException(LocalizedResource.getMessage(NoSuchTable, c));, 	}, 	static ijException noUsingResults() {, 		return new ijException(LocalizedResource.getMessage(NoUsingResults));, 	}, 	static public ijException objectWasNull(String objectName) {, 		return new ijException(LocalizedResource.getMessage(ObjectWasNull, objectName));, 	}, 	static ijException resultSetGetWarningsFailed() {, 		return new ijException(LocalizedResource.getMessage(ResultSetGetWarningsFailed));, 	}, 	static ijException scrollCursorsNotSupported() {, 		return new ijException(LocalizedResource.getMessage(ScrollCursorsNotSupported));, 	}, 	static ijException statementGetWarningsFailed() {, 		return new ijException(LocalizedResource.getMessage(StatementGetWarningsFailed));, 	}, 	static ijException waitInterrupted(Throwable t) {, 		return new ijException(LocalizedResource.getMessage(WaitInterrupted, t.toString()));, 	}, 	public static ijException zeroInvalidForAbsolute() {, 		return new ijException(LocalizedResource.getMessage(ZeroInvalidForAbsolute));, 	}, 	public static ijException notAvailableForDriver(String s) {, 		return new ijException(, 			LocalizedResource.getMessage(NotAvailableForDriver, s));],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijExceptionResult.java,,37-45,[	ijExceptionResult(SQLException e) {, 		except = e;, 	}, , 	public boolean isException() { return true; }, 	public SQLException getException() { return except; }, , 	public SQLWarning getSQLWarnings() { return null; }, 	public void clearSQLWarnings() { }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijFatalException.java,,33-55,[	private final static String FatalException = LocalizedResource.getMessage("IJ_FataExceTerm");, 	private SQLException e;, , 	public ijFatalException() , 	{, 		super(FatalException);, 		e = null;, 	}, , 	public ijFatalException(SQLException e) , 	{, 		super(FatalException); , 		this.e = e;, 	}, , 	public String getSQLState(), 	{, 		return e.getSQLState();, 	}, 	, 	public String toString(), 	{, 		return LocalizedResource.getMessage("IJ_Fata01",e.getSQLState(),e.getMessage());],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijMultiResult.java,,43-56,[	ijMultiResult(Statement s, ResultSet rs, boolean c) {, 		statement = s;, 		this.rs = rs;, 		closeWhenDone = c;, 	}, , 	public boolean isMulti() { return true; }, , 	public Statement getStatement() { return statement; }, 	public ResultSet getResultSet() { return rs; }, 	public void closeStatement() throws SQLException { if (closeWhenDone) statement.close(); }, , 	public SQLWarning getSQLWarnings() { return null; }, 	public void clearSQLWarnings() { }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijMultipleResultSetResult.java,,40-116,[public class ijMultipleResultSetResult extends ijResultImpl {, ,     private ArrayList<ResultSet> resultSets = null;, ,     private int[] displayColumns = null;,     private int[] columnWidths = null;, ,     /**,      * Create a ijResultImpl that represents multiple result sets, only,      * displaying a subset of the columns, using specified column widths.,      * ,      * @param resultSets The result sets to display,      * @param display Which column numbers to display, or null to display,      *                all columns.,      * @param widths  The widths of the columns specified in 'display', or,      *                null to display using default column sizes.,      */,     public ijMultipleResultSetResult(List<ResultSet> resultSets, int[] display,,                                      int[] widths) throws SQLException {,         this.resultSets = new ArrayList<ResultSet>();,         this.resultSets.addAll(resultSets);, ,         displayColumns = ToolUtils.copy( display );,         columnWidths   = ToolUtils.copy( widths );,     }, , ,     public void addResultSet(ResultSet rs){,         resultSets.add(rs);,     }, ,     public boolean isMultipleResultSetResult(){,         return true;,     }, ,     public List<ResultSet> getMultipleResultSets() {,         return new ArrayList<ResultSet>(resultSets);,     }, ,     public void closeStatement() throws SQLException {,         if (resultSets != null) {,             ResultSet rs = null;,             for (int i = 0; i<resultSets.size(); i++){,                 rs = resultSets.get(i);,                 if(rs.getStatement() != null) rs.getStatement().close();,                 else rs.close(); ,             },         },     }, ,     public int[] getColumnDisplayList() { return ToolUtils.copy( displayColumns ); },     public int[] getColumnWidthList() { return ToolUtils.copy( columnWidths ); }, ,     /**,      * @return the warnings from all resultsets as one SQLWarning chain,      */,     public SQLWarning getSQLWarnings() throws SQLException { ,         SQLWarning warning = null;,         ResultSet rs = null;,         for (int i=0; i<resultSets.size(); i++){,             rs = resultSets.get(i);,             if (rs.getWarnings() != null) {,                 if (warning == null) warning = rs.getWarnings();,                 else                 warning.setNextWarning(rs.getWarnings());,             },         },         return warning;,     },     ,     /**,      * Clears the warnings in all resultsets,      */,     public void clearSQLWarnings() throws SQLException {,         for (int i=0; i<resultSets.size(); i++){,             (resultSets.get(i)).clearWarnings();,         },     }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijResultImpl.java,,37-81,[abstract class ijResultImpl implements ijResult {, 	public boolean isConnection() { return false; }, 	public boolean isStatement() { return false; }, 	public boolean isResultSet() throws SQLException { return false; }, 	public boolean isUpdateCount() throws SQLException { return false; }, 	public boolean isNextRowOfResultSet() { return false; }, 	public boolean isVector() { return false; }, 	public boolean isMulti() { return false; }, 	public boolean isException() { return false; }, 	public boolean isMultipleResultSetResult(){ return false; }, 	public boolean hasWarnings() throws SQLException { return getSQLWarnings()!=null; }, , 	public Connection getConnection() { return null; }, 	public Statement getStatement() { return null; }, 	public int getUpdateCount() throws SQLException { return -1; }, 	public ResultSet getResultSet() throws SQLException { return null; }, 	public List<ResultSet> getMultipleResultSets() { return null; }, 	public ResultSet getNextRowOfResultSet() { return null; }, 	public Vector getVector() { return null; }, 	public SQLException getException() { return null; }, , 	public int[] getColumnDisplayList() { return null; }, 	public int[] getColumnWidthList() { return null; }, , 	public void closeStatement() throws SQLException { }, , 	public abstract SQLWarning getSQLWarnings() throws SQLException;, 	public abstract void clearSQLWarnings() throws SQLException;, , , 	public String toString() {, 		if (isConnection()) return LocalizedResource.getMessage("IJ_Con0",getConnection().toString());, 		if (isStatement()) return LocalizedResource.getMessage("IJ_Stm0",getStatement().toString());, 		if (isNextRowOfResultSet()) return LocalizedResource.getMessage("IJ_Row0",getNextRowOfResultSet().toString());, 		if (isVector()) return LocalizedResource.getMessage("IJ_Vec0",getVector().toString());, 		if (isMulti()) return LocalizedResource.getMessage("IJ_Mul0",getVector().toString());, 		if (isException()) return LocalizedResource.getMessage("IJ_Exc0",getException().toString());, 		if (isMultipleResultSetResult()), 			return LocalizedResource.getMessage("IJ_MRS0",, 										getMultipleResultSets().toString());, 		try {, 			if (isResultSet()) return LocalizedResource.getMessage("IJ_Rse0",getStatement().toString());, 		} catch(SQLException se) {, 		}, 		return LocalizedResource.getMessage("IJ_Unkn0",this.getClass().getName());],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/tools/ij/ijResultImpl.java,getColumnDisplayList,58-58,[	public int[] getColumnDisplayList() { return null; }],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/tools/ij/ijResultImpl.java,getColumnWidthList,59-59,[	public int[] getColumnWidthList() { return null; }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijResultSetResult.java,,37-82,[public class ijResultSetResult extends ijResultImpl {, , 	private ResultSet resultSet;, 	private Statement statement;, , 	private int[]     displayColumns = null;, 	private int[]     columnWidths = null;, , 	/**, 	 * Create a ijResultImpl that represents a result set., 	 */, 	public ijResultSetResult(ResultSet r) throws SQLException {, 		resultSet = r;, 		statement = resultSet.getStatement();, 	}, , 	/**, 	 * Create a ijResultImpl that represents a result set, only, 	 * displaying a subset of the columns, using specified column widths., 	 * , 	 * @param r The result set to display, 	 * @param display Which column numbers to display, or null to display, 	 *                all columns., 	 * @param widths  The widths of the columns specified in 'display', or, 	 *                null to display using default column sizes., 	 */, 	public ijResultSetResult(ResultSet r, int[] display,, 							 int[] widths) throws SQLException {, 		resultSet = r;, 		statement = resultSet.getStatement();, , 		displayColumns = ToolUtils.copy( display );, 		columnWidths   = ToolUtils.copy( widths );, 	}, , 	public boolean isResultSet() throws SQLException { return statement==null || statement.getUpdateCount() == -1; }, , 	public ResultSet getResultSet() throws SQLException { return resultSet; }, , 	public void closeStatement() throws SQLException { if(statement!=null) statement.close(); else resultSet.close(); }, , 	public int[] getColumnDisplayList() { return ToolUtils.copy( displayColumns ); }, 	public int[] getColumnWidthList() { return ToolUtils.copy( columnWidths ); }, , 	public SQLWarning getSQLWarnings() throws SQLException { return resultSet.getWarnings(); }, 	public void clearSQLWarnings() throws SQLException { resultSet.clearWarnings(); }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijRowResult.java,,42-52,[	public ijRowResult(ResultSet r, boolean hadRow) {, 		rowResult = r;, 		this.hadRow = hadRow;, 	}, , 	public boolean isNextRowOfResultSet() { return true; }, , 	public ResultSet getNextRowOfResultSet() { return hadRow?rowResult:null; }, , 	public SQLWarning getSQLWarnings() throws SQLException { return rowResult.getWarnings(); }, 	public void clearSQLWarnings() throws SQLException { rowResult.clearWarnings(); }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijStatementResult.java,,41-57,[	ijStatementResult(Statement s, boolean c) {, 		statement = s;, 		closeWhenDone = c;, 	}, , 	public boolean isStatement() { return true; }, 	public boolean isResultSet() throws SQLException { return statement.getUpdateCount() == -1; }, 	public boolean isUpdateCount() throws SQLException { return statement.getUpdateCount() >= 0; }, , 	public Statement getStatement() { return statement; }, 	public int getUpdateCount() throws SQLException { return statement.getUpdateCount(); }, 	public ResultSet getResultSet() throws SQLException { return statement.getResultSet(); }, , 	public void closeStatement() throws SQLException { if (closeWhenDone) statement.close(); }, , 	public SQLWarning getSQLWarnings() throws SQLException { return statement.getWarnings(); }, 	public void clearSQLWarnings() throws SQLException { statement.clearWarnings(); }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijTokenException.java,,27-28,[		super(message);, 	}],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/impl/tools/ij/ijTokenManager.java,jjMoveStringLiteralDfa16_0,1497-1497,[   if (((active0 &= old0) | (active1 &= old1)) == 0L)],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijTokenManager.java,,32-2388,[        int commentNestingDepth = 0;,   public  java.io.PrintStream debugStream = System.out;,   public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }, private final int jjStopAtPos(int pos, int kind), {,    jjmatchedKind = kind;,    jjmatchedPos = pos;,    return pos + 1;, }, private final int jjMoveStringLiteralDfa0_0(), {,    switch(curChar),    {,       case 9:,          jjmatchedKind = 2;,          return jjMoveNfa_0(5, 0);,       case 10:,          jjmatchedKind = 4;,          return jjMoveNfa_0(5, 0);,       case 12:,          jjmatchedKind = 6;,          return jjMoveNfa_0(5, 0);,       case 13:,          jjmatchedKind = 5;,          return jjMoveStringLiteralDfa1_0(0x8L, 0x0L);,       case 32:,          jjmatchedKind = 1;,          return jjMoveNfa_0(5, 0);,       case 33:,          jjmatchedKind = 22;,          return jjMoveNfa_0(5, 0);,       case 34:,          jjmatchedKind = 126;,          return jjMoveNfa_0(5, 0);,       case 35:,          jjmatchedKind = 127;,          return jjMoveNfa_0(5, 0);,       case 40:,          jjmatchedKind = 124;,          return jjMoveNfa_0(5, 0);,       case 41:,          jjmatchedKind = 125;,          return jjMoveNfa_0(5, 0);,       case 43:,          jjmatchedKind = 129;,          return jjMoveNfa_0(5, 0);,       case 44:,          jjmatchedKind = 123;,          return jjMoveNfa_0(5, 0);,       case 45:,          jjmatchedKind = 128;,          return jjMoveNfa_0(5, 0);,       case 46:,          jjmatchedKind = 63;,          return jjMoveNfa_0(5, 0);,       case 47:,          return jjMoveStringLiteralDfa1_0(0x100L, 0x0L);,       case 61:,          jjmatchedKind = 37;,          return jjMoveNfa_0(5, 0);,       case 64:,          jjmatchedKind = 122;,          return jjMoveNfa_0(5, 0);,       case 65:,       case 97:,          return jjMoveStringLiteralDfa1_0(0x3fc000L, 0x0L);,       case 66:,       case 98:,          return jjMoveStringLiteralDfa1_0(0x800000L, 0x0L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa1_0(0x7f000000L, 0x1e0000000000000L);,       case 68:,       case 100:,          return jjMoveStringLiteralDfa1_0(0x380000000L, 0x10000000000000L);,       case 69:,       case 101:,          return jjMoveStringLiteralDfa1_0(0xdc00000000L, 0x0L);,       case 70:,       case 102:,          return jjMoveStringLiteralDfa1_0(0x1f0000000000L, 0x0L);,       case 71:,       case 103:,          return jjMoveStringLiteralDfa1_0(0x600000000000L, 0x0L);,       case 72:,       case 104:,          return jjMoveStringLiteralDfa1_0(0x1800000000000L, 0x0L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa1_0(0x1e000000000000L, 0x0L);,       case 76:,       case 108:,          return jjMoveStringLiteralDfa1_0(0x60000000000000L, 0x0L);,       case 77:,       case 109:,          return jjMoveStringLiteralDfa1_0(0x80000000000000L, 0x0L);,       case 78:,       case 110:,          return jjMoveStringLiteralDfa1_0(0xf00000000000000L, 0x0L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa1_0(0x3000000000000000L, 0x0L);,       case 80:,       case 112:,          return jjMoveStringLiteralDfa1_0(0x4000000000000000L, 0x3fL);,       case 81:,       case 113:,          return jjMoveStringLiteralDfa1_0(0x0L, 0x40L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa1_0(0x0L, 0x3f80L);,       case 83:,       case 115:,          return jjMoveStringLiteralDfa1_0(0x0L, 0x1ff8000L);,       case 84:,       case 116:,          return jjMoveStringLiteralDfa1_0(0x0L, 0x2004000L);,       case 85:,       case 117:,          return jjMoveStringLiteralDfa1_0(0x0L, 0xc000000L);,       case 86:,       case 118:,          return jjMoveStringLiteralDfa1_0(0x0L, 0x10000000L);,       case 87:,       case 119:,          return jjMoveStringLiteralDfa1_0(0x0L, 0x200000060000000L);,       case 88:,       case 120:,          return jjMoveStringLiteralDfa1_0(0x0L, 0xfffff80000000L);,       default :,          return jjMoveNfa_0(5, 0);,    }, }, private final int jjMoveStringLiteralDfa1_0(long active0, long active1), {,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 0);,    },    switch(curChar),    {,       case 10:,          if ((active0 & 0x8L) != 0L),          {,             jjmatchedKind = 3;,             jjmatchedPos = 1;,          },          break;,       case 42:,          if ((active0 & 0x100L) != 0L),          {,             jjmatchedKind = 8;,             jjmatchedPos = 1;,          },          break;,       case 65:,       case 97:,          return jjMoveStringLiteralDfa2_0(active0, 0x41a0010000000000L, active1, 0x1fffffa2008000L);,       case 66:,       case 98:,          return jjMoveStringLiteralDfa2_0(active0, 0x4000L, active1, 0L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x30000L);,       case 69:,       case 101:,          return jjMoveStringLiteralDfa2_0(active0, 0x201600080800000L, active1, 0x1c0780L);,       case 70:,       case 102:,          return jjMoveStringLiteralDfa2_0(active0, 0x1000000000008000L, active1, 0L);,       case 72:,       case 104:,          return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x600000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa2_0(active0, 0x20100000000L, active1, 0x50000000L);,       case 76:,       case 108:,          return jjMoveStringLiteralDfa2_0(active0, 0x401030000L, active1, 0L);,       case 78:,       case 110:,          if ((active0 & 0x2000000000000L) != 0L),          {,             jjmatchedKind = 49;,             jjmatchedPos = 1;,          },          else if ((active0 & 0x2000000000000000L) != 0L),          {,             jjmatchedKind = 61;,             jjmatchedPos = 1;,          },          return jjMoveStringLiteralDfa2_0(active0, 0x1c001800000000L, active1, 0L);,       case 79:,       case 111:,          if ((active1 & 0x4000L) != 0L),          {,             jjmatchedKind = 78;,             jjmatchedPos = 1;,          },          return jjMoveStringLiteralDfa2_0(active0, 0xc4084001e000000L, active1, 0x200000000001800L);,       case 80:,       case 112:,          return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x1e0000000000000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa2_0(active0, 0x80200000000L, active1, 0x3fL);,       case 83:,       case 115:,          if ((active0 & 0x40000L) != 0L),          {,             jjmatchedKind = 18;,             jjmatchedPos = 1;,          },          return jjMoveStringLiteralDfa2_0(active0, 0x80000L, active1, 0xc000000L);,       case 84:,       case 116:,          return jjMoveStringLiteralDfa2_0(active0, 0x100000L, active1, 0x800000L);,       case 85:,       case 117:,          return jjMoveStringLiteralDfa2_0(active0, 0x100060200000L, active1, 0x2040L);,       case 88:,       case 120:,          return jjMoveStringLiteralDfa2_0(active0, 0xc000000000L, active1, 0L);,       case 89:,       case 121:,          return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x1000000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 1);, }, private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 1);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 1);,    },    switch(curChar),    {,       case 95:,          return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x1efffff80000000L);,       case 65:,       case 97:,          return jjMoveStringLiteralDfa3_0(active0, 0xc00000000L, active1, 0x800080L);,       case 66:,       case 98:,          return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x2000000L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa3_0(active0, 0x40000000000000L, active1, 0L);,       case 68:,       case 100:,          if ((active0 & 0x1000000000L) != 0L),          {,             jjmatchedKind = 36;,             jjmatchedPos = 2;,          },          return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0L);,       case 69:,       case 101:,          return jjMoveStringLiteralDfa3_0(active0, 0x4000000000L, active1, 0x14000003L);,       case 70:,       case 102:,          if ((active0 & 0x1000000000000000L) != 0L),          {,             jjmatchedKind = 60;,             jjmatchedPos = 2;,          },          return jjMoveStringLiteralDfa3_0(active0, 0x800000L, active1, 0L);,       case 72:,       case 104:,          return jjMoveStringLiteralDfa3_0(active0, 0xc00000000000000L, active1, 0x10000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa3_0(active0, 0x18200010000L, active1, 0x28000040L);,       case 76:,       case 108:,          if ((active0 & 0x20000L) != 0L),          {,             jjmatchedKind = 17;,             jjmatchedPos = 2;,          },          return jjMoveStringLiteralDfa3_0(active0, 0x1800000000000L, active1, 0x1900L);,       case 77:,       case 109:,          return jjMoveStringLiteralDfa3_0(active0, 0x100000002000000L, active1, 0x200L);,       case 78:,       case 110:,          if ((active1 & 0x2000L) != 0L),          {,             jjmatchedKind = 77;,             jjmatchedPos = 2;,          },          return jjMoveStringLiteralDfa3_0(active0, 0x10001c000000L, active1, 0x1040000L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa3_0(active0, 0x80001000000L, active1, 0x20003cL);,       case 82:,       case 114:,          if ((active0 & 0x40000000000L) != 0L),          {,             jjmatchedKind = 42;,             jjmatchedPos = 2;,          },          return jjMoveStringLiteralDfa3_0(active0, 0x20060000000L, active1, 0x200000000020000L);,       case 83:,       case 115:,          return jjMoveStringLiteralDfa3_0(active0, 0x4028000180004000L, active1, 0x400L);,       case 84:,       case 116:,          if ((active0 & 0x200000000000L) != 0L),          {,             jjmatchedKind = 45;,             jjmatchedPos = 2;,          },          else if ((active1 & 0x80000L) != 0L),          {,             jjmatchedKind = 83;,             jjmatchedPos = 2;,          },          return jjMoveStringLiteralDfa3_0(active0, 0x10400000308000L, active1, 0x10000040100000L);,       case 85:,       case 117:,          return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x400000L);,       case 86:,       case 118:,          return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x8000L);,       case 88:,       case 120:,          return jjMoveStringLiteralDfa3_0(active0, 0x280000000000000L, active1, 0L);,       case 89:,       case 121:,          return jjMoveStringLiteralDfa3_0(active0, 0x80000L, active1, 0L);,       default :,          break;,    },    return jjMoveNfa_0(5, 2);, }, private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 2);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 2);,    },    switch(curChar),    {,       case 49:,          return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x80000000L);,       case 50:,          return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100000000L);,       case 65:,       case 97:,          return jjMoveStringLiteralDfa4_0(active0, 0x40000000010000L, active1, 0x10000000000100L);,       case 66:,       case 98:,          return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa4_0(active0, 0x504180000000L, active1, 0x40000c0000000cL);,       case 68:,       case 100:,          if ((active0 & 0x800000000000L) != 0L),          {,             jjmatchedKind = 47;,             jjmatchedPos = 3;,          },          return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x120001200000080L);,       case 69:,       case 101:,          if ((active0 & 0x100000000000000L) != 0L),          {,             jjmatchedKind = 56;,             jjmatchedPos = 3;,          },          return jjMoveStringLiteralDfa4_0(active0, 0xc000000008000L, active1, 0x6000018800L);,       case 70:,       case 102:,          return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x18000000000L);,       case 71:,       case 103:,          return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x80020000000000L);,       case 72:,       case 104:,          if ((active1 & 0x40000000L) != 0L),          {,             jjmatchedKind = 94;,             jjmatchedPos = 3;,          },          break;,       case 73:,       case 105:,          return jjMoveStringLiteralDfa4_0(active0, 0x80000000000000L, active1, 0L);,       case 74:,       case 106:,          return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x40000000000L);,       case 75:,       case 107:,          if ((active1 & 0x200000000000000L) != 0L),          {,             jjmatchedKind = 121;,             jjmatchedPos = 3;,          },          break;,       case 76:,       case 108:,          if ((active0 & 0x10000000000L) != 0L),          {,             jjmatchedKind = 40;,             jjmatchedPos = 3;,          },          return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2001000L);,       case 77:,       case 109:,          if ((active0 & 0x80000000000L) != 0L),          {,             jjmatchedKind = 43;,             jjmatchedPos = 3;,          },          return jjMoveStringLiteralDfa4_0(active0, 0x2000000L, active1, 0L);,       case 78:,       case 110:,          return jjMoveStringLiteralDfa4_0(active0, 0x1c080000L, active1, 0x80008000000L);,       case 79:,       case 111:,          if ((active0 & 0x10000000000000L) != 0L),          {,             jjmatchedKind = 52;,             jjmatchedPos = 3;,          },          return jjMoveStringLiteralDfa4_0(active0, 0xc00000000a04000L, active1, 0x1020600L);,       case 80:,       case 112:,          if ((active0 & 0x1000000000000L) != 0L),          {,             jjmatchedKind = 48;,             jjmatchedPos = 3;,          },          return jjMoveStringLiteralDfa4_0(active0, 0x400000000L, active1, 0x100000000011L);,       case 82:,       case 114:,          if ((active1 & 0x4000000L) != 0L),          {,             jjmatchedKind = 90;,             jjmatchedPos = 3;,          },          return jjMoveStringLiteralDfa4_0(active0, 0x20100000L, active1, 0xe00000000000L);,       case 83:,       case 115:,          return jjMoveStringLiteralDfa4_0(active0, 0x4000020041000000L, active1, 0xf000000040000L);,       case 84:,       case 116:,          if ((active0 & 0x8000000000L) != 0L),          {,             jjmatchedKind = 39;,             jjmatchedPos = 3;,          },          else if ((active0 & 0x20000000000000L) != 0L),          {,             jjmatchedKind = 53;,             jjmatchedPos = 3;,          },          else if ((active0 & 0x200000000000000L) != 0L),          {,             jjmatchedKind = 57;,             jjmatchedPos = 3;,          },          else if ((active1 & 0x40L) != 0L),          {,             jjmatchedKind = 70;,             jjmatchedPos = 3;,          },          else if ((active1 & 0x20000000L) != 0L),          {,             jjmatchedKind = 93;,             jjmatchedPos = 3;,          },          return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0xd00020L);,       case 86:,       case 118:,          return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2L);,       case 87:,       case 119:,          if ((active1 & 0x200000L) != 0L),          {,             jjmatchedKind = 85;,             jjmatchedPos = 3;,          },          return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x10000000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 3);, }, private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 3);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 3);,    },    switch(curChar),    {,       case 65:,       case 97:,          return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x20008200100001L);,       case 66:,       case 98:,          return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x1000L);,       case 67:,       case 99:,          if ((active0 & 0x80000L) != 0L),          {,             jjmatchedKind = 19;,             jjmatchedPos = 4;,          },          return jjMoveStringLiteralDfa5_0(active0, 0x200000L, active1, 0L);,       case 68:,       case 100:,          return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x400000L);,       case 69:,       case 101:,          if ((active0 & 0x1000000L) != 0L),          {,             jjmatchedKind = 24;,             jjmatchedPos = 4;,          },          return jjMoveStringLiteralDfa5_0(active0, 0x23c000000L, active1, 0x8062000280001cL);,       case 71:,       case 103:,          if ((active1 & 0x8000000L) != 0L),          {,             jjmatchedKind = 91;,             jjmatchedPos = 4;,          },          break;,       case 73:,       case 105:,          return jjMoveStringLiteralDfa5_0(active0, 0x2100000L, active1, 0x100001000040002L);,       case 76:,       case 108:,          return jjMoveStringLiteralDfa5_0(active0, 0xc40000800004000L, active1, 0x20000L);,       case 77:,       case 109:,          return jjMoveStringLiteralDfa5_0(active0, 0x80000000000000L, active1, 0x10000L);,       case 78:,       case 110:,          return jjMoveStringLiteralDfa5_0(active0, 0x8000000000000L, active1, 0x6001000000L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa5_0(active0, 0x140000000L, active1, 0x408d0c000000a0L);,       case 80:,       case 112:,          return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x180008000L);,       case 82:,       case 114:,          if ((active0 & 0x8000L) != 0L),          {,             jjmatchedKind = 15;,             jjmatchedPos = 4;,          },          return jjMoveStringLiteralDfa5_0(active0, 0x80800000L, active1, 0x100000000000L);,       case 83:,       case 115:,          if ((active1 & 0x800L) != 0L),          {,             jjmatchedKind = 75;,             jjmatchedPos = 4;,          },          else if ((active1 & 0x10000000L) != 0L),          {,             jjmatchedKind = 92;,             jjmatchedPos = 4;,          },          return jjMoveStringLiteralDfa5_0(active0, 0x400010000L, active1, 0x10000000000000L);,       case 84:,       case 116:,          if ((active0 & 0x20000000000L) != 0L),          {,             jjmatchedKind = 41;,             jjmatchedPos = 4;,          },          return jjMoveStringLiteralDfa5_0(active0, 0x100000000000L, active1, 0x3000000000100L);,       case 85:,       case 117:,          return jjMoveStringLiteralDfa5_0(active0, 0x404000000000L, active1, 0xc000000000400L);,       case 86:,       case 118:,          return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x200L);,       case 87:,       case 119:,          return jjMoveStringLiteralDfa5_0(active0, 0x4000000000000000L, active1, 0L);,       case 88:,       case 120:,          return jjMoveStringLiteralDfa5_0(active0, 0x4000000000000L, active1, 0L);,       default :,          break;,    },    return jjMoveNfa_0(5, 4);, }, private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 4);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 4);,    },    switch(curChar),    {,       case 65:,       case 97:,          return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3000000011000L);,       case 66:,       case 98:,          return jjMoveStringLiteralDfa6_0(active0, 0x100000L, active1, 0x100000L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa6_0(active0, 0x1c000000L, active1, 0x4200000000020L);,       case 68:,       case 100:,          if ((active0 & 0x400000000000000L) != 0L),          {,             jjmatchedKind = 58;,             jjmatchedPos = 5;,          },          else if ((active1 & 0x2000000000L) != 0L),          {,             jjmatchedKind = 101;,             jjmatchedPos = 5;,          },          return jjMoveStringLiteralDfa6_0(active0, 0x800000000000000L, active1, 0x400000000cL);,       case 69:,       case 101:,          if ((active0 & 0x800000L) != 0L),          {,             jjmatchedKind = 23;,             jjmatchedPos = 5;,          },          else if ((active1 & 0x200L) != 0L),          {,             jjmatchedKind = 73;,             jjmatchedPos = 5;,          },          return jjMoveStringLiteralDfa6_0(active0, 0x4000c00010000L, active1, 0x100000000000L);,       case 70:,       case 102:,          return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x80000000000L);,       case 72:,       case 104:,          return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x180000000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa6_0(active0, 0x40100080000000L, active1, 0x48000000100L);,       case 76:,       case 108:,          if ((active1 & 0x20000L) != 0L),          {,             jjmatchedKind = 81;,             jjmatchedPos = 5;,          },          return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x800000000000L);,       case 77:,       case 109:,          return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x800800000L);,       case 78:,       case 110:,          return jjMoveStringLiteralDfa6_0(active0, 0x120000000L, active1, 0x40000400000080L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa6_0(active0, 0x4000000000200000L, active1, 0x10000000408002L);,       case 82:,       case 114:,          if ((active0 & 0x40000000L) != 0L),          {,             jjmatchedKind = 30;,             jjmatchedPos = 5;,          },          else if ((active0 & 0x200000000L) != 0L),          {,             jjmatchedKind = 33;,             jjmatchedPos = 5;,          },          return jjMoveStringLiteralDfa6_0(active0, 0x400000000000L, active1, 0x10000000411L);,       case 83:,       case 115:,          if ((active1 & 0x2000000L) != 0L),          {,             jjmatchedKind = 89;,             jjmatchedPos = 5;,          },          return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000L, active1, 0x108401000000000L);,       case 84:,       case 116:,          if ((active0 & 0x2000000L) != 0L),          {,             jjmatchedKind = 25;,             jjmatchedPos = 5;,          },          return jjMoveStringLiteralDfa6_0(active0, 0x4000000000L, active1, 0xa0020200040000L);,       case 85:,       case 117:,          return jjMoveStringLiteralDfa6_0(active0, 0x80000000004000L, active1, 0L);,       case 89:,       case 121:,          return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x1000000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 5);, }, private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 5);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 5);,    },    switch(curChar),    {,       case 65:,       case 97:,          return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x20000380000000L);,       case 66:,       case 98:,          return jjMoveStringLiteralDfa7_0(active0, 0x80000000L, active1, 0L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x184021000001400L);,       case 68:,       case 100:,          return jjMoveStringLiteralDfa7_0(active0, 0xc00000000L, active1, 0L);,       case 69:,       case 101:,          if ((active0 & 0x4000000000L) != 0L),          {,             jjmatchedKind = 38;,             jjmatchedPos = 6;,          },          else if ((active1 & 0x1L) != 0L),          {,             jjmatchedKind = 64;,             jjmatchedPos = 6;,          },          return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x800000L);,       case 70:,       case 102:,          return jjMoveStringLiteralDfa7_0(active0, 0x800000000000000L, active1, 0L);,       case 71:,       case 103:,          return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x10000000000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa7_0(active0, 0x8000000000000L, active1, 0x48000L);,       case 76:,       case 108:,          if ((active1 & 0x8000000000L) != 0L),          {,             jjmatchedKind = 103;,             jjmatchedPos = 6;,          },          return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x880000100080L);,       case 77:,       case 109:,          return jjMoveStringLiteralDfa7_0(active0, 0x80000000200000L, active1, 0x801000000L);,       case 78:,       case 110:,          if ((active1 & 0x40000000000L) != 0L),          {,             jjmatchedKind = 106;,             jjmatchedPos = 6;,          },          return jjMoveStringLiteralDfa7_0(active0, 0x100000000L, active1, 0x40000400000000L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa7_0(active0, 0x100000000000L, active1, 0x200000000020L);,       case 80:,       case 112:,          return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x8100000000000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa7_0(active0, 0x4000400000000000L, active1, 0x3004000000000L);,       case 83:,       case 115:,          if ((active0 & 0x10000L) != 0L),          {,             jjmatchedKind = 16;,             jjmatchedPos = 6;,          },          else if ((active0 & 0x4000000000000L) != 0L),          {,             jjmatchedKind = 50;,             jjmatchedPos = 6;,          },          else if ((active1 & 0x10000L) != 0L),          {,             jjmatchedKind = 80;,             jjmatchedPos = 6;,          },          break;,       case 84:,       case 116:,          if ((active0 & 0x4000000L) != 0L),          {,             jjmatchedKind = 26;,             jjmatchedPos = 6;,          },          else if ((active0 & 0x20000000L) != 0L),          {,             jjmatchedKind = 29;,             jjmatchedPos = 6;,          },          return jjMoveStringLiteralDfa7_0(active0, 0x18004000L, active1, 0x10L);,       case 85:,       case 117:,          return jjMoveStringLiteralDfa7_0(active0, 0x100000L, active1, 0x1040000000000eL);,       case 86:,       case 118:,          return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x100L);,       case 87:,       case 119:,          return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x400000L);,       case 90:,       case 122:,          return jjMoveStringLiteralDfa7_0(active0, 0x40000000000000L, active1, 0L);,       default :,          break;,    },    return jjMoveNfa_0(5, 6);, }, private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 6);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 6);,    },    switch(curChar),    {,       case 95:,          return jjMoveStringLiteralDfa8_0(active0, 0x800000000L, active1, 0L);,       case 65:,       case 97:,          return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x180000000000L);,       case 66:,       case 98:,          return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x800000000000L);,       case 68:,       case 100:,          if ((active0 & 0x4000000000000000L) != 0L),          {,             jjmatchedKind = 62;,             jjmatchedPos = 7;,          },          return jjMoveStringLiteralDfa8_0(active0, 0x80000000000000L, active1, 0L);,       case 69:,       case 101:,          if ((active0 & 0x4000L) != 0L),          {,             jjmatchedKind = 14;,             jjmatchedPos = 7;,          },          else if ((active0 & 0x80000000L) != 0L),          {,             jjmatchedKind = 31;,             jjmatchedPos = 7;,          },          else if ((active1 & 0x100L) != 0L),          {,             jjmatchedKind = 72;,             jjmatchedPos = 7;,          },          else if ((active1 & 0x400L) != 0L),          {,             jjmatchedKind = 74;,             jjmatchedPos = 7;,          },          return jjMoveStringLiteralDfa8_0(active0, 0x40400100000000L, active1, 0x4c010400100000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa8_0(active0, 0x18000000L, active1, 0x800000010L);,       case 75:,       case 107:,          if ((active1 & 0x1000L) != 0L),          {,             jjmatchedKind = 76;,             jjmatchedPos = 7;,          },          break;,       case 76:,       case 108:,          if ((active1 & 0x20L) != 0L),          {,             jjmatchedKind = 69;,             jjmatchedPos = 7;,          },          break;,       case 77:,       case 109:,          return jjMoveStringLiteralDfa8_0(active0, 0x200000L, active1, 0x400000000000L);,       case 78:,       case 110:,          if ((active1 & 0x400000L) != 0L),          {,             jjmatchedKind = 86;,             jjmatchedPos = 7;,          },          return jjMoveStringLiteralDfa8_0(active0, 0x100000000000L, active1, 0x808000L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa8_0(active0, 0x800000000000000L, active1, 0x180021000000000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1000000000000cL);,       case 83:,       case 115:,          if ((active1 & 0x2L) != 0L),          {,             jjmatchedKind = 65;,             jjmatchedPos = 7;,          },          else if ((active1 & 0x1000000L) != 0L),          {,             jjmatchedKind = 88;,             jjmatchedPos = 7;,          },          return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x20004380000000L);,       case 84:,       case 116:,          if ((active1 & 0x1000000000000L) != 0L),          {,             jjmatchedKind = 112;,             jjmatchedPos = 7;,          },          return jjMoveStringLiteralDfa8_0(active0, 0x8000400100000L, active1, 0x2000000000000L);,       case 86:,       case 118:,          return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x200000040000L);,       case 89:,       case 121:,          if ((active1 & 0x80L) != 0L),          {,             jjmatchedKind = 71;,             jjmatchedPos = 7;,          },          break;,       default :,          break;,    },    return jjMoveNfa_0(5, 7);, }, private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 7);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 7);,    },    switch(curChar),    {,       case 95:,          return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x100000L);,       case 65:,       case 97:,          return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x800000000000L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa9_0(active0, 0x100000000L, active1, 0x50004400000000L);,       case 68:,       case 100:,          return jjMoveStringLiteralDfa9_0(active0, 0x40000000000000L, active1, 0L);,       case 69:,       case 101:,          if ((active1 & 0x4L) != 0L),          {,             jjmatchedKind = 66;,             jjmatchedPos = 8;,          },          else if ((active1 & 0x40000L) != 0L),          {,             jjmatchedKind = 82;,             jjmatchedPos = 8;,          },          else if ((active1 & 0x80000000L) != 0L),          {,             jjmatchedKind = 95;,             jjmatchedPos = 8;,          },          else if ((active1 & 0x100000000L) != 0L),          {,             jjmatchedKind = 96;,             jjmatchedPos = 8;,          },          else if ((active1 & 0x400000000000L) != 0L),          {,             jjmatchedKind = 110;,             jjmatchedPos = 8;,          },          return jjMoveStringLiteralDfa9_0(active0, 0x100000L, active1, 0x200000000018L);,       case 71:,       case 103:,          return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x80000000000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa9_0(active0, 0x88000400200000L, active1, 0L);,       case 78:,       case 110:,          return jjMoveStringLiteralDfa9_0(active0, 0x400000000000L, active1, 0x188021000000000L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa9_0(active0, 0x18000000L, active1, 0x20000200000000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa9_0(active0, 0x800000800000000L, active1, 0x2100000000000L);,       case 83:,       case 115:,          if ((active0 & 0x100000000000L) != 0L),          {,             jjmatchedKind = 44;,             jjmatchedPos = 8;,          },          return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x4000000000000L);,       case 84:,       case 116:,          if ((active1 & 0x8000L) != 0L),          {,             jjmatchedKind = 79;,             jjmatchedPos = 8;,          },          else if ((active1 & 0x800000L) != 0L),          {,             jjmatchedKind = 87;,             jjmatchedPos = 8;,          },          else if ((active1 & 0x800000000L) != 0L),          {,             jjmatchedKind = 99;,             jjmatchedPos = 8;,          },          else if ((active1 & 0x10000000000L) != 0L),          {,             jjmatchedKind = 104;,             jjmatchedPos = 8;,          },          break;,       default :,          break;,    },    return jjMoveNfa_0(5, 8);, }, private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 8);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 8);,    },    switch(curChar),    {,       case 65:,       case 97:,          return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x4000000000L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa10_0(active0, 0x800000000000000L, active1, 0x800000000000L);,       case 68:,       case 100:,          if ((active1 & 0x8000000000000L) != 0L),          {,             jjmatchedKind = 115;,             jjmatchedPos = 9;,          },          return jjMoveStringLiteralDfa10_0(active0, 0x40000000000000L, active1, 0L);,       case 69:,       case 101:,          if ((active1 & 0x100000000000L) != 0L),          {,             jjmatchedKind = 108;,             jjmatchedPos = 9;,          },          else if ((active1 & 0x10000000000000L) != 0L),          {,             jjmatchedKind = 116;,             jjmatchedPos = 9;,          },          break;,       case 77:,       case 109:,          return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L);,       case 78:,       case 110:,          if ((active0 & 0x8000000L) != 0L),          {,             jjmatchedKind = 27;,             jjmatchedPos = 9;,          },          return jjMoveStringLiteralDfa10_0(active0, 0x10000000L, active1, 0x180021000000000L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa10_0(active0, 0x800000000L, active1, 0L);,       case 82:,       case 114:,          if ((active1 & 0x200000000000L) != 0L),          {,             jjmatchedKind = 109;,             jjmatchedPos = 9;,          },          return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x100000L);,       case 83:,       case 115:,          if ((active0 & 0x100000L) != 0L),          {,             jjmatchedKind = 20;,             jjmatchedPos = 9;,          },          else if ((active1 & 0x8L) != 0L),          {,             jjmatchedKind = 67;,             jjmatchedPos = 9;,          },          else if ((active1 & 0x10L) != 0L),          {,             jjmatchedKind = 68;,             jjmatchedPos = 9;,          },          else if ((active1 & 0x80000000000L) != 0L),          {,             jjmatchedKind = 107;,             jjmatchedPos = 9;,          },          else if ((active1 & 0x4000000000000L) != 0L),          {,             jjmatchedKind = 114;,             jjmatchedPos = 9;,          },          return jjMoveStringLiteralDfa10_0(active0, 0x80000000000000L, active1, 0x2000000000000L);,       case 84:,       case 116:,          if ((active0 & 0x200000L) != 0L),          {,             jjmatchedKind = 21;,             jjmatchedPos = 9;,          },          else if ((active0 & 0x100000000L) != 0L),          {,             jjmatchedKind = 32;,             jjmatchedPos = 9;,          },          else if ((active1 & 0x400000000L) != 0L),          {,             jjmatchedKind = 98;,             jjmatchedPos = 9;,          },          else if ((active1 & 0x40000000000000L) != 0L),          {,             jjmatchedKind = 118;,             jjmatchedPos = 9;,          },          return jjMoveStringLiteralDfa10_0(active0, 0x400000000000L, active1, 0L);,       case 85:,       case 117:,          return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x20000200000000L);,       case 86:,       case 118:,          return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000L, active1, 0L);,       default :,          break;,    },    return jjMoveNfa_0(5, 9);, }, private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 9);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 9);,    },    switch(curChar),    {,       case 67:,       case 99:,          return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x2000000000000L);,       case 69:,       case 101:,          if ((active0 & 0x400000000L) != 0L),          {,             jjmatchedKind = 34;,             jjmatchedPos = 10;,          },          else if ((active0 & 0x8000000000000L) != 0L),          {,             jjmatchedKind = 51;,             jjmatchedPos = 10;,          },          return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x180021000000000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L);,       case 75:,       case 107:,          if ((active1 & 0x800000000000L) != 0L),          {,             jjmatchedKind = 111;,             jjmatchedPos = 10;,          },          break;,       case 76:,       case 108:,          return jjMoveStringLiteralDfa11_0(active0, 0x800000000L, active1, 0L);,       case 78:,       case 110:,          if ((active1 & 0x4000000000L) != 0L),          {,             jjmatchedKind = 102;,             jjmatchedPos = 10;,          },          break;,       case 79:,       case 111:,          return jjMoveStringLiteralDfa11_0(active0, 0x800000000000000L, active1, 0x100000L);,       case 80:,       case 112:,          return jjMoveStringLiteralDfa11_0(active0, 0x80000000000000L, active1, 0L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa11_0(active0, 0x400000000000L, active1, 0x20000200000000L);,       case 83:,       case 115:,          if ((active0 & 0x10000000L) != 0L),          {,             jjmatchedKind = 28;,             jjmatchedPos = 10;,          },          break;,       default :,          break;,    },    return jjMoveNfa_0(5, 10);, }, private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 10);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 10);,    },    switch(curChar),    {,       case 65:,       case 97:,          return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x2000000000000L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1a0021200000000L);,       case 69:,       case 101:,          return jjMoveStringLiteralDfa12_0(active0, 0x800000000L, active1, 0L);,       case 76:,       case 108:,          return jjMoveStringLiteralDfa12_0(active0, 0x80000000000000L, active1, 0x100000L);,       case 78:,       case 110:,          return jjMoveStringLiteralDfa12_0(active0, 0x800000000000000L, active1, 0L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa12_0(active0, 0x400000000000L, active1, 0L);,       case 83:,       case 115:,          return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L);,       default :,          break;,    },    return jjMoveNfa_0(5, 11);, }, private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 11);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 11);,    },    switch(curChar),    {,       case 65:,       case 97:,          return jjMoveStringLiteralDfa13_0(active0, 0x80000000000000L, active1, 0L);,       case 69:,       case 101:,          if ((active1 & 0x200000000L) != 0L),          {,             jjmatchedKind = 97;,             jjmatchedPos = 12;,          },          else if ((active1 & 0x20000000000000L) != 0L),          {,             jjmatchedKind = 117;,             jjmatchedPos = 12;,          },          return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x100000L);,       case 78:,       case 110:,          if ((active1 & 0x2000000000000L) != 0L),          {,             jjmatchedKind = 113;,             jjmatchedPos = 12;,          },          return jjMoveStringLiteralDfa13_0(active0, 0x800000000000000L, active1, 0L);,       case 80:,       case 112:,          return jjMoveStringLiteralDfa13_0(active0, 0x40000000000000L, active1, 0L);,       case 83:,       case 115:,          if ((active0 & 0x800000000L) != 0L),          {,             jjmatchedKind = 35;,             jjmatchedPos = 12;,          },          break;,       case 84:,       case 116:,          if ((active1 & 0x1000000000L) != 0L),          {,             jjmatchedKind = 100;,             jjmatchedPos = 12;,          },          else if ((active1 & 0x100000000000000L) != 0L),          {,             jjmatchedKind = 120;,             jjmatchedPos = 12;,          },          return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x80020000000000L);,       case 87:,       case 119:,          return jjMoveStringLiteralDfa13_0(active0, 0x400000000000L, active1, 0L);,       default :,          break;,    },    return jjMoveNfa_0(5, 12);, }, private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 12);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 12);,    },    switch(curChar),    {,       case 69:,       case 101:,          return jjMoveStringLiteralDfa14_0(active0, 0x800000000000000L, active1, 0L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa14_0(active0, 0L, active1, 0x80020000000000L);,       case 76:,       case 108:,          return jjMoveStringLiteralDfa14_0(active0, 0x40000000000000L, active1, 0L);,       case 78:,       case 110:,          return jjMoveStringLiteralDfa14_0(active0, 0x400000000000L, active1, 0L);,       case 83:,       case 115:,          if ((active1 & 0x100000L) != 0L),          {,             jjmatchedKind = 84;,             jjmatchedPos = 13;,          },          break;,       case 89:,       case 121:,          return jjMoveStringLiteralDfa14_0(active0, 0x80000000000000L, active1, 0L);,       default :,          break;,    },    return jjMoveNfa_0(5, 13);, }, private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 13);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 13);,    },    switch(curChar),    {,       case 65:,       case 97:,          return jjMoveStringLiteralDfa15_0(active0, 0x40000000000000L, active1, 0L);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa15_0(active0, 0x800000000000000L, active1, 0L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa15_0(active0, 0L, active1, 0x80020000000000L);,       case 85:,       case 117:,          return jjMoveStringLiteralDfa15_0(active0, 0x400000000000L, active1, 0L);,       case 87:,       case 119:,          return jjMoveStringLiteralDfa15_0(active0, 0x80000000000000L, active1, 0L);,       default :,          break;,    },    return jjMoveNfa_0(5, 14);, }, private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 14);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 14);,    },    switch(curChar),    {,       case 73:,       case 105:,          return jjMoveStringLiteralDfa16_0(active0, 0x80000000000000L, active1, 0L);,       case 77:,       case 109:,          return jjMoveStringLiteralDfa16_0(active0, 0x400000000000L, active1, 0L);,       case 78:,       case 110:,          if ((active1 & 0x20000000000L) != 0L),          {,             jjmatchedKind = 105;,             jjmatchedPos = 15;,          },          else if ((active1 & 0x80000000000000L) != 0L),          {,             jjmatchedKind = 119;,             jjmatchedPos = 15;,          },          break;,       case 84:,       case 116:,          return jjMoveStringLiteralDfa16_0(active0, 0x800000000000000L, active1, 0L);,       case 89:,       case 121:,          if ((active0 & 0x40000000000000L) != 0L),          {,             jjmatchedKind = 54;,             jjmatchedPos = 15;,          },          break;,       default :,          break;,    },    return jjMoveNfa_0(5, 15);, }, private final int jjMoveStringLiteralDfa16_0(long old0, long active0, long old1, long active1), {,    if (((active0 &= old0) | (active1 &= old1)) == 0L),       return jjMoveNfa_0(5, 15);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 15);,    },    switch(curChar),    {,       case 66:,       case 98:,          return jjMoveStringLiteralDfa17_0(active0, 0x400000000000L);,       case 68:,       case 100:,          return jjMoveStringLiteralDfa17_0(active0, 0x80000000000000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa17_0(active0, 0x800000000000000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 16);, }, private final int jjMoveStringLiteralDfa17_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 16);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 16);,    },    switch(curChar),    {,       case 69:,       case 101:,          return jjMoveStringLiteralDfa18_0(active0, 0x400000000000L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa18_0(active0, 0x800000000000000L);,       case 84:,       case 116:,          return jjMoveStringLiteralDfa18_0(active0, 0x80000000000000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 17);, }, private final int jjMoveStringLiteralDfa18_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 17);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 17);,    },    switch(curChar),    {,       case 72:,       case 104:,          if ((active0 & 0x80000000000000L) != 0L),          {,             jjmatchedKind = 55;,             jjmatchedPos = 18;,          },          break;,       case 78:,       case 110:,          if ((active0 & 0x800000000000000L) != 0L),          {,             jjmatchedKind = 59;,             jjmatchedPos = 18;,          },          break;,       case 82:,       case 114:,          if ((active0 & 0x400000000000L) != 0L),          {,             jjmatchedKind = 46;,             jjmatchedPos = 18;,          },          break;,       default :,          break;,    },    return jjMoveNfa_0(5, 18);, }, private final void jjCheckNAdd(int state), {,    if (jjrounds[state] != jjround),    {,       jjstateSet[jjnewStateCnt++] = state;,       jjrounds[state] = jjround;,    }, }, private final void jjAddStates(int start, int end), {,    do {,       jjstateSet[jjnewStateCnt++] = jjnextStates[start];,    } while (start++ != end);, }, private final void jjCheckNAddTwoStates(int state1, int state2), {,    jjCheckNAdd(state1);,    jjCheckNAdd(state2);, }, private final void jjCheckNAddStates(int start, int end), {,    do {,       jjCheckNAdd(jjnextStates[start]);,    } while (start++ != end);, }, private final void jjCheckNAddStates(int start), {,    jjCheckNAdd(jjnextStates[start]);,    jjCheckNAdd(jjnextStates[start + 1]);, }, static final long[] jjbitVec0 = {,    0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, };, static final long[] jjbitVec2 = {,    0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, };, static final long[] jjbitVec3 = {,    0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x12000000007fffffL, };, static final long[] jjbitVec4 = {,    0x0L, 0x0L, 0x420040000000000L, 0xff7fffffff7fffffL, };, static final long[] jjbitVec5 = {,    0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfc3fffffffffffffL, };, static final long[] jjbitVec6 = {,    0xffffffL, 0xffffffffffff0000L, 0xf9ff01ffffffffffL, 0x1f00030003L, };, static final long[] jjbitVec7 = {,    0x0L, 0x400000000000000L, 0xfffffffbffffd740L, 0xffffffc7f7fffL, };, static final long[] jjbitVec8 = {,    0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL, };, static final long[] jjbitVec9 = {,    0xfffe000000000000L, 0xfffffffe027fffffL, 0xffL, 0x707ffffff0000L, };, static final long[] jjbitVec10 = {,    0x7fffffe00000000L, 0xfffe0000000007ffL, 0x7cffffffffffffffL, 0x60002f7fffL, };, static final long[] jjbitVec11 = {,    0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L, };, static final long[] jjbitVec12 = {,    0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L, };, static final long[] jjbitVec13 = {,    0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L, };, static final long[] jjbitVec14 = {,    0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L, };, static final long[] jjbitVec15 = {,    0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L, };, static final long[] jjbitVec16 = {,    0xd7ffffffffffeL, 0x7fL, 0x200d6caefef02596L, 0x3000005fL, };, static final long[] jjbitVec17 = {,    0x0L, 0x3fffffffeffL, 0x0L, 0x0L, };, static final long[] jjbitVec18 = {,    0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL, };, static final long[] jjbitVec19 = {,    0xffffffffffffffffL, 0xffffffff83ffffffL, 0xffffff07ffffffffL, 0x3ffffffffffffffL, };, static final long[] jjbitVec20 = {,    0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL, };, static final long[] jjbitVec21 = {,    0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL, };, static final long[] jjbitVec22 = {,    0x0L, 0x8000000000000000L, 0x0L, 0x0L, };, static final long[] jjbitVec23 = {,    0x1fbfd503f2ffc84L, 0x0L, 0x0L, 0x0L, };, static final long[] jjbitVec24 = {,    0x3fffffffffL, 0x0L, 0x0L, 0x0L, };, static final long[] jjbitVec25 = {,    0x3e000000000020L, 0xfffffffffffffffeL, 0xfffffffe781fffffL, 0x77ffffffffffffffL, };, static final long[] jjbitVec26 = {,    0xfffe1fffffffffe0L, 0xffffffffffffffffL, 0x7fffL, 0x0L, };, static final long[] jjbitVec27 = {,    0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L, };, static final long[] jjbitVec28 = {,    0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L, };, static final long[] jjbitVec29 = {,    0x3fffffffffffL, 0x0L, 0x0L, 0x0L, };, static final long[] jjbitVec30 = {,    0x5f7ffdff80f8007fL, 0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L, };, static final long[] jjbitVec31 = {,    0x3fffffffffffffffL, 0xffffffffffff0000L, 0xfffffffffffcffffL, 0xfff0000000000ffL, };, static final long[] jjbitVec32 = {,    0x0L, 0xffd7000000000000L, 0xffffffffffffffffL, 0x1fffffffffffffffL, };, static final long[] jjbitVec33 = {,    0x7fffffe00000000L, 0xffffffc007fffffeL, 0x7fffffffffffffffL, 0x1cfcfcfcL, };, static final long[] jjbitVec34 = {,    0x7fffffe00000000L, 0xfffe03ff000007ffL, 0x7cffffffffffffffL, 0x3ff0060002f7fffL, };, static final long[] jjbitVec35 = {,    0x23ffffffffffffe0L, 0xffc3ff000000L, 0x3c5fdfffff99fe0L, 0x3ffc3b0000000L, };, static final long[] jjbitVec36 = {,    0x36dfdfffff987e0L, 0x1cffc05e000000L, 0x23edfdfffffbafe0L, 0xffc100000000L, };, static final long[] jjbitVec37 = {,    0x23cdfdfffff99fe0L, 0xffc3b0000000L, 0x3bfc718d63dc7e0L, 0xff8000000000L, };, static final long[] jjbitVec38 = {,    0x3effdfffffddfe0L, 0xffc300000000L, 0x3effdfffffddfe0L, 0xffc340000000L, };, static final long[] jjbitVec39 = {,    0x3fffdfffffddfe0L, 0xffc300000000L, 0x0L, 0x0L, };, static final long[] jjbitVec40 = {,    0xd7ffffffffffeL, 0x3ff007fL, 0x200d6caefef02596L, 0x33ff005fL, };, static final long[] jjbitVec41 = {,    0x3ff00000000L, 0x3fffffffeffL, 0x0L, 0x0L, };, static final long[] jjbitVec42 = {,    0x7fffffe03ff0000L, 0xffffffc007fffffeL, 0x7fffffffffffffffL, 0x1cfcfcfcL, };, private final int jjMoveNfa_0(int startState, int curPos), {,    int strKind = jjmatchedKind;,    int strPos = jjmatchedPos;,    int seenUpto;,    input_stream.backup(seenUpto = curPos + 1);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { throw new Error("Internal Error"); },    curPos = 0;,    int[] nextStates;,    int startsAt = 0;,    jjnewStateCnt = 14;,    int i = 1;,    jjstateSet[0] = startState;,    int j, kind = 0x7fffffff;,    for (;;),    {,       if (++jjround == 0x7fffffff),          ReInitRounds();,       if (curChar < 64),       {,          long l = 1L << curChar;,          MatchLoop: do,          {,             switch(jjstateSet[--i]),             {,                case 5:,                   if ((0x3ff000000000000L & l) != 0L),                   {,                      if (kind > 133),                         kind = 133;,                      jjCheckNAdd(8);,                   },                   else if (curChar == 39),                      jjCheckNAddStates(0, 2);,                   else if (curChar == 45),                      jjstateSet[jjnewStateCnt++] = 0;,                   break;,                case 0:,                   if (curChar == 45),                      jjCheckNAddStates(3, 5);,                   break;,                case 1:,                   if ((0xffffffffffffdbffL & l) != 0L),                      jjCheckNAddStates(3, 5);,                   break;,                case 2:,                   if ((0x2400L & l) != 0L && kind > 7),                      kind = 7;,                   break;,                case 3:,                   if (curChar == 10 && kind > 7),                      kind = 7;,                   break;,                case 4:,                   if (curChar == 13),                      jjstateSet[jjnewStateCnt++] = 3;,                   break;,                case 7:,                   if ((0x3ff000000000000L & l) == 0L),                      break;,                   if (kind > 130),                      kind = 130;,                   jjstateSet[jjnewStateCnt++] = 7;,                   break;,                case 8:,                   if ((0x3ff000000000000L & l) == 0L),                      break;,                   if (kind > 133),                      kind = 133;,                   jjCheckNAdd(8);,                   break;,                case 9:,                case 10:,                   if (curChar == 39),                      jjCheckNAddStates(0, 2);,                   break;,                case 11:,                   if (curChar == 39),                      jjstateSet[jjnewStateCnt++] = 10;,                   break;,                case 12:,                   if ((0xffffff7fffffffffL & l) != 0L),                      jjCheckNAddStates(0, 2);,                   break;,                case 13:,                   if (curChar == 39 && kind > 134),                      kind = 134;,                   break;,                default : break;,             },          } while(i != startsAt);,       },       else if (curChar < 128),       {,          long l = 1L << (curChar & 077);,          MatchLoop: do,          {,             switch(jjstateSet[--i]),             {,                case 5:,                case 7:,                   if ((0x7fffffe87fffffeL & l) == 0L),                      break;,                   if (kind > 130),                      kind = 130;,                   jjCheckNAdd(7);,                   break;,                case 1:,                   jjAddStates(3, 5);,                   break;,                case 12:,                   jjAddStates(0, 2);,                   break;,                default : break;,             },          } while(i != startsAt);,       },       else,       {,          int hiByte = (int)(curChar >> 8);,          int i1 = hiByte >> 6;,          long l1 = 1L << (hiByte & 077);,          int i2 = (curChar & 0xff) >> 6;,          long l2 = 1L << (curChar & 077);,          MatchLoop: do,          {,             switch(jjstateSet[--i]),             {,                case 5:,                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2)),                      break;,                   if (kind > 130),                      kind = 130;,                   jjCheckNAdd(7);,                   break;,                case 1:,                   if (jjCanMove_0(hiByte, i1, i2, l1, l2)),                      jjAddStates(3, 5);,                   break;,                case 7:,                   if (!jjCanMove_2(hiByte, i1, i2, l1, l2)),                      break;,                   if (kind > 130),                      kind = 130;,                   jjCheckNAdd(7);,                   break;,                case 12:,                   if (jjCanMove_0(hiByte, i1, i2, l1, l2)),                      jjAddStates(0, 2);,                   break;,                default : break;,             },          } while(i != startsAt);,       },       if (kind != 0x7fffffff),       {,          jjmatchedKind = kind;,          jjmatchedPos = curPos;,          kind = 0x7fffffff;,       },       ++curPos;,       if ((i = jjnewStateCnt) == (startsAt = 14 - (jjnewStateCnt = startsAt))),          break;,       try { curChar = input_stream.readChar(); },       catch(java.io.IOException e) { break; },    },    if (jjmatchedPos > strPos),       return curPos;, ,    int toRet = Math.max(curPos, seenUpto);, ,    if (curPos < toRet),       for (i = toRet - Math.min(curPos, seenUpto); i-- > 0; ),          try { curChar = input_stream.readChar(); },          catch(java.io.IOException e) { throw new Error("Internal Error : Please send a bug report."); }, ,    if (jjmatchedPos < strPos),    {,       jjmatchedKind = strKind;,       jjmatchedPos = strPos;,    },    else if (jjmatchedPos == strPos && jjmatchedKind > strKind),       jjmatchedKind = strKind;, ,    return toRet;, }, private final int jjMoveStringLiteralDfa0_2(), {,    switch(curChar),    {,       case 42:,          return jjMoveStringLiteralDfa1_2(0x1000L);,       case 47:,          return jjMoveStringLiteralDfa1_2(0x800L);,       default :,          return 1;,    }, }, private final int jjMoveStringLiteralDfa1_2(long active0), {,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,       return 1;,    },    switch(curChar),    {,       case 42:,          if ((active0 & 0x800L) != 0L),             return jjStopAtPos(1, 11);,          break;,       case 47:,          if ((active0 & 0x1000L) != 0L),             return jjStopAtPos(1, 12);,          break;,       default :,          return 2;,    },    return 2;, }, private final int jjMoveStringLiteralDfa0_1(), {,    switch(curChar),    {,       case 42:,          return jjMoveStringLiteralDfa1_1(0x400L);,       case 47:,          return jjMoveStringLiteralDfa1_1(0x200L);,       default :,          return 1;,    }, }, private final int jjMoveStringLiteralDfa1_1(long active0), {,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,       return 1;,    },    switch(curChar),    {,       case 42:,          if ((active0 & 0x200L) != 0L),             return jjStopAtPos(1, 9);,          break;,       case 47:,          if ((active0 & 0x400L) != 0L),             return jjStopAtPos(1, 10);,          break;,       default :,          return 2;,    },    return 2;, }, static final int[] jjnextStates = {,    11, 12, 13, 1, 2, 4, , };, private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2), {,    switch(hiByte),    {,       case 0:,          return ((jjbitVec2[i2] & l2) != 0L);,       default : ,          if ((jjbitVec0[i1] & l1) != 0L),             return true;,          return false;,    }, }, private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2), {,    switch(hiByte),    {,       case 0:,          return ((jjbitVec4[i2] & l2) != 0L);,       case 1:,          return ((jjbitVec5[i2] & l2) != 0L);,       case 2:,          return ((jjbitVec6[i2] & l2) != 0L);,       case 3:,          return ((jjbitVec7[i2] & l2) != 0L);,       case 4:,          return ((jjbitVec8[i2] & l2) != 0L);,       case 5:,          return ((jjbitVec9[i2] & l2) != 0L);,       case 6:,          return ((jjbitVec10[i2] & l2) != 0L);,       case 9:,          return ((jjbitVec11[i2] & l2) != 0L);,       case 10:,          return ((jjbitVec12[i2] & l2) != 0L);,       case 11:,          return ((jjbitVec13[i2] & l2) != 0L);,       case 12:,          return ((jjbitVec14[i2] & l2) != 0L);,       case 13:,          return ((jjbitVec15[i2] & l2) != 0L);,       case 14:,          return ((jjbitVec16[i2] & l2) != 0L);,       case 15:,          return ((jjbitVec17[i2] & l2) != 0L);,       case 16:,          return ((jjbitVec18[i2] & l2) != 0L);,       case 17:,          return ((jjbitVec19[i2] & l2) != 0L);,       case 30:,          return ((jjbitVec20[i2] & l2) != 0L);,       case 31:,          return ((jjbitVec21[i2] & l2) != 0L);,       case 32:,          return ((jjbitVec22[i2] & l2) != 0L);,       case 33:,          return ((jjbitVec23[i2] & l2) != 0L);,       case 45:,          return ((jjbitVec24[i2] & l2) != 0L);,       case 48:,          return ((jjbitVec25[i2] & l2) != 0L);,       case 49:,          return ((jjbitVec26[i2] & l2) != 0L);,       case 159:,          return ((jjbitVec27[i2] & l2) != 0L);,       case 215:,          return ((jjbitVec28[i2] & l2) != 0L);,       case 250:,          return ((jjbitVec29[i2] & l2) != 0L);,       case 251:,          return ((jjbitVec30[i2] & l2) != 0L);,       case 253:,          return ((jjbitVec31[i2] & l2) != 0L);,       case 254:,          return ((jjbitVec32[i2] & l2) != 0L);,       case 255:,          return ((jjbitVec33[i2] & l2) != 0L);,       default : ,          if ((jjbitVec3[i1] & l1) != 0L),             return true;,          return false;,    }, }, private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2), {,    switch(hiByte),    {,       case 0:,          return ((jjbitVec4[i2] & l2) != 0L);,       case 1:,          return ((jjbitVec5[i2] & l2) != 0L);,       case 2:,          return ((jjbitVec6[i2] & l2) != 0L);,       case 3:,          return ((jjbitVec7[i2] & l2) != 0L);,       case 4:,          return ((jjbitVec8[i2] & l2) != 0L);,       case 5:,          return ((jjbitVec9[i2] & l2) != 0L);,       case 6:,          return ((jjbitVec34[i2] & l2) != 0L);,       case 9:,          return ((jjbitVec35[i2] & l2) != 0L);,       case 10:,          return ((jjbitVec36[i2] & l2) != 0L);,       case 11:,          return ((jjbitVec37[i2] & l2) != 0L);,       case 12:,          return ((jjbitVec38[i2] & l2) != 0L);,       case 13:,          return ((jjbitVec39[i2] & l2) != 0L);,       case 14:,          return ((jjbitVec40[i2] & l2) != 0L);,       case 15:,          return ((jjbitVec41[i2] & l2) != 0L);,       case 16:,          return ((jjbitVec18[i2] & l2) != 0L);,       case 17:,          return ((jjbitVec19[i2] & l2) != 0L);,       case 30:,          return ((jjbitVec20[i2] & l2) != 0L);,       case 31:,          return ((jjbitVec21[i2] & l2) != 0L);,       case 32:,          return ((jjbitVec22[i2] & l2) != 0L);,       case 33:,          return ((jjbitVec23[i2] & l2) != 0L);,       case 45:,          return ((jjbitVec24[i2] & l2) != 0L);,       case 48:,          return ((jjbitVec25[i2] & l2) != 0L);,       case 49:,          return ((jjbitVec26[i2] & l2) != 0L);,       case 159:,          return ((jjbitVec27[i2] & l2) != 0L);,       case 215:,          return ((jjbitVec28[i2] & l2) != 0L);,       case 250:,          return ((jjbitVec29[i2] & l2) != 0L);,       case 251:,          return ((jjbitVec30[i2] & l2) != 0L);,       case 253:,          return ((jjbitVec31[i2] & l2) != 0L);,       case 254:,          return ((jjbitVec32[i2] & l2) != 0L);,       case 255:,          return ((jjbitVec42[i2] & l2) != 0L);,       default : ,          if ((jjbitVec3[i1] & l1) != 0L),             return true;,          return false;,    }, }, public static final String[] jjstrLiteralImages = {, "", null, null, null, null, null, null, null, null, null, null, null, null, , null, null, null, null, null, null, null, null, null, "\41", null, null, null, null, , null, null, null, null, null, null, null, null, null, null, "\75", null, null, null, , null, null, null, null, null, null, null, null, null, null, null, null, null, null, , null, null, null, null, null, null, null, null, "\56", null, null, null, null, null, , null, null, null, null, null, null, null, null, null, null, null, null, null, null, , null, null, null, null, null, null, null, null, null, null, null, null, null, null, , null, null, null, null, null, null, null, null, null, null, null, null, null, null, , null, null, null, null, null, null, null, null, null, null, null, "\100", "\54", , "\50", "\51", "\42", "\43", "\55", "\53", null, null, null, null, null, };, public static final String[] lexStateNames = {,    "DEFAULT", ,    "IN_BRACKETED_COMMENT", ,    "IN_NESTED_BRACKETED_COMMENT", , };, public static final int[] jjnewLexState = {,    -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, ,    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, ,    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, ,    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, ,    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, ,    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, , };, static final long[] jjtoToken = {,    0xffffffffffffc001L, 0xffffffffffffffffL, 0x67L, , };, static final long[] jjtoSkip = {,    0x4feL, 0x0L, 0x0L, , };, static final long[] jjtoSpecial = {,    0x80L, 0x0L, 0x0L, , };, static final long[] jjtoMore = {,    0x3b00L, 0x0L, 0x0L, , };, protected CharStream input_stream;, private final int[] jjrounds = new int[14];, private final int[] jjstateSet = new int[28];, StringBuffer image;, int jjimageLen;, int lengthOfMatch;, protected char curChar;, public ijTokenManager(CharStream stream){,    input_stream = stream;, }, public ijTokenManager(CharStream stream, int lexState){,    this(stream);,    SwitchTo(lexState);, }, public void ReInit(CharStream stream), {,    jjmatchedPos = jjnewStateCnt = 0;,    curLexState = defaultLexState;,    input_stream = stream;,    ReInitRounds();, }, private final void ReInitRounds(), {,    int i;,    jjround = 0x80000001;,    for (i = 14; i-- > 0;),       jjrounds[i] = 0x80000000;, }, public void ReInit(CharStream stream, int lexState), {,    ReInit(stream);,    SwitchTo(lexState);, }, public void SwitchTo(int lexState), {,    if (lexState >= 3 || lexState < 0),       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);,    else,       curLexState = lexState;, }, , protected Token jjFillToken(), {,    Token t = Token.newToken(jjmatchedKind);,    t.kind = jjmatchedKind;,    String im = jjstrLiteralImages[jjmatchedKind];,    t.image = (im == null) ? input_stream.GetImage() : im;,    t.beginLine = input_stream.getBeginLine();,    t.beginColumn = input_stream.getBeginColumn();,    t.endLine = input_stream.getEndLine();,    t.endColumn = input_stream.getEndColumn();,    return t;, }, , int curLexState = 0;, int defaultLexState = 0;, int jjnewStateCnt;, int jjround;, int jjmatchedPos;, int jjmatchedKind;, , public Token getNextToken() , {,   int kind;,   Token specialToken = null;,   Token matchedToken;,   int curPos = 0;, ,   EOFLoop :,   for (;;),   {   ,    try   ,    {     ,       curChar = input_stream.BeginToken();,    }     ,    catch(java.io.IOException e),    {        ,       jjmatchedKind = 0;,       matchedToken = jjFillToken();,       matchedToken.specialToken = specialToken;,       return matchedToken;,    },    image = null;,    jjimageLen = 0;, ,    for (;;),    {,      switch(curLexState),      {,        case 0:,          jjmatchedKind = 0x7fffffff;,          jjmatchedPos = 0;,          curPos = jjMoveStringLiteralDfa0_0();,          break;,        case 1:,          jjmatchedKind = 0x7fffffff;,          jjmatchedPos = 0;,          curPos = jjMoveStringLiteralDfa0_1();,          if (jjmatchedPos == 0 && jjmatchedKind > 13),          {,             jjmatchedKind = 13;,          },          break;,        case 2:,          jjmatchedKind = 0x7fffffff;,          jjmatchedPos = 0;,          curPos = jjMoveStringLiteralDfa0_2();,          if (jjmatchedPos == 0 && jjmatchedKind > 13),          {,             jjmatchedKind = 13;,          },          break;,      },      if (jjmatchedKind != 0x7fffffff),      {,         if (jjmatchedPos + 1 < curPos),            input_stream.backup(curPos - jjmatchedPos - 1);,         if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L),         {,            matchedToken = jjFillToken();,            matchedToken.specialToken = specialToken;,        if (jjnewLexState[jjmatchedKind] != -1),          curLexState = jjnewLexState[jjmatchedKind];,            return matchedToken;,         },         else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L),         {,            if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L),            {,               matchedToken = jjFillToken();,               if (specialToken == null),                  specialToken = matchedToken;,               else,               {,                  matchedToken.specialToken = specialToken;,                  specialToken = (specialToken.next = matchedToken);,               },            },          if (jjnewLexState[jjmatchedKind] != -1),            curLexState = jjnewLexState[jjmatchedKind];,            continue EOFLoop;,         },         MoreLexicalActions();,       if (jjnewLexState[jjmatchedKind] != -1),         curLexState = jjnewLexState[jjmatchedKind];,         curPos = 0;,         jjmatchedKind = 0x7fffffff;,         try {,            curChar = input_stream.readChar();,            continue;,         },         catch (java.io.IOException e1) { },      },      int error_line = input_stream.getEndLine();,      int error_column = input_stream.getEndColumn();,      String error_after = null;,      boolean EOFSeen = false;,      try { input_stream.readChar(); input_stream.backup(1); },      catch (java.io.IOException e1) {,         EOFSeen = true;,         error_after = curPos <= 1 ? "" : input_stream.GetImage();,         if (curChar == '\n' || curChar == '\r') {,            error_line++;,            error_column = 0;,         },         else,            error_column++;,      },      if (!EOFSeen) {,         input_stream.backup(1);,         error_after = curPos <= 1 ? "" : input_stream.GetImage();,      },      throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);,    },   }, }, , void MoreLexicalActions(), {,    jjimageLen += (lengthOfMatch = jjmatchedPos + 1);,    switch(jjmatchedKind),    {,       case 9 :,          if (image == null),             image = new StringBuffer();,          image.append(input_stream.GetSuffix(jjimageLen));,          jjimageLen = 0;,                commentNestingDepth = 1;,          break;,       case 11 :,          if (image == null),             image = new StringBuffer();,          image.append(input_stream.GetSuffix(jjimageLen));,          jjimageLen = 0;,                commentNestingDepth++;,          break;,       case 12 :,          if (image == null),             image = new StringBuffer();,          image.append(input_stream.GetSuffix(jjimageLen));,          jjimageLen = 0;,           commentNestingDepth--; SwitchTo(commentNestingDepth == 0 ? IN_BRACKETED_COMMENT : IN_NESTED_BRACKETED_COMMENT);,          break;,       default : ,          break;,    }, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijTokenManager.java,MoreLexicalActions,2361-2388,[   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);,    switch(jjmatchedKind),    {,       case 9 :,          if (image == null),             image = new StringBuffer();,          image.append(input_stream.GetSuffix(jjimageLen));,          jjimageLen = 0;,                commentNestingDepth = 1;,          break;,       case 11 :,          if (image == null),             image = new StringBuffer();,          image.append(input_stream.GetSuffix(jjimageLen));,          jjimageLen = 0;,                commentNestingDepth++;,          break;,       case 12 :,          if (image == null),             image = new StringBuffer();,          image.append(input_stream.GetSuffix(jjimageLen));,          jjimageLen = 0;,           commentNestingDepth--; SwitchTo(commentNestingDepth == 0 ? IN_BRACKETED_COMMENT : IN_NESTED_BRACKETED_COMMENT);,          break;,       default : ,          break;,    }, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijTokenManager.java,ReInit,2198-2202,[   jjmatchedPos = jjnewStateCnt = 0;,    curLexState = defaultLexState;,    input_stream = stream;,    ReInitRounds();, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijTokenManager.java,ReInit,2212-2214,[   ReInit(stream);,    SwitchTo(lexState);, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijTokenManager.java,ReInitRounds,2206-2209,[   jjround = 0x80000001;,    for (i = 14; i-- > 0;),       jjrounds[i] = 0x80000000;, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijTokenManager.java,SwitchTo,2217-2221,[   if (lexState >= 3 || lexState < 0),       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);,    else,       curLexState = lexState;, }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/tools/ij/ijTokenManager.java,getNextToken,2269-2291,[     switch(curLexState),      {,        case 0:,          jjmatchedKind = 0x7fffffff;,          jjmatchedPos = 0;,          curPos = jjMoveStringLiteralDfa0_0();,          break;,        case 1:,          jjmatchedKind = 0x7fffffff;,          jjmatchedPos = 0;,          curPos = jjMoveStringLiteralDfa0_1();,          if (jjmatchedPos == 0 && jjmatchedKind > 13),          {,             jjmatchedKind = 13;,          },          break;,        case 2:,          jjmatchedKind = 0x7fffffff;,          jjmatchedPos = 0;,          curPos = jjMoveStringLiteralDfa0_2();,          if (jjmatchedPos == 0 && jjmatchedKind > 13),          {,             jjmatchedKind = 13;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/tools/ij/ijTokenManager.java,jjCheckNAddStates,1609-1611,[   jjCheckNAdd(jjnextStates[start]);,    jjCheckNAdd(jjnextStates[start + 1]);, }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/tools/ij/ijTokenManager.java,jjCheckNAddTwoStates,1598-1600,[   jjCheckNAdd(state1);,    jjCheckNAdd(state2);, }],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/tools/ij/ijTokenManager.java,,2361-2361,[   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/tools/ij/ijTokenManager.java,,34-34,[  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/tools/ij/ijVectorResult.java,<init>,53-53,[		this(new Integer(value), w);],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijVectorResult.java,,36-62,[	ijVectorResult(Vector<Object> v, SQLWarning w) {, 		vec = v;, 		warns = w;, 	}, , 	/**, 	 * Initialize a new vector containing only one object., 	 */, 	ijVectorResult(Object value, SQLWarning w) {, 		this(new Vector<Object>(1), w);, 		vec.add(value);, 	}, , 	/**, 	 * Initialize a new vector containing only one integer value., 	 */, 	ijVectorResult(int value, SQLWarning w) {, 		this(new Integer(value), w);, 	}, , , 	public boolean isVector() { return true; }, , 	public Vector getVector() { return vec; }, , 	public SQLWarning getSQLWarnings() { return warns; }, 	public void clearSQLWarnings() { warns = null; }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/ijWarningResult.java,,41-46,[	ijWarningResult(SQLWarning w) {, 		warn = w;, 	}, , 	public SQLWarning getSQLWarnings() { return warn; }, 	public void clearSQLWarnings() { warn = null; }],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,,644-681,[	{, 		format_id = xid;, 		global_id = id;, 		branch_id = id;, 		, 	},     /**,      * Obtain the format id part of the Xid.,      * <p>,      *,      * @return Format identifier. O means the OSI CCR format.,      **/,     public int getFormatId(),     {,         return(format_id);,     }, ,     /**,      * Obtain the global transaction identifier part of XID as an array of ,      * bytes.,      * <p>,      *, 	 * @return A byte array containing the global transaction identifier.,      **/,     public byte[] getGlobalTransactionId(),     {,         return(global_id);,     }, ,     /**,      * Obtain the transaction branch qualifier part of the Xid in a byte array.,      * <p>,      *, 	 * @return A byte array containing the branch qualifier of the transaction.,      **/,     public byte[] getBranchQualifier(),     {,         return(branch_id);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/tools/ij/mtGrammar.java,getError,268-268,[                errorList.put(s, new Integer(0));],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammar.java,,14-613,[        mtGrammar() { }, , //, // start of BNF rules, //,   final public mtTestSuite grammarStatement() throws ParseException {,         Vector cases = null;,         Vector init = null;,         Vector last = null;,         int     threads = 0;,         mtTime time;,     threads = numThreads();,     time = runTime();,     switch (jj_nt.kind) {,     case INIT:,       init = init();,       break;,     default:,       jj_la1[0] = jj_gen;,       ;,     },     cases = cases();,     switch (jj_nt.kind) {,     case LAST:,       last = last();,       break;,     default:,       jj_la1[1] = jj_gen;,       ;,     },     jj_consume_token(0);,                 {if (true) return new mtTestSuite(threads, time, init, cases, last);},     throw new Error("Missing return statement in function");,   }, ,   final public int numThreads() throws ParseException {,         Token   t;,     jj_consume_token(THREADS);,     t = jj_consume_token(INT);,                 int val = Integer.decode(t.image).intValue();,                 {if (true) return val;},     throw new Error("Missing return statement in function");,   }, ,   final public mtTime runTime() throws ParseException {,         mtTime time;,     jj_consume_token(RUNTIME);,     time = time();,                 {if (true) return time;},     throw new Error("Missing return statement in function");,   }, ,   final public Vector cases() throws ParseException {,         Vector<mtTestCase> testCases = new Vector<mtTestCase>(5);,     label_1:,     while (true) {,       testCase(testCases);,       switch (jj_nt.kind) {,       case CASE:,         ;,         break;,       default:,         jj_la1[2] = jj_gen;,         break label_1;,       },     },                 {if (true) return testCases;},     throw new Error("Missing return statement in function");,   }, ,   final public void testCase(Vector<mtTestCase> testCases) throws ParseException {,         Token   t;,         mtTestCase testCase = new mtTestCase();,     jj_consume_token(CASE);,     t = jj_consume_token(WORD);,     caseInfo(testCase);,                 testCase.setName(t.image);,                 testCases.addElement(testCase);,   }, ,   final public Vector<mtTestCase> init() throws ParseException {,         Vector<mtTestCase> testCases = new Vector<mtTestCase>(5);,     label_2:,     while (true) {,       initCase(testCases);,       switch (jj_nt.kind) {,       case INIT:,         ;,         break;,       default:,         jj_la1[3] = jj_gen;,         break label_2;,       },     },                 {if (true) return testCases;},     throw new Error("Missing return statement in function");,   }, ,   final public void initCase(Vector<mtTestCase> testCases) throws ParseException {,         Token   t;,         mtTestCase testCase = new mtTestCase();,     jj_consume_token(INIT);,     t = jj_consume_token(WORD);,     caseInfo(testCase);,                 testCase.setName(t.image);,                 testCases.addElement(testCase);,   }, ,   final public Vector last() throws ParseException {,         Vector<mtTestCase> testCases = new Vector<mtTestCase>(1);,     label_3:,     while (true) {,       lastCase(testCases);,       switch (jj_nt.kind) {,       case LAST:,         ;,         break;,       default:,         jj_la1[4] = jj_gen;,         break label_3;,       },     },                 {if (true) return testCases;},     throw new Error("Missing return statement in function");,   }, ,   final public void lastCase(Vector<mtTestCase> testCases) throws ParseException {,         Token   t;,         mtTestCase testCase = new mtTestCase();,     jj_consume_token(LAST);,     t = jj_consume_token(WORD);,     caseInfo(testCase);,                 testCase.setName(t.image);,                 testCases.addElement(testCase);,   }, ,   final public void caseInfo(mtTestCase testCase) throws ParseException {,         String  file;,         String  prop = null;,         int     weight = 50;,         Hashtable<String,Integer> errorList = null;,         String  description = null;,     file = scriptFile();,                 testCase.setFile(file);,     switch (jj_nt.kind) {,     case PROPERTIES:,       prop = propFile();,       break;,     default:,       jj_la1[5] = jj_gen;,       ;,     },                 testCase.setPropFile(prop);,     switch (jj_nt.kind) {,     case WEIGHT:,       weight = weight();,       break;,     default:,       jj_la1[6] = jj_gen;,       ;,     },                 testCase.setWeight(weight);,     switch (jj_nt.kind) {,     case IGNOREERRORS:,       errorList = ignoreErrors();,       break;,     default:,       jj_la1[7] = jj_gen;,       ;,     },                 if (errorList == null),                         errorList = new Hashtable<String,Integer>();, ,                 testCase.setIgnoreErrors(errorList);,     switch (jj_nt.kind) {,     case DESCRIPTION:,       description = description();,       break;,     default:,       jj_la1[8] = jj_gen;,       ;,     },                 testCase.setDescription(description);,   }, ,   final public String scriptFile() throws ParseException {,         Token   t;,     jj_consume_token(FILE);,     t = jj_consume_token(WORD);,                 {if (true) return t.image;},     throw new Error("Missing return statement in function");,   }, ,   final public String propFile() throws ParseException {,         Token   t;,     jj_consume_token(PROPERTIES);,     t = jj_consume_token(WORD);,                 {if (true) return t.image;},     throw new Error("Missing return statement in function");,   }, ,   final public int weight() throws ParseException {,         Token   t;,     jj_consume_token(WEIGHT);,     t = jj_consume_token(INT);,                 int val = Integer.decode(t.image).intValue();,                 if (val > 100 || val < 1),                 {,                         System.out.println("LINE "+t.beginLine +": Weight '"+t.image,                                                         +"' is invalid, must be between 1..100",                                                         +" -- defaulting to 50.");,                         val = 50;,                 },                 {if (true) return val;},     throw new Error("Missing return statement in function");,   }, ,   final public String description() throws ParseException {,         Token   t;,     jj_consume_token(DESCRIPTION);,     t = jj_consume_token(STRING);,                 {if (true) return t.image;},     throw new Error("Missing return statement in function");,   }, ,   final public Hashtable<String,Integer> ignoreErrors() throws ParseException {,         // note: we need a non-null errorlist even,         // if there is nothing in it,         Hashtable<String,Integer> errorList = new Hashtable<String,Integer>();,     jj_consume_token(IGNOREERRORS);,     getError(errorList);,     label_4:,     while (true) {,       switch (jj_nt.kind) {,       case COMMA:,         ;,         break;,       default:,         jj_la1[9] = jj_gen;,         break label_4;,       },       jj_consume_token(COMMA);,       getError(errorList);,     },                 {if (true) return errorList;},     throw new Error("Missing return statement in function");,   }, ,   final public void getError(Hashtable<String,Integer> errorList) throws ParseException {,         String  s;,     s = word_or_int();,                 if (errorList == null),                 {,                 },                 errorList.put(s, new Integer(0));,   }, ,   final public String word_or_int() throws ParseException {,         Token   t;,     switch (jj_nt.kind) {,     case WORD:,       t = jj_consume_token(WORD);,                 {if (true) return t.image;},       break;,     case INT:,       t = jj_consume_token(INT);,                 {if (true) return t.image;},       break;,     default:,       jj_la1[10] = jj_gen;,       jj_consume_token(-1);,       throw new ParseException();,     },     throw new Error("Missing return statement in function");,   }, , /*, ** Possible formats:, **, ** 	HH:MM:SS, ** 	   MM:SS, ** 	      SS, */,   final public mtTime time() throws ParseException {,         Token h, m, s;,     if (jj_2_1(4)) {,       h = jj_consume_token(INT);,       jj_consume_token(COLON);,       m = jj_consume_token(INT);,       jj_consume_token(COLON);,       s = jj_consume_token(INT);,                 {if (true) return new mtTime(,                                 Integer.decode(h.image).intValue(),,                                 Integer.decode(m.image).intValue(),,                                 Integer.decode(s.image).intValue());},     } else if (jj_2_2(2)) {,       m = jj_consume_token(INT);,       jj_consume_token(COLON);,       s = jj_consume_token(INT);,                 {if (true) return new mtTime(,                                 0,,                                 Integer.decode(m.image).intValue(),,                                 Integer.decode(s.image).intValue());},     } else {,       switch (jj_nt.kind) {,       case INT:,         s = jj_consume_token(INT);,                 {if (true) return new mtTime(,                                 0,,                                 0,,                                 Integer.decode(s.image).intValue());},         break;,       default:,         jj_la1[11] = jj_gen;,         jj_consume_token(-1);,         throw new ParseException();,       },     },     throw new Error("Missing return statement in function");,   }, ,   final private boolean jj_2_1(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_1(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(0, xla); },   }, ,   final private boolean jj_2_2(int xla) {,     jj_la = xla; jj_lastpos = jj_scanpos = token;,     try { return !jj_3_2(); },     catch(LookaheadSuccess ls) { return true; },     finally { jj_save(1, xla); },   }, ,   final private boolean jj_3_1() {,     if (jj_scan_token(INT)) return true;,     if (jj_scan_token(COLON)) return true;,     if (jj_scan_token(INT)) return true;,     if (jj_scan_token(COLON)) return true;,     return false;,   }, ,   final private boolean jj_3_2() {,     if (jj_scan_token(INT)) return true;,     if (jj_scan_token(COLON)) return true;,     return false;,   }, ,   public mtGrammarTokenManager token_source;,   SimpleCharStream jj_input_stream;,   public Token token, jj_nt;,   private Token jj_scanpos, jj_lastpos;,   private int jj_la;,   public boolean lookingAhead = false;,   private boolean jj_semLA;,   private int jj_gen;,   final private int[] jj_la1 = new int[12];,   static private int[] jj_la1_0;,   static {,       jj_la1_0();,    },    private static void jj_la1_0() {,       jj_la1_0 = new int[] {0x2000,0x1000,0x400,0x2000,0x1000,0x20000,0x4000,0x10000,0x8000,0x800000,0x300000,0x100000,};,    },   final private JJCalls[] jj_2_rtns = new JJCalls[2];,   private boolean jj_rescan = false;,   private int jj_gc = 0;, ,   public mtGrammar(java.io.InputStream stream) {,      this(stream, null);,   },   public mtGrammar(java.io.InputStream stream, String encoding) {,     try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); },     token_source = new mtGrammarTokenManager(jj_input_stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 12; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public void ReInit(java.io.InputStream stream) {,      ReInit(stream, null);,   },   public void ReInit(java.io.InputStream stream, String encoding) {,     try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); },     token_source.ReInit(jj_input_stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 12; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public mtGrammar(java.io.Reader stream) {,     jj_input_stream = new SimpleCharStream(stream, 1, 1);,     token_source = new mtGrammarTokenManager(jj_input_stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 12; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public void ReInit(java.io.Reader stream) {,     jj_input_stream.ReInit(stream, 1, 1);,     token_source.ReInit(jj_input_stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 12; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public mtGrammar(mtGrammarTokenManager tm) {,     token_source = tm;,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 12; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   public void ReInit(mtGrammarTokenManager tm) {,     token_source = tm;,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 12; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }, ,   final private Token jj_consume_token(int kind) throws ParseException {,     Token oldToken = token;,     if ((token = jj_nt).next != null) jj_nt = jj_nt.next;,     else jj_nt = jj_nt.next = token_source.getNextToken();,     if (token.kind == kind) {,       jj_gen++;,       if (++jj_gc > 100) {,         jj_gc = 0;,         for (int i = 0; i < jj_2_rtns.length; i++) {,           JJCalls c = jj_2_rtns[i];,           while (c != null) {,             if (c.gen < jj_gen) c.first = null;,             c = c.next;,           },         },       },       return token;,     },     jj_nt = token;,     token = oldToken;,     jj_kind = kind;,     throw generateParseException();,   }, ,   static private final class LookaheadSuccess extends java.lang.Error { },   final private LookaheadSuccess jj_ls = new LookaheadSuccess();,   final private boolean jj_scan_token(int kind) {,     if (jj_scanpos == jj_lastpos) {,       jj_la--;,       if (jj_scanpos.next == null) {,         jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();,       } else {,         jj_lastpos = jj_scanpos = jj_scanpos.next;,       },     } else {,       jj_scanpos = jj_scanpos.next;,     },     if (jj_rescan) {,       int i = 0; Token tok = token;,       while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; },       if (tok != null) jj_add_error_token(kind, i);,     },     if (jj_scanpos.kind != kind) return true;,     if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;,     return false;,   }, ,   final public Token getNextToken() {,     if ((token = jj_nt).next != null) jj_nt = jj_nt.next;,     else jj_nt = jj_nt.next = token_source.getNextToken();,     jj_gen++;,     return token;,   }, ,   final public Token getToken(int index) {,     Token t = lookingAhead ? jj_scanpos : token;,     for (int i = 0; i < index; i++) {,       if (t.next != null) t = t.next;,       else t = t.next = token_source.getNextToken();,     },     return t;,   }, ,   private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();,   private int[] jj_expentry;,   private int jj_kind = -1;,   private int[] jj_lasttokens = new int[100];,   private int jj_endpos;, ,   private void jj_add_error_token(int kind, int pos) {,     if (pos >= 100) return;,     if (pos == jj_endpos + 1) {,       jj_lasttokens[jj_endpos++] = kind;,     } else if (jj_endpos != 0) {,       jj_expentry = new int[jj_endpos];,       for (int i = 0; i < jj_endpos; i++) {,         jj_expentry[i] = jj_lasttokens[i];,       },       boolean exists = false;,       for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {,         int[] oldentry = (int[])(e.nextElement());,         if (oldentry.length == jj_expentry.length) {,           exists = true;,           for (int i = 0; i < jj_expentry.length; i++) {,             if (oldentry[i] != jj_expentry[i]) {,               exists = false;,               break;,             },           },           if (exists) break;,         },       },       if (!exists) jj_expentries.addElement(jj_expentry);,       if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;,     },   }, ,   public ParseException generateParseException() {,     jj_expentries.removeAllElements();,     boolean[] la1tokens = new boolean[25];,     for (int i = 0; i < 25; i++) {,       la1tokens[i] = false;,     },     if (jj_kind >= 0) {,       la1tokens[jj_kind] = true;,       jj_kind = -1;,     },     for (int i = 0; i < 12; i++) {,       if (jj_la1[i] == jj_gen) {,         for (int j = 0; j < 32; j++) {,           if ((jj_la1_0[i] & (1<<j)) != 0) {,             la1tokens[j] = true;,           },         },       },     },     for (int i = 0; i < 25; i++) {,       if (la1tokens[i]) {,         jj_expentry = new int[1];,         jj_expentry[0] = i;,         jj_expentries.addElement(jj_expentry);,       },     },     jj_endpos = 0;,     jj_rescan_token();,     jj_add_error_token(0, 0);,     int[][] exptokseq = new int[jj_expentries.size()][];,     for (int i = 0; i < jj_expentries.size(); i++) {,       exptokseq[i] = (int[])jj_expentries.elementAt(i);,     },     return new ParseException(token, exptokseq, mtGrammarConstants.tokenImage);,   }, ,   final public void enable_tracing() {,   }, ,   final public void disable_tracing() {,   }, ,   final private void jj_rescan_token() {,     jj_rescan = true;,     for (int i = 0; i < 2; i++) {,     try {,       JJCalls p = jj_2_rtns[i];,       do {,         if (p.gen > jj_gen) {,           jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;,           switch (i) {,             case 0: jj_3_1(); break;,             case 1: jj_3_2(); break;,           },         },         p = p.next;,       } while (p != null);,       } catch(LookaheadSuccess ls) { },     },     jj_rescan = false;,   }, ,   final private void jj_save(int index, int xla) {,     JJCalls p = jj_2_rtns[index];,     while (p.gen > jj_gen) {,       if (p.next == null) { p = p.next = new JJCalls(); break; },       p = p.next;,     },     p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammar.java,ReInit,397-398,[     ReInit(stream, null);,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammar.java,ReInit,400-407,[    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); },     token_source.ReInit(jj_input_stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 12; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammar.java,ReInit,420-427,[    jj_input_stream.ReInit(stream, 1, 1);,     token_source.ReInit(jj_input_stream);,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 12; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammar.java,ReInit,439-445,[    token_source = tm;,     token = new Token();,     token.next = jj_nt = token_source.getNextToken();,     jj_gen = 0;,     for (int i = 0; i < 12; i++) jj_la1[i] = -1;,     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();,   }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/tools/ij/mtGrammar.java,jj_rescan_token,594-596,[          switch (i) {,             case 0: jj_3_1(); break;,             case 1: jj_3_2(); break;],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/derby/impl/tools/ij/mtGrammar.java,getError,265-265,[                if (errorList == null)],,
MALICIOUS_CODE,MS_OOI_PKGPROTECT,org/apache/derby/impl/tools/ij/mtGrammarConstants.java,,28-28,[  String[] tokenImage = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,,746-746,[public static final String[] jjstrLiteralImages = {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,,749-749,[public static final String[] lexStateNames = {],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,,10-891,[  public  java.io.PrintStream debugStream = System.out;,   public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }, private final int jjStopAtPos(int pos, int kind), {,    jjmatchedKind = kind;,    jjmatchedPos = pos;,    return pos + 1;, }, private final int jjMoveStringLiteralDfa0_0(), {,    switch(curChar),    {,       case 9:,          jjmatchedKind = 2;,          return jjMoveNfa_0(5, 0);,       case 10:,          jjmatchedKind = 4;,          return jjMoveNfa_0(5, 0);,       case 12:,          jjmatchedKind = 6;,          return jjMoveNfa_0(5, 0);,       case 13:,          jjmatchedKind = 5;,          return jjMoveStringLiteralDfa1_0(0x8L);,       case 32:,          jjmatchedKind = 1;,          return jjMoveNfa_0(5, 0);,       case 44:,          jjmatchedKind = 23;,          return jjMoveNfa_0(5, 0);,       case 58:,          jjmatchedKind = 24;,          return jjMoveNfa_0(5, 0);,       case 67:,       case 99:,          return jjMoveStringLiteralDfa1_0(0x400L);,       case 68:,       case 100:,          return jjMoveStringLiteralDfa1_0(0x8000L);,       case 70:,       case 102:,          return jjMoveStringLiteralDfa1_0(0x800L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa1_0(0x12000L);,       case 76:,       case 108:,          return jjMoveStringLiteralDfa1_0(0x1000L);,       case 80:,       case 112:,          return jjMoveStringLiteralDfa1_0(0x20000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa1_0(0x80000L);,       case 84:,       case 116:,          return jjMoveStringLiteralDfa1_0(0x40000L);,       case 87:,       case 119:,          return jjMoveStringLiteralDfa1_0(0x4000L);,       default :,          return jjMoveNfa_0(5, 0);,    }, }, private final int jjMoveStringLiteralDfa1_0(long active0), {,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 0);,    },    switch(curChar),    {,       case 10:,          if ((active0 & 0x8L) != 0L),          {,             jjmatchedKind = 3;,             jjmatchedPos = 1;,          },          break;,       case 65:,       case 97:,          return jjMoveStringLiteralDfa2_0(active0, 0x1400L);,       case 69:,       case 101:,          return jjMoveStringLiteralDfa2_0(active0, 0xc000L);,       case 71:,       case 103:,          return jjMoveStringLiteralDfa2_0(active0, 0x10000L);,       case 72:,       case 104:,          return jjMoveStringLiteralDfa2_0(active0, 0x40000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa2_0(active0, 0x800L);,       case 78:,       case 110:,          return jjMoveStringLiteralDfa2_0(active0, 0x2000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa2_0(active0, 0x20000L);,       case 85:,       case 117:,          return jjMoveStringLiteralDfa2_0(active0, 0x80000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 1);, }, private final int jjMoveStringLiteralDfa2_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 1);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 1);,    },    switch(curChar),    {,       case 73:,       case 105:,          return jjMoveStringLiteralDfa3_0(active0, 0x6000L);,       case 76:,       case 108:,          return jjMoveStringLiteralDfa3_0(active0, 0x800L);,       case 78:,       case 110:,          return jjMoveStringLiteralDfa3_0(active0, 0x90000L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa3_0(active0, 0x20000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa3_0(active0, 0x40000L);,       case 83:,       case 115:,          return jjMoveStringLiteralDfa3_0(active0, 0x9400L);,       default :,          break;,    },    return jjMoveNfa_0(5, 2);, }, private final int jjMoveStringLiteralDfa3_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 2);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 2);,    },    switch(curChar),    {,       case 67:,       case 99:,          return jjMoveStringLiteralDfa4_0(active0, 0x8000L);,       case 69:,       case 101:,          return jjMoveStringLiteralDfa4_0(active0, 0x40c00L);,       case 71:,       case 103:,          return jjMoveStringLiteralDfa4_0(active0, 0x4000L);,       case 79:,       case 111:,          return jjMoveStringLiteralDfa4_0(active0, 0x10000L);,       case 80:,       case 112:,          return jjMoveStringLiteralDfa4_0(active0, 0x20000L);,       case 84:,       case 116:,          return jjMoveStringLiteralDfa4_0(active0, 0x83000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 3);, }, private final int jjMoveStringLiteralDfa4_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 3);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 3);,    },    switch(curChar),    {,       case 58:,          if ((active0 & 0x400L) != 0L),          {,             jjmatchedKind = 10;,             jjmatchedPos = 4;,          },          else if ((active0 & 0x800L) != 0L),          {,             jjmatchedKind = 11;,             jjmatchedPos = 4;,          },          else if ((active0 & 0x1000L) != 0L),          {,             jjmatchedKind = 12;,             jjmatchedPos = 4;,          },          else if ((active0 & 0x2000L) != 0L),          {,             jjmatchedKind = 13;,             jjmatchedPos = 4;,          },          break;,       case 65:,       case 97:,          return jjMoveStringLiteralDfa5_0(active0, 0x40000L);,       case 69:,       case 101:,          return jjMoveStringLiteralDfa5_0(active0, 0x20000L);,       case 72:,       case 104:,          return jjMoveStringLiteralDfa5_0(active0, 0x4000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa5_0(active0, 0x80000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa5_0(active0, 0x18000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 4);, }, private final int jjMoveStringLiteralDfa5_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 4);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 4);,    },    switch(curChar),    {,       case 68:,       case 100:,          return jjMoveStringLiteralDfa6_0(active0, 0x40000L);,       case 69:,       case 101:,          return jjMoveStringLiteralDfa6_0(active0, 0x10000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa6_0(active0, 0x8000L);,       case 77:,       case 109:,          return jjMoveStringLiteralDfa6_0(active0, 0x80000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa6_0(active0, 0x20000L);,       case 84:,       case 116:,          return jjMoveStringLiteralDfa6_0(active0, 0x4000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 5);, }, private final int jjMoveStringLiteralDfa6_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 5);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 5);,    },    switch(curChar),    {,       case 58:,          if ((active0 & 0x4000L) != 0L),          {,             jjmatchedKind = 14;,             jjmatchedPos = 6;,          },          break;,       case 69:,       case 101:,          return jjMoveStringLiteralDfa7_0(active0, 0x90000L);,       case 80:,       case 112:,          return jjMoveStringLiteralDfa7_0(active0, 0x8000L);,       case 83:,       case 115:,          return jjMoveStringLiteralDfa7_0(active0, 0x40000L);,       case 84:,       case 116:,          return jjMoveStringLiteralDfa7_0(active0, 0x20000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 6);, }, private final int jjMoveStringLiteralDfa7_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 6);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 6);,    },    switch(curChar),    {,       case 58:,          if ((active0 & 0x40000L) != 0L),          {,             jjmatchedKind = 18;,             jjmatchedPos = 7;,          },          else if ((active0 & 0x80000L) != 0L),          {,             jjmatchedKind = 19;,             jjmatchedPos = 7;,          },          break;,       case 73:,       case 105:,          return jjMoveStringLiteralDfa8_0(active0, 0x20000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa8_0(active0, 0x10000L);,       case 84:,       case 116:,          return jjMoveStringLiteralDfa8_0(active0, 0x8000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 7);, }, private final int jjMoveStringLiteralDfa8_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 7);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 7);,    },    switch(curChar),    {,       case 69:,       case 101:,          return jjMoveStringLiteralDfa9_0(active0, 0x20000L);,       case 73:,       case 105:,          return jjMoveStringLiteralDfa9_0(active0, 0x8000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa9_0(active0, 0x10000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 8);, }, private final int jjMoveStringLiteralDfa9_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 8);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 8);,    },    switch(curChar),    {,       case 79:,       case 111:,          return jjMoveStringLiteralDfa10_0(active0, 0x18000L);,       case 83:,       case 115:,          return jjMoveStringLiteralDfa10_0(active0, 0x20000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 9);, }, private final int jjMoveStringLiteralDfa10_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 9);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 9);,    },    switch(curChar),    {,       case 58:,          if ((active0 & 0x20000L) != 0L),          {,             jjmatchedKind = 17;,             jjmatchedPos = 10;,          },          break;,       case 78:,       case 110:,          return jjMoveStringLiteralDfa11_0(active0, 0x8000L);,       case 82:,       case 114:,          return jjMoveStringLiteralDfa11_0(active0, 0x10000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 10);, }, private final int jjMoveStringLiteralDfa11_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 10);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 10);,    },    switch(curChar),    {,       case 58:,          if ((active0 & 0x8000L) != 0L),          {,             jjmatchedKind = 15;,             jjmatchedPos = 11;,          },          break;,       case 83:,       case 115:,          return jjMoveStringLiteralDfa12_0(active0, 0x10000L);,       default :,          break;,    },    return jjMoveNfa_0(5, 11);, }, private final int jjMoveStringLiteralDfa12_0(long old0, long active0), {,    if (((active0 &= old0)) == 0L),       return jjMoveNfa_0(5, 11);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) {,    return jjMoveNfa_0(5, 11);,    },    switch(curChar),    {,       case 58:,          if ((active0 & 0x10000L) != 0L),          {,             jjmatchedKind = 16;,             jjmatchedPos = 12;,          },          break;,       default :,          break;,    },    return jjMoveNfa_0(5, 12);, }, private final void jjCheckNAdd(int state), {,    if (jjrounds[state] != jjround),    {,       jjstateSet[jjnewStateCnt++] = state;,       jjrounds[state] = jjround;,    }, }, private final void jjAddStates(int start, int end), {,    do {,       jjstateSet[jjnewStateCnt++] = jjnextStates[start];,    } while (start++ != end);, }, private final void jjCheckNAddTwoStates(int state1, int state2), {,    jjCheckNAdd(state1);,    jjCheckNAdd(state2);, }, private final void jjCheckNAddStates(int start, int end), {,    do {,       jjCheckNAdd(jjnextStates[start]);,    } while (start++ != end);, }, private final void jjCheckNAddStates(int start), {,    jjCheckNAdd(jjnextStates[start]);,    jjCheckNAdd(jjnextStates[start + 1]);, }, static final long[] jjbitVec0 = {,    0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, };, static final long[] jjbitVec2 = {,    0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, };, private final int jjMoveNfa_0(int startState, int curPos), {,    int strKind = jjmatchedKind;,    int strPos = jjmatchedPos;,    int seenUpto;,    input_stream.backup(seenUpto = curPos + 1);,    try { curChar = input_stream.readChar(); },    catch(java.io.IOException e) { throw new Error("Internal Error"); },    curPos = 0;,    int[] nextStates;,    int startsAt = 0;,    jjnewStateCnt = 22;,    int i = 1;,    jjstateSet[0] = startState;,    int j, kind = 0x7fffffff;,    for (;;),    {,       if (++jjround == 0x7fffffff),          ReInitRounds();,       if (curChar < 64),       {,          long l = 1L << curChar;,          MatchLoop: do,          {,             switch(jjstateSet[--i]),             {,                case 5:,                   if ((0x3ffc01000000000L & l) != 0L),                   {,                      if (kind > 21),                         kind = 21;,                      jjCheckNAdd(18);,                   },                   else if (curChar == 34),                      jjCheckNAdd(20);,                   else if (curChar == 35),                      jjCheckNAddStates(0, 2);,                   else if (curChar == 45),                      jjstateSet[jjnewStateCnt++] = 0;,                   if ((0x3ff000000000000L & l) != 0L),                   {,                      if (kind > 20),                         kind = 20;,                      jjCheckNAdd(17);,                   },                   else if (curChar == 47),                      jjstateSet[jjnewStateCnt++] = 6;,                   break;,                case 0:,                   if (curChar == 45),                      jjCheckNAddStates(3, 5);,                   break;,                case 1:,                   if ((0xffffffffffffdbffL & l) != 0L),                      jjCheckNAddStates(3, 5);,                   break;,                case 2:,                   if ((0x2400L & l) != 0L && kind > 7),                      kind = 7;,                   break;,                case 3:,                   if (curChar == 10 && kind > 7),                      kind = 7;,                   break;,                case 4:,                   if (curChar == 13),                      jjstateSet[jjnewStateCnt++] = 3;,                   break;,                case 6:,                   if (curChar == 47),                      jjCheckNAddStates(6, 8);,                   break;,                case 7:,                   if ((0xffffffffffffdbffL & l) != 0L),                      jjCheckNAddStates(6, 8);,                   break;,                case 8:,                   if ((0x2400L & l) != 0L && kind > 8),                      kind = 8;,                   break;,                case 9:,                   if (curChar == 10 && kind > 8),                      kind = 8;,                   break;,                case 10:,                   if (curChar == 13),                      jjstateSet[jjnewStateCnt++] = 9;,                   break;,                case 11:,                   if (curChar == 47),                      jjstateSet[jjnewStateCnt++] = 6;,                   break;,                case 12:,                   if (curChar == 35),                      jjCheckNAddStates(0, 2);,                   break;,                case 13:,                   if ((0xffffffffffffdbffL & l) != 0L),                      jjCheckNAddStates(0, 2);,                   break;,                case 14:,                   if ((0x2400L & l) != 0L && kind > 9),                      kind = 9;,                   break;,                case 15:,                   if (curChar == 10 && kind > 9),                      kind = 9;,                   break;,                case 16:,                   if (curChar == 13),                      jjstateSet[jjnewStateCnt++] = 15;,                   break;,                case 17:,                   if ((0x3ff000000000000L & l) == 0L),                      break;,                   if (kind > 20),                      kind = 20;,                   jjCheckNAdd(17);,                   break;,                case 18:,                   if ((0x3ffc01000000000L & l) == 0L),                      break;,                   if (kind > 21),                      kind = 21;,                   jjCheckNAdd(18);,                   break;,                case 19:,                   if (curChar == 34),                      jjCheckNAdd(20);,                   break;,                case 20:,                   if ((0xfffffffbffffdbffL & l) != 0L),                      jjCheckNAddTwoStates(20, 21);,                   break;,                case 21:,                   if (curChar == 34 && kind > 22),                      kind = 22;,                   break;,                default : break;,             },          } while(i != startsAt);,       },       else if (curChar < 128),       {,          long l = 1L << (curChar & 077);,          MatchLoop: do,          {,             switch(jjstateSet[--i]),             {,                case 5:,                case 18:,                   if ((0x7fffffe87fffffeL & l) == 0L),                      break;,                   if (kind > 21),                      kind = 21;,                   jjCheckNAdd(18);,                   break;,                case 1:,                   jjAddStates(3, 5);,                   break;,                case 7:,                   jjAddStates(6, 8);,                   break;,                case 13:,                   jjAddStates(0, 2);,                   break;,                case 20:,                   jjAddStates(9, 10);,                   break;,                default : break;,             },          } while(i != startsAt);,       },       else,       {,          int hiByte = (int)(curChar >> 8);,          int i1 = hiByte >> 6;,          long l1 = 1L << (hiByte & 077);,          int i2 = (curChar & 0xff) >> 6;,          long l2 = 1L << (curChar & 077);,          MatchLoop: do,          {,             switch(jjstateSet[--i]),             {,                case 1:,                   if (jjCanMove_0(hiByte, i1, i2, l1, l2)),                      jjAddStates(3, 5);,                   break;,                case 7:,                   if (jjCanMove_0(hiByte, i1, i2, l1, l2)),                      jjAddStates(6, 8);,                   break;,                case 13:,                   if (jjCanMove_0(hiByte, i1, i2, l1, l2)),                      jjAddStates(0, 2);,                   break;,                case 20:,                   if (jjCanMove_0(hiByte, i1, i2, l1, l2)),                      jjAddStates(9, 10);,                   break;,                default : break;,             },          } while(i != startsAt);,       },       if (kind != 0x7fffffff),       {,          jjmatchedKind = kind;,          jjmatchedPos = curPos;,          kind = 0x7fffffff;,       },       ++curPos;,       if ((i = jjnewStateCnt) == (startsAt = 22 - (jjnewStateCnt = startsAt))),          break;,       try { curChar = input_stream.readChar(); },       catch(java.io.IOException e) { break; },    },    if (jjmatchedPos > strPos),       return curPos;, ,    int toRet = Math.max(curPos, seenUpto);, ,    if (curPos < toRet),       for (i = toRet - Math.min(curPos, seenUpto); i-- > 0; ),          try { curChar = input_stream.readChar(); },          catch(java.io.IOException e) { throw new Error("Internal Error : Please send a bug report."); }, ,    if (jjmatchedPos < strPos),    {,       jjmatchedKind = strKind;,       jjmatchedPos = strPos;,    },    else if (jjmatchedPos == strPos && jjmatchedKind > strKind),       jjmatchedKind = strKind;, ,    return toRet;, }, static final int[] jjnextStates = {,    13, 14, 16, 1, 2, 4, 7, 8, 10, 20, 21, , };, private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2), {,    switch(hiByte),    {,       case 0:,          return ((jjbitVec2[i2] & l2) != 0L);,       default : ,          if ((jjbitVec0[i1] & l1) != 0L),             return true;,          return false;,    }, }, public static final String[] jjstrLiteralImages = {, "", null, null, null, null, null, null, null, null, null, null, null, null, , null, null, null, null, null, null, null, null, null, null, "\54", "\72", };, public static final String[] lexStateNames = {,    "DEFAULT", , };, static final long[] jjtoToken = {,    0x1fffc01L, , };, static final long[] jjtoSkip = {,    0x3feL, , };, static final long[] jjtoSpecial = {,    0x380L, , };, protected SimpleCharStream input_stream;, private final int[] jjrounds = new int[22];, private final int[] jjstateSet = new int[44];, protected char curChar;, public mtGrammarTokenManager(SimpleCharStream stream){,    if (SimpleCharStream.staticFlag),       throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");,    input_stream = stream;, }, public mtGrammarTokenManager(SimpleCharStream stream, int lexState){,    this(stream);,    SwitchTo(lexState);, }, public void ReInit(SimpleCharStream stream), {,    jjmatchedPos = jjnewStateCnt = 0;,    curLexState = defaultLexState;,    input_stream = stream;,    ReInitRounds();, }, private final void ReInitRounds(), {,    int i;,    jjround = 0x80000001;,    for (i = 22; i-- > 0;),       jjrounds[i] = 0x80000000;, }, public void ReInit(SimpleCharStream stream, int lexState), {,    ReInit(stream);,    SwitchTo(lexState);, }, public void SwitchTo(int lexState), {,    if (lexState >= 1 || lexState < 0),       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);,    else,       curLexState = lexState;, }, , protected Token jjFillToken(), {,    Token t = Token.newToken(jjmatchedKind);,    t.kind = jjmatchedKind;,    String im = jjstrLiteralImages[jjmatchedKind];,    t.image = (im == null) ? input_stream.GetImage() : im;,    t.beginLine = input_stream.getBeginLine();,    t.beginColumn = input_stream.getBeginColumn();,    t.endLine = input_stream.getEndLine();,    t.endColumn = input_stream.getEndColumn();,    return t;, }, , int curLexState = 0;, int defaultLexState = 0;, int jjnewStateCnt;, int jjround;, int jjmatchedPos;, int jjmatchedKind;, , public Token getNextToken() , {,   int kind;,   Token specialToken = null;,   Token matchedToken;,   int curPos = 0;, ,   EOFLoop :,   for (;;),   {   ,    try   ,    {     ,       curChar = input_stream.BeginToken();,    }     ,    catch(java.io.IOException e),    {        ,       jjmatchedKind = 0;,       matchedToken = jjFillToken();,       matchedToken.specialToken = specialToken;,       return matchedToken;,    }, ,    jjmatchedKind = 0x7fffffff;,    jjmatchedPos = 0;,    curPos = jjMoveStringLiteralDfa0_0();,    if (jjmatchedKind != 0x7fffffff),    {,       if (jjmatchedPos + 1 < curPos),          input_stream.backup(curPos - jjmatchedPos - 1);,       if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L),       {,          matchedToken = jjFillToken();,          matchedToken.specialToken = specialToken;,          return matchedToken;,       },       else,       {,          if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L),          {,             matchedToken = jjFillToken();,             if (specialToken == null),                specialToken = matchedToken;,             else,             {,                matchedToken.specialToken = specialToken;,                specialToken = (specialToken.next = matchedToken);,             },          },          continue EOFLoop;,       },    },    int error_line = input_stream.getEndLine();,    int error_column = input_stream.getEndColumn();,    String error_after = null;,    boolean EOFSeen = false;,    try { input_stream.readChar(); input_stream.backup(1); },    catch (java.io.IOException e1) {,       EOFSeen = true;,       error_after = curPos <= 1 ? "" : input_stream.GetImage();,       if (curChar == '\n' || curChar == '\r') {,          error_line++;,          error_column = 0;,       },       else,          error_column++;,    },    if (!EOFSeen) {,       input_stream.backup(1);,       error_after = curPos <= 1 ? "" : input_stream.GetImage();,    },    throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,ReInit,776-780,[   jjmatchedPos = jjnewStateCnt = 0;,    curLexState = defaultLexState;,    input_stream = stream;,    ReInitRounds();, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,ReInit,790-792,[   ReInit(stream);,    SwitchTo(lexState);, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,SwitchTo,795-799,[   if (lexState >= 1 || lexState < 0),       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);,    else,       curLexState = lexState;, }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,ReInitRounds,784-787,[   jjround = 0x80000001;,    for (i = 22; i-- > 0;),       jjrounds[i] = 0x80000000;, }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,jjCheckNAddStates,486-488,[   jjCheckNAdd(jjnextStates[start]);,    jjCheckNAdd(jjnextStates[start + 1]);, }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,jjStopAtPos,14-16,[   jjmatchedKind = kind;,    jjmatchedPos = pos;,    return pos + 1;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derby/impl/tools/ij/mtGrammarTokenManager.java,,11-11,[  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/derby/impl/tools/ij/mtTestCase.java,setIgnoreErrors,94-94,[		this.ignoreErrors = t;],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtTestCase.java,,37-325,[public class mtTestCase, {, 	public String name = null;, 	public String file = null;, 	public String propFile = null;, 	public float weight = (float).5;, 	public Hashtable ignoreErrors = null;, 	public String description = null;, , , 	private int iterations;, 	private int attempts;, , 	public void mtTestCase(), 	{ };, , 	public void setName(String name), 	{, 		this.name = name;, 	}, 	public String getName(), 	{, 		return name;, 	}, , 	public void setFile(String name), 	{, 		this.file = name;, 	}, , 	public void setInputDir(String dir), 	{, 		file = dir + "/" + file;, 	}, , 	public String getFile(), 	{, 		return file;, 	}, 	, 	public void setPropFile(String name), 	{, 		this.propFile = name;, 	}, , 	public String getPropFile(), 	{, 		return propFile;, 	}, , 	public void setWeight(int weight), 	{, 		this.weight = (float)(weight/100.0);, 	}, 	, 	public void setIgnoreErrors(Hashtable t), 	{, 		this.ignoreErrors = t;, 	}, 	, 	public void setDescription(String description), 	{, 		this.description = description;, 	}, , 	/**, 	** Initialize the test case.  See initialize(String), 	*/, 	public synchronized BufferedInputStream initialize() , 			throws FileNotFoundException, IOException, 	{, 		return initialize(null);, 	}, , 	/**, 	** Initizalize the test case.  Loads up the properties, 	** file and sets the input stream.  Used to set up, 	** prior to running the thread., 	*/, 	public synchronized BufferedInputStream initialize(String inputDir) , 			throws FileNotFoundException, IOException, 	{, 		String filePath; , 		BufferedInputStream	inStream = null;, , 		// load up properties, 		if (propFile != null), 		{	, 			BufferedInputStream	propStream;, 			Properties		p;, 			String propPath = (inputDir == null) ?, 						propFile : , 				(inputDir + "/" + propFile);, 			, 			try , 			{, 				propStream = new BufferedInputStream(new FileInputStream(propPath));, 			} catch (FileNotFoundException e), 			{, 				System.out.println(name+": unable to find properties file "+propPath);, 				throw e;, 			}, , 			p = System.getProperties();, 			p.load(propStream);, 			// for network server need to alter url, 			String framework = p.getProperty("framework");, 			, 			if (framework != null),             {,                 String newURLPrefix = null;,                 framework = framework.toUpperCase(java.util.Locale.ENGLISH);,                 if (framework.equals("DB2JNET") || framework.equals("DERBYNET")),                     newURLPrefix= "jdbc:derby:net://localhost:1527/";,                 else if (framework.equals("DERBYNETCLIENT")),                     newURLPrefix= "jdbc:derby://localhost:1527/";,                 if (newURLPrefix != null),                 {,                     updateURLProperties(p,newURLPrefix);,                     p.setProperty("ij.user","APP");,                     p.setProperty("ij.password","PWD");,                 }, 			},             // this is a special case for the MultiTest.,             // check and alter url if there are any encryption related ,             // properties that need to be set on the url ,             if (("true").equalsIgnoreCase(p.getProperty("encryption"))) ,             {,                String encryptUrl = "dataEncryption=true;bootPassword=Thursday";,                String dbUrl = p.getProperty("ij.database");,                String encryptionAlgorithm = p.getProperty("encryptionAlgorithm");,                if (encryptionAlgorithm != null),                {,                    p.setProperty(,                        "ij.database",,                        dbUrl + ";" + encryptUrl + ";" + encryptionAlgorithm);,                },                else,                {,                    p.setProperty("ij.database",dbUrl + ";"+encryptUrl);,                },             },             , 			// If the initial connection is being specified as a DataSource, 			// on the command line using -Dij.dataSource=<dsclassname>, 			// then remove the ij.database and ij.protocol property.,             // This is because the ij.database and ij.protocol ,             // will override the ij.dataSource property., 			if (System.getProperty("ij.dataSource") != null), 			{, 				p.remove("ij.database");, 				p.remove("ij.protocol");, 			},             , 			System.setProperties(p);, 		}, 		// set input stream, 		filePath = (inputDir == null) ?, 						file : (inputDir + "/" + file);, , 		try , 		{, 			inStream = new BufferedInputStream(new FileInputStream(filePath), , 							utilMain.BUFFEREDFILESIZE);		, 		} catch (FileNotFoundException e), 		{, 			System.out.println("unable to find properties file "+filePath);, 			throw e;, 		}, 		return inStream;, 	}, , 	/**, 	** Attempt to grab this test case.  , 	** Uses random number and the weight of this, 	** case to determine if the grab was successful., 	** , 	** @return true/false, 	*/, 	public synchronized boolean grab(), 	{, 		attempts++;, 		if (java.lang.Math.random() < weight), 		{, 			iterations++;, 			return true;, 		}, 		else, 		{, 			return false;, 		}, 	}, , 	/**, 	** Run the test case.  Invokes IJ to do our, 	** dirty work., 	*/, 	public void runMe(LocalizedOutput log, LocalizedOutput out, BufferedInputStream infile), 	{, 		utilMain	utilInstance;,         LocalizedInput is;,         is = LocalizedResource.getInstance().getNewInput(infile);, , 		LocalizedInput [] in = { is };, 	, 		out.println("--------------"+file+"-----------------");, 		utilInstance = new utilMain(1, out, ignoreErrors);, 		utilInstance.initFromEnvironment();, 		utilInstance.setMtUse(true);, 		utilInstance.go(in, out);, 		log.flush();, 		out.flush();, 	}, , 	public void updateURLProperties(Properties p, String newURLPrefix), 	{, 		String[] propsToUpdate = {"ij.database", "ij.protocol",, 								  "database"};, 		for (int i = 0; i < propsToUpdate.length; i++), 		{, 			String key = propsToUpdate[i];, 			String val = p.getProperty(key);, 			if (val != null), 				p.setProperty(key,alterURL(val,newURLPrefix));, 		}, 	}, , , 	public String alterURL(String url, String newURLPrefix), 	{, 		String urlPrefix = "jdbc:derby:";, 	, 		if (url.startsWith(newURLPrefix)), 			return url;, , 		// If we don't have a URL prefix for this framework, 		// just return, 		if (newURLPrefix == null), 			return url;, 	, 		if (url.equals(urlPrefix)) // Replace embedded, 			return newURLPrefix;, , 		if (url.startsWith(urlPrefix)), 		{, 			// replace jdbc:derby: with our url:, 			url = newURLPrefix +, 				url.substring(urlPrefix.length());, , 		}, 		else, 		{, 			if (! (url.startsWith("jdbc:"))), 	    {, 			url = newURLPrefix + url;, 	    }, 		}, 		//System.out.println("New url:" +url);, 		return url;,     },   , , // NOTE: tried invoking ij directly, but had some problems,, // so stick with calling utilMain().	, //	/**, //	** Run the test case.  Invokes IJ to do our, //	** dirty work., //	*/, //	public void runMe(AppStreamWriter log, AppStreamWriter out, BufferedInputStream infile), //	{, //		ASCII_UCodeESC_CharStream charStream;, //		ijTokenManager	ijTokMgr;, //		ij	ijParser;, //	, //		, //		out.println("--------------"+file+"-----------------");, //		charStream = new ASCII_UCodeESC_CharStream(in, 1, 1);, //		ijTokMgr = new ijTokenManager(charStream);, //		ijParser = new ij(ijTokMgr, System.out, this);, //		log.flush();, //		out.flush();, //	}, , 	/**, 	** Name says it all, 	*/, 	public String toString(), 	{, 		return "name: "+name+],,
CORRECTNESS,NM_METHOD_CONSTRUCTOR_CONFUSION,org/apache/derby/impl/tools/ij/mtTestCase.java,mtTestCase,51-51,[	{ };],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/tools/ij/mtTestCase.java,initialize,133-133,[				propStream = new BufferedInputStream(new FileInputStream(propPath));],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/tools/ij/mtTestCase.java,alterURL,269-269,[		if (url.startsWith(newURLPrefix))],,alterURL,274-274,[		if (newURLPrefix == null)],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/derby/impl/tools/ij/mtTestSuite.java,getTimeMillis,133-133,[		return ((time.hours * 360) +],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtTestSuite.java,,40-185,[	private String rootDir = null;, , , 	mtTestSuite(int numThreads, mtTime time, , 			Vector initCases, Vector testCases, Vector finalCases), 	{, 		this.numThreads = numThreads;, 		this.time = time;, 		this.cases = testCases;, 		this.init = initCases;, 		this.last = finalCases;, 	}, , 	public void init(), 	{, 		boolean loadInitFailed = loadCases(init);, 		boolean loadTestsFailed = loadCases(cases);, 		boolean loadLastFailed = loadCases(last);, , 		if ((loadInitFailed == true) ||, 			(loadTestsFailed == true) ||, 			(loadLastFailed == true)), 		{, 			throw new Error("Initialization Error");, 		}, 	}, , 	/**, 	** @return boolean indicates if there was a problem loading, 	** 	the file, 	*/, 	private boolean loadCases(Vector cases), 	{, 		if (cases == null), 			return false;, , 		boolean gotError = false;, 		Enumeration e = cases.elements();, 		mtTestCase tcase;,  , 		while (e.hasMoreElements()), 		{, 			tcase = (mtTestCase)e.nextElement();, 			try, 			{, 				tcase.initialize(rootDir);, 			}, 			catch (Throwable t), 			{, 				gotError = true;, 			}, 		}, , 		return gotError;, 	}, , 	public void setRoot(String rootDir), 	{, 		this.rootDir = rootDir;, 	}, , 	public String getRoot(), 	{, 		return rootDir;, 	}, , 	public int getNumThreads(), 	{, 		return numThreads;, 	}, , 	public Vector getCases(), 	{, 		return cases;, 	}, , 	public Vector getInitCases(), 	{, 		return init;, 	}, , 	public Vector getFinalCases(), 	{, 		return last;, 	}, , 	public mtTime getTime(), 	{, 		return time;, 	}, , 	public long getTimeMillis(), 	{, 		return ((time.hours * 360) +, 				(time.minutes * 60) +, 				(time.seconds)) * 1000;, 	}, , 	public String toString(), 	{, 		String str;, 		int	len;, 		int i;, 	, 		str = "TEST CASES\nNumber of Threads: "+numThreads;, 		str +="\nTime: "+time;, 		str +="\nNumber of Initializers: "+init.size()+"\n";, 		for (i = 0, len = init.size(); i < len; i++), 		{, 			str += init.elementAt(i).toString() + "\n";, 		}, , 		str +="\nNumber of Cases: "+cases.size()+"\n";, 		for (i = 0, len = cases.size(); i < len; i++), 		{, 			str += cases.elementAt(i).toString() + "\n";, 		}, , 		str +="\nNumber of Final Cases: "+last.size()+"\n";, 		for (i = 0, len = last.size(); i < len; i++), 		{, 			str += last.elementAt(i).toString() + "\n";, 		}, , 		return str;, 	}, , 	/*, 	** Grab a test case.  Pick one randomly and, 	** try to grab that case.  If we get it we are, 	** done.  Otherwise, try try again., 	*/, 	public mtTestCase grabTestCase() , 	{, 		int numCases = cases.size();, 		int caseNum;, 		mtTestCase testCase;, , 		do, 		{, 			caseNum = (int)((java.lang.Math.random() * 1311) % numCases);, 			testCase = (mtTestCase)cases.elementAt(caseNum);, 		}, 		while (testCase.grab() == false);, 	, 		return testCase;	],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/tools/ij/mtTestSuite.java,toString,149-149,[			str += init.elementAt(i).toString() + "\n";],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtTester.java,,43-124,[	private boolean		stop = false;, 	private boolean   testOK = false;, 							, 	public mtTester(String name, mtTestSuite suite, LocalizedOutput out, LocalizedOutput log), 	{ , 		this.name = name;, 		this.suite = suite;, 		this.log = log;, 		this.out = out;, 		log.println("...initialized "+ name + " at " + new Date());, 	}, , 	/**, 	** Run until killed or until there is a problem., 	** If we get other than 'connection closed' we'll, 	** signal that we recieved a fatal error before, 	** quittiing; otherwise, we are silent., 	*/, 	public void run(), 	{, 		int numIterations = 0;, , 		try , 		{, 			mtTestCase testCase;, 			BufferedInputStream	in;, , 			// loop until we get an error or, 			// are killed.	, 			while (!stop), 			{, 				numIterations++;, 				testCase = suite.grabTestCase();, 				try , 				{, 					in = testCase.initialize(suite.getRoot());, 				} catch (FileNotFoundException e) , 				{, 					System.out.println(e);, 					return;, 				}, 				catch (IOException e), 				{, 					System.out.println(e);, 					return;, 				}, 	, 				log.println(name + ": "+ testCase.getName() + " " + new Date());, 				testCase.runMe(log, out, in);, 			}, 		}	, 		catch (ijFatalException e), 		{, , 			/*, 			** If we got connection closed (XJ010), we'll, 			** assume that we were deliberately killed, 			** via a Thread.stop() and it was caught by, 			** jbms.  Otherwise, we'll print out an, 			** error message., 			*/, 			if (e.getSQLState() == null || !(e.getSQLState().equals("XJ010"))), 			{, 				log.println(name + ": TERMINATING due to unexpected error:\n"+e);, 				throw new ThreadDeath();, 			}, 		}, 		if (stop), 		{, 			log.println(name + ": stopping on request after " + numIterations +, 						" iterations");, 			testOK = true;, 		}, 	}, , 	public void stop(), 	{, 		stop = true;, 	}, 	public boolean noFailure(), 	{, 		return testOK;],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/mtTime.java,,33-41,[	{ , 		this.hours = hours;, 		this.minutes = minutes;, 		this.seconds = seconds;, 	}, , 	public String toString(), 	{, 		return hours+":"+minutes+":"+seconds;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/tools/ij/util.java,getDataSourceConnection,369-369,[				throw (SQLException) ite.getTargetException();],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/util.java,,54-806,[public final class util implements java.security.PrivilegedAction<String> {, 	, 	private static final Class[] DS_GET_CONN_TYPES = {"".getClass(), "".getClass()};, 	private util() {}, , 	//-----------------------------------------------------------------, 	// Methods for starting up JBMS, , 	/**, 	 * Find the argument that follows the specified parameter., 	 *, 	 *	@param param the parameter (e.g. "-p"), 	 *	@param args	the argument list to consider., 	 *, 	 *	@return the argument that follows the parameter, or null if not found, 	 */, 	static public String getArg(String param, String[] args), 	{, 		int pLocn;, 		Properties p;, , 		if (args == null) return null;, , 		for (pLocn=0; pLocn<args.length; pLocn++) {, 			if (param.equals(args[pLocn])) break;, 		}, 		if (pLocn >= (args.length-1))  // not found or no file, 			return null;, , 		return args[pLocn+1];, 	}, , 	/**, 		ij is started with "-p[r] file OtherArgs";, 		the file contains properties to control the driver and database, 		used to run ij, and can provide additional system properties., 		<p>, 		getPropertyArg will look at the args and take out a "-p <file>" pair,, 		reading the file into the system properties., 		<p>, 		If there was a -p without a following <file>, no action is taken., , 		@exception IOException thrown if file not found, , 		@param args	the argument list to consider., 		@return true if a property item was found and loaded., 	 */, 	static public boolean getPropertyArg(String[] args) throws IOException {, 		String n;, 		InputStream in1;, 		Properties p;, , 		if ((n = getArg("-p", args))!= null){, 			in1 = new FileInputStream(n);, 			in1 = new BufferedInputStream(in1);, 		}, 		else if ((n = getArg("-pr", args)) != null) {, 			in1 = getResourceAsStream(n);, 			if (in1 == null) throw ijException.resourceNotFound();, 		}, 		else, 			return false;, , 		p = System.getProperties();, , 		// Trim off excess whitespace in property file, if any, and, 		// then load those properties into 'p'., 		util.loadWithTrimmedValues(in1, p);, , 		return true;, 	}, , , 	/**, 	  Convenience routine to qualify a resource name with "ij.defaultPackageName", 	  if it is not qualified (does not begin with a "/")., , 	  @param absolute true means return null if the name is not absolute and false, 	  means return partial names. , 	  */, 	static String qualifyResourceName(String resourceName, boolean absolute), 	{, 		resourceName=resourceName.trim();, 		if (resourceName.startsWith("/")), 		{, 			return resourceName;, 		}, 		else, 		{, 			String pName = util.getSystemProperty("ij.defaultResourcePackage").trim();, 			if (pName == null) return null;, 			if ((pName).endsWith("/")), 				resourceName = pName+resourceName;, 			else, 				resourceName = pName+"/"+resourceName;, 			if (absolute && !resourceName.startsWith("/")), 				return null;, 			else, 				return resourceName;, 		}, 	}, 	/**, 	  Convenience routine to get a resource as a BufferedInputStream. If the, 	  resourceName is not absolute (does not begin with a "/") this qualifies, 	  the name with the "ij.defaultResourcePackage" name., , 	  @param resourceName the name of the resource, 	  @return a buffered stream for the resource if it exists and null otherwise., 	  */, 	static public InputStream getResourceAsStream(String resourceName) , 	{, 		final Class c = util.class;, 		final String resource = qualifyResourceName(resourceName,true);, 		if (resource == null) , 			return null;, 		InputStream is = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {,             public InputStream run() { ,                       InputStream locis = ,                           c.getResourceAsStream(resource);,                                   return locis;,             },         },      );, , 		if (is != null) , 			is = new BufferedInputStream(is, utilMain.BUFFEREDFILESIZE);, 		return is;, 	}, , 	/**, 	  Return the name of the ij command file or null if none is, 	  specified. The command file may be proceeded with -f flag on, 	  the command line. Alternatively, the command file may be , 	  specified without a -f flag. In this case we assume the first, 	  unknown argument is the command file., , 	  <P>, 	  This should only be called after calling invalidArgs., , 	  <p>, 	  If there is no such argument, a null is returned., , 	  @param args	the argument list to consider., 	  @return the name of the first argument not preceded by "-p",, 	  null if none found., 	  , 	  @exception IOException thrown if file not found, 	 */, 	static public String getFileArg(String[] args) throws IOException {, 		String fileName;, 		int fLocn;, 		boolean foundP = false;, , 		if (args == null) return null;, 		if ((fileName=getArg("-f",args))!=null) return fileName;, 		//, 		//The first unknown arg is the file, 		for (int ix=0; ix < args.length; ix++), 			if(args[ix].equals("-f")  ||, 			   args[ix].equals("-fr") ||, 			   args[ix].equals("-p")  ||, 			   args[ix].equals("-pr")), 				ix++; //skip the parameter to these args, 			else, 				return args[ix];, 		return null;, 	}, , 	/**, 	  Return the name of a resource containing input commands or, 	  null iff none has been specified., 	  */,  	static public String getInputResourceNameArg(String[] args) {, 		return getArg("-fr", args);, 	}, , 	/**, 	  Verify the ij line arguments command arguments. Also used to detect --help., 	  @return true if the args are invalid, 	  <UL>, 	  <LI>Only legal argument provided., 	  <LI>Only specify a quantity once., 	  </UL>, 	 */, 	static public boolean invalidArgs(String[] args) {, 		int countSupported = 0;, 		boolean haveInput = false;, 		for (int ix=0; ix < args.length; ix++), 		{, 			//, 			//If the arguemnt is a supported flag skip the flags argument, 			if(!haveInput && (args[ix].equals("-f") || args[ix].equals("-fr"))), 			{, 				haveInput = true;, 				ix++;, 				if (ix >= args.length) return true;, 			}, , 			else if ((args[ix].equals("-p") || args[ix].equals("-pr") )), 			{, 				// next arg is the file/resource name, 				ix++;, 				if (ix >= args.length) return true;, 			} else if (args[ix].equals("--help")) { return true; }, , 			//, 			//Assume the first unknown arg is a file name., 			else if (!haveInput), 			{, 				haveInput = true;, 			}, , 			else, 			{, 				return true;, 			}, 		}, 		return false;, 	}, , 	/**, 	 * print a usage message for invocations of main()., 	 */, 	static void Usage(LocalizedOutput out) {,      	out.println(, 		LocalizedResource.getMessage("IJ_UsageJavaComCloudToolsIjPPropeInput"));, 		out.flush();,    	}, , ,     private static final Class[] STRING_P = { "".getClass() };,     private static final Class[] INT_P = { Integer.TYPE };, , ,     /**,      * Sets up a data source with values specified in ij.dataSource.* properties or,      * passed as parameters of this method,      * ,      * @param ds DataSource object,      * @param dbName Database Name,      * @param firstTime If firstTime is false, ij.dataSource.createDatabase and ij.dataSource.databaseName ,      * properties will not be used. The value in parameter dbName will be used instead of ,      * ij.dataSource.databaseName.,      * ,      * @throws Exception,      */,     static public void setupDataSource(Object ds,String dbName,boolean firstTime) throws Exception {, 	// Loop over set methods on Datasource object, if there is a property, 	// then call the method with corresponding value. Call setCreateDatabase based on,     //parameter create. 	,    java.lang.reflect.Method[] methods = ds.getClass().getMethods();, 	for (int i = 0; i < methods.length; i++) {, 	    java.lang.reflect.Method m = methods[i];, 	    String name = m.getName();, 	    , 	    if (name.startsWith("set") && (name.length() > "set".length())) {, 	     	//Check if setCreateDatabase has to be called based on create parameter, 	    	if(name.equals("setCreateDatabase") && !firstTime), 	    		continue;, 	    	, 	    	String property = name.substring("set".length()); // setXyyyZwww, 	    	property = "ij.dataSource."+property.substring(0,1).toLowerCase(java.util.Locale.ENGLISH)+ property.substring(1); // xyyyZwww, 	    	String value = util.getSystemProperty(property);, 	    	if(name.equals("setDatabaseName") && !firstTime), 	    		value = dbName;, 	    	if (value != null) {, 	    		try {, 	    			// call string method, 	    			m.invoke(ds, new Object[] {value});, 	    		} catch (Throwable ignore) {, 	    			// failed, assume it's an integer parameter, 	    			m.invoke(ds, new Object[] {Integer.valueOf(value)});, 	    		}, 	    	}, 	    }, 	},     },     ,     /**,      * Returns a connection obtained using the DataSource. This method will be called when ij.dataSource,      * property is set. It uses ij.dataSource.* properties to get details for the connection. ,      * ,      * @param dsName Data Source name,      * @param user User name,      * @param password Password,      * @param dbName Database Name,      * @param firstTime Indicates if the method is called first time. This is passed to setupDataSource ,      * method.,      *   ,      * @throws SQLException,      */,     public static Connection getDataSourceConnection(String dsName,String user,String password,,     												String dbName,boolean firstTime) throws SQLException{, 		// Get a new proxied connection through DataSource, 		Object ds = null; // really javax.sql.DataSource, 		try {, 			, 		    Class<?> dc = Class.forName(dsName);, 		    ds = dc.newInstance();, 		    , 		    // set datasource properties, 		    setupDataSource(ds,dbName,firstTime);	   , , 		    // Java method call "by hand" {  con = ds.getConnection(); }, 		    // or con = ds.getConnection(user, password), 		    	, 			java.lang.reflect.Method m = , 				user == null ? dc.getMethod("getConnection", null) :, 					 dc.getMethod("getConnection", DS_GET_CONN_TYPES);, 				, 			return (java.sql.Connection) m.invoke(ds,, 					 user == null ? null : new String[] {user, password});, 		} catch (InvocationTargetException ite), 		{, 			if (ite.getTargetException() instanceof SQLException), 				throw (SQLException) ite.getTargetException();, 			ite.printStackTrace(System.out);, 		} catch (Exception e), 		{, 			e.printStackTrace(System.out);, 		}, 		return null;,     }, , 	/**, 		This will look for the System properties "ij.driver" and "ij.database", 		and return a java.sql.Connection if it successfully connects., 		The deprecated driver and database properties are examined first., 		<p>, 		If no connection was possible, it will return a null., 		<p>, 		Failure to load the driver class is quietly ignored., , 		@param defaultDriver the driver to use if no property value found, 		@param defaultURL the database URL to use if no property value found, 		@param connInfo Connection attributes to pass to getConnection, 		@return a connection to the defaultURL if possible; null if not., 		@exception SQLException on failure to connect., 		@exception ClassNotFoundException on failure to load driver., 		@exception InstantiationException on failure to load driver., 		@exception IllegalAccessException on failure to load driver., 	 */,     static public Connection startJBMS(String defaultDriver, String defaultURL,, 				       Properties connInfo) , 	throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException,     {, 	Connection con = null;,         String driverName;,         String databaseURL;, , 	// deprecate the non-ij prefix.  actually, we should defer to jdbc.drivers...,         driverName = util.getSystemProperty("driver");,         if (driverName == null) driverName = util.getSystemProperty("ij.driver");, 	if (driverName == null || driverName.length()==0) driverName = defaultDriver;,         if (driverName != null) {, 	    util.loadDriver(driverName);, 	}, , 	String jdbcProtocol = util.getSystemProperty("ij.protocol");, 	if (jdbcProtocol != null), 	    util.loadDriverIfKnown(jdbcProtocol);, 	,     String user = util.getSystemProperty("ij.user");,     String password = util.getSystemProperty("ij.password");, , 	// deprecate the non-ij prefix name, 	databaseURL = util.getSystemProperty("database");, 	if (databaseURL == null) databaseURL = util.getSystemProperty("ij.database");, 	if (databaseURL == null || databaseURL.length()==0) databaseURL = defaultURL;, 	if (databaseURL != null) {, 	    // add protocol if might help find driver., 		// if have full URL, load driver for it, 		if (databaseURL.startsWith("jdbc:")), 		    util.loadDriverIfKnown(databaseURL);, 	    if (!databaseURL.startsWith("jdbc:") && jdbcProtocol != null), 		databaseURL = jdbcProtocol+databaseURL;, , 	    // Update connInfo for ij system properties and, 	    // framework network server, , 	    connInfo = updateConnInfo(user, password,connInfo);, , 	    // JDBC driver, 	    String driver = util.getSystemProperty("driver");, 	    if (driver == null) {, 		driver = "org.apache.derby.jdbc.EmbeddedDriver";, 	    }, 	    , 	    loadDriver(driver);, 		con = DriverManager.getConnection(databaseURL,connInfo);, 		return con;  , 	}, , 	    // handle datasource property, 	    String dsName = util.getSystemProperty("ij.dataSource");, 	    if (dsName == null), 	    	return null;,         , 	    //First connection - pass firstTime=true, dbName=null. For database name, , 	    //value in ij.dataSource.databaseName will be used. , 	    con = getDataSourceConnection(dsName,user,password,null,true);, 	    return con;,    }, , , 	public static Properties updateConnInfo(String user, String password, Properties connInfo), 	{, 		String ijGetMessages = util.getSystemProperty("ij.retrieveMessagesFromServerOnGetMessage");, 		boolean retrieveMessages = false;, 		, 		, 		// For JCC make sure we set it to retrieve messages, 		if (isJCCFramework()), 			retrieveMessages = true;, 		, 		if (ijGetMessages != null), 		{, 			if (ijGetMessages.equals("false")), 				retrieveMessages = false;, 			else, 				retrieveMessages = true;, 			, 		}, 		, 		if (connInfo == null), 			connInfo = new Properties();, 		, 		if (retrieveMessages == true), 		{, 			connInfo.put("retrieveMessagesFromServerOnGetMessage",, 						 "true");, 		}, 		if (user != null), 			connInfo.put("user",user);, 		if (password != null), 			connInfo.put("password", password);, 		, 		return connInfo;, 	}, , 	/**, 		Utility interface that defaults driver and database to null., , 		@return a connection to the defaultURL if possible; null if not., 		@exception SQLException on failure to connect., 		@exception ClassNotFoundException on failure to load driver., 		@exception InstantiationException on failure to load driver., 		@exception IllegalAccessException on failure to load driver., 	 */,     static public Connection startJBMS() throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {, 		return startJBMS(null,null);, 	}, 	, 	/**, 	   Utility interface that defaults connInfo to null, 	   <p>, , , 		@param defaultDriver the driver to use if no property value found, 		@param defaultURL the database URL to use if no property value found, 		@return a connection to the defaultURL if possible; null if not., 		@exception SQLException on failure to connect., 		@exception ClassNotFoundException on failure to load driver., 		@exception InstantiationException on failure to load driver., 		@exception IllegalAccessException on failure to load driver., 	 */,     static public Connection startJBMS(String defaultDriver, String defaultURL) , 			throws SQLException, ClassNotFoundException, InstantiationException,, 				   IllegalAccessException {, 		return startJBMS(defaultDriver,defaultURL,null);, 		, 	}, 	//-----------------------------------------------------------------, 	// Methods for displaying and checking results, 	// See org.apache.derby.tools.JDBCDisplayUtil for more general displays., , , 	/**, 		Display a vector of strings to the out stream., 	 */, 	public static void DisplayVector(LocalizedOutput out, Vector v) {, 		int l = v.size();, 		for (int i=0;i<l;i++), 			out.println(v.elementAt(i));, 	}, , 	/**, 		Display a vector of statements to the out stream., 	public static void DisplayVector(AppStreamWriter out, Vector v, Connection conn) throws SQLException {, 		int l = v.size();, AppUI.out.println("SIZE="+l);, 		for (int i=0;i<l;i++) {, 			Object o = v.elementAt(i);, 			if (o instanceof Integer) { // update count, 				JDBCDisplayUtil.DisplayUpdateCount(out,((Integer)o).intValue());, 			} else { // o instanceof ResultSet, 			    JDBCDisplayUtil.DisplayResults(out,(ResultSet)o,conn);, 				((ResultSet)o).close(); // release the result set, 			}, 		}, 	}, 	 */, , 	/**, 		Display a statement that takes parameters by, 		stuffing it with rows from the result set and, 		displaying each result each time through., 		Deal with autocommit behavior along the way., , 		@exception SQLException thrown on db error, 		@exception ijException thrown on ij error, 	 */, 	public static void DisplayMulti(LocalizedOutput out, PreparedStatement ps,, 		ResultSet rs, Connection conn) throws SQLException, ijException {, , 		boolean autoCommited = false; // mark if autocommit in place, 		boolean exec = false; // mark the first time through, 		boolean anotherUsingRow = false;	// remember if there's another row , 											// from using., 		ResultSetMetaData rsmd = rs.getMetaData();, 		int numCols = rsmd.getColumnCount();, , 		/* NOTE: We need to close the USING RS first, 		 * so that RunTimeStatistic gets info from, 		 * the user query., 		 */, 		anotherUsingRow = rs.next();, , 		while (! autoCommited && anotherUsingRow) {, 			// note the first time through, 			if (!exec) {, 				exec = true;, , 				// send a warning if additional results may be lost, 				if (conn.getAutoCommit()) {, 					out.println(LocalizedResource.getMessage("IJ_IjWarniAutocMayCloseUsingResulSet"));, 					autoCommited = true;, 				}, 			}, , 			// We need to make sure we pass along the scale, because, 			// setObject assumes a scale of zero (beetle 4365), 			for (int c=1; c<=numCols; c++) {, 				int sqlType = rsmd.getColumnType(c);, 				, 				if (sqlType == Types.DECIMAL), 				{,                     ps.setObject(c, rs.getObject(c), sqlType, rsmd.getScale(c));, 				}, 				else, 				{, 					ps.setObject(c,rs.getObject(c),, 							 sqlType);					, 				}, 				, 				, , 			}, , , 			// Advance in the USING RS, 			anotherUsingRow = rs.next();, 			// Close the USING RS when exhausted and appropriate, 			// NOTE: Close before the user query, 			if (! anotherUsingRow || conn.getAutoCommit()) //if no more rows or if auto commit is on, close the resultset, 			{, 				rs.close();, 			}, , 			/*, 				4. execute the statement against those parameters, 			 */, , 			ps.execute();, 			JDBCDisplayUtil.DisplayResults(out,ps,conn);, , 			/*, 				5. clear the parameters, 			 */, 			ps.clearParameters();, 		}, 		if (!exec) {, 			rs.close(); //this means, using clause didn't qualify any rows. Just close the resultset associated with using clause, 			throw ijException.noUsingResults();, 		}, 		// REMIND: any way to look for more rsUsing rows if autoCommit?, 		// perhaps just document the behavior... , 	}, , 	static final String getSystemProperty(String propertyName) {, 		try, 		{, 			if (propertyName.startsWith("ij.") || propertyName.startsWith("derby.")), 			{, 				util u = new util();, 				u.key = propertyName;, 				return java.security.AccessController.doPrivileged(u);, 			}, 			else, 			{, 				return System.getProperty(propertyName);, 			}, 		} catch (SecurityException se) {, 			return null;, 		}, 	}, , 	private String key;, , 	public final String run() {, 		return System.getProperty(key);, 	}, 	/** , 	 * Read a set of properties from the received input stream, strip, 	 * off any excess white space that exists in those property values,, 	 * and then add those newly-read properties to the received, 	 * Properties object; not explicitly removing the whitespace here can, 	 * lead to problems., 	 *, 	 * This method exists because of the manner in which the jvm reads, 	 * properties from file--extra spaces are ignored after a _key_, but, 	 * if they exist at the _end_ of a property decl line (i.e. as part, 	 * of a _value_), they are preserved, as outlined in the Java API:, 	 *, 	 * "Any whitespace after the key is skipped; if the first non-, 	 * whitespace character after the key is = or :, then it is ignored,  	 * and any whitespace characters after it are also skipped. All, 	 * remaining characters on the line become part of the associated, 	 * element string.", 	 *, 	 * Creates final properties set consisting of 'prop' plus all, 	 * properties loaded from 'iStr' (with the extra whitespace (if any), 	 *  removed from all values), will be returned via the parameter., 	 *, 	 * @param iStr An input stream from which the new properties are to be, 	 *  loaded (should already be initialized)., 	 * @param prop A set of properties to which the properties from, 	 *  iStr will be added (should already be initialized)., 	 *, 	 * Copied here to avoid dependency on an engine class., 	 **/, 	private static void loadWithTrimmedValues(InputStream iStr,, 		Properties prop) throws IOException {, , 		// load the properties from the received input stream., 		Properties p = new Properties();, 		p.load(iStr);, , 		// Now, trim off any excess whitespace, if any, and then, 		// add the properties from file to the received Properties, 		// set., 		for (java.util.Enumeration propKeys = p.propertyNames();, 		  propKeys.hasMoreElements();) {, 		// get the value, trim off the whitespace, then store it, 		// in the received properties object., 			String tmpKey = (String)propKeys.nextElement();, 			String tmpValue = p.getProperty(tmpKey);, 			tmpValue = tmpValue.trim();, 			prop.put(tmpKey, tmpValue);, 		}, , 		return;, , 	}, , 	private static final String[][] protocolDrivers =, 		{, 		  { "jdbc:derby:net:",			"com.ibm.db2.jcc.DB2Driver"},, 		  { "jdbc:derby://",            "org.apache.derby.jdbc.ClientDriver"},, , 		  { "jdbc:derby:",				"org.apache.derby.jdbc.EmbeddedDriver" },, 		};, , 	/**, 		Find the appropriate driver and load it, given a JDBC URL., 		No action if no driver known for a given URL., , 		@param jdbcProtocol the protocol to try., , 		@exception ClassNotFoundException if unable to, 			locate class for driver., 		@exception InstantiationException if unable to, 			create an instance., 		@exception IllegalAccessException if driver class constructor not visible., 	 */, 	public static void loadDriverIfKnown(String jdbcProtocol) throws ClassNotFoundException, InstantiationException, IllegalAccessException {, 		for (int i=0; i < protocolDrivers.length; i++) {, 			if (jdbcProtocol.startsWith(protocolDrivers[i][0])) {, 				loadDriver(protocolDrivers[i][1]);, 				break; // only want the first one, 			}, 		}, 	}, , 	/**, 		Load a driver given a class name., , 		@exception ClassNotFoundException if unable to, 			locate class for driver., 		@exception InstantiationException if unable to, 			create an instance., 		@exception IllegalAccessException if driver class constructor not visible., 	 */, 	public static void loadDriver(String driverClass) throws ClassNotFoundException, InstantiationException, IllegalAccessException {,         Class.forName(driverClass).newInstance();, 	}, , 	/**, 	 * Used to determine if this is a JCC testing framework , 	 * So that retrieveMessages can be sent.  The plan is to have  , 	 * ij will retrieve messages by default and not look at the testing , 	 * frameworks. So, ulitmately  this function will look at the driver, 	 * rather than the framework., 	 * , 	 * @return true if the framework contains Net or JCC., 	 */, 	private static boolean isJCCFramework(), 	{, 		String framework = util.getSystemProperty("framework");, 		return ((framework != null)  &&, 			((framework.toUpperCase(Locale.ENGLISH).equals("DERBYNET")) ||, 			 (framework.toUpperCase(Locale.ENGLISH).indexOf("JCC") != -1)));, 	}, 	, 	/**, 	 * Selects the current schema from the given connection., 	 * , 	 * As there are no way of getting current schema supported by, 	 * all major DBMS-es, this method may return null., 	 * , 	 * @param theConnection  Connection to get current schema for, 	 * @return the current schema of the connection, or null if error., 	 */, 	public static String getSelectedSchema(Connection theConnection) throws SQLException {, 		String schema = null;,                 if (theConnection == null),                   return null;, 		Statement st = theConnection.createStatement();, 		try {, 			if(!st.execute("VALUES CURRENT SCHEMA")), 				return null;, 			, 			ResultSet rs = st.getResultSet();, 			if(rs==null || !rs.next()), 				return null;, 			schema = rs.getString(1);, 		} catch(SQLException e) {, 			// There are no standard way of getting schema., 			// Getting default schema may fail., 		} finally {, 			st.close();, 		}, 		return schema;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/util.java,DisplayMulti,569-641,[		boolean autoCommited = false; // mark if autocommit in place, 		boolean exec = false; // mark the first time through, 		boolean anotherUsingRow = false;	// remember if there's another row , 											// from using., 		ResultSetMetaData rsmd = rs.getMetaData();, 		int numCols = rsmd.getColumnCount();, , 		/* NOTE: We need to close the USING RS first, 		 * so that RunTimeStatistic gets info from, 		 * the user query., 		 */, 		anotherUsingRow = rs.next();, , 		while (! autoCommited && anotherUsingRow) {, 			// note the first time through, 			if (!exec) {, 				exec = true;, , 				// send a warning if additional results may be lost, 				if (conn.getAutoCommit()) {, 					out.println(LocalizedResource.getMessage("IJ_IjWarniAutocMayCloseUsingResulSet"));, 					autoCommited = true;, 				}, 			}, , 			// We need to make sure we pass along the scale, because, 			// setObject assumes a scale of zero (beetle 4365), 			for (int c=1; c<=numCols; c++) {, 				int sqlType = rsmd.getColumnType(c);, 				, 				if (sqlType == Types.DECIMAL), 				{,                     ps.setObject(c, rs.getObject(c), sqlType, rsmd.getScale(c));, 				}, 				else, 				{, 					ps.setObject(c,rs.getObject(c),, 							 sqlType);					, 				}, 				, 				, , 			}, , , 			// Advance in the USING RS, 			anotherUsingRow = rs.next();, 			// Close the USING RS when exhausted and appropriate, 			// NOTE: Close before the user query, 			if (! anotherUsingRow || conn.getAutoCommit()) //if no more rows or if auto commit is on, close the resultset, 			{, 				rs.close();, 			}, , 			/*, 				4. execute the statement against those parameters, 			 */, , 			ps.execute();, 			JDBCDisplayUtil.DisplayResults(out,ps,conn);, , 			/*, 				5. clear the parameters, 			 */, 			ps.clearParameters();, 		}, 		if (!exec) {, 			rs.close(); //this means, using clause didn't qualify any rows. Just close the resultset associated with using clause, 			throw ijException.noUsingResults();, 		}, 		// REMIND: any way to look for more rsUsing rows if autoCommit?, 		// perhaps just document the behavior... , 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/util.java,DisplayVector,535-538,[		int l = v.size();, 		for (int i=0;i<l;i++), 			out.println(v.elementAt(i));, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/util.java,Usage,278-281,[     	out.println(, 		LocalizedResource.getMessage("IJ_UsageJavaComCloudToolsIjPPropeInput"));, 		out.flush();,    	}],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/tools/ij/util.java,qualifyResourceName,144-144,[			if (pName == null) return null;],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/utilMain.java,,66-833,[	private boolean firstRun = true;, 	private LocalizedOutput out = null;, 	private Hashtable ignoreErrors;, 	/**, 	 * True if to display the error code when, 	 * displaying a SQLException., 	 */, 	private final boolean showErrorCode;,     ,     /**,      * Value of the system property ij.execptionTrace,      */,     private final String ijExceptionTrace;, , 	/*, 		In the goodness of time, this could be an ij property, 	 */, 	public static final int BUFFEREDFILESIZE = 2048;, , 	/*, 	 * command can be redirected, so we stack up command, 	 * grabbers as needed., 	 */, 	Stack<StatementFinder> oldGrabbers = new Stack<StatementFinder>();, , 	LocalizedResource langUtil = LocalizedResource.getInstance();, 	/**, 	 * Set up the test to run with 'numConnections' connections/users., 	 *, 	 * @param numConnections	The number of connections/users to test., 	 */, 	utilMain(int numConnections, LocalizedOutput out), 		throws ijFatalException, 	{, 		this(numConnections, out, (Hashtable)null);, 	}, ,     /**, 	 * Set up the test to run with 'numConnections' connections/users.,      * This overload allows the choice of whether the system properties,      * will be used or not., 	 *, 	 * @param numConnections	The number of connections/users to test., 	 */,     utilMain(int numConnections, LocalizedOutput out, boolean loadSystemProperties), 		throws ijFatalException, 	{, 		this(numConnections, out, (Hashtable)null);,         if (loadSystemProperties) {,             initFromEnvironment();,         }, 	}, , 	/**, 	 * Set up the test to run with 'numConnections' connections/users., 	 *, 	 * @param numConnections	The number of connections/users to test., 	 * @param ignoreErrors		A list of errors to ignore.  If null,, 	 *							all errors are printed out and nothing, 	 *							is fatal.  If non-null, if an error is, 	 *							hit and it is in this list, it is silently	, 	 *							ignore.  Otherwise, an ijFatalException is, 	 *							thrown.  ignoreErrors is used for stress, 	 *							tests., 	 */, 	public utilMain(int numConnections, LocalizedOutput out, Hashtable ignoreErrors), 		throws ijFatalException, 	{, 		/* init the parser; give it no input to start with., 		 * (1 parser for entire test.), 		 */, 		charStream = new UCode_CharStream(, 						new StringReader(" "), 1, 1);, 		ijTokMgr = new ijTokenManager(charStream);, 		ijParser = new ij(ijTokMgr, this);, 		this.out = out;, 		if ( ignoreErrors != null ) { this.ignoreErrors = (Hashtable) ignoreErrors.clone(); }, 		, 		showErrorCode = , 			Boolean.valueOf(, 					util.getSystemProperty("ij.showErrorCode"), 					).booleanValue();,         ,         ijExceptionTrace = util.getSystemProperty("ij.exceptionTrace");, , 		this.numConnections = numConnections;, 		/* 1 StatementFinder and ConnectionEnv per connection/user. */, 		commandGrabber = new StatementFinder[numConnections];, 		connEnv = new ConnectionEnv[numConnections];, , 		for (int ictr = 0; ictr < numConnections; ictr++), 		{, 		    commandGrabber[ictr] = new StatementFinder(langUtil.getNewInput(System.in), out);, 			connEnv[ictr] = new ConnectionEnv(ictr, (numConnections > 1), (numConnections == 1));, 		}, , 		/* Start with connection/user 0 */, 		currCE = 0;, 		fileInput = false;, 		initialFileInput = false;, 		firstRun = true;, 	}, 	, 	/**, 	 * Initialize the connections from the environment., 	 *, 	 */, 	public void initFromEnvironment(), 	{, 		ijParser.initFromEnvironment();, 		, 		for (int ictr = 0; ictr < numConnections; ictr++), 		{, 			try {, 				connEnv[ictr].init(out);, 			} catch (SQLException s) {, 				JDBCDisplayUtil.ShowException(out, s); // will continue past connect failure, 			} catch (ClassNotFoundException c) {, 				JDBCDisplayUtil.ShowException(out, c); // will continue past driver failure, 			} catch (InstantiationException i) {, 				JDBCDisplayUtil.ShowException(out, i); // will continue past driver failure, 			} catch (IllegalAccessException ia) {, 				JDBCDisplayUtil.ShowException(out, ia); // will continue past driver failure, 			}, 		}, 	}, , , 	/**, 	 * run ij over the specified input, sending output to the, 	 * specified output. Any prior input and output will be lost., 	 *, 	 * @param in source for input to ij, 	 * @param out sink for output from ij, 	 */, 	public void go(LocalizedInput[] in, LocalizedOutput out), 				   throws ijFatalException, 	{, 		this.out = out;, 		, 		ijParser.setConnection(connEnv[currCE], (numConnections > 1));, 		fileInput = initialFileInput = (!in[currCE].isStandardInput());, , 		for (int ictr = 0; ictr < commandGrabber.length; ictr++) {, 			commandGrabber[ictr].ReInit(in[ictr]);, 		}, , 		if (firstRun) {, , 			// figure out which version this is, 			InputStream versionStream = (InputStream) java.security.AccessController.doPrivileged(this);, , 			// figure out which version this is, 			ProductVersionHolder ijVersion = , 				ProductVersionHolder.getProductVersionHolderFromMyEnv(versionStream);, , 			String version;, 			if (ijVersion != null), 			{, 				version = "" + ijVersion.getMajorVersion() + "." +, 					ijVersion.getMinorVersion();, 			}, 			else, 			{, 				version = "?";, 			}, ,    			out.println(langUtil.getTextMessage("IJ_IjVers30C199", version));, 			for (int i=connEnv.length-1;i>=0;i--) { // print out any initial warnings..., 				Connection c = connEnv[i].getConnection();, 				if (c!=null) {, 					JDBCDisplayUtil.ShowWarnings(out,c);, 				}, 			}, 			firstRun = false;, , 			supportIJProperties(connEnv[currCE]);,     	}, 		this.out = out;, 		runScriptGuts();, 		cleanupGo(in);, 	}, 	, 	/**, 	 * Support to run a script. Performs minimal setup, 	 * to set the passed in connection into the existing, 	 * ij setup, ConnectionEnv., 	 * @param conn, 	 * @param in, 	 */, 	public int goScript(Connection conn,, 			LocalizedInput in), 	{, 	    connEnv[0].addSession(conn, (String) null);,         ijParser.setConnection(connEnv[0], (numConnections > 1));, 	    supportIJProperties(connEnv[0]);   , 	    		, 		fileInput = initialFileInput = !in.isStandardInput();, 		commandGrabber[0].ReInit(in);, 		return runScriptGuts();, 	}, 	, 	private void supportIJProperties(ConnectionEnv env) {, 	  //check if the property is set to not show select count and set the static variable,         //accordingly. ,         boolean showNoCountForSelect = Boolean.valueOf(util.getSystemProperty("ij.showNoCountForSelect")).booleanValue();,         JDBCDisplayUtil.setShowSelectCount( !showNoCountForSelect );, ,         //check if the property is set to not show initial connections and accordingly set the,         //static variable.,         boolean showNoConnectionsAtStart = Boolean.valueOf(util.getSystemProperty("ij.showNoConnectionsAtStart")).booleanValue();, ,         if (!(showNoConnectionsAtStart)) {,             try {,                 ijResult result = ijParser.showConnectionsMethod(true);,                 displayResult(out,result,env.getConnection());,             } catch (SQLException ex) {,                 handleSQLException(out,ex);,             },         }        ,     }, ,     /**, 	 * Run the guts of the script. Split out to allow, 	 * calling from the full ij and the minimal goScript.,      * @return The number of errors seen in the script., 	 *, 	 */, 	private int runScriptGuts() {, ,         int scriptErrorCount = 0;, 		, 		boolean done = false;, 		String command = null;, 		while (!ijParser.exit && !done) {, 			try{, 				ijParser.setConnection(connEnv[currCE], (numConnections > 1));, 			} catch(Throwable t){, 				//do nothing, 				}, , 			connEnv[currCE].doPrompt(true, out);,    			try {,    				command = null;, 				out.flush();, 				command = commandGrabber[currCE].nextStatement();, , 				// if there is no next statement,, 				// pop back to the top saved grabber., 				while (command == null && ! oldGrabbers.empty()) {, 					// close the old input file if not System.in, 					if (fileInput) commandGrabber[currCE].close();, 					commandGrabber[currCE] = oldGrabbers.pop();, 					if (oldGrabbers.empty()), 						fileInput = initialFileInput;, 					command = commandGrabber[currCE].nextStatement();, 				}, , 				// if there are no grabbers left,, 				// we are done., 				if (command == null && oldGrabbers.empty()) {, 					done = true;, 				}, 				else {, 					boolean	elapsedTimeOn = ijParser.getElapsedTimeState();, 					long	beginTime = 0;, 					long	endTime;, , 					if (fileInput) {, 						out.println(command+";");, 						out.flush();, 					}, , 					charStream.ReInit(new StringReader(command), 1, 1);, 					ijTokMgr.ReInit(charStream);, 					ijParser.ReInit(ijTokMgr);, , 					if (elapsedTimeOn) {, 						beginTime = System.currentTimeMillis();, 					}, , 					ijResult result = ijParser.ijStatement();, 					displayResult(out,result,connEnv[currCE].getConnection());, , 					// if something went wrong, an SQLException or ijException was thrown., 					// we can keep going to the next statement on those (see catches below)., 					// ijParseException means we try the SQL parser., , 					/* Print the elapsed time if appropriate */, 					if (elapsedTimeOn) {, 						endTime = System.currentTimeMillis();, 						out.println(langUtil.getTextMessage("IJ_ElapTime0Mil", , 						langUtil.getNumberAsString(endTime - beginTime)));, 					}, , 					// would like when it completes a statement, 					// to see if there is stuff after the ;, 					// and before the <EOL> that we will IGNORE, 					// (with a warning to that effect), 				}, ,     			} catch (ParseException e) {,  					if (command != null),                         scriptErrorCount += doCatch(command) ? 0 : 1;, 				} catch (TokenMgrError e) {,  					if (command != null),                         scriptErrorCount += doCatch(command) ? 0 : 1;,     			} catch (SQLException e) {,                     scriptErrorCount++;, 					// SQL exception occurred in ij's actions; print and continue, 					// unless it is considered fatal., 					handleSQLException(out,e);,     			} catch (ijException e) {,                     scriptErrorCount++;, 					// exception occurred in ij's actions; print and continue,     			  	out.println(langUtil.getTextMessage("IJ_IjErro0",e.getMessage()));, 					doTrace(e);,     			} catch (Throwable e) {,                     scriptErrorCount++;,     			  	out.println(langUtil.getTextMessage("IJ_JavaErro0",e.toString()));, 					doTrace(e);, 				}, , 			/* Go to the next connection/user, if there is one */, 			currCE = ++currCE % connEnv.length;, 		},         ,         return scriptErrorCount;, 	}, 	, 	/**, 	 * Perform cleanup after a script has been run., 	 * Close the input streams if required and shutdown, 	 * derby on an exit., 	 * @param in, 	 */, 	private void cleanupGo(LocalizedInput[] in) {, , 		// we need to close all sessions when done; otherwise we have, 		// a problem when a single VM runs successive IJ threads, 		try {, 			for (int i = 0; i < connEnv.length; i++) {, 				connEnv[i].removeAllSessions();, 			}, 		} catch (SQLException se ) {, 			handleSQLException(out,se);, 		}, 		// similarly must close input files, 		for (int i = 0; i < numConnections; i++) {, 			try {, 				in[i].close();	, 			} catch (Exception e ) {,     			  	out.println(langUtil.getTextMessage("IJ_CannotCloseInFile",, 					e.toString()));, 			}, 		}, , 		/*, 			If an exit was requested, then we will be shutting down., 		 */, 		if (ijParser.exit || (initialFileInput && !mtUse)) {, 			Driver d = null;, 			try {, 			    d = DriverManager.getDriver("jdbc:derby:");, 			} catch (Throwable e) {, 				d = null;, 			}, 			if (d!=null) { // do we have a driver running? shutdown on exit., 				try {, 					DriverManager.getConnection("jdbc:derby:;shutdown=true");, 				} catch (SQLException e) {, 					// ignore the errors, they are expected., 				}, 			}, 		},   	}, , 	private void displayResult(LocalizedOutput out, ijResult result, Connection conn) throws SQLException {, 		// display the result, if appropriate., 		if (result!=null) {, 			if (result.isConnection()) {, 				if (result.hasWarnings()) {, 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());, 					result.clearSQLWarnings();, 				}, 			} else if (result.isStatement()) {, 				Statement s = result.getStatement();, 				try {, 				    JDBCDisplayUtil.DisplayResults(out,s,connEnv[currCE].getConnection());, 				} catch (SQLException se) {, 				    result.closeStatement();, 					throw se;, 				}, 				result.closeStatement();, 			} else if (result.isNextRowOfResultSet()) {, 				ResultSet r = result.getNextRowOfResultSet();, 				JDBCDisplayUtil.DisplayCurrentRow(out,r,connEnv[currCE].getConnection());, 			} else if (result.isVector()) {, 				util.DisplayVector(out,result.getVector());, 				if (result.hasWarnings()) {, 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());, 					result.clearSQLWarnings();, 				}, 			} else if (result.isMulti()) {, 			    try {, 				    util.DisplayMulti(out,(PreparedStatement)result.getStatement(),result.getResultSet(),connEnv[currCE].getConnection());, 				} catch (SQLException se) {, 				    result.closeStatement();, 					throw se;, 				}, 				result.closeStatement(); // done with the statement now, 				if (result.hasWarnings()) {, 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());, 					result.clearSQLWarnings();, 				}, 			} else if (result.isResultSet()) {, 				ResultSet rs = result.getResultSet();, 				try {, 					JDBCDisplayUtil.DisplayResults(out,rs,connEnv[currCE].getConnection(), result.getColumnDisplayList(), result.getColumnWidthList());, 				} catch (SQLException se) {, 					result.closeStatement();, 					throw se;, 				}, 				result.closeStatement();,             } else if (result.isMultipleResultSetResult()) {,               List<ResultSet> resultSets = result.getMultipleResultSets();,               try {,                 JDBCDisplayUtil.DisplayMultipleResults(out,resultSets,,                                      connEnv[currCE].getConnection(),,                                      result.getColumnDisplayList(),,                                      result.getColumnWidthList());,               } catch (SQLException se) {,                 result.closeStatement();,                 throw se;,               }, 			} else if (result.isException()) {, 				JDBCDisplayUtil.ShowException(out,result.getException());, 			}, 		}, 	}, , 	/**, 	 * catch processing on failed commands. This really ought to, 	 * be in ij somehow, but it was easier to catch in Main., 	 */, 	private boolean doCatch(String command) {, 		// this retries the failed statement, 		// as a JSQL statement; it uses the, 		// ijParser since that maintains our, 		// connection and state., ,         , 	    try {, 			boolean	elapsedTimeOn = ijParser.getElapsedTimeState();, 			long	beginTime = 0;, 			long	endTime;, , 			if (elapsedTimeOn) {, 				beginTime = System.currentTimeMillis();, 			}, , 			ijResult result = ijParser.executeImmediate(command);, 			displayResult(out,result,connEnv[currCE].getConnection());, , 			/* Print the elapsed time if appropriate */, 			if (elapsedTimeOn) {, 				endTime = System.currentTimeMillis();, 				out.println(langUtil.getTextMessage("IJ_ElapTime0Mil_4", , 				langUtil.getNumberAsString(endTime - beginTime)));, 			},             return true;, , 	    } catch (SQLException e) {, 			// SQL exception occurred in ij's actions; print and continue, 			// unless it is considered fatal., 			handleSQLException(out,e);, 	    } catch (ijException i) {, 	  		out.println(langUtil.getTextMessage("IJ_IjErro0_5", i.getMessage()));, 			doTrace(i);, 		} catch (ijTokenException ie) {, 	  		out.println(langUtil.getTextMessage("IJ_IjErro0_6", ie.getMessage()));, 			doTrace(ie);, 	    } catch (Throwable t) {, 	  		out.println(langUtil.getTextMessage("IJ_JavaErro0_7", t.toString()));, 			doTrace(t);, 	    },         return false;, 	}, , 	/**, 	 * This routine displays SQL exceptions and decides whether they, 	 * are fatal or not, based on the ignoreErrors field. If they, 	 * are fatal, an ijFatalException is thrown., 	 * Lifted from ij/util.java:ShowSQLException, 	 */, 	private void handleSQLException(LocalizedOutput out, SQLException e) , 		throws ijFatalException, 	{, 		String errorCode;, 		String sqlState = null;, 		SQLException fatalException = null;, , 		if (showErrorCode) {, 			errorCode = langUtil.getTextMessage("IJ_Erro0", , 			langUtil.getNumberAsString(e.getErrorCode()));, 		}, 		else {, 			errorCode = "";, 		}, , 		boolean syntaxErrorOccurred = false;, 		for (; e!=null; e=e.getNextException()), 		{, 			sqlState = e.getSQLState();, 			if ("42X01".equals(sqlState)), 				syntaxErrorOccurred = true;, 			/*, 			** If we are to throw errors, then throw the exceptions, 			** that aren't in the ignoreErrors list.  If, 			** the ignoreErrors list is null we don't throw, 			** any errors., 			*/, 		 	if (ignoreErrors != null) , 			{, 				if ((sqlState != null) &&, 					(ignoreErrors.get(sqlState) != null)), 				{, 					continue;, 				}, 				else, 				{, 					fatalException = e;, 				}, 			}, , 			String st1 = JDBCDisplayUtil.mapNull(e.getSQLState(),langUtil.getTextMessage("IJ_NoSqls"));, 			String st2 = JDBCDisplayUtil.mapNull(e.getMessage(),langUtil.getTextMessage("IJ_NoMess"));, 			out.println(langUtil.getTextMessage("IJ_Erro012",  st1, st2, errorCode));, 			doTrace(e);, 		}, 		if (fatalException != null), 		{, 			throw new ijFatalException(fatalException);, 		}, 		if (syntaxErrorOccurred), 			out.println(langUtil.getTextMessage("IJ_SuggestHelp"));, 	}, , 	/**, 	 * stack trace dumper, 	 */, 	private void doTrace(Throwable t) {, 		if (ijExceptionTrace != null) {, 			t.printStackTrace(out);, 		}, 		out.flush();, 	}, , 	void newInput(String fileName) {, 		FileInputStream newFile = null;, 		try {, 			newFile = new FileInputStream(fileName);,       	} catch (FileNotFoundException e) {,         	throw ijException.fileNotFound();, 		}, 		if (newFile == null) return;, , 		// if the file was opened, move to use it for input., 		oldGrabbers.push(commandGrabber[currCE]);, 	    commandGrabber[currCE] = ,                 new StatementFinder(langUtil.getNewInput(new BufferedInputStream(newFile, BUFFEREDFILESIZE)), null);, 		fileInput = true;, 	}, , 	void newResourceInput(String resourceName) {, 		InputStream is = util.getResourceAsStream(resourceName);, 		if (is==null) throw ijException.resourceNotFound();, 		oldGrabbers.push(commandGrabber[currCE]);, 	    commandGrabber[currCE] = ,                 new StatementFinder(langUtil.getNewEncodedInput(new BufferedInputStream(is, BUFFEREDFILESIZE), "UTF8"), null);, 		fileInput = true;, 	}, , 	/**, 	 * REMIND: eventually this might be part of StatementFinder,, 	 * used at each carriage return to show that it is still "live", 	 * when it is reading multi-line input., 	 */, 	static void doPrompt(boolean newStatement, LocalizedOutput out, String tag) , 	 {, 		if (newStatement) {, 	  		out.print("ij"+(tag==null?"":tag)+"> ");, 		}, 		else {, 			out.print("> ");, 		}, 		out.flush();, 	}, , 	void setMtUse(boolean b) {, 		mtUse = b;, 	}, ,     /**,      * Check that the cursor is scrollable.,      *,      * @param rs the ResultSet to check,      * @param operation which operation this is checked for,      * @exception ijException if the cursor isn't scrollable,      * @exception SQLException if a database error occurs,      */,     private void checkScrollableCursor(ResultSet rs, String operation),             throws ijException, SQLException {,         if (rs.getType() == ResultSet.TYPE_FORWARD_ONLY) {,             throw ijException.forwardOnlyCursor(operation);,         },     }, , 	/**, 	 * Position on the specified row of the specified ResultSet., 	 *, 	 * @param rs	The specified ResultSet., 	 * @param row	The row # to move to., 	 *				(Negative means from the end of the result set.), 	 *, 	 * @return	NULL., 	 *, 	 * @exception	SQLException thrown on error., 	 *				(absolute() not supported pre-JDBC2.0), 	 */, 	ijResult absolute(ResultSet rs, int row), 		throws SQLException, 	{,         checkScrollableCursor(rs, "ABSOLUTE");, 		// 0 is an *VALID* value for row, 		return new ijRowResult(rs, rs.absolute(row));, 	}, , 	/**, 	 * Move the cursor position by the specified amount., 	 *, 	 * @param rs	The specified ResultSet., 	 * @param row	The # of rows to move., 	 *				(Negative means toward the beginning of the result set.), 	 *, 	 * @return	NULL., 	 *, 	 * @exception	SQLException thrown on error., 	 *				(relative() not supported pre-JDBC2.0), 	 */, 	ijResult relative(ResultSet rs, int row), 		throws SQLException, 	{,         checkScrollableCursor(rs, "RELATIVE");, 		return new ijRowResult(rs, rs.relative(row));, 	}, , 	/**, 	 * Position before the first row of the specified ResultSet, 	 * and return NULL to the user., 	 *, 	 * @param rs	The specified ResultSet., 	 *, 	 * @return	NULL., 	 *, 	 * @exception	SQLException thrown on error., 	 *				(beforeFirst() not supported pre-JDBC2.0), 	 */, 	ijResult beforeFirst(ResultSet rs), 		throws SQLException, 	{,         checkScrollableCursor(rs, "BEFORE FIRST");, 		rs.beforeFirst();, 		return new ijRowResult(rs, false);, 	}, , 	/**, 	 * Position on the first row of the specified ResultSet, 	 * and return that row to the user., 	 *, 	 * @param rs	The specified ResultSet., 	 *, 	 * @return	The first row of the ResultSet., 	 *, 	 * @exception	SQLException thrown on error., 	 *				(first() not supported pre-JDBC2.0), 	 */, 	ijResult first(ResultSet rs), 		throws SQLException, 	{,         checkScrollableCursor(rs, "FIRST");, 		return new ijRowResult(rs, rs.first());, 	}, , 	/**, 	 * Position after the last row of the specified ResultSet, 	 * and return NULL to the user., 	 *, 	 * @param rs	The specified ResultSet., 	 *, 	 * @return	NULL., 	 *, 	 * @exception	SQLException thrown on error., 	 *				(afterLast() not supported pre-JDBC2.0), 	 */, 	ijResult afterLast(ResultSet rs), 		throws SQLException, 	{,         checkScrollableCursor(rs, "AFTER LAST");, 		rs.afterLast();, 		return new ijRowResult(rs, false);, 	}, , 	/**, 	 * Position on the last row of the specified ResultSet, 	 * and return that row to the user., 	 *, 	 * @param rs	The specified ResultSet., 	 *, 	 * @return	The last row of the ResultSet., 	 *, 	 * @exception	SQLException thrown on error., 	 *				(last() not supported pre-JDBC2.0), 	 */, 	ijResult last(ResultSet rs), 		throws SQLException, 	{,         checkScrollableCursor(rs, "LAST");, 		return new ijRowResult(rs, rs.last());, 	}, , 	/**, 	 * Position on the previous row of the specified ResultSet, 	 * and return that row to the user., 	 *, 	 * @param rs	The specified ResultSet., 	 *, 	 * @return	The previous row of the ResultSet., 	 *, 	 * @exception	SQLException thrown on error., 	 *				(previous() not supported pre-JDBC2.0), 	 */, 	ijResult previous(ResultSet rs), 		throws SQLException, 	{,         checkScrollableCursor(rs, "PREVIOUS");, 		return new ijRowResult(rs, rs.previous());, 	}, , 	/**, 	 * Get the current row number, 	 *, 	 * @param rs	The specified ResultSet., 	 *, 	 * @return	The current row number, 	 *, 	 * @exception	SQLException thrown on error., 	 *				(getRow() not supported pre-JDBC2.0), 	 */, 	int getCurrentRowNumber(ResultSet rs), 		throws SQLException, 	{,         checkScrollableCursor(rs, "GETCURRENTROWNUMBER");, 		return rs.getRow();, 	}, , 	public final Object run() {, 		return  getClass().getResourceAsStream(ProductGenusNames.TOOLS_INFO);],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/impl/tools/ij/utilMain.java,runScriptGuts,339-339,[					charStream.ReInit(new StringReader(command), 1, 1);],,runScriptGuts,326-326,[				if (command == null && oldGrabbers.empty()) {],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE,org/apache/derby/impl/tools/ij/utilMain.java,cleanupGo,435-435,[					DriverManager.getConnection("jdbc:derby:;shutdown=true");],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/tools/ij/utilMain.java,newInput,631-631,[		if (newFile == null) return;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/derby/impl/tools/ij/utilMain.java,runScriptGuts,339-339,[					charStream.ReInit(new StringReader(command), 1, 1);],,runScriptGuts,368-368,[ 					if (command != null)],,
STYLE,SA_FIELD_DOUBLE_ASSIGNMENT,org/apache/derby/impl/tools/ij/utilMain.java,runScriptGuts,390-390,[			currCE = ++currCE % connEnv.length;],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/derby/impl/tools/ij/utilMain.java,run,833-833,[		return  getClass().getResourceAsStream(ProductGenusNames.TOOLS_INFO);],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derby/impl/tools/ij/xaHelper.java,setDataSourceProperty,624-624,[			m.invoke(ds, new Object[] {new Boolean(value)});],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/tools/ij/xaHelper.java,setDataSourceProperty,592-592,[			m.invoke(ds, new Object[] {new Integer(value)});],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,,62-627,[  {,   }, 	  , 	  , 	public void setFramework(String fm), 	{,                 if (fm == null) {,                     return;,                 }, 		framework = fm.toUpperCase(Locale.ENGLISH);, 		if (framework.endsWith("NET") ||, 			framework.equals("DB2JCC")), 			isJCC = true;, 		else if (framework.equals("DERBYNETCLIENT")), 				 isNetClient = true;, , 	}, 		, 	private Xid makeXid(int xid), 	{, 		try {, 			return new ijXid(xid, databaseName.getBytes("UTF-8"));, 		} catch (UnsupportedEncodingException e) {, 			// UTF-8 is a required encoding. We should never get here., 			e.printStackTrace();, 			return null;, 		}, 	}, , 	public void XADataSourceStatement(ij parser, Token dbname, Token shutdown,, 									String create), 		 throws SQLException, 	{, 		try, 		{, 			  currentXADataSource = (XADataSource) getXADataSource();, , 			  databaseName = parser.stringValue(dbname.image);, 			  , 			  if (isJCC || isNetClient), 			  {, 			  	String hostName = System.getProperty("hostName");, 			  	if ((hostName != null ) && (!hostName.equals("localhost"))), 				{			, 			  		xaHelper.setDataSourceProperty(currentXADataSource,, 											 "ServerName", hostName);, 				}, 			  	else, 				{			, 			  		xaHelper.setDataSourceProperty(currentXADataSource,, 							 "ServerName", "localhost");, 				}, 			  xaHelper.setDataSourceProperty(currentXADataSource,, 											 "portNumber", 1527);, 			  , 			  String user;, 			  String password;, 			  user = "APP";, 			  password = "APP";, 			  xaHelper.setDataSourceProperty(currentXADataSource,, 											 "user", user);, 			  xaHelper.setDataSourceProperty(currentXADataSource,, 											 "password", password);, 			  //xaHelper.setDataSourceProperty(currentXADataSource,, 			  //"traceFile", "trace.out." + framework);, 			  }, 			  if (isJCC), 			  {, 				  xaHelper.setDataSourceProperty(currentXADataSource,, 												 "driverType", 4);, , 				  xaHelper.setDataSourceProperty(currentXADataSource, , 												 "retrieveMessagesFromServerOnGetMessage", true);, 			  }, 			  xaHelper.setDataSourceProperty(currentXADataSource, "databaseName", databaseName);, , 			if (shutdown != null && shutdown.toString().toLowerCase(Locale.ENGLISH).equals("shutdown")), 			{	, 				if (isJCC || isNetClient), 					xaHelper.setDataSourceProperty(currentXADataSource,"databaseName", databaseName + ";shutdown=true");, 				else, 					xaHelper.setDataSourceProperty(currentXADataSource, "shutdownDatabase", "shutdown");, , 				// do a getXAConnection to shut it down */, 				currentXADataSource.getXAConnection().getConnection();, 				currentXADataSource = null;, 				currentXAConnection = null;, 			}, 			else if (create != null && create.toLowerCase(java.util.Locale.ENGLISH).equals("create")), 			{, 				if (isJCC || isNetClient), 					xaHelper.setDataSourceProperty(currentXADataSource,"databaseName", databaseName + ";create=true");, 				else, 					xaHelper.setDataSourceProperty(currentXADataSource,, 												   "createDatabase", "create");, , 				/* do a getXAConnection to create it */, 				XAConnection conn = currentXADataSource.getXAConnection();, 				conn.close();, 				, 				xaHelper.setDataSourceProperty(currentXADataSource, "createDatabase", null);, 			}, 		}, 		catch (Throwable t), 		{,             throw handleException(t);, 		}	, 	}, , , 	public void XAConnectStatement(ij parser, Token user, Token pass, String id), 		 throws SQLException, 	{, 		try, 		{, 			if (currentXAConnection != null), 			{, 				try {, 					currentXAConnection.close();, 				} catch (SQLException sqle) {, 				}, , 				currentXAConnection = null;, 			}, , 			String username = null;, 			String password = "";, , 			if (pass != null), 				password = parser.stringValue(pass.image);, , 			if (user != null), 			{, 				username = parser.stringValue(user.image);, , 				currentXAConnection = , 					currentXADataSource.getXAConnection(username, password);, 			}, 			else, 			{, , 				currentXAConnection = currentXADataSource.getXAConnection();, 			}, , 		}, 		catch (Throwable t), 		{,             throw handleException(t);, 		}, 	}, , 	public void XADisconnectStatement(ij parser, String n) throws SQLException, 	{, 		if (currentXAConnection == null), 			throw ijException.noSuchConnection("XAConnection");, 		currentXAConnection.close();, 		currentXAConnection = null;, 	}, , 	public Connection XAGetConnectionStatement(ij parser, String n) throws SQLException, 	{, 		try, 		{, 			return currentXAConnection.getConnection();, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}, , 	public void CommitStatement(ij parser, Token onePhase, Token twoPhase, , 								int xid) , 		 throws SQLException, 	{, 		try, 		{	, 			currentXAConnection.getXAResource().commit(makeXid(xid), (onePhase != null));, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}, , 	public void EndStatement(ij parser, int flag, int xid) throws SQLException, 	{, 		try, 		{	, 			currentXAConnection.getXAResource().end(makeXid(xid), flag);, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}, , 	public void ForgetStatement(ij parser, int xid) throws SQLException, 	{, 		try, 		{	, 			currentXAConnection.getXAResource().forget(makeXid(xid));, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}, , 	public void PrepareStatement(ij parser, int xid) throws SQLException, 	{, 		try, 		{	, 			currentXAConnection.getXAResource().prepare(makeXid(xid));, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}, , 	public ijResult RecoverStatement(ij parser, int flag) throws SQLException, 	{, 		Object[] val = null;, , 		try, 		{	, 			val = currentXAConnection.getXAResource().recover(flag);, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, , 		Vector<String> v = new Vector<String>();, 		v.addElement("");, 		v.addElement(LocalizedResource.getMessage("IJ_Reco0InDoubT", LocalizedResource.getNumber(val.length)));, 		v.addElement("");, 		for (int i = 0; i < val.length; i++), 			v.addElement(LocalizedResource.getMessage("IJ_Tran01", LocalizedResource.getNumber(i+1), val[i].toString()));, , 		return new ijVectorResult(v,null);, , 	}, , 	public void RollbackStatement(ij parser, int xid) throws SQLException, 	{, 		try, 		{	, 			currentXAConnection.getXAResource().rollback(makeXid(xid));, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}, , 	public void StartStatement(ij parser, int flag, int xid) throws SQLException, 	{, 		try, 		{	, 			currentXAConnection.getXAResource().start(makeXid(xid), flag);, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}, ,     /**,      * Handles the given throwable.,      * <p>,      * If possible, an {@code SQLException} is returned. Otherwise the,      * appropriate actions are taken and a {@code RuntimeException} is thrown.,      *,      * @param t exception to handle,      * @return An {@code SQLException}.,      * @throws RuntimeException if the throwable isn't an {@code SQLException},      */, 	private SQLException handleException(Throwable t), 	{, 		if (t instanceof SQLException), 		{, 			// let ij handle it,             return (SQLException)t;, 		}, 		if (t instanceof XAException), 		{, 			int errorCode = ((XAException)t).errorCode;, 			String error = LocalizedResource.getMessage("IJ_IlleValu");, , 			// XA_RBBASE 100, 			// XA_RBROLLBACK 100, 			// XA_RBCOMMFAIL 101, 			// XA_RBDEADLOCK 102, 			// XA_RBINTEGRITY 103, 			// XA_RBOTHER 104, 			// XA_RBPROTO 105, 			// XA_RBTIMEOUT 106, 			// XA_RBTRANSIENT 107, 			// XA_RBEND 107, 			//, 			// XA_RDONLY 3, 			// XA_RETRY 4, 			// XA_HEURMIX 5, 			// XA_HEURRB 6, 			// XA_HEURCOM 7, 			// XA_HEURHAZ 8, 			// XA_NOMIGRATE 9, 			//, 			// XAER_ASYNC -2, 			// XAER_RMERR -3, 			// XAER_NOTA -4, 			// XAER_INVAL -5, 			// XAER_PROTO -6, 			// XAER_RMFAIL -7, 			// XAER_DUPID -8, 			// XAER_OUTSIDE -9, , 			switch(errorCode), 			{, 			case XAException.XA_HEURCOM : error = "XA_HEURCOM "; break;, 			case XAException.XA_HEURHAZ : error = "XA_HEURHAZ"; break;, 			case XAException.XA_HEURMIX : error = "XA_HEURMIX"; break;, 			case XAException.XA_HEURRB : error = "XA_HEURRB "; break;, 			case XAException.XA_NOMIGRATE : error = "XA_NOMIGRATE "; break;, 				// case XAException.XA_RBBASE : error = "XA_RBBASE "; break;, 			case XAException.XA_RBCOMMFAIL : error = "XA_RBCOMMFAIL "; break;, 			case XAException.XA_RBDEADLOCK : error = "XA_RBDEADLOCK "; break;, 				// case XAException.XA_RBEND : error = "XA_RBEND "; break;, 			case XAException.XA_RBINTEGRITY : error = "XA_RBINTEGRITY "; break;, 			case XAException.XA_RBOTHER : error = "XA_RBOTHER "; break;, 			case XAException.XA_RBPROTO : error = "XA_RBPROTO "; break;, 			case XAException.XA_RBROLLBACK : error = "XA_RBROLLBACK "; break;, 			case XAException.XA_RBTIMEOUT : error = "XA_RBTIMEOUT "; break;, 			case XAException.XA_RBTRANSIENT : error = "XA_RBTRANSIENT "; break;, 			case XAException.XA_RDONLY : error = "XA_RDONLY "; break;, 			case XAException.XA_RETRY : error = "XA_RETRY "; break;, 			case XAException.XAER_ASYNC : error = "XAER_ASYNC "; break;, 			case XAException.XAER_DUPID : error = "XAER_DUPID "; break;, 			case XAException.XAER_INVAL : error = "XAER_INVAL "; break;, 			case XAException.XAER_NOTA : error = "XAER_NOTA "; break;, 			case XAException.XAER_OUTSIDE : error = "XAER_OUTSIDE "; break;, 			case XAException.XAER_PROTO : error = "XAER_PROTO "; break;, 			case XAException.XAER_RMERR : error = "XAER_RMERR "; break;, 			case XAException.XAER_RMFAIL : error = "XAER_RMFAIL "; break;, 			}, 			//t.printStackTrace(System.out);, 			throw new ijException(error);, , 		}, 		else // StandardException or run time exception, log it first, 		{, 			String info = LocalizedResource.getMessage("IJ_01SeeLog", t.toString(), t.getMessage());, 			//		t.printStackTrace(System.out);, 			throw new ijException(info);, 		}, 	}, , , 	// non-xa stuff. DataSource and ConnectionPoolDataSource, 	public Connection DataSourceStatement(ij parser, Token dbname, Token protocol,, 									Token userT, Token passT, String id), 		 throws SQLException, 	{, , 		try {, 			currentDataSource = (DataSource) (Class.forName("org.apache.derby.jdbc.EmbeddedDataSource").newInstance());, 		} catch (Exception e) {, 			throw new SQLException(e.toString());, 		}, 		databaseName = parser.stringValue(dbname.image);, 		xaHelper.setDataSourceProperty(currentDataSource, "databaseName", databaseName);, 		xaHelper.setDataSourceProperty(currentXADataSource, "dataSourceName", databaseName);, 		// make a connection, 		Connection c = null;, 		String username = null;, 		String password = "";, , 		if (passT != null), 			password = parser.stringValue(passT.image);, , 		if (userT != null), 		{, 			username = parser.stringValue(userT.image);, 			c = currentDataSource.getConnection(username, password);, 		}, 		else, 		{, 			c = currentDataSource.getConnection();, 		}, , 		return c;, , 	}, , 	public void CPDataSourceStatement(ij parser, Token dbname, Token protocol), 		 throws SQLException, 	{, 		try {, 			currentCPDataSource = (ConnectionPoolDataSource) (Class.forName("org.apache.derby.jdbc.EmbeddedConnectionPoolDataSource").newInstance());, 		} catch (Exception e) {, 			throw new SQLException(e.toString());, 		}, 		databaseName = parser.stringValue(dbname.image);, 		xaHelper.setDataSourceProperty(currentCPDataSource, "databaseName", databaseName);, 	}, , 	public void CPConnectStatement(ij parser, Token userT, Token passT, String n), 		 throws SQLException, 	{, 		String username = null;, 		String password = "";, , 		if (passT != null), 			password = parser.stringValue(passT.image);, , 		if (userT != null), 		{, 			username = parser.stringValue(userT.image);, 			currentPooledConnection =, 				currentCPDataSource.getPooledConnection(username, password);, 		}, 		else, 		{, 			currentPooledConnection =, 				currentCPDataSource.getPooledConnection();, 		}, 	}, , 	public Connection CPGetConnectionStatement(ij parser, String n) , 		 throws SQLException , 	{, 		return currentPooledConnection.getConnection();, 	}, , 	public void CPDisconnectStatement(ij parser, String n) throws SQLException, 	{, 		if (currentPooledConnection == null), 			throw ijException.noSuchConnection(LocalizedResource.getMessage("PooledConnection"));, 		currentPooledConnection.close();, 		currentPooledConnection = null;, 	}, , 	/**, 	 * Get a DataSource that supports distributed transactions., 	 *, 	 * @return XADataSource object , 	 *, 	 * @exception Exception if XaDataSource is not in class path., 	 */, 	private XADataSource getXADataSource() throws Exception, 	{, 		// We need to construct this object in this round about fashion because, 		// if we new it directly, then it will the tools.jar file to bloat., 		try, 		{, 		    ,             if (isJCC),                return (XADataSource) ,                 (Class.forName("com.ibm.db2.jcc.DB2XADataSource").newInstance());,             else if (isNetClient){,                 if (ij.JNDI()) {,                     //running under jdk1.6 or higher,                     // try instantiating EmbeddedXADataSource40,                     try {,                         return (XADataSource)(Class.forName(,                                 "org.apache.derby.jdbc.ClientXADataSource40").,                                 newInstance());,                     },                     catch (ClassNotFoundException e) {,                         //probably it was not compiled with jdbc4.0,                         //support go ahead with ClientXADataSource,                     },                     catch (UnsupportedClassVersionError ue) {,                         // ClientXADataSource,                     },                     return (XADataSource) (Class.forName(,                             "org.apache.derby.jdbc.ClientXADataSource",                             ).newInstance());,                 } else {,                     return (XADataSource)(Class.forName(,                         "org.apache.derby.jdbc.BasicClientXADataSource40").,                             newInstance());,                 },             } else {,                 if (ij.JNDI()) {,                     //running under jdk1.6 or higher,                     // try instantiating EmbeddedXADataSource40,                     try {,                         return (XADataSource)(Class.forName(,                             "org.apache.derby.jdbc.EmbeddedXADataSource40").,                                 newInstance());,                     } catch (ClassNotFoundException e) {,                         //probably it was not compiled with jdbc4.0,                         //support go ahead with EmbeddedXADataSource,                     } catch (UnsupportedClassVersionError ue) {,                         // not jdk 16 or higher. Go ahead with,                         // EmbeddedXADataSource,                     }, ,                     return (XADataSource)(Class.forName(,                         "org.apache.derby.jdbc.EmbeddedXADataSource").,                             newInstance());,                 } else {,                     return (XADataSource)(Class.forName(,                         "org.apache.derby.jdbc.BasicEmbeddedXADataSource40").,                             newInstance());,                 },             },         },         catch(ClassNotFoundException cnfe) {, 			throw new ijException(LocalizedResource.getMessage("IJ_XAClass"));, 		}, 		catch (InstantiationException e) { }, 		catch (IllegalAccessException e) { }, , 		throw new ijException(LocalizedResource.getMessage("IJ_XANoI"));, 	}, 	private static final Class[] STRING_P = { "".getClass() };, 	private static final Class[] INT_P = { Integer.TYPE };, 	private static final Class[] BOOLEAN_P = {Boolean.TYPE };, , 	private static void setDataSourceProperty(Object ds, String property, int , 											  value) throws SQLException, 	{, 		String methodName =, 			"set" + Character.toUpperCase(property.charAt(0)) + property.substring(1);, 		try {, 			java.lang.reflect.Method m = ds.getClass().getMethod(methodName, INT_P);, 			m.invoke(ds, new Object[] {new Integer(value)});, 		}, 		catch (Exception e), 		{, 			throw new SQLException(property + " ???" + e.getMessage());, 		}		, 		, 	}, 	, 	private static void setDataSourceProperty(Object ds, String property, String value) throws SQLException {, , 		String methodName =, 			"set" + Character.toUpperCase(property.charAt(0)) + property.substring(1);, , 		try {, 			java.lang.reflect.Method m = ds.getClass().getMethod(methodName, STRING_P);, 			m.invoke(ds, new Object[] {value});, 			return;, 		} catch (/*NoSuchMethod*/Exception nsme) {, 			throw new SQLException(property + " ???");, 			//java.lang.reflect.Method m = ds.getClass().getMethod("set" + property, INT_P);, 			//m.invoke(ds, new Object[] {Integer.valueOf(value)});, 		}, 	}, , private static void setDataSourceProperty(Object ds, String property, boolean value) throws SQLException {, , 		String methodName =, 			"set" + Character.toUpperCase(property.charAt(0)) + property.substring(1);, , 		try {, 			java.lang.reflect.Method m = ds.getClass().getMethod(methodName, BOOLEAN_P);, 			m.invoke(ds, new Object[] {new Boolean(value)});, 			return;, 		} catch (Exception nsme) {, 			throw new SQLException(property + " ???");],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,CommitStatement,239-245,[			currentXAConnection.getXAResource().commit(makeXid(xid), (onePhase != null));, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,DataSourceStatement,429-454,[			currentDataSource = (DataSource) (Class.forName("org.apache.derby.jdbc.EmbeddedDataSource").newInstance());, 		} catch (Exception e) {, 			throw new SQLException(e.toString());, 		}, 		databaseName = parser.stringValue(dbname.image);, 		xaHelper.setDataSourceProperty(currentDataSource, "databaseName", databaseName);, 		xaHelper.setDataSourceProperty(currentXADataSource, "dataSourceName", databaseName);, 		// make a connection, 		Connection c = null;, 		String username = null;, 		String password = "";, , 		if (passT != null), 			password = parser.stringValue(passT.image);, , 		if (userT != null), 		{, 			username = parser.stringValue(userT.image);, 			c = currentDataSource.getConnection(username, password);, 		}, 		else, 		{, 			c = currentDataSource.getConnection();, 		}, , 		return c;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,EndStatement,251-257,[			currentXAConnection.getXAResource().end(makeXid(xid), flag);, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,ForgetStatement,263-269,[			currentXAConnection.getXAResource().forget(makeXid(xid));, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,PrepareStatement,275-281,[			currentXAConnection.getXAResource().prepare(makeXid(xid));, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,RecoverStatement,285-303,[		Object[] val = null;, , 		try, 		{	, 			val = currentXAConnection.getXAResource().recover(flag);, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, , 		Vector<String> v = new Vector<String>();, 		v.addElement("");, 		v.addElement(LocalizedResource.getMessage("IJ_Reco0InDoubT", LocalizedResource.getNumber(val.length)));, 		v.addElement("");, 		for (int i = 0; i < val.length; i++), 			v.addElement(LocalizedResource.getMessage("IJ_Tran01", LocalizedResource.getNumber(i+1), val[i].toString()));, , 		return new ijVectorResult(v,null);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,RollbackStatement,311-317,[			currentXAConnection.getXAResource().rollback(makeXid(xid));, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/impl/tools/ij/xaHelper.java,StartStatement,323-329,[			currentXAConnection.getXAResource().start(makeXid(xid), flag);, 		}, 		catch(Throwable t), 		{,             throw handleException(t);, 		}, 	}],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/tools/ij/xaHelper.java,setDataSourceProperty,626-626,[		} catch (Exception nsme) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/tools/ij/xaHelper.java,setDataSourceProperty,594-594,[		catch (Exception e)],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/impl/tools/ij/xaHelper.java,setDataSourceProperty,610-610,[		} catch (/*NoSuchMethod*/Exception nsme) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/tools/optional/DBMDWrapper.java,unregisterFunction,712-712,[        } catch (SQLException se) {}],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/tools/optional/DBMDWrapper.java,getDummyValue,813-813,[        else if ( Integer.TYPE == type ) { return new Integer( 1 ); }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/impl/tools/optional/DBMDWrapper.java,getDummyValue,814-814,[        else if ( Short.TYPE == type ) { return new Short( (short) 1 ); }],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/optional/DBMDWrapper.java,registerFunction,733-733,[        executeDDL( conn, buffer.toString() );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/optional/DBMDWrapper.java,executeDDL,887-887,[			ps = prepareStatement( conn, text );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/optional/DBMDWrapper.java,prepareStatement,902-902,[		PreparedStatement	ps = conn.prepareStatement( text );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/optional/DBMDWrapper.java,unregisterFunction,711-711,[            executeDDL( conn, "drop function " + method.getName() );],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/optional/ForeignDBViews.java,createDerbySchema,296-296,[        ResultSet   existsRS = existsPS.executeQuery();],,createDerbySchema,297-297,[        existsRS.next();],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/optional/ForeignDBViews.java,registerForeignTable,264-264,[        executeDDL( derbyConn, tfDDL );],,registerForeignTable,265-265,[        executeDDL( derbyConn, viewDDL );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/optional/ForeignDBViews.java,createDerbySchema,305-305,[                ( derbyConn, "create schema " + delimitedID( derbySchemaName ) );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/optional/ForeignDBViews.java,dropObject,452-452,[                (],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/optional/ForeignDBViews.java,executeDDL,500-500,[        PreparedStatement   ddl = prepareStatement( conn, text );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/optional/ForeignDBViews.java,prepareStatement,509-509,[        return conn.prepareStatement( text );],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,closeConnection,583-583,[        catch (SQLException sqlExcept){}],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,createXMLData,441-441,[                    data[i].setParent(text+"");],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,createXMLData,379-379,[        ResultSet results = ps.executeQuery();],,createXMLData,381-381,[        int i=0;],,createXMLData,382-382,[        while(results.next())],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,createXMLData,376-376,[        PreparedStatement ps = conn.prepareStatement(qry);],,createXMLData,377-377,[        ps.setString(1, getQuery());],,createXMLData,379-379,[        ResultSet results = ps.executeQuery();],,createXMLData,381-381,[        int i=0;],,createXMLData,382-382,[        while(results.next())],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,noOfNodes,460-460,[        ResultSet results = ps.executeQuery();],,noOfNodes,461-461,[        results.next();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,noOfNodes,457-457,[        PreparedStatement ps = conn.prepareStatement(],,noOfNodes,459-459,[        ps.setString(1, getQuery());],,noOfNodes,460-460,[        ResultSet results = ps.executeQuery();],,noOfNodes,461-461,[        results.next();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,setSchema,138-138,[        PreparedStatement setSchema = conn.prepareStatement("SET SCHEMA ?");],,setSchema,139-139,[        setSchema.setString(1, schema);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,statement,478-478,[        ResultSet results = ps.executeQuery();],,statement,479-479,[        results.next();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,statement,475-475,[        PreparedStatement ps = conn.prepareStatement(],,statement,477-477,[        ps.setString(1, getQuery());],,statement,478-478,[        ResultSet results = ps.executeQuery();],,statement,479-479,[        results.next();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,time,554-554,[        ResultSet results = ps.executeQuery();],,time,555-555,[        results.next();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,time,549-549,[        PreparedStatement ps = conn.prepareStatement(],,time,553-553,[        ps.setString(1, getQuery());],,time,554-554,[        ResultSet results = ps.executeQuery();],,time,555-555,[        results.next();],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,createXMLData,376-376,[        PreparedStatement ps = conn.prepareStatement(qry);],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,noOfNodes,457-457,[        PreparedStatement ps = conn.prepareStatement(],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,setSchema,138-138,[        PreparedStatement setSchema = conn.prepareStatement("SET SCHEMA ?");],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,statement,475-475,[        PreparedStatement ps = conn.prepareStatement(],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,time,549-549,[        PreparedStatement ps = conn.prepareStatement(],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,indent,309-309,[            str +="    ";],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,createXMLData,392-430,[                switch(x){,                 case ID:,                     data[i].setId(text+" ");,                     break;,                 case P_ID:,                     data[i].setParent(text);,                     break;,                 case NODE_TYPE:,                     data[i].setNodeType(text+" ");,                     break;,                 case NO_OF_OPENS:,                     data[i].setNoOfOpens(text+" ");,                     break;,                 case INPUT_ROWS:,                     data[i].setInputRows(text+" ");,                     break;,                 case RETURNED_ROWS:,                     data[i].setReturnedRows(text+" ");,                     break;,                 case VISITED_PAGES:,                     data[i].setVisitedPages(text+" ");,                     break;,                 case SCAN_QUALIFIERS:,                     data[i].setScanQualifiers(text+" ");,                     break;,                 case NEXT_QUALIFIERS:,                     data[i].setNextQualifiers(text+" ");,                     break;,                 case SCANNED_OBJECT:,                     data[i].setScannedObject(text+" ");,                     break;,                 case SCAN_TYPE:,                     data[i].setScanType(text+" ");,                     break;,                 case SORT_TYPE:,                     data[i].setSortType(text+" ");,                     break;,                 case NO_OF_OUTPUT_ROWS_BY_SORTER:,                     data[i].setSorterOutput(text+" ");],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/impl/tools/planexporter/AccessDatabase.java,createXMLData,376-376,[        PreparedStatement ps = conn.prepareStatement(qry);],,
I18N,DM_CONVERT_CASE,org/apache/derby/impl/tools/planexporter/CreateHTMLFile.java,getHTML,54-54,[        if(!(HTMLFile.toUpperCase()).endsWith(".HTML"))],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/derby/impl/tools/planexporter/CreateHTMLFile.java,getHTML,61-61,[            URL url=getClass().getResource(XSLSheetName);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/impl/tools/planexporter/CreateXMLFile.java,writeTheXMLFile,80-80,[            throw (IOException) pae.getCause();],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derby/impl/tools/planexporter/CreateXMLFile.java,writeTheXMLFile,83-83,[        Writer out = new BufferedWriter(new OutputStreamWriter(fos, "UTF-8"));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/impl/tools/planexporter/CreateXMLFile.java,,74-76,[                    new PrivilegedExceptionAction<FileOutputStream>() {,                         public FileOutputStream run() throws IOException {,                             return new FileOutputStream(file_name);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/tools/sysinfo/Main.java,pause,214-214,[      BufferedReader br = new BufferedReader (new InputStreamReader (System.in));],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/impl/tools/sysinfo/Main.java,useMe,631-631,[	        localPW = new java.io.PrintWriter(System.out);],,
PERFORMANCE,DM_NEW_FOR_GETCLASS,org/apache/derby/impl/tools/sysinfo/Main.java,getAllInfo,914-914,[            zip.setLocation(getFileWhichLoadedClass(new Main().getClass()));],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/impl/tools/sysinfo/Main.java,checkFile,1134-1134,[            ZipFile zf = new ZipFile(filename);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/tools/sysinfo/Main.java,loadZipFromResource,1008-1008,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/impl/tools/sysinfo/Main.java,parseClasspath,1030-1030,[            return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/impl/tools/sysinfo/Main.java,getAllInfo,252-252,[    if (zip != null) {],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/tools/sysinfo/Main.java,lookForMainArg,818-838,[		int length=args.length;, 		String[] legalargs = new String[1];, 		legalargs[0] = EMBEDDED;, , 		int argsfound = 0;, 		String whichargument="";, , 		for (int i = 0; i < length; i++) {, , 			for (int j=0; j < legalargs.length; j++) {, 				if (args[i].toUpperCase(java.util.Locale.ENGLISH).equals(legalargs[j].toUpperCase(java.util.Locale.ENGLISH))) {, 					argsfound++;, 					whichargument=legalargs[j];, 				}, 			}, 		}, 		if (argsfound > 1 || argsfound < 1) {,             localPW.println(Main.getTextMessage("SIF08.A", USAGESTRINGPARTA, USAGESTRINGPARTB));, 			return "";, 		}, 		return whichargument;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/impl/tools/sysinfo/Main.java,tryAsResource,779-790,[			java.io.InputStream in = cn.getClass().getResourceAsStream(cn);, 			in.close();,                         String loc = getFileWhichLoadedClass(cn.getClass());, 			successes.append(found(cn, library, loc));, 		}, , 		catch (Throwable t) {, 			failures.append(notFound(cn, library));, , 		}, , 	}],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/impl/tools/sysinfo/Main.java,,176-176,[  private static boolean setLicense = false;],,
PERFORMANCE,DM_NEW_FOR_GETCLASS,org/apache/derby/impl/tools/sysinfo/Main.java,run,981-981,[                        new Main().getClass().getResourceAsStream(resource);],,
PERFORMANCE,DM_NEW_FOR_GETCLASS,org/apache/derby/impl/tools/sysinfo/Main.java,run,996-996,[                                URL realUrl = new Main().getClass().getResource(resource);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/jdbc/AutoloadedDriver.java,deregisterDriver,295-295,[            throw (SQLException) pae.getCause();],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/jdbc/AutoloadedDriver.java,unregisterDriverModule,264-266,[            if (InternalDriver.getDeregister() && _autoloadedDriver != null) {,                 deregisterDriver(_autoloadedDriver);,                 _autoloadedDriver = null;],,
MT_CORRECTNESS,LI_LAZY_INIT_UPDATE_STATIC,org/apache/derby/jdbc/AutoloadedDriver.java,registerDriverModule,243-245,[            if (_autoloadedDriver == null) {,                 //Support JDBC 4 or higher (DERBY-2905),                 _autoloadedDriver = makeAutoloadedDriver();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/jdbc/BasicClientDataSource40.java,,52-53,[        super();,     }],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/BasicEmbeddedConnectionPoolDataSource40.java,,47-88,[        super();,     }, ,     /*,      * Implementation of ConnectionPoolDataSource interface methods,      */, ,     /**,      * @see javax.sql.ConnectionPoolDataSource#getPooledConnection(),      */,     public final PooledConnection getPooledConnection() throws SQLException {,         return createPooledConnection (getUser(), getPassword(), false);,     }, ,     /**,      * @see javax.sql.ConnectionPoolDataSource#getPooledConnection(,      *      String, String),      */,     public final PooledConnection getPooledConnection(,             String username,,             String password) throws SQLException {, ,         return createPooledConnection (username, password, true);,     }, ,     /**,      * Minion helper method. Create and return a pooled connection,      *,      * @param user the user name used to authenticate the connection,      * @param password the user's password,      * @param requestPassword {@code false} if original call is from a,      *        no-argument constructor, otherwise {@code true},      *,      * @return a connection to the database,      * @throws SQLException if a database-access error occurs,      */,     private PooledConnection createPooledConnection (,             String user,,             String password,,             boolean requestPassword) throws SQLException {, ,         return findDriver().getNewPooledConnection(],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/BasicEmbeddedDataSource40.java,,44-44,[    public BasicEmbeddedDataSource40() {}],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/jdbc/BasicEmbeddedDataSource40.java,,44-44,[    public BasicEmbeddedDataSource40() {}],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/BasicEmbeddedXADataSource40.java,,52-116,[        super();,     }, ,     /*,      * Implementation of XADataSource interface methods,      */, ,     /**,      * @see javax.sql.XADataSource#getXAConnection(),      */,     public final XAConnection getXAConnection() throws SQLException     {, ,         if (ra == null || !ra.isActive()) {,             ra = setupResourceAdapter(this, ra, null, null, false);,         }, ,         return createXAConnection (ra, getUser(), getPassword(), false);,     }, ,     /**,      * @see javax.sql.XADataSource#getXAConnection(String, String),      */,     public final XAConnection getXAConnection(String user, String password),          throws SQLException {, ,         if (ra == null || !ra.isActive()) {,             ra = setupResourceAdapter(this, ra, user, password, true);,         }, ,         return createXAConnection (ra, user, password, true);,     }, ,     // implementation methods,     protected void update() {,         ra = null;,         super.update();,     }, , ,     /**,      * Instantiate and return an EmbedXAConnection from this instance,      * of EmbeddedXADataSource.,      *,      * @param user,      * @param password,      * @return XAConnection,      * @throws SQLException if a connection can't be created,      */,     private XAConnection createXAConnection(,             ResourceAdapter ra,,             String user,,             String password,,             boolean requestPassword) throws SQLException {, ,         // See comment for EmbeddedXADataSource#createXAConnection,         return findDriver().getNewXAConnection(,             this, ra, user, password, requestPassword);,     }, , ,     /**,      * @return The ResourceAdapter instance for the underlying database,      */,     public ResourceAdapter getResourceAdapter() {,         return ra;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,<clinit>,70-70,[        }catch(Exception e)],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,,756-756,[        return this.dataSourceName;],,,752-752,[        this.dataSourceName = dataSourceName;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,,764-764,[        return this.description;],,,760-760,[        this.description = description;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,,109-109,[        return this.loginTimeout;],,,105-105,[        this.loginTimeout = seconds;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,,498-498,[        return password;],,,494-494,[        this.password = password;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,,800-800,[        return this.retrieveMessageText;],,,796-796,[        this.retrieveMessageText = retrieveMessageText;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,,790-790,[        return this.user;],,,786-786,[        this.user = user;],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getPooledConnectionMinion,1296-1296,[            handleConnectionException(dncLogWriter, se);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getPooledConnectionMinion,1329-1329,[            handleConnectionException(dncLogWriter, se);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getXAConnectionMinion,1357-1357,[            handleConnectionException(dncLogWriter, se);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getXAConnectionMinion,1377-1377,[            handleConnectionException(dncLogWriter, se);],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,checkEnumeration,728-728,[            choicesStr += choices[i];],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getDataSourceName,756-756,[        return this.dataSourceName;],,setDataSourceName,752-753,[        this.dataSourceName = dataSourceName;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getDatabaseName,747-747,[        return this.databaseName;],,setDatabaseName,743-744,[        this.databaseName = databaseName;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getDescription,764-764,[        return this.description;],,setDescription,760-761,[        this.description = description;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getLogWriter,127-127,[        return this.logWriter;],,setLogWriter,123-124,[        this.logWriter = logWriter;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getLoginTimeout,109-109,[        return this.loginTimeout;],,setLoginTimeout,105-106,[        this.loginTimeout = seconds;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getPassword,498-498,[        return password;],,setPassword,494-495,[        this.password = password;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getPortNumber,773-773,[        return this.portNumber;],,setPortNumber,769-770,[        this.portNumber = portNumber;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getRetrieveMessageText,800-800,[        return this.retrieveMessageText;],,setRetrieveMessageText,796-797,[        this.retrieveMessageText = retrieveMessageText;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getSecurityMechanism,836-840,[        if ( securityMechanism == SECMEC_HAS_NOT_EXPLICITLY_SET ) {,             return getUpgradedSecurityMechanism(password);,         }, ,         return securityMechanism;],,setSecurityMechanism,809-810,[        this.securityMechanism = securityMechanism;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getServerName,781-781,[        return this.serverName;],,setServerName,777-778,[        this.serverName = serverName;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getTraceDirectory,1025-1025,[        return this.traceDirectory;],,setTraceDirectory,1021-1022,[        this.traceDirectory = traceDirectory;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getTraceFile,1016-1016,[        return this.traceFile;],,setTraceFile,1012-1013,[        this.traceFile = traceFile;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getTraceFileAppend,1033-1033,[        return this.traceFileAppend;],,setTraceFileAppend,1029-1030,[        this.traceFileAppend = traceFileAppend;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getTraceLevel,1008-1008,[        return this.traceLevel;],,setTraceLevel,1004-1005,[        this.traceLevel = traceLevel;,     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/ClientBaseDataSourceRoot.java,getUser,790-790,[        return this.user;],,setUser,786-787,[        this.user = user;,     }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/jdbc/ClientConnectionPoolDataSource40.java,,35-35,[public class ClientConnectionPoolDataSource40],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/jdbc/ClientDataSource40.java,,41-42,[        super();,     }],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/jdbc/ClientDriver.java,getParentLogger,301-301,[             ).getSQLException();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/jdbc/ClientDriver.java,connect,119-119,[                    slashOrNull = urlTokenizer.nextToken(":/");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/derby/jdbc/ClientDriver.java,getFactory,440-445,[        if(factoryObject!=null),             return factoryObject;,         if (Configuration.supportsJDBC42()) {,             factoryObject = createJDBC42FactoryImpl();,         } else {,             factoryObject = createDefaultFactoryImpl();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/jdbc/ClientXADataSource40.java,,35-35,[public class ClientXADataSource40 extends ClientXADataSource],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/jdbc/EmbedPooledConnection.java,wrapStatement,543-543,[                EmbedCallableStatement cs_ = (EmbedCallableStatement)cs;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/jdbc/EmbedPooledConnection.java,wrapStatement,524-524,[                EmbedPreparedStatement ps_ = (EmbedPreparedStatement)ps;],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/derby/jdbc/EmbedXAResource.java,start,687-687,[                        timeoutMillis = 1000*timeoutSeconds;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/jdbc/EmbedXAResource.java,,929-929,[        currentXid = aCurrentXid;],,,764-764,[        return currentXid;],,,587-587,[        if (currentXid != null)],,,756-756,[        currentXid = xid_im;],,,679-679,[                currentXid = xid_im;],,,198-198,[        if (currentXid != null) {],,,199-199,[            if (!currentXid.equals(xid_im))],,,213-213,[            currentXid = null;            ],,
STYLE,EQ_UNUSUAL,org/apache/derby/jdbc/EmbeddedBaseDataSource.java,equals,478-538,[        if (p0 instanceof EmbeddedDataSource) {,             EmbeddedDataSource ds = (EmbeddedDataSource)p0;, ,             boolean match = true;, ,             if (databaseName != null) {,                 if  (!(databaseName.equals(ds.databaseName))),                     match = false;,             } else if (ds.databaseName != null) {,                 match = false;,             }, ,             if (dataSourceName != null) {,                 if  (!(dataSourceName.equals(ds.dataSourceName))) {,                     match = false;,                 },             } else if (ds.dataSourceName != null) {,                 match = false;,             }, ,             if (description != null) {,                 if  (!(description.equals(ds.description))) {,                     match = false;,                 },             } else if (ds.description != null) {,                 match = false;,             }, ,             if (createDatabase != null) {,                 if  (!(createDatabase.equals(ds.createDatabase))) {,                     match = false;,                 },             } else if (ds.createDatabase != null) {,                 match = false;,             }, ,             if (shutdownDatabase != null) {,                 if  (!(shutdownDatabase.equals(ds.shutdownDatabase))) {,                     match = false;,                 },             } else if (ds.shutdownDatabase != null) {,                 match = false;,             }, ,             if (connectionAttributes != null) {,                 if  (!(connectionAttributes.equals(ds.connectionAttributes))) {,                     match = false;,                 },             } else if (ds.connectionAttributes != null) {,                 match = false;,             }, ,             if (loginTimeout != ds.loginTimeout) {,                 match = false;,             }, ,             return match;, ,         }, ,         return false;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/EmbeddedBaseDataSource.java,equals,478-538,[        if (p0 instanceof EmbeddedDataSource) {,             EmbeddedDataSource ds = (EmbeddedDataSource)p0;, ,             boolean match = true;, ,             if (databaseName != null) {,                 if  (!(databaseName.equals(ds.databaseName))),                     match = false;,             } else if (ds.databaseName != null) {,                 match = false;,             }, ,             if (dataSourceName != null) {,                 if  (!(dataSourceName.equals(ds.dataSourceName))) {,                     match = false;,                 },             } else if (ds.dataSourceName != null) {,                 match = false;,             }, ,             if (description != null) {,                 if  (!(description.equals(ds.description))) {,                     match = false;,                 },             } else if (ds.description != null) {,                 match = false;,             }, ,             if (createDatabase != null) {,                 if  (!(createDatabase.equals(ds.createDatabase))) {,                     match = false;,                 },             } else if (ds.createDatabase != null) {,                 match = false;,             }, ,             if (shutdownDatabase != null) {,                 if  (!(shutdownDatabase.equals(ds.shutdownDatabase))) {,                     match = false;,                 },             } else if (ds.shutdownDatabase != null) {,                 match = false;,             }, ,             if (connectionAttributes != null) {,                 if  (!(connectionAttributes.equals(ds.connectionAttributes))) {,                     match = false;,                 },             } else if (ds.connectionAttributes != null) {,                 match = false;,             }, ,             if (loginTimeout != ds.loginTimeout) {,                 match = false;,             }, ,             return match;, ,         }, ,         return false;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/jdbc/EmbeddedBaseDataSource.java,,386-386,[        return driver;],,,367-367,[            if (driver == null || !driver.acceptsURL(url)) {],,,380-380,[                    driver = (InternalDriver) registerDriver;],,,378-378,[                        (InternalDriver)AutoloadedDriver.getDriverModule();],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/derby/jdbc/EmbeddedBaseDataSource.java,getDatabaseName,135-135,[        return databaseName;],,setDatabaseName,119-129,[        this.databaseName = databaseName;, ,         if( databaseName!= null && (databaseName.indexOf(";") >= 0)){,             String[] dbShort = databaseName.split(";");,             this.shortDatabaseName = dbShort[0];,         } else {,             this.shortDatabaseName = databaseName;,         }, ,         update();,     }],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/EmbeddedConnectionPoolDataSource.java,,73-142,[		super();, 	}, , 	/*, 	 * ConnectionPoolDataSource methods, 	 */, , 	/**, 		Attempt to establish a database connection., , 		@return a Connection to the database, , 		@exception SQLException if a database-access error occurs., 	*/, 	public final PooledConnection getPooledConnection() throws SQLException { , 		return createPooledConnection (getUser(), getPassword(), false);, 	}, , 	/**, 		Attempt to establish a database connection., , 		@param username the database user on whose behalf the Connection is being made, 		@param password the user's password, , 		@return a Connection to the database, , 		@exception SQLException if a database-access error occurs., 	*/, 	public final PooledConnection getPooledConnection(String username, , 												String password), 		 throws SQLException, 	{, 		return createPooledConnection (username, password, true);, 	},         ,     /**,      * Create and return an EmbedPooledConnection from this instance,      * of EmbeddedConnectionPoolDataSource.,      */,     private PooledConnection createPooledConnection (String user,,         String password, boolean requestPassword) throws SQLException,     {,         /* This object (EmbeddedConnectionPoolDataSource) is a JDBC 2,          * and JDBC 3 implementation of ConnectionPoolDatSource.  However,,          * it's possible that we are running with a newer driver (esp.,          * JDBC 4) in which case we should return a PooledConnection that,          * implements the newer JDBC interfaces--even if "this" object,          * does not itself satisfy those interfaces.  As an example, if,          * we have a JDK 6 application then even though this specific,          * object doesn't implement JDBC 4 (it only implements JDBC 2,          * and 3), we should still return a PooledConnection object that,          * *does* implement JDBC 4 because that's what a JDK 6 app,          * expects.,          *,          * By calling "findDriver()" here we will get the appropriate,          * driver for the JDK in use (ex. if using JDK 6 then findDriver(),          * will return the JDBC 4 driver).  If we then ask the driver to,          * give us a pooled connection, we will get a connection that,          * corresponds to whatever driver/JDBC implementation is being,          * used--which is what we want.  So for a JDK 6 application we,          * will correctly return a JDBC 4 PooledConnection. DERBY-2488.,          *,          * This type of scenario can occur if an application that was,          * previously running with an older JVM (ex. JDK 1.4/1.5) starts,          * running with a newer JVM (ex. JDK 6), in which case the app,          * is probably still using the "old" data source (ex. is still,          * instantiating EmbeddedConnectionPoolDataSource) instead of,          * the newer one (EmbeddedConnectionPoolDataSource40).,          */,         return findDriver().getNewPooledConnection(],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/EmbeddedConnectionPoolDataSource40.java,,32-32,[public class EmbeddedConnectionPoolDataSource40 ],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/jdbc/EmbeddedConnectionPoolDataSource40.java,,32-32,[public class EmbeddedConnectionPoolDataSource40 ],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/EmbeddedDataSource.java,,199-310,[	public EmbeddedDataSource() {, 		// needed by Object Factory, , 		// don't put anything in here or in any of the set method because this, 		// object may be materialized in a remote machine and then sent thru, 		// the net to the machine where it will be used., 	}, , , , , ,     /**,      * {@code javax.naming.Referenceable} interface,      */, ,     /**,      * This method creates a new {@code Reference} object to represent this,      * data source.  The class name of the data source object is saved,      * in the {@code Reference}, so that an object factory will know that it,      * should create an instance of that class when a lookup operation,      * is performed. The class is also stored in the reference.  This,      * is not required by JNDI, but is recommend in practice.  JNDI,      * will always use the object factory class specified in the,      * reference when reconstructing an object, if a class name has,      * been specified.  See the JNDI SPI documentation for further,      * details on this topic, and for a complete description of the,      * {@code Reference} and {@code StringRefAddr} classes.,      * <p/>,      * Derby data source classes class provides several standard JDBC,      * properties.  The names and values of the data source properties,      * are also stored in the reference using the {@code StringRefAddr} class.,      * This is all the information needed to reconstruct an embedded,      * data source object.,      *,      * @return the created reference object for this data source,      * @exception NamingException cannot find named object,      */,     public final Reference getReference() throws NamingException, 	{,         // These fields will be set by the JNDI server when it decides to,         // materialize a data source.,         Reference ref = new Reference(,             this.getClass().getName(),,             "org.apache.derby.jdbc.ReferenceableDataSource",,             null);, ,         addBeanProperties(this, ref);, ,         return ref;, 	}, ,     /**,      * Add Java Bean properties to the reference using,      * StringRefAddr for each property. List of bean properties,      * is defined from the public getXXX() methods on this object,      * that take no arguments and return short, int, boolean or String.,      * The StringRefAddr has a key of the Java bean property name,,      * converted from the method name. E.g. traceDirectory for,      * traceDirectory.,      *,      */,     private static void addBeanProperties(Object ths, Reference ref),     {,         // Look for all the getXXX methods in the class that take no arguments.,         Method[] methods = ths.getClass().getMethods();, ,         for (int i = 0; i < methods.length; i++) {, ,             Method m = methods[i];, ,             // only look for simple getter methods.,             if (m.getParameterTypes().length != 0),                 continue;, ,             // only non-static methods,             if (Modifier.isStatic(m.getModifiers())),                 continue;, ,             // Only getXXX methods,             String methodName = m.getName();,             if ((methodName.length() < 5) || !methodName.startsWith("get")),                 continue;, ,             Class returnType = m.getReturnType();, ,             if (Integer.TYPE.equals(returnType),                     || Short.TYPE.equals(returnType),                     || String.class.equals(returnType),                     || Boolean.TYPE.equals(returnType)) {, ,                 // setSomeProperty,                 // 01234, ,                 String propertyName = methodName.substring(3, 4).toLowerCase(,                         java.util.Locale.ENGLISH).concat(,                         methodName.substring(4));, ,                 try {,                     Object ov = m.invoke(ths, null);,                     // Need to check if property value is null, otherwise,                     // "null" string gets stored.,                     if (ov != null) {,                         ref.add(new StringRefAddr(propertyName, ov.toString()));,                     },                 } catch (IllegalAccessException iae) {,                 } catch (InvocationTargetException ite) {,                 }, ,             },         },     }],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/EmbeddedDataSource40.java,,38-39,[    public EmbeddedDataSource40() {,     }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/jdbc/EmbeddedDataSource40.java,,38-39,[    public EmbeddedDataSource40() {,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/jdbc/EmbeddedDriver.java,boot,196-196,[            pw = new PrintWriter(System.err, true);],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/EmbeddedXADataSource.java,,86-187,[		super();, 	}, , , 	/*, 	 * XADataSource methods , 	 */, , , 	/**, 	 * Attempt to establish a database connection., 	 *, 	 * @return  a Connection to the database, 	 * @exception SQLException if a database-access error occurs., 	 */, 	public final XAConnection getXAConnection() throws SQLException, 	{, 		if (ra == null || !ra.isActive()),            ra = setupResourceAdapter(this, ra, null, null, false);, , 		return createXAConnection (ra, getUser(), getPassword(), false);, 	}, , 	/**, 	 * Attempt to establish a database connection with the given user, 	 * name and password., 	 *, 	 * @param user the database user on whose behalf the Connection is being made, 	 * @param password the user's password, 	 * @return  a Connection to the database, 	 * @exception SQLException if a database-access error occurs., 	 */, 	public final XAConnection getXAConnection(String user, String password), 		 throws SQLException , 	{, 		if (ra == null || !ra.isActive()),            ra = setupResourceAdapter(this, ra, user, password, true);, ,         return createXAConnection (ra, user, password, true);, 	}, 	, 	/*, 	 * private method, 	 */, ,    protected void update() {, 		ra = null;, 		super.update();, 	}, ,         ,     /**,      * Instantiate and return an EmbedXAConnection from this instance,      * of EmbeddedXADataSource.,      *,      * @param user ,      * @param password ,      * @return XAConnection,      */,     private XAConnection createXAConnection (ResourceAdapter ra,,         String user, String password, boolean requestPassword),         throws SQLException,     {,         /* This object (EmbeddedXADataSource) is a JDBC 2 and JDBC 3,          * implementation of XADatSource.  However, it's possible that we,          * are running with a newer driver (esp. JDBC 4) in which case we,          * should return a PooledConnection that implements the newer JDBC,          * interfaces--even if "this" object does not itself satisfy those,          * interfaces.  As an example, if we have a JDK 6 application then,          * even though this specific object doesn't implement JDBC 4 (it,          * only implements JDBC 2 and 3), we should still return an,          * XAConnection object that *does* implement JDBC 4 because that's,          * what a JDK 6 app expects.,          *,          * By calling "findDriver()" here we will get the appropriate,          * driver for the JDK in use (ex. if using JDK 6 then findDriver(),          * will return the JDBC 4 driver).  If we then ask the driver to,          * give us an XA connection, we will get a connection that,          * corresponds to whatever driver/JDBC implementation is being,          * used--which is what we want.  So for a JDK 6 application we,          * will correctly return a JDBC 4 XAConnection. DERBY-2488.,          *,          * This type of scenario can occur if an application that was,          * previously running with an older JVM (ex. JDK 1.4/1.5) starts,          * running with a newer JVM (ex. JDK 6), in which case the app,          * is probably still using the "old" data source (ex. is still,          * instantiating EmbeddedXADataSource) instead of the newer one,          * (EmbeddedXADataSource40).,          */,         return findDriver().getNewXAConnection(,             this, ra, user, password, requestPassword);,     }, , ,     /**,      *,      * @return The ResourceAdapter instance for,      *         the underlying database,      */,     public ResourceAdapter getResourceAdapter(),     {,         return ra;],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/EmbeddedXADataSource40.java,,39-39,[    public EmbeddedXADataSource40() { super(); }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/derby/jdbc/EmbeddedXADataSource40.java,,39-39,[    public EmbeddedXADataSource40() { super(); }],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/jdbc/InternalDriver.java,connect,242-242,[            info = null; // ensure we don't use this reference directly again.],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/jdbc/InternalDriver.java,getAttributes,500-500,[		info = null; // ensure we don't use this reference directly again.],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/jdbc/InternalDriver.java,getPropertyInfo,852-852,[        info = null; // ensure we don't use this reference directly again.],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/jdbc/InternalDriver.java,getAttributes,919-919,[                optionsNoDB[attrIndex] = new DriverPropertyInfo(connBooleanAttributes[i][0],],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/jdbc/InternalDriver.java,checkEnumeration,564-564,[            choicesStr += choices[i];],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/jdbc/InternalDriver.java,boot,136-136,[			InternalDriver.activeDriver = this;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/jdbc/InternalDriver.java,stop,155-155,[			InternalDriver.activeDriver = null;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derby/jdbc/InternalDriver.java,checkShutdownPrivileges,445-463,[        if (System.getSecurityManager() == null) {,             return;,         }, ,         // the check,         try {,             final Permission sp = new SystemPermission(,                 SystemPermission.ENGINE, SystemPermission.SHUTDOWN);,             checkSystemPrivileges(user, sp);,         } catch (AccessControlException ace) {,             throw Util.generateCsSQLException(, 				SQLState.AUTH_SHUTDOWN_MISSING_PERMISSION,, 				user, (Object)ace); // overloaded method,         } catch (Exception e) {,             throw Util.generateCsSQLException(, 				SQLState.AUTH_SHUTDOWN_MISSING_PERMISSION,, 				user, (Object)e); // overloaded method,         },     }],,
BAD_PRACTICE,HE_INHERITS_EQUALS_USE_HASHCODE,org/apache/derby/jdbc/ReferenceableDataSource.java,,57-170,[public class ReferenceableDataSource extends EmbeddedBaseDataSource,                                      implements ObjectFactory {, ,     private static final long serialVersionUID = 1872877359127597176L;, ,     /**,      * Reconstructs a Derby embedded-driver data source object from a JNDI data,      * source reference.,      * <p>,      * The {@code getObjectInstance} method is passed a reference that,      * corresponds to the object being retrieved as its first parameter. The,      * other parameters are optional in the case of JDBC data source objects.,      * The object factory should use the information contained in the reference,      * to reconstruct the data source. If for some reason, a data source,      * object cannot be reconstructed from the reference, a value of,      * {@code null} may be returned. This allows other object factories that may,      * be registered in JNDI to be tried. If an exception is thrown then no,      * other object factories are tried.,      *,      * @param refObj the possibly {@code null} object containing location or,      *      reference information that can be used in creating an object,      * @param name the name of this object relative to {@code nameContext}, or,      *      {@code null} if no name is specified,      * @param nameContext context relative to which the name parameter is,      *      specified, or {@code null} if name is relative to the default,      *      initial context.,      * @param environment possibly {@code null} environment that is used in,      *      creating the object.,      *,      * @return Object created, or {@code null} if no attempt to create the,      *      object is made.,      * @throws Exception if recreating the object fails,      */,     public Object getObjectInstance(Object refObj,,                                     javax.naming.Name name,,                                     javax.naming.Context nameContext,,                                     java.util.Hashtable environment),             throws java.lang.Exception {, ,         Object ds = null;,         if (refObj instanceof javax.naming.Reference) {,             javax.naming.Reference ref = (javax.naming.Reference) refObj;, ,             // See if this object belongs to Derby.,             String className = ref.getClassName();,             if (className != null &&,                     className.startsWith("org.apache.derby.jdbc.Embedded")) {,                 // Create the proper data source object shell.,                 ds = Class.forName(className).newInstance();, ,                 // Fill in the data source object shell with values from the,                 // jndi reference.,                 setBeanProperties(ds, ref);,             },         },         return ds;,     }, ,     /** Reflect lookup for Java bean method taking a single String arg */,     private static final Class[] STRING_ARG = { "".getClass() };,     /** Reflect lookup for Java bean method taking a single int arg */,     private static final Class[] INT_ARG = { Integer.TYPE };,     /** Reflect lookup for Java bean method taking a single boolean arg */,     private static final Class[] BOOLEAN_ARG = { Boolean.TYPE };,     /** Reflect lookup for Java bean method taking a single short arg */,     private static final Class[] SHORT_ARG = { Short.TYPE };, ,     /**,      * Set the Java bean properties for an object from its Reference. The,      * Reference contains a set of StringRefAddr values with the key being the,      * bean name and the value a String representation of the bean's value. This,      * code looks for setXXX() method where the set method corresponds to the,      * standard bean naming scheme and has a single parameter of type String,,      * int, boolean or short.,      */,     private static void setBeanProperties(Object ds, Reference ref),             throws Exception {, ,         for (Enumeration e = ref.getAll(); e.hasMoreElements();) {, ,             RefAddr attribute = (RefAddr) e.nextElement();, ,             String propertyName = attribute.getType();, ,             String value = (String) attribute.getContent();, ,             String methodName = "set",                     + propertyName.substring(0, 1).toUpperCase(,                             java.util.Locale.ENGLISH),                     + propertyName.substring(1);, ,             Method m;, ,             Object argValue;,             try {,                 m = ds.getClass().getMethod(methodName, STRING_ARG);,                 argValue = value;,             } catch (NoSuchMethodException nsme) {,                 try {,                     m = ds.getClass().getMethod(methodName, INT_ARG);,                     argValue = Integer.valueOf(value);,                 } catch (NoSuchMethodException nsme2) {,                     try {,                         m = ds.getClass().getMethod(methodName, BOOLEAN_ARG);,                         argValue = Boolean.valueOf(value);,                     } catch (NoSuchMethodException nsme3) {,                         m = ds.getClass().getMethod(methodName, SHORT_ARG);,                         argValue = Short.valueOf(value);,                     },                 },             },             m.invoke(ds, new Object[] { argValue });,         },     }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/derby/jdbc/ResourceAdapterImpl.java,,80-80,[        for (Enumeration<XATransactionState> e = connectionTable.elements();],,,66-66,[        connectionTable = new Hashtable<XAXactId, XATransactionState>();],,,121-121,[		return connectionTable.remove(xid);],,,109-109,[		if (connectionTable.get(xid) != null)],,,115-115,[        connectionTable.put(xid, (XATransactionState) conn);],,,105-105,[		return connectionTable.get(xid);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/jdbc/XAStatementControl.java,getRealCallableStatement,203-203,[			CallableStatement newCallableStatement =],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/jdbc/XAStatementControl.java,getRealPreparedStatement,163-163,[			PreparedStatement newPreparedStatement =],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/derby/jdbc/XAStatementControl.java,wrapResultSet,233-233,[            ((EmbedResultSet) rs).setApplicationStatement(s);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/optional/lucene/LuceneListIndexesVTI.java,getRawColumn,148-148,[            throw LuceneSupport.newSQLException],,getRawColumn,152-152,[                 new Integer( getColumnCount() )],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/optional/lucene/LuceneListIndexesVTI.java,getTimestamp,169-169,[            throw LuceneSupport.newSQLException],,getTimestamp,173-173,[                 new Integer( getColumnCount() )],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/optional/lucene/LuceneQueryVTI.java,getDate,221-221,[            int     docID = scoreDoc.doc;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/optional/lucene/LuceneQueryVTI.java,getLong,203-203,[            int     docID = scoreDoc.doc;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/optional/lucene/LuceneQueryVTI.java,getTime,239-239,[            int     docID = scoreDoc.doc;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derby/optional/lucene/LuceneQueryVTI.java,getTimestamp,257-257,[            int     docID = scoreDoc.doc;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derby/optional/lucene/LuceneQueryVTI.java,invalidColumnPosition,329-329,[        return LuceneSupport.newSQLException],,invalidColumnPosition,333-333,[             new Integer( getColumnCount() )],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/derby/optional/lucene/LuceneQueryVTI.java,initScan,429-429,[            _indexReader = LuceneSupport.getIndexReader( new File( indexhome.toString() ) );],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/optional/lucene/LuceneQueryVTI.java,vetPrivileges,471-471,[        _connection.prepareStatement( buffer.toString() ).executeQuery().close();],,vetPrivileges,472-472,[    }],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE,org/apache/derby/optional/lucene/LuceneQueryVTI.java,vetPrivileges,471-471,[        _connection.prepareStatement( buffer.toString() ).executeQuery().close();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/optional/lucene/LuceneQueryVTI.java,getBytes,320-320,[                return null;],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/optional/lucene/LuceneQueryVTI.java,vetPrivileges,471-471,[        _connection.prepareStatement( buffer.toString() ).executeQuery().close();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/optional/lucene/LuceneSupport.java,getDerbySystemHome,1275-1275,[            throw (IOException) se.getCause();],,
I18N,DM_CONVERT_CASE,org/apache/derby/optional/lucene/LuceneSupport.java,luceneSchemaExists,1198-1198,[        ps.setString( 1, LUCENE_SCHEMA.toUpperCase() );],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/optional/lucene/LuceneSupport.java,getCurrentUser,1166-1166,[        ResultSet   rs = conn.prepareStatement( "values current_user" ).executeQuery();],,getCurrentUser,1168-1168,[            rs.next();],,getCurrentUser,1169-1169,[            return rs.getString( 1 );],,getCurrentUser,1170-1170,[        } finally { rs.close(); }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/optional/lucene/LuceneSupport.java,getOwner,1182-1182,[            ( "select authorizationID from sys.sysschemas where schemaName = ?" );],,getOwner,1183-1183,[        ps.setString( 1, derbyIdentifier( schema ) );],,getOwner,1185-1185,[        ResultSet   rs = ps.executeQuery();],,getOwner,1187-1187,[            if ( rs.next() ) { return rs.getString( 1 ); }],,getOwner,1188-1188,[            else { return null; }],,getOwner,1189-1189,[        } finally { rs.close(); }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/optional/lucene/LuceneSupport.java,sqlAuthorizationEnabled,1221-1221,[            rs = conn.prepareStatement( "select count(*) from sys.sysusers" ).executeQuery();],,sqlAuthorizationEnabled,1222-1222,[            rs.next();],,sqlAuthorizationEnabled,1224-1224,[                if ( rs.getInt( 1 ) > 0 ) { return true; }],,sqlAuthorizationEnabled,1226-1226,[            finally { rs.close(); }],,sqlAuthorizationEnabled,1231-1231,[        }],,sqlAuthorizationEnabled,1233-1233,[        ResultSet   rs = conn.prepareStatement],,sqlAuthorizationEnabled,1234-1234,[            (],,sqlAuthorizationEnabled,1236-1236,[             ).executeQuery();],,sqlAuthorizationEnabled,1239-1239,[            if ( !( rs.next() ) ) { return false; }],,sqlAuthorizationEnabled,1243-1243,[        finally { rs.close(); }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/optional/lucene/LuceneSupport.java,executeDDL,1254-1254,[    	PreparedStatement ddl = c.prepareStatement(text);],,executeDDL,1255-1255,[    	ddl.execute();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/optional/lucene/LuceneSupport.java,luceneSchemaExists,1197-1197,[            ( "select count(*) from sys.sysschemas where schemaName = ?" );],,luceneSchemaExists,1198-1198,[        ps.setString( 1, LUCENE_SCHEMA.toUpperCase() );],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE,org/apache/derby/optional/lucene/LuceneSupport.java,dropIndex,534-534,[            (],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE,org/apache/derby/optional/lucene/LuceneSupport.java,unloadTool,238-238,[            (],,unloadTool,263-263,[        conn.prepareStatement( "drop schema " + LUCENE_SCHEMA + " restrict" ).execute();],,unloadTool,255-255,[                conn.prepareStatement( "drop " + routineType + " " + makeTableName( schema, routineName ) ).execute();],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/derby/optional/lucene/LuceneSupport.java,forbidCharacter,1511-1511,[		if (schema.indexOf( invalidCharacter ) > 0 || table.indexOf( invalidCharacter ) > 0 || textcol.indexOf( invalidCharacter ) > 0)],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/optional/lucene/LuceneSupport.java,loadTool,177-177,[		executeDDL( conn, createProcedure.toString() );],,loadTool,166-166,[		executeDDL( conn, listFunction.toString() );],,loadTool,187-187,[		executeDDL( conn, dropProcedure.toString() );],,loadTool,198-198,[		executeDDL( conn, updateProcedure.toString() );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/optional/lucene/LuceneSupport.java,createOrRecreateIndex,468-468,[                conn.prepareStatement( tableFunction.toString() ).execute();],,createOrRecreateIndex,475-475,[            ps = conn.prepareStatement( query.toString() );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/optional/lucene/LuceneSupport.java,dropIndex,534-534,[            (],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/optional/lucene/LuceneSupport.java,executeDDL,1254-1254,[    	PreparedStatement ddl = c.prepareStatement(text);],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/optional/lucene/LuceneSupport.java,getPrimaryKeys,1309-1309,[                    ( "select " + columnName + " from " + makeTableName( schema, table ) + " where 1=2" ).executeQuery();],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/optional/lucene/LuceneSupport.java,unloadTool,255-255,[                conn.prepareStatement( "drop " + routineType + " " + makeTableName( schema, routineName ) ).execute();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/optional/lucene/LuceneSupport.java,run,1059-1059,[                        properties.load( new FileInputStream( file ) );],,run,1061-1061,[                        return properties;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derby/optional/lucene/LuceneSupport.java,run,1059-1059,[                        properties.load( new FileInputStream( file ) );],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/optional/lucene/LuceneSupport.java,run,1081-1081,[                        FileOutputStream    fos = new FileOutputStream( file );],,run,1083-1083,[                        properties.store( fos, null );],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derby/optional/lucene/LuceneSupport.java,run,1081-1081,[                        FileOutputStream    fos = new FileOutputStream( file );],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE,org/apache/derby/osgi/EmbeddedActivator.java,stop,38-38,[			DriverManager.getConnection("jdbc:derby:;shutdown=true");],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/derby/security/DatabasePermission.java,initLocation,339-339,[                throw (IOException)pae.getCause();],,
MALICIOUS_CODE,MS_MUTABLE_COLLECTION_PKGPROTECT,org/apache/derby/security/DatabasePermission.java,,122-122,[    static protected final Set<String> LEGAL_ACTIONS = new HashSet<String>();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/derby/security/DatabasePermission.java,,99-495,[    static public final String URL_PATH_SEPARATOR_STRING,         = String.valueOf(URL_PATH_SEPARATOR_CHAR);,     static public final String URL_PATH_RELATIVE_STRING,         = String.valueOf(URL_PATH_RELATIVE_CHAR);,     static public final String URL_PATH_RELATIVE_PREFIX,         = (URL_PATH_RELATIVE_STRING + URL_PATH_SEPARATOR_CHAR);,     static public final String URL_PATH_WILDCARD_STRING,         = String.valueOf(URL_PATH_WILDCARD_CHAR);,     static public final String URL_PATH_WILDCARD_SUFFIX,         = (URL_PATH_SEPARATOR_STRING + URL_PATH_WILDCARD_CHAR);,     static public final String URL_PATH_RECURSIVE_STRING,         = String.valueOf(URL_PATH_RECURSIVE_CHAR);,     static public final String URL_PATH_RECURSIVE_SUFFIX,         = (URL_PATH_SEPARATOR_STRING + URL_PATH_RECURSIVE_CHAR);, ,     /**,      * The create database permission.,      */,     static public final String CREATE = "create";, ,     /**,      * The legal database permission action names.,      */,     static protected final Set<String> LEGAL_ACTIONS = new HashSet<String>();,     static {,         // when adding new actions, check: implies(Permission), getActions(),         LEGAL_ACTIONS.add(CREATE);,     };, ,     /**,      * The original location URL passed to constructor.,      */,     private final String url;, ,     /**,      * This permission's canonical directory path.,      *,      * The path consists of a canonicalized form of the user-specified URL,,      * stripped off the protocol specification and any recursive/wildcard,      * characters, or {@code "<<ALL FILES>>"} for the "anywhere" permission.,      * The canonical path is used when testing permissions with implies(),,      * where real directory locations, not just notational differences,,      * ought to be compared.  Analog to java.io.FilePermission, the,      * canonical path is also used by equals() and hashCode() to support,      * hashing and mapping of permissions by their real directory locations.,      *,      * Because canonical file paths are platform dependent, this field,      * must not be serialized (hence transient) but be recomputed from,      * the original URL upon deserialization.,      */,     private transient String path;, ,     /**,      * The parent directory of this permission's canonical directory path,,      * or null if this permission's path does not have a parent directory.,      *,      * Because canonical file paths are platform dependent, this field,      * must not be serialized (hence transient) but be recomputed from,      * the original URL upon deserialization.,      */,     private transient String parentPath;, ,     /**,      * Indicates whether the path denotes an inclusive, recursive, wildcard,,      * or single location.,      *,      * If the path denotes an inclusive, recursive or wildcard location,,      * this field's value is URL_PATH_INCLUSIVE_CHAR, URL_PATH_RECURSIVE_CHAR,,      * or URL_PATH_WILDCARD_CHAR, respectively; otherwise, it's,      * URL_PATH_SEPARATOR_CHAR denoting a single location.,      */,     private char pathType;, ,     /**,      * Creates a new DatabasePermission with the specified URL and actions.,      * <P>,      * <i>actions</i> contains a comma-separated list of the desired actions,      * granted on a database. Currently, the only supported action is,      * <code>create</code>.,      * <P>,      * <i>URL</i> denotes a database location URL, which, at this time, must,      * start with <code>directory:</code> followed by a directory pathname.,      * Note that in a URL, the separator character is always "/" rather than,      * the file separator of the operating-system.  The directory path may,      * be absolute or relative, in which case it is prefixed with the current,      * user directory. In addition, similar to java.io.FilePermission, the,      * directory pathname may end with a wildcard character to allow for,      * arbitrarily named databases under a path:,      * <ul>,      * <li> "directory:location" - refers to a database called,      *      <i>location</i>,,      * <li> "directory:location/*" - matches any database in the,      *      directory <i>location</i>,,      * <li> "directory:location/-" - matches any database under,      *      <i>location</i> or its subdirectories.,      * <li> "directory:*" - matches any database in the user's current,      *      working directory.,      * <li> "directory:-" - matches any database under the,      *      user's current working directory or its subdirectories.,      * <li> {@code "directory:<<ALL FILES>>"} matches any database anywhere.,      * </ul>,      *,      * @param url the database URL,      * @param actions the action string,      * @throws NullPointerException if an argument is null,      * @throws IllegalArgumentException if an argument is not legal,      * @throws IOException if the location URL cannot be canonicalized,      * @see Permission#Permission(String),      * @see java.io.FilePermission#FilePermission(String,String),      */,     public DatabasePermission(String url, String actions),         throws IOException {,         super(url);,         initActions(actions);,         initLocation(url);, ,         // store original URL for reconstructing path at deserialization,         this.url = url;,     }, ,     /**,      * Parses the list of database actions.,      *,      * @param actions the comma-separated action list,      * @throws NullPointerException if actions is null,      * @throws IllegalArgumentException if not a list of legal actions,      */,     protected void initActions(String actions) {,         // analog to java.security.BasicPermission, we check that actions,         // is not null nor empty,         if (actions == null) {,             throw new NullPointerException("actions can't be null");,         },         if (actions.length() == 0) {,             throw new IllegalArgumentException("actions can't be empty");,         }, ,         // check for any illegal actions,         actions = actions.toLowerCase(Locale.ENGLISH);,         final String[] s = StringUtil.split(actions, ',');,         for (int i = 0; i < s.length; i++) {,             final String action = s[i].trim();,             if (!LEGAL_ACTIONS.contains(action)) {,                 // report illegal action,                 final String msg = "Illegal action '" + action + "'";,                 throw new IllegalArgumentException(msg);,             },         },     }, ,     /**,      * Parses the database location URL.,      *,      * @param url the database URL,      * @throws NullPointerException if the URL is null,      * @throws IllegalArgumentException if the URL is not well-formed,      * @throws IOException if the location URL cannot be canonicalized,      */,     protected void initLocation(String url),         throws IOException {,         // analog to java.security.BasicPermission, we check that URL,         // is not null nor empty,         if (url == null) {,             throw new NullPointerException("URL can't be null");,         },         if (url.length() == 0) {,             throw new IllegalArgumentException("URL can't be empty");,         }, ,         // check URL's protocol scheme and initialize path,         if (!url.startsWith(URL_PROTOCOL_DIRECTORY)) {,             final String msg = "Unsupported protocol in URL '" + url + "'";,             throw new IllegalArgumentException(msg);,         },         String p = url.substring(URL_PROTOCOL_DIRECTORY.length());, ,         // check path for inclusive/relative/recursive/wildcard specifications,,         // split path into real pathname and the path type,         if (p.equals(URL_PATH_INCLUSIVE_STRING)) {,             // inclusive:  "<<ALL FILES>>" --> 'I', "<<ALL FILES>>",             pathType = URL_PATH_INCLUSIVE_CHAR;,             // p = p;,         } else if (p.equals(URL_PATH_RECURSIVE_STRING)) {,             // relative & recursive:  "-" --> '-', "./",             pathType = URL_PATH_RECURSIVE_CHAR;,             p = URL_PATH_RELATIVE_PREFIX;,         } else if (p.equals(URL_PATH_WILDCARD_STRING)) {,             // relative & wildcard:   "*" --> '*', "./",             pathType = URL_PATH_WILDCARD_CHAR;,             p = URL_PATH_RELATIVE_PREFIX;,         } else if (p.endsWith(URL_PATH_RECURSIVE_SUFFIX)) {,             // absolute & recursive:  "<path>/-" --> '-', "<path>/",             pathType = URL_PATH_RECURSIVE_CHAR;,             p = p.substring(0, p.length() - 1);,         } else if (p.endsWith(URL_PATH_WILDCARD_SUFFIX)) {,             // absolute & wildcard:   "<path>/*" --> '*', "<path>/",             pathType = URL_PATH_WILDCARD_CHAR;,             p = p.substring(0, p.length() - 1);,         } else {,             // absolute | relative:   "<path>" --> '/', "<path>",             pathType = URL_PATH_SEPARATOR_CHAR;,             // p = p;,         }, ,         // canonicalize the path and assign parentPath,         if (pathType == URL_PATH_INCLUSIVE_CHAR) {,             path = URL_PATH_INCLUSIVE_STRING;,             //assert(parentPath == null);,         } else {,             // resolve against user's working directory if relative pathname;,             // the read access to the system property is encapsulated in a,             // doPrivileged() block to allow for confined codebase permission,             // grants,             if (p.startsWith(URL_PATH_RELATIVE_PREFIX)) {,                 final String cwd = AccessController.doPrivileged(,                     new PrivilegedAction<String>() {,                         public String run() {,                             return System.getProperty("user.dir");,                         },                     });,                 // concatenated path "<cwd>/./<path>" will be canonicalized,                 p = cwd + URL_PATH_SEPARATOR_STRING + p;,             },             final String absPath = p;, ,             // store canonicalized path as required for implies(Permission);,             // may throw IOException; canonicalization reads the "user.dir",             // system property, which we encapsulate in a doPrivileged(),             // block to allow for confined codebase permission grants,             final File f;,             try {,                 f = AccessController.doPrivileged(,                     new PrivilegedExceptionAction<File>() {,                         public File run() throws IOException {,                             return (new File(absPath)).getCanonicalFile();,                         },                     });,             } catch (PrivilegedActionException pae) {,                 // pae.getCause() should be an instance of IOException,,                 // as only checked exceptions will be wrapped,                 throw (IOException)pae.getCause();,             },             path = f.getPath();, ,             // store canonicalized path of parent file as required for,             // implies(Permission); may throw IOException; note that,             // the path already denotes parent directory if of wildcard type:,             // for example, the parent of "/a/-" or "/a/*" is "/a",             parentPath = ((pathType != URL_PATH_SEPARATOR_CHAR),                           ? path : f.getParent());,         }, ,         //assert(pathType == URL_PATH_SEPARATOR_CHAR,         //       || pathType == URL_PATH_WILDCARD_CHAR,         //       || pathType == URL_PATH_RECURSIVE_CHAR,         //       || pathType == URL_PATH_INCLUSIVE_CHAR);,         //assert(path != null);,         //assert(parentPath == null || parentPath != null);,     }, ,     /**,      * Checks if this DatabasePermission implies a specified permission.,      * <P>,      * This method returns true if:<p>,      * <ul>,      * <li> <i>p</i> is an instanceof DatabasePermission and<p>,      * <li> <i>p</i>'s directory pathname is implied by this object's,      *      pathname. For example, "/tmp/*" implies "/tmp/foo", since,      *      "/tmp/*" encompasses the "/tmp" directory and all files in that,      *      directory, including the one named "foo".,      * </ul>,      * @param p the permission to check against,      * @return true if the specified permission is implied by this object,,      * false if not,      * @see Permission#implies(Permission),      */,     public boolean implies(Permission p) {,         // can only imply other DatabasePermissions,         if (!(p instanceof DatabasePermission)) {,             return false;,         },         final DatabasePermission that = (DatabasePermission)p;, ,         // an inclusive permission implies any other,         if (this.pathType == URL_PATH_INCLUSIVE_CHAR) {,             return true;,         },         //assert(this.pathType != URL_PATH_INCLUSIVE_CHAR);, ,         // a non-inclusive permission cannot imply an inclusive one,         if (that.pathType == URL_PATH_INCLUSIVE_CHAR) {,             return false;,         },         //assert(that.pathType != URL_PATH_INCLUSIVE_CHAR);, ,         // a recursive permission implies any other if a path prefix,         if (this.pathType == URL_PATH_RECURSIVE_CHAR) {,             return (that.parentPath != null,                     && that.parentPath.startsWith(this.path));,         },         //assert(this.pathType != URL_PATH_RECURSIVE_CHAR);, ,         // a non-recursive permission cannot imply a recursive one,         if (that.pathType == URL_PATH_RECURSIVE_CHAR) {,             return false;,         },         //assert(that.pathType != URL_PATH_RECURSIVE_CHAR);, ,         // a wildcard permission implies another if a parent directory,         if (this.pathType == URL_PATH_WILDCARD_CHAR) {,             return this.path.equals(that.parentPath);,         },         //assert(this.pathType != URL_PATH_WILDCARD_CHAR);, ,         // a non-wildcard permission cannot imply a wildcard one,         if (that.pathType == URL_PATH_WILDCARD_CHAR) {,             return false;,         },         //assert(that.pathType != URL_PATH_WILDCARD_CHAR);, ,         // non-recursive, non-wildcard permissions imply when paths are equal,         //assert(this.pathType == URL_PATH_SEPARATOR_CHAR);,         //assert(that.pathType == URL_PATH_SEPARATOR_CHAR);,         return this.path.equals(that.path);,     }, ,     /**,      * Checks two DatabasePermission objects for equality.,      * <P>,      * Checks that <i>obj</i> is a DatabasePermission and has the same,      * canonizalized URL and actions as this object.,      * <P>,      * @param obj the object we are testing for equality with this object,      * @return true if obj is a DatabasePermission, and has the same URL and,      * actions as this DatabasePermission object, false if not,      *,      * @see Permission#equals(Object),      */,     public boolean equals(Object obj) {,         if (obj == this) {,             return true;,         }, ,         if (!(obj instanceof DatabasePermission)) {,             return false;,         },         final DatabasePermission that = (DatabasePermission)obj;, ,         // compare canonicalized URLs,         return (pathType == that.pathType && path.equals(that.path));,     }, ,     /**,      * Returns the hash code value for this object.,      *,      * @return a hash code value for this object,      * @see Permission#hashCode(),      */,     public int hashCode() {,         // hash canonicalized URL,         return (path.hashCode() ^ pathType);,     }, ,     /**,      * Returns the "canonical string representation" of the actions.,      *,      * @return the canonical string representation of the actions,      * @see Permission#getActions(),      */,     public String getActions() {,         // currently, the only supported action,         return CREATE;,     }, , ,     /**,      * Called upon Serialization for saving the state of this,      * DatabasePermission to a stream.,      */,     private void writeObject(ObjectOutputStream s),         throws IOException {,         // write the non-static and non-transient fields to the stream,         s.defaultWriteObject();,     }, ,     /**,      * Called upon Deserialization for restoring the state of this,      * DatabasePermission from a stream.,      */,     private void readObject(ObjectInputStream s),          throws IOException, ClassNotFoundException,     {,         // read the non-static and non-transient fields from the stream,         s.defaultReadObject();,         // restore the platform-dependent path from the original URL,         initLocation(url);,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/security/DatabasePermission.java,,314-316,[                    new PrivilegedAction<String>() {,                         public String run() {,                             return System.getProperty("user.dir");],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/security/DatabasePermission.java,,331-333,[                    new PrivilegedExceptionAction<File>() {,                         public File run() throws IOException {,                             return (new File(absPath)).getCanonicalFile();],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/derby/security/SystemPermission.java,equals,183-187,[        if (!super.equals(other)),             return false;,         ,         SystemPermission osp = (SystemPermission) other;,         return getActions().equals(osp.getActions());],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/derby/shared/common/error/ExceptionUtil.java,getSeverityFromIdentifier,55-64,[				switch (messageID.charAt(1)) {, 				case '1':, 					lseverity = ExceptionSeverity.WARNING_SEVERITY;, 					break;, 				case 'A':, 				case '7':, 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;, 					break;, 				case '8':, 					lseverity = ExceptionSeverity.SESSION_SEVERITY;],,getSeverityFromIdentifier,73-78,[				switch (messageID.charAt(1)) {, 				case '0':, 					lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;, 					break;, 				case '2':, 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;],,getSeverityFromIdentifier,86-103,[			switch (messageID.charAt(6)) {, 			case 'M':, 				lseverity = ExceptionSeverity.SYSTEM_SEVERITY;, 				break;, 			case 'D':, 				lseverity = ExceptionSeverity.DATABASE_SEVERITY;, 				break;, 			case 'C':, 				lseverity = ExceptionSeverity.SESSION_SEVERITY;, 				break;, 			case 'T':, 				lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;, 				break;, 			case 'S':, 				lseverity = ExceptionSeverity.STATEMENT_SEVERITY;, 				break;, 			case 'U':, 				lseverity = ExceptionSeverity.NO_APPLICABLE_SEVERITY;],,
STYLE,UCF_USELESS_CONTROL_FLOW_NEXT_LINE,org/apache/derby/shared/common/i18n/MessageUtil.java,formatMessage,220-220,[                    if ( !composeDefault || SanityManager.DEBUG )],,formatMessage,227-227,[                    if ( !composeDefault  || SanityManager.DEBUG )],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/derby/shared/common/sanity/AssertFailure.java,,182-187,[            (new PrivilegedExceptionAction<Object>(){,                 public Object run() throws,                         IllegalArgumentException,,                         IllegalAccessException,,                         InvocationTargetException {,                     return m.invoke(null, (Object[])null);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derby/shared/common/sanity/SanityManager.java,<clinit>,70-70,[	static private java.io.PrintWriter debugStream = new java.io.PrintWriter(System.err);],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayBanner,1168-1168,[		buf = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayBanner,641-641,[		buf = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayCurrentRow,1088-1088,[		nestedResults = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayCurrentRow,556-556,[		nestedResults = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayNextRow,1049-1049,[		nestedResults = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayNextRow,507-507,[		nestedResults = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayResults,981-981,[		nestedResults = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayResults,421-421,[        nestedResults = null;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayBanner,1095-1095,[		return indent_DisplayBanner( out, rsmd, 0, null,],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayBanner,573-573,[		return indent_DisplayBanner( out, rsmd, 0, null, ],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayCurrentRow,1056-1058,[		indent_DisplayCurrentRow( out, rs, conn, 0, null, (rs == null) ? null, 								  : getColumnDisplayWidths(rs.getMetaData(),null,false) );, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayCurrentRow,524-526,[		indent_DisplayCurrentRow( out, rs, conn, 0, null, (rs == null) ? null, 								  : getColumnDisplayWidths(rs.getMetaData(), null, true) );, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayMultipleResults,315-317,[        indent_DisplayResults( out, resultSets, conn, 0, displayColumns,,                                displayColumnWidths);,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayNestedResults,987-1009,[		if (nr == null) return;, , 		String s="+ ResultSet #";, 		String b="++++++++++++++++";, 		String oldString="0";, , 		for (int i=0; i < nr.size(); i++) {, 			System.out.println();, , 			//just too clever to get the extra +s, 			String t = Integer.toString(i);, 			if (t.length() > oldString.length()) {, 				oldString = t;, 				b=b+"+";, 			}, , 			System.out.println(b);, 			System.out.println(s+i+" +");, 			System.out.println(b);, 			indent_DisplayResults(out, nr.elementAt(i), conn, , 								  indentLevel, null, null);, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayNestedResults,436-457,[		if (nr == null) return;, , 		String b=LocalizedResource.getMessage("UT_JDBCDisplayUtil_16");, 		String oldString="0";, , 		for (int i=0; i < nr.size(); i++) {, 			LocalizedResource.OutputWriter().println();, , 			//just too clever to get the extra +s, 			String t = Integer.toString(i);, 			if (t.length() > oldString.length()) {, 				oldString = t;, 				b=b+LocalizedResource.getMessage("UT_JDBCDisplayUtil_17");, 			}, , 			LocalizedResource.OutputWriter().println(b);, 			LocalizedResource.OutputWriter().println(LocalizedResource.getMessage("UT_Resul0", LocalizedResource.getNumber(i)));, 			LocalizedResource.OutputWriter().println(b);, 			indent_DisplayResults(out, (ResultSet) nr.elementAt(i), conn,, 								  indentLevel, null, null);, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayNextRow,1014-1016,[		indent_DisplayNextRow( out, rs, conn, 0, null, (rs == null) ? null, 							   : getColumnDisplayWidths(rs.getMetaData(),null,false) );, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayNextRow,472-474,[		indent_DisplayNextRow( out, rs, conn, 0, null, (rs == null) ? null, 							   : getColumnDisplayWidths(rs.getMetaData(), null, true));, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayResults,921-922,[		indent_DisplayResults( out, rs, conn, 0, null, null);, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayResults,883-884,[		indent_DisplayResults( out, stmt, conn, 0, null, null);			, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayResults,334-336,[		indent_DisplayResults( out, rs, conn, 0, displayColumns, , 							   displayColumnWidths);, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayResults,235-236,[		indent_DisplayResults( out, stmt, conn, 0, null, null);			, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayRow,1177-1237,[		StringBuffer buf = new StringBuffer();, 		buf.ensureCapacity(rowLen);, , 		int numCols = displayColumnWidths.length;, 		int i;, , 		// get column header info, 		// truncate it to the column display width, 		// add a bar between each item., 		for (i=1; i <= numCols; i++){, 			int colnum = displayColumns==null ? i : displayColumns[i-1];, 			if (i>1), 				buf.append('|');, , 			String s;, 			switch (rsmd.getColumnType(colnum)) {, 			default:, 				s = rs.getString(colnum);, 				break;, 			case Types.JAVA_OBJECT:, 			case Types.OTHER:, 			{, 				Object o = rs.getObject(colnum);, 				if (o == null) { s = "NULL"; }, 				else if (o instanceof ResultSet && nestedResults != null), 				{, 					s = "ResultSet #"+nestedResults.size();, 					nestedResults.addElement( (ResultSet) o);, 				}, 				else, 				{, 					try {, 						s = rs.getString(colnum);, 					} catch (SQLException se) {, 						// oops, they don't support refetching the column, 						s = o.toString();, 					}, 				}, 			}, 			break;, 			}, , 			if (s==null) s = "NULL";, , 			int w = displayColumnWidths[i-1];, 			if (s.length() < w) {, 				StringBuffer fullS = new StringBuffer(s);, 				fullS.ensureCapacity(w);, 				for (int k=s.length(); k<w; k++), 					fullS.append(' ');, 				s = fullS.toString();, 			}, 			else if (s.length() > w), 				// add the & marker to know it got cut off, 				s = s.substring(0,w-1)+"&";, , 			buf.append(s);, 		}, 		indentedPrintLine( out, indentLevel, buf);, , 	} // DisplayRow],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayRow,667-726,[		StringBuffer buf = new StringBuffer();, 		buf.ensureCapacity(rowLen);, , 		int numCols = displayColumnWidths.length;, 		int i;, , 		// get column header info, 		// truncate it to the column display width, 		// add a bar between each item., 		for (i=1; i <= numCols; i++){, 			int colnum = displayColumns==null ? i : displayColumns[i-1];, 			if (i>1), 				buf.append('|');, , 			String s;, 			switch (rsmd.getColumnType(colnum)) {, 			default:, 				s = LocalizedResource.getInstance().getLocalizedString(rs, rsmd, colnum );, 				break;, 			case Types.JAVA_OBJECT:, 			case Types.OTHER:, 			{, 				Object o = rs.getObject(colnum);, 				if (o == null) { s = "NULL"; }, 				else if (o instanceof ResultSet && nestedResults != null), 				{, 					s = LocalizedResource.getMessage("UT_Resul0_20", LocalizedResource.getNumber(nestedResults.size()));, 					nestedResults.addElement( (ResultSet) o);, 				}, 				else, 				{, 					try {, 						s = rs.getString(colnum);, 					} catch (SQLException se) {, 						// oops, they don't support refetching the column, 						s = o.toString();, 					}, 				}, 			}, 			break;, 			}, 			if (s==null) s = "NULL";, , 			int w = displayColumnWidths[i-1];, 			if (s.length() < w) {, 				StringBuffer fullS = new StringBuffer(s);, 				fullS.ensureCapacity(w);, 				for (int k=s.length(); k<w; k++), 					fullS.append(' ');, 				s = fullS.toString();, 			}, 			else if (s.length() > w), 				// add the & marker to know it got cut off, 				s = s.substring(0,w-1)+"&";, , 			buf.append(s);, 		}, 		indentedPrintLine( out, indentLevel, buf);, , 	} // DisplayRow],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayUpdateCount,907-916,[		if (count == 1) {, 			indentedPrintLine( out, indentLevel, "1 row inserted/updated/deleted");, 		}, 		else if (count >= 0) {, 			indentedPrintLine( out, indentLevel, count+" rows inserted/updated/deleted");, 		}, 		else {, 			indentedPrintLine( out, indentLevel, "Statement executed.");, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayUpdateCount,264-273,[		if (count == 1) {, 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_1RowInserUpdatDelet"));, 		}, 		else if (count >= 0) {, 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_0RowsInserUpdatDelet", LocalizedResource.getNumber(count)));, 		}, 		else {, 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_StateExecu"));, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowException,793-799,[		if (e == null) return;, , 		if (e instanceof SQLException), 			ShowSQLException(out, (SQLException)e);, 		else, 			e.printStackTrace(out);, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowException,90-96,[		if (e == null) return;, , 		if (e instanceof SQLException), 			ShowSQLException(out, (SQLException)e);, 		else, 			e.printStackTrace(out);, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowSQLException,804-817,[		if (getSystemBoolean("ij.showErrorCode")) {, 			errorCode = " (errorCode = " + e.getErrorCode() + ")";, 		}, 		else {, 			errorCode = "";, 		}, , 		while (e!=null) {, 			out.println("ERROR "+mapNull(e.getSQLState(),"(no SQLState)")+": "+, 				 mapNull(e.getMessage(),"(no message)")+errorCode);, 			doTrace(out, e);, 			e=e.getNextException();, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowSQLException,108-122,[		if (getSystemBoolean("ij.showErrorCode")) {, 			errorCode = LocalizedResource.getMessage("UT_Error0", LocalizedResource.getNumber(e.getErrorCode()));, 		}, 		else {, 			errorCode = "";, 		}, , 		while (e!=null) {, 			String p1 = mapNull(e.getSQLState(),LocalizedResource.getMessage("UT_NoSqlst"));, 			String p2 = mapNull(e.getMessage(),LocalizedResource.getMessage("UT_NoMessa"));, 			out.println(LocalizedResource.getMessage("UT_Error012", p1, p2,errorCode));, 			doTrace(out, e);, 			e=e.getNextException();, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowWarnings,822-834,[		SQLWarning warning = null;, , 		if (theConnection != null) {, 			ShowWarnings(out, theConnection.getWarnings());, 		}, , 		if (theConnection != null) {, 			theConnection.clearWarnings();, 		}, 	    } catch (SQLException e) {, 			ShowSQLException(out, e);, 	    }, 	} // ShowWarnings],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowWarnings,848-860,[		SQLWarning warning = null;, , 		if (rs != null) {, 			ShowWarnings(out, rs.getWarnings());, 		}, , 		if (rs != null) {, 			rs.clearWarnings();, 		}, 	    } catch (SQLException e) {, 			ShowSQLException(out, e);, 	    }, 	} // ShowResultSetWarnings],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowWarnings,837-843,[		while (warning != null) {, 			out.println("WARNING "+, 				mapNull(warning.getSQLState(),"(no SQLState)")+": "+, 				mapNull(warning.getMessage(),"(no message)"));, 			warning = warning.getNextWarning();, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowWarnings,866-878,[		SQLWarning warning = null;, , 		if (s != null) {, 			ShowWarnings(out, s.getWarnings());, 		}, , 		if (s != null) {, 			s.clearWarnings();, 		}, 	    } catch (SQLException e) {, 			ShowSQLException(out, e);, 	    }, 	} // ShowStatementWarnings],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowWarnings,135-147,[		SQLWarning warning = null;, , 		if (theConnection != null) {, 			ShowWarnings(out, theConnection.getWarnings());, 		}, , 		if (theConnection != null) {, 			theConnection.clearWarnings();, 		}, 	    } catch (SQLException e) {, 			ShowSQLException(out, e);, 	    }, 	} // ShowWarnings],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowWarnings,173-185,[		SQLWarning warning = null;, , 		if (rs != null) {, 			ShowWarnings(out, rs.getWarnings());, 		}, , 		if (rs != null) {, 			rs.clearWarnings();, 		}, 	    } catch (SQLException e) {, 			ShowSQLException(out, e);, 	    }, 	} // ShowResultSetWarnings],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowWarnings,154-160,[		while (warning != null) {, 			String p1 = mapNull(warning.getSQLState(),LocalizedResource.getMessage("UT_NoSqlst_7"));, 			String p2 = mapNull(warning.getMessage(),LocalizedResource.getMessage("UT_NoMessa_8"));, 			out.println(LocalizedResource.getMessage("UT_Warni01", p1, p2));, 			warning = warning.getNextWarning();, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/derby/tools/JDBCDisplayUtil.java,ShowWarnings,199-211,[		SQLWarning warning = null;, , 		if (s != null) {, 			ShowWarnings(out, s.getWarnings());, 		}, , 		if (s != null) {, 			s.clearWarnings();, 		}, 	    } catch (SQLException e) {, 			ShowSQLException(out, e);, 	    }, 	} // ShowStatementWarnings],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayResults,383-383,[        for (int i = 0; i< resultSets.size(); i++) {],,indent_DisplayResults,356-356,[        if (resultSets != null && resultSets.size() > 0)],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayNextRow,1014-1014,[		indent_DisplayNextRow( out, rs, conn, 0, null, (rs == null) ? null],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayNextRow,472-472,[		indent_DisplayNextRow( out, rs, conn, 0, null, (rs == null) ? null],,
CORRECTNESS,NP_NULL_PARAM_DEREF_NONVIRTUAL,org/apache/derby/tools/JDBCDisplayUtil.java,indent_DisplayBanner,1038-1038,[			int rowLen = indent_DisplayBanner(out, rsmd, indentLevel, null, null);],,
CORRECTNESS,NP_NULL_PARAM_DEREF_NONVIRTUAL,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayRow,497-497,[    		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel,],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derby/tools/JDBCDisplayUtil.java,DisplayNestedResults,448-448,[				b=b+LocalizedResource.getMessage("UT_JDBCDisplayUtil_17");],,
I18N,DM_CONVERT_CASE,org/apache/derby/tools/PlanExporter.java,generateHTML,259-259,[        if(arg.toUpperCase().endsWith(".XML")){],,
I18N,DM_CONVERT_CASE,org/apache/derby/tools/PlanExporter.java,generateXML,234-234,[        if(arg.toUpperCase().endsWith(".XML")){],,
I18N,DM_CONVERT_CASE,org/apache/derby/tools/PlanExporter.java,main,74-74,[                				if(args[7].toUpperCase().endsWith(".XSL"))],,main,80-80,[                				if(args[5].toUpperCase().endsWith(".XSL"))],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/derby/tools/PlanExporter.java,run,301-301,[                delFile.delete();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/tools/SignatureChecker.java,countFunctionArgs,396-396,[        } catch (Exception e) { throw new SQLException( e.getMessage() ); }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/tools/SignatureChecker.java,findFunctions,355-355,[        } catch (Exception e) { throw new SQLException( e.getMessage() ); }],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/tools/SignatureChecker.java,matchFunctions,250-250,[            checkSignature( conn, function, query.toString(), makeReadableSignature( function ) );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/tools/SignatureChecker.java,matchProcedures,206-206,[            checkSignature( conn, procedure, buffer.toString(), makeReadableSignature( procedure ) );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/tools/SignatureChecker.java,checkSignature,408-408,[            PreparedStatement   ps = prepareStatement( conn, query );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/tools/SignatureChecker.java,prepareStatement,459-459,[        return conn.prepareStatement( text );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/derby/tools/SignatureChecker.java,,582-619,[        private ArrayList<String>   _argList = new ArrayList<String>();, ,         public SQLRoutine( String schema, String name, boolean isTableFunction ),         {,             _schema = schema;,             _name = name;,             _isTableFunction = isTableFunction;,         }, ,         public void addArg( String typeName ) { _argList.add( typeName ); }, ,         public String getSchema() { return _schema; },         public String getName() { return _name; },         public int      getArgCount() { return _argList.size(); },         public String getArgType( int idx ) { return _argList.get( idx ); },         public boolean isTableFunction() { return _isTableFunction; }, ,         public  String  toString(),         {,             StringBuffer    buffer = new StringBuffer();, ,             buffer.append( "SQLRoutine( " );,             buffer.append( _schema + ", " );,             buffer.append( _name + ", " );,             buffer.append(  "isTableFunction = " + _isTableFunction + ", " );,             buffer.append( " argCount = " + getArgCount() );,             buffer.append( " )" );, ,             return buffer.toString();,         }, ,         private String doubleQuote( String raw ),         {,             return '\"' + raw + '\"';,         },         public  String  getQualifiedName(),         {,             return doubleQuote( _schema ) + '.' + doubleQuote( _name );],,
I18N,DM_CONVERT_CASE,org/apache/derby/tools/dblook.java,getColumnListFromDescription,687-687,[				tok = tok.toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/derby/tools/dblook.java,stringContainsTargetTable,905-905,[				strCopy = str.toUpperCase();],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/tools/dblook.java,,81-1222,[	private static String lookLogName = "dblook.log";, , 	private static LocalizedResource langUtil;, , 	private static boolean sqlAuthorization;, , 	/* ************************************************, 	 * main:, 	 * Initialize program state by creating a dblook object,, 	 * and then start the DDL generation by calling "go"., 	 * ****/, , 	public static void main(String[] args) {, , 		try {, 			new dblook(args);, 		} catch (Exception e) {, 		// All "normal" errors are logged and printed to, 		// console according to command line arguments,, 		// so if we get here, something unexpected must, 		// have happened; print to error stream., 			e.printStackTrace();, 		}, , 	}, , 	/* ************************************************, 	 * Constructor:, 	 * Parse the command line, initialize logs, echo program variables,, 	 * and load the Derby driver., 	 * @param args Array of dblook command-line arguments., 	 * ****/, , 	public dblook(String[] args) throws Exception {, ,         // Adjust the application in accordance with derby.ui.locale, 		// and derby.ui.codeset, 		langUtil = LocalizedResource.getInstance();, , 		// Initialize class variables., 		initState();, , 		// Parse the command line., 		if (!parseArgs(args)) {, 			System.out.println(lookupMessage("DBLOOK_Usage"));, 			return;, 		}, , 		showVariables();, , 		if (!loadDriver()) {, 		// Failed when loading the driver.  We already logged, 		// the exception, so just return., 			return;, 		}, , 		schemaMap = new HashMap<String,String>();, 		tableIdToNameMap = new HashMap<String,String>();, , 		// Now run the utility., 		go();, , 	}, , 	/* ************************************************, 	 * initState:, 	 * Initialize class variables., 	 ****/, , 	private void initState() {, , 		sourceDBUrl = null;, 		ddlFileName = null;, 		stmtDelimiter = null;, 		appendLogs = false;, 		tableList = null;, 		targetSchema = null;, 		schemaParam = null;, 		skipViews = false;, 		verbose= false;, 		sourceDBName = null;, 		return;, , 	}, , 	/* ************************************************, 	 * parseArgs:, 	 * Parse the command-line arguments., 	 * @param args args[0] is the url for the source database., 	 * @return true if all parameters were loaded and the output, 	 *  files were successfully created; false otherwise., 	 ****/, , 	private boolean parseArgs(String[] args) {, , 		if (args.length < 2), 		// must have minimum of 2 args: "-d" and "<dbUrl>"., 			return false;, , 		int st = 0;, 		for (int i = 0; i < args.length; i++) {, 			st = loadParam(args, i);, 			if (st == -1), 				return false;, 			i = st;, 		}, , 		if (sourceDBUrl == null) {, 		// must have at least a database url., 			return false;	, 		}, , 		// At this point, all parameters should have been read into, 		// their respective class variables.  Use those, 		// variables for some further processing., , 		// Setup logs., 		boolean okay = Logs.initLogs(lookLogName, ddlFileName, appendLogs,, 		 	verbose, (stmtDelimiter == null ? ";" : stmtDelimiter));, , 		// Get database name., 		sourceDBName = extractDBNameFromUrl(sourceDBUrl);, , 		// Set up schema restriction., 		if ((schemaParam != null) && (schemaParam.length() > 0) &&, 			(schemaParam.charAt(0) != '"')), 		// not quoted, so upper case, then add quotes., 		{, 			targetSchema = addQuotes(expandDoubleQuotes(, 				schemaParam.toUpperCase(java.util.Locale.ENGLISH)));, 		}, 		else, 			targetSchema = addQuotes(expandDoubleQuotes(stripQuotes(schemaParam)));, 		return okay;, , 	}, , 	/* ************************************************, 	 * loadParam:, 	 * Read in a flag and its corresponding values from, 	 * list of command line arguments, starting at, 	 * the start'th argument., 	 * @return The position of the argument that was, 	 *  most recently processed., 	 ****/, , 	private int loadParam(String [] args, int start) {, , 		if ((args[start].length() == 0) || args[start].charAt(0) != '-'), 		// starting argument should be a flag; if it's, 		// not, ignore it., 			return start;, , 		boolean haveVal = (args.length > start + 1);, 		switch (args[start].charAt(1)) {, , 			case 'd':, 				if (!haveVal), 					return -1;, 				if (args[start].length() == 2) {, 					sourceDBUrl = stripQuotes(args[++start]);, 					return start;, 				}, 				return -1;, , 			case 'z':, 				if (!haveVal), 					return -1;, 				if (args[start].length() == 2) {, 					schemaParam = args[++start];, 					return start;, 				}, 				return -1;, , 			case 't':, 				if (!haveVal), 					return -1;, 				if (args[start].equals("-td")) {, 					stmtDelimiter = args[++start];, 					return start;, 				}, 				else if (args[start].equals("-t")), 				// list of tables., 					return extractTableNamesFromList(args, start+1);, 				return -1;, , 			case 'o':, 				if (!haveVal), 					return -1;, 				if ((args[start].length() == 2) && (args[start+1].length() > 0)) {, 					ddlFileName = args[++start];, 					return start;, 				}, 				return -1;, , 			case 'a':, 				if (args[start].equals("-append")) {, 					appendLogs = true;, 					return start;, 				}, 				return -1;, , 			case 'n':, 				if (args[start].equals("-noview")) {, 					skipViews = true;, 					return start;, 				}, 				return -1;, , 			case 'v':, 				if (args[start].equals("-verbose")) {, 					verbose = true;, 					return start;, 				}, 				return -1;, , 			default:, 				return -1;, , 		}, , 	}, , 	/* ************************************************, 	 * loadDriver:, 	 * Load derby driver., 	 * @param precondition sourceDBUrl has been loaded., 	 * @return false if anything goes wrong; true otherwise., 	 ****/, , 	private boolean loadDriver() {, , 		String derbyDriver = System.getProperty("driver");, 		if (derbyDriver == null) {, 			if (sourceDBUrl.indexOf(":net://") != -1), 				derbyDriver = "com.ibm.db2.jcc.DB2Driver";, 			else if (sourceDBUrl.startsWith("jdbc:derby://")), 			   derbyDriver = "org.apache.derby.jdbc.ClientDriver";, 			else, 				derbyDriver = "org.apache.derby.jdbc.EmbeddedDriver";, 	    }, , 		try {, 			Class.forName(derbyDriver).newInstance();, 	    }, 		catch (Exception e), 		{, 			Logs.debug(e);, 			return false;, 		}, , 		return true;, 	}, , 	/* ************************************************, 	 * extractDBNameFromUrl:, 	 * Given a database url, parse out the actual name, 	 * of the database.  This is required for creation, 	 * the DB2JJARS directory (the database name is part, 	 * of the path to the jar)., 	 * @param dbUrl The database url from which to extract the, 	 *  the database name., 	 * @return the name of the database (including its, 	 *  path, if provided) that is referenced by the url., 	 ****/, , 	private String extractDBNameFromUrl(String dbUrl) {, , 		if (dbUrl == null), 		// shouldn't happen; ignore it here, as an error, 		// will be thrown we try to connect., 			return "";, , 		int start = dbUrl.indexOf("jdbc:derby:");, 		if (start == -1), 		// not a valid url; just ignore it (an error, 		// will be thrown when we try to connect)., 			return "";, , 		start = dbUrl.indexOf("://");, 		if (start == -1), 		// standard url (jdbc:derby:<dbname>).  Database, 		// name starts right after "derby:".  The "6" in, 		// the following line is the length of "derby:"., 			start = dbUrl.indexOf("derby:") + 6;, 		else, 		// Network Server url.  Database name starts right, 		// after next slash (":net://hostname:port/<dbname>)., 		// The "3" in the following line is the length of, 		// "://"., 			start = dbUrl.indexOf("/", start+3) + 1;, , 		int stop = -1;, 		if (dbUrl.charAt(start) == '"') {, 		// database name is quoted; end of the name is the, 		// closing quote., 			start++;, 			stop = dbUrl.indexOf("\"", start);, 		}, 		else {, 		// Database name ends with the start of a list of connection	, 		// attributes.  This list can begin with either a colon, 		// or a semi-colon., 			stop = dbUrl.indexOf(":", start);, 			if (stop != -1) {, 				if ((dbUrl.charAt(stop+1) == '/') ||, 						(dbUrl.charAt(stop+1) == '\\')), 				// then this colon is part of the path (ex. "C:"),, 				// so ignore it., 					stop = dbUrl.indexOf(":", stop+2);, 			}, 			int stop2 = dbUrl.length();, 			if (stop == -1), 			// no colons; see if we can find a semi-colon., 				stop = dbUrl.indexOf(";", start);, 			else, 				stop2 = dbUrl.indexOf(";", start);, 			stop = (stop <= stop2 ? stop : stop2);, 		}, , 		if (stop == -1), 		// we have a url that ends with database name (no, 		// other attributes appended)., 			stop = dbUrl.length();, , 		return dbUrl.substring(start, stop);, , 	}, , 	/* ************************************************, 	 * extractTableNamesFromList:, 	 * Given an array of command line arguments containing, 	 * a list of table names beginning at start'th position,, 	 * read the list of table names and store them as, 	 * our target table list.  Names without quotes are, 	 * turned into ALL CAPS and then double quotes are, 	 * added; names whcih already have double quotes are, 	 * stored exactly as they are. NOTE: DB2 enforces, 	 * maximum of 30 tables, and ignores the rest; so, 	 * do we., 	 * @param args Array of command line arguments., 	 * @start Position of the start of the list of tables, 	 *  with the args array., 	 * @return The position of the last table name in, 	 *  the list of table names., 	 ****/, , 	private int extractTableNamesFromList(String [] args,, 		int start), 	{, , 		int argIndex = start;, 		int count = 0;, 		tableList = new ArrayList<String>();, 		while (argIndex < args.length) {, , 			if (((args[argIndex].length() > 0) && (args[argIndex].charAt(0) == '-')) ||, 				(++count > DB2_MAX_NUMBER_OF_TABLES)), 			// we're done with the table list., 				break;, , 			if ((args[argIndex].length() > 0) && (args[argIndex].charAt(0) == '"')), 			// it's quoted., 				tableList.add(addQuotes(expandDoubleQuotes(, 					stripQuotes(args[argIndex++]))));, 			else, 			// not quoted, so make it all caps, then add, 			// quotes., 				tableList.add(addQuotes(, 					expandDoubleQuotes(args[argIndex++].toUpperCase(, 					java.util.Locale.ENGLISH))));, , 		}, , 		if (tableList.size() == 0), 			tableList = null;, , 		return argIndex - 1;, , 	}, , 	/* ************************************************, 	 * showVariables:, 	 * Echo primary variables to output, so user can see, 	 * what s/he specified., 	 ****/, , 	private void showVariables() {, , 		if (ddlFileName != null) {, 			Logs.reportString("============================\n");, 			Logs.reportMessage("DBLOOK_FileCreation");, 			if (verbose), 				writeVerboseOutput("DBLOOK_OutputLocation",, 					ddlFileName);, 		}, , 		Logs.reportMessage("DBLOOK_Timestamp",, 			new Timestamp(System.currentTimeMillis()).toString());, 		Logs.reportMessage("DBLOOK_DBName", sourceDBName);, 		Logs.reportMessage("DBLOOK_DBUrl", sourceDBUrl);, 		if (tableList != null), 			Logs.reportMessage("DBLOOK_TargetTables");, 		if (schemaParam != null), 			Logs.reportMessage("DBLOOK_TargetSchema", stripQuotes(schemaParam));, 		Logs.reportString("appendLogs: " + appendLogs + "\n");, 		return;, , 	}, , 	/* ************************************************, 	 * go:, 	 * Connect to the source database, prepare statements,, 	 * and load a list of table id-to-name mappings.  Then,, 	 * generate the DDL for the various objects in the, 	 * database by making calls to static methods of helper, 	 * classes (one helper class for each type of database, 	 * object).  If a particular object type should not be, 	 * generated (because of the user-specified command-, 	 * line), then we enforce that here., 	 * @precondition all user-specified parameters have, 	 *  been loaded., 	 * @return DDL for the source database has been, 	 *  generated and printed to output, subject to, 	 *  user-specified restrictions., 	 * ****/, , 	private void go(), 		throws Exception, 	{, , 		try, 		{, 			// Connect to the database, prepare statements,, 			// and load id-to-name mappings., 			this.conn = DriverManager.getConnection(sourceDBUrl);, 			prepForDump();, ,             boolean at10_6 = atVersion( conn, 10, 6 );,             boolean at10_9 = atVersion( conn, 10, 9 );,             boolean at10_11 = atVersion(conn, 10, 11);, , 			// Generate DDL., , 			// Start with schemas, since we might need them to, 			// exist for jars to load properly., 			DB_Schema.doSchemas(this.conn,, 				(tableList != null) && (targetSchema == null));, ,             if ( at10_6 ) { DB_Sequence.doSequences( conn ); }, , 			if (tableList == null) {, 			// Don't do these if user just wants table-related objects.,                 DB_Jar.doJars(sourceDBName, this.conn, at10_9);, 				DB_Alias.doPFAU(this.conn, at10_6 );, 			}, , 			DB_Table.doTables(this.conn, tableIdToNameMap);, 			DB_Index.doIndexes(this.conn);, 			DB_Alias.doSynonyms(this.conn);, 			DB_Key.doKeys(this.conn);, 			DB_Check.doChecks(this.conn);, , 			if (!skipViews), 				DB_View.doViews(this.conn);, ,             DB_Trigger.doTriggers(this.conn, at10_11);, , 			DB_Roles.doRoles(this.conn);, 			DB_GrantRevoke.doAuthorizations(this.conn, at10_6);, , 			// That's it; we're done., 			if (getColNameFromNumberQuery != null), 				getColNameFromNumberQuery.close();, 			Logs.cleanup();, , 		}, 		catch (SQLException sqlE), 		{, 			Logs.debug(sqlE);, 			Logs.debug(Logs.unRollExceptions(sqlE), (String)null);, 			Logs.cleanup();, 			return;, 		}, 		catch (Exception e), 		{, 			Logs.debug(e);, 			Logs.cleanup();, 			return;, 		}, 		finally {, 		// Close our connection., 			if (conn != null) {, 				conn.commit();, 				conn.close();, 			}, 		}, , 	}, , 	/* ************************************************, 	 * prepForDump:, 	 * Prepare any useful statements (i.e. statements that, 	 * are required by more than one helper class) and load, 	 * the id-to-name mappings for the source database., 	 ****/, , 	private void prepForDump() throws Exception {, , 		// We're only SELECTing throughout all of this, so no need, 		// to commit (plus, disabling commit makes it easier to, 		// have multiple ResultSets open on the same connection)., 		this.conn.setAutoCommit(false);, , 		// Set the system schema to ensure that UCS_BASIC collation is used., 		Statement stmt = conn.createStatement();, 		stmt.executeUpdate("SET SCHEMA SYS");, , 		// Prepare statements., 		getColNameFromNumberQuery = conn.prepareStatement(, 			"SELECT COLUMNNAME FROM SYS.SYSCOLUMNS WHERE " +, 			"REFERENCEID = ? AND COLUMNNUMBER = ?");, , 		// Load list of user tables and table ids, for general use., 		ResultSet rs = stmt.executeQuery("SELECT T.TABLEID, T.TABLENAME, " +, 				"S.SCHEMANAME FROM SYS.SYSTABLES T, SYS.SYSSCHEMAS S " + , 				"WHERE T.TABLETYPE = 'T' AND T.SCHEMAID = S.SCHEMAID");, , 		while (rs.next()) {, 			String tableName = addQuotes(expandDoubleQuotes(rs.getString(2)));, 			String schemaName = addQuotes(expandDoubleQuotes(rs.getString(3)));, 			tableIdToNameMap.put(rs.getString(1), , 				schemaName + "." + tableName);, 		}, , 		// Load schema id's and names., 		rs = stmt.executeQuery("SELECT SCHEMAID, SCHEMANAME FROM " +, 			"SYS.SYSSCHEMAS");, 		while (rs.next()) {, 			schemaMap.put(rs.getString(1),, 				addQuotes(expandDoubleQuotes(rs.getString(2))));, 		}, , 		// Check if sqlAuthorization mode is on. If so, need to generate, 		// authorization statements., 		rs = stmt.executeQuery("VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY" +, 						"('derby.database.sqlAuthorization')");, 		if (rs.next()), 		{, 			String sqlAuth = rs.getString(1);, 			if (Boolean.valueOf(sqlAuth).booleanValue()), 				sqlAuthorization = true;, 		}, 		stmt.close();, , 		// Load default property values., 		return;, , 	}, , 	/* ************************************************, 	 * getColumnListFromDescription:, 	 * Takes string description of column numbers in the, 	 * form of "(2, 1, 3...)" and the id of the table, 	 * having those columns, and then returns a string, 	 * with the column numbers replaced by their actual, 	 * names ('2' is replaced with the 2nd column in the, 	 * table, '1' with the first column, etc.)., 	 * @param tableId the id of the table to which the column, 	 *   numbers should be applied., 	 * @param description a string holding a list of column, 	 *  numbers, enclosed in parentheses and separated, 	 *  by commas., 	 * @return a new string with the column numbers in, 	 *  'description' replaced by their column names;, 	 *  also, the parentheses have been stripped off., 	 ****/, , 	public static String getColumnListFromDescription(String tableId,, 		String description) throws SQLException, 	{, , 		StringBuffer sb = new StringBuffer();, 		StringTokenizer tokenizer = new StringTokenizer(, 			description.substring(description.indexOf("(") + 1,, 				description.lastIndexOf(")")), " ,", true);, , 		boolean firstCol = true;, 		while (tokenizer.hasMoreTokens()) {, , 			String tok = tokenizer.nextToken().trim();, 			if (tok.equals("")), 				continue;, 			else if (tok.equals(",")) {, 				firstCol = false;, 				continue;, 			}, 			try {, 				String colName = getColNameFromNumber(tableId,, 					(Integer.parseInt(tok)));, 				if (!firstCol), 					sb.append(", ");, 				sb.append(colName);, 			} catch (NumberFormatException e) {, 			// not a number; could be "ASC" or "DESC" tag,, 			// which is okay; otherwise, something's wrong., 				tok = tok.toUpperCase();, 				if (tok.equals("DESC") || tok.equals("ASC")), 				// then this is okay; just add the token to result., 					sb.append(" " + tok);, 				else, 				// shouldn't happen., 					Logs.debug("INTERNAL ERROR: read a non-number (" +, 						tok + ") when a column number was expected:\n" +, 						description, (String)null);, 			}, , 		}, , 		return sb.toString();, , 	}, , 	/* ************************************************, 	 * getColNameFromNumber:, 	 * Takes a tableid and a column number colNum, and, 	 * returns the name of the colNum'th column in the, 	 * table with tableid., 	 * @param tableid id of the table., 	 * @param colNum number of the column for which we want, 	 *  the name., 	 * @return The name of the colNum'th column in the, 	 *  table with tableid., 	 ****/, , 	public static String getColNameFromNumber(String tableId,, 		int colNum) throws SQLException, 	{, , 		getColNameFromNumberQuery.setString(1, tableId);, 		getColNameFromNumberQuery.setInt(2, colNum);, 		ResultSet rs = getColNameFromNumberQuery.executeQuery();, , 		if (!rs.next()) {, 		// shouldn't happen., 			Logs.debug("INTERNAL ERROR: Failed column number " +, 				"lookup for table " + lookupTableId(tableId) +, 				", column " + colNum, (String)null);, 			rs.close();, 			return "";, 		}, 		else {, 			String colName = addQuotes(expandDoubleQuotes(rs.getString(1)));, 			rs.close();, 			return colName;, 		}, , 	}, , 	/* ************************************************, 	 * addQuotes:, 	 * Add quotes to the received object name, and return, 	 * the result., 	 * @param name the name to which to add quotes., 	 * @return the name with double quotes around it., 	 ****/, , 	public static String addQuotes(String name) {, , 		if (name == null), 			return null;, , 		return "\"" + name + "\"";, , 	}, , , 	public static String addSingleQuotes(String name) {, , 		if (name == null), 			return null;, , 		return "'" + name + "'";, 	}, , 	/* ************************************************, 	 * stripQuotes:, 	 * Takes a name and, if the name is enclosed in, 	 * quotes, strips the quotes off.  This method, 	 * assumes that the received String either has no quotes,, 	 * or has a quote (double or single) as the very first, 	 * AND very last character., 	 * @param quotedName a name with quotes as the first, 	 *  and last character, or else with no quotes at all., 	 * @return quotedName, without the quotes., 	 ****/, , 	public static String stripQuotes(String quotedName) {, , 		if (quotedName == null), 			return null;, , 		if (!(quotedName.startsWith("'") || quotedName.startsWith("\""))), 		// name doesn't _start_ with a quote, so we do nothing., 			return quotedName;, , 		if (!(quotedName.endsWith("'") || quotedName.endsWith("\""))), 		// name doesn't _end_ with a quote, so we do nothing., 			return quotedName;, , 		// Remove starting and ending quotes., 		return quotedName.substring(1, quotedName.length() - 1);, , 	}, , 	/* ************************************************, 	 * isExcludedTable:, 	 * Takes a table name and determines whether or not, 	 * the DDL for objects related to that table should be, 	 * generated., 	 * @param tableName name of the table to check., 	 * @return true if 1) the user specified a table list, 	 *  and that list does NOT include the received name; or, 	 *  2) if the user specified a schema restriction and, 	 *  the received name does NOT have that schema; false, 	 *  otherwise., 	 ****/, , 	public static boolean isExcludedTable(String tableName) {, , 		if (tableName == null), 			return true;, , 		int dot = tableName.indexOf(".");, 		if (dot != -1) {, 		// strip off the schema part of the name, and see if we're, 		// okay to use it., 			if (isIgnorableSchema(tableName.substring(0, dot))), 			// then we exclude this table., 				return true;, 			tableName = tableName.substring(dot + 1,, 				tableName.length());, 		}, , 		return ((tableList != null) && !tableList.contains(tableName));, , 	}, , 	/* ************************************************, 	 * Takes a schema name and determines whether or, 	 * not the DDL for objects with that schema should, 	 * be generated., 	 * @param schemaName schema name to be checked., 	 * @return true if 1) the user specified a target, 	 *  schema and that target is NOT the same as the, 	 *  received schema name, or 2) the schema is a, 	 *  system schema (SYS, SYSVISUAL, or SYSIBM);, 	 *  false otherwise;, 	 ****/, ,     private static final String[] ignorableSchemaNames = {,         "SYSIBM",,         "SYS",,         "SYSVISUAL",,         "SYSCAT",,         "SYSFUN",,         "SYSPROC",,         "SYSSTAT",,         "NULLID",,         "SYSCS_ADMIN",,         "SYSCS_DIAG",,         "SYSCS_UTIL",,         "SQLJ"};, , 	public static boolean isIgnorableSchema(String schemaName) {, , 		if ((targetSchema != null) && (!schemaName.equals(targetSchema))), 			return true;, , 		schemaName = stripQuotes(schemaName);, ,         boolean ret = false;, ,         for (int i = ignorableSchemaNames.length - 1; i >= 0;),         {,             if ((ret = ignorableSchemaNames[i--].equalsIgnoreCase(schemaName))),                 break;,         }, ,         return(ret);, 	}, , 	/* ************************************************, 	 * Takes a string and determines whether or not that, 	 * string makes reference to any of the table names, 	 * in the user-specified table list., 	 * @param str The string in which to search for table names., 	 * @return true if 1) the user didn't specify a, 	 *  target table list, or 2) the received string, 	 *  contains at least one of the table names in the, 	 *  user-specified target list; false otherwise., 	 ****/, , 	public static boolean stringContainsTargetTable(String str) {, , 		if (str == null), 		// if the string is null, it can't possibly contain, 		// any table names., 			return false;, , 		if (tableList == null), 		// if we have no target tables, then default to true., 			return true;, , 		int strLen = str.length();, 		for (int i = 0; i < tableList.size(); i++) {, , 			String tableName = tableList.get(i);, 			tableName = expandDoubleQuotes(stripQuotes(tableName));, 			int nameLen = tableName.length();, 			String strCopy;, 			if (tableName.equals(tableName.toUpperCase(, 				java.util.Locale.ENGLISH))), 			// case doesn't matter., 				strCopy = str.toUpperCase();, 			else, 				strCopy = str;, 			int pos = strCopy.indexOf(tableName);, 			while (pos != -1) {, , 				// If we found it, make sure it's really a match., 				// First, see if it's part of another word., 				if (!partOfWord(str, pos, nameLen, strLen)) {, , 					// See if the match is in quotes--if so, then, 					// it should match the table name's case., 					if ((pos >= 1) && (strCopy.charAt(pos-1) == '"') &&, 					  (pos + nameLen < strCopy.length()) &&, 					  (strCopy.charAt(pos+nameLen) == '"')), 					{ // match is quoted; check it's case., 						if (str.substring(pos,, 							pos + nameLen).equals(tableName)), 						// everything checks out., 							return true;, 					}, 					else, 					// match isn't quoted, so we're okay as is., 						return true;, 				}, , 				pos = str.indexOf(tableName, pos + nameLen);, , 			}, 		}, , 		// If we get here, we didn't find it., 		return false;, , 	}, , 	/* ************************************************, 	 * partOfWord:, 	 * Returns true if the part of the string given by, 	 * str.substring(pos, pos + nameLen) is part of, 	 * another word., 	 * @param str The string in which we're looking., 	 * @param pos The position at which the substring in, 	 *  question begins., 	 * @param nameLen the length of the substring in, 	 *  question., 	 * @param strLen The length of the string in which, 	 *  we're looking., 	 * @return true if the substring from pos to, 	 *  pos+nameLen is part of larger word (i.e., 	 *  if it has a letter/digit immediately before, 	 *  or after); false otherwise., 	 ****/, , 	private static boolean partOfWord (String str,, 		int pos, int nameLen, int strLen), 	{, , 		boolean somethingBefore = false;, 		if (pos > 0) {, 			char c = str.charAt(pos-1);, 			somethingBefore = ((c == '_') ||, 				Character.isLetterOrDigit(c));, 		}, , 		boolean somethingAfter = false;, 		if (pos + nameLen < strLen) {, 			char c = str.charAt(pos + nameLen);, 			somethingAfter = ((c == '_') ||, 				Character.isLetterOrDigit(c));, 		}, , 		return (somethingBefore || somethingAfter);, , 	}, , 	/* ************************************************, 	 * expandDoubleQuotes:, 	 * If the received SQL id contains a quote, we have, 	 * to expand it into TWO quotes so that it can be, 	 * treated correctly at parse time., 	 * @param name Id that we want to print., 	 ****/, , 	public static String expandDoubleQuotes(String name) {, , 		if ((name == null) || (name.indexOf("\"") < 0)), 		// nothing to do., 			return name;, , 		char [] cA = name.toCharArray();, , 		// Worst (and extremely unlikely) case is every , 		// character is a double quote, which means the, 		// escaped string would need to be 2 times as long., 		char [] result = new char[2*cA.length];, , 		int j = 0;, 		for (int i = 0; i < cA.length; i++) {, , 			if (cA[i] == '"') {, 				result[j++] = '"';, 				result[j++] = '"';, 			}, 			else, 				result[j++] = cA[i];, , 		}, , 		return new String(result, 0, j);, , 	}, ,     /**,      * inverse of expandDoubleQuotes,      */,     public static String unExpandDoubleQuotes(String name) {, ,         if ((name == null) || (name.indexOf("\"") < 0)),         // nothing to do.,             return name;, ,         char [] cA = name.toCharArray();, ,         char [] result = new char[cA.length];, ,         int j = 0;,         for (int i = 0; i < cA.length; i++) {, ,             if (cA[i] == '"') {,                 result[j++] = cA[i];,                 j++; // skip next char which must be " also,             },             else,                 result[j++] = cA[i];, ,         }, ,         return new String(result, 0, j);, ,     }, , , 	/* ************************************************, 	 * lookupSchemaId:, 	 * Return the schema name corresponding to the, 	 * received schema id., 	 * @param schemaId The id to look up., 	 * @return the schema name., 	 ****/, , 	public static String lookupSchemaId(String schemaId) {, , 		return schemaMap.get(schemaId);, , 	}, , 	/* ************************************************, 	 * lookupTableId:, 	 * Return the table name corresponding to the, 	 * received table id., 	 * @param tableId The id to look up., 	 * @return the table name., 	 ****/, , 	public static String lookupTableId(String tableId) {, , 		return tableIdToNameMap.get(tableId);, , 	}, , 	/* ************************************************, 	 * writeVerboseOutput:, 	 * Writes the received string as "verbose" output,, 	 * meaning that we write it to System.err.  We, 	 * choose System.err so that the string doesn't, 	 * show up if the user pipes dblook output to, 	 * a file (unless s/he explicitly pipes System.err, 	 * output to that file, as well)., 	 * @param key Key for the message to be printed as, 	 *  verbose output., 	 * @param value Value to be substituted into the, 	 *  message., 	 * @return message for received key has been printed, 	 *  to System.err., 	 ****/, , 	public static void writeVerboseOutput(String key,, 		String value) {, , 		if (value == null), 			System.err.println(lookupMessage(key));, 		else, 			System.err.println(lookupMessage(key,, 				new String [] {value}));, 		return;, , 	}, , 	/* ************************************************, 	 * lookupMessage:, 	 * Retrieve a localized message., 	 * @param key The key for the localized message., 	 * @return the message corresponding to the received, 	 *  key., 	 ****/, , 	public static String lookupMessage(String key) {, , 		return lookupMessage(key, null);, , 	}, , 	/* ************************************************, 	 * lookupMessage:, 	 * Retreive a localized message., 	 * @param key The key for the localized message., 	 * @param vals Array of values to be used in the, 	 *   message., 	 * @return the message corresponding to the received, 	 *  key, with the received values substituted where, 	 *  appropriate., 	 ****/, , 	public static String lookupMessage(String key, String[] vals) {, 	, 		String msg = "";, 		if (vals == null), 			msg = langUtil.getTextMessage(key);, 		else {, 			switch (vals.length) {, 				case 1: msg = langUtil.getTextMessage(, 							key, vals[0]);, 						break;, 				case 2: msg = langUtil.getTextMessage(, 							key, vals[0], vals[1]);, 						break;, 				default: /* shouldn't happen */, 						break;, 			}, 		}, , 		return msg;, , 	}, , 	/* ************************************************, 	 * removeNewlines:, 	 * Remove any newline characters from the received, 	 * string (replace them with spaces)., 	 * @param str The string from which we are removing, 	 *  all newline characters., 	 * @return The string, with all newline characters, 	 *  replaced with spaces., 	 ****/, , 	public static String removeNewlines(String str) {, , 		if (str == null), 		// don't do anything., 			return null;, , 		StringBuffer result = null;, 		try {, , 			BufferedReader strVal = new BufferedReader (new StringReader(str));, 			for (String txt = strVal.readLine(); txt != null;, 				txt = strVal.readLine()), 			{, 				if (result == null), 					result = new StringBuffer(txt);, 				else {, 					result.append(" ");, 					result.append(txt);, 				}, 			}, , 			return result.toString();, , 		} catch (Exception e) {, 		// if something went wrong, just return the string as is--, 		// worst case is that the generated DDL is correct, it just, 		// can't be run in some SQL script apps (because of the newline, 		// characters)., 			return str;, 		}, , 	}, ,     /**,      * Return true if we are at 10.6 or later.,      */,     private static boolean atVersion( Connection conn, int major, int minor ) throws SQLException,     {,         PreparedStatement ps = null;,         ResultSet rs =  null;,         try {,             ps = conn.prepareStatement( "values syscs_util.syscs_get_database_property('DataDictionaryVersion')" );,             rs = ps.executeQuery();, ,             rs.next();, ,             String versionString = rs.getString( 1 );,             int  dotIdx = versionString.indexOf( '.' );,             int actualMajor = Integer.parseInt( versionString.substring( 0, dotIdx ) );,             int actualMinor = Integer.parseInt( versionString.substring( dotIdx + 1, versionString.length() ) );, ,             if ( actualMajor > major ) { return true; },             if ( actualMajor < major ) { return false; }, ,             boolean result = ( actualMinor >= minor );,             ,             return result;,         },         finally,         {,             if ( rs != null ) { rs.close(); },             if ( ps != null ) { ps.close(); }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/tools/dblook.java,prepForDump,605-605,[		ResultSet rs = stmt.executeQuery("SELECT T.TABLEID, T.TABLENAME, " +],,prepForDump,609-609,[		while (rs.next()) {],,prepForDump,617-617,[		rs = stmt.executeQuery("SELECT SCHEMAID, SCHEMANAME FROM " +],,prepForDump,619-619,[		while (rs.next()) {],,prepForDump,626-626,[		rs = stmt.executeQuery("VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY" +],,prepForDump,628-628,[		if (rs.next())],,prepForDump,634-634,[		stmt.close();],,prepForDump,637-637,[		return;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/tools/dblook.java,atVersion,1202-1202,[            ps = conn.prepareStatement( "values syscs_util.syscs_get_database_property('DataDictionaryVersion')" );],,atVersion,1203-1203,[            rs = ps.executeQuery();],,atVersion,1205-1205,[            rs.next();],,atVersion,1221-1221,[            if ( rs != null ) { rs.close(); }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derby/tools/dblook.java,getColNameFromNumber,722-722,[		ResultSet rs = getColNameFromNumberQuery.executeQuery();],,getColNameFromNumber,724-724,[		if (!rs.next()) {],,
BAD_PRACTICE,ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH,org/apache/derby/tools/dblook.java,prepForDump,596-596,[		Statement stmt = conn.createStatement();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/derby/tools/dblook.java,removeNewlines,1184-1184,[		} catch (Exception e) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,<init>,118-118,[		langUtil = LocalizedResource.getInstance();],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,<init>,137-137,[		schemaMap = new HashMap<String,String>();],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,<init>,138-138,[		tableIdToNameMap = new HashMap<String,String>();],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,extractTableNamesFromList,434-434,[		tableList = new ArrayList<String>();],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,155-155,[		appendLogs = false;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,153-153,[		ddlFileName = null;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,158-158,[		schemaParam = null;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,159-159,[		skipViews = false;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,161-161,[		sourceDBName = null;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,152-152,[		sourceDBUrl = null;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,154-154,[		stmtDelimiter = null;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,156-156,[		tableList = null;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,157-157,[		targetSchema = null;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,initState,160-160,[		verbose= false;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derby/tools/dblook.java,prepForDump,600-600,[		getColNameFromNumberQuery = conn.prepareStatement(],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derby/tools/dblook.java,,632-632,[				sqlAuthorization = true;],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/tools/ij.java,,59-143,[      Main.main(args);,   },   ,   /**,    * Run a SQL script from an InputStream and write,    * the resulting output to the provided PrintStream.,    * SQL commands are separated by a semi-colon ';' character.,    * ,    * @param conn Connection to be used as the script's default connection. ,    * @param sqlIn InputStream for the script.,    * @param inputEncoding Encoding of the script.,    * @param sqlOut OutputStream for the script's output,    * @param outputEncoding Output encoding to use.,    * @return Number of SQLExceptions thrown during the execution, -1 if not known.,    * @throws UnsupportedEncodingException,    */,   public static int runScript(, 		  Connection conn,, 		  InputStream sqlIn,, 		  String inputEncoding,, 		  OutputStream sqlOut,, 		  String outputEncoding), 		  throws UnsupportedEncodingException,   {, 	  return ij.runScript(conn, sqlIn, inputEncoding, sqlOut, outputEncoding,false);,   }, ,     /**,     * Run a SQL script from an InputStream and write,     * the resulting output to the provided PrintStream.,     * SQL commands are separated by a semi-colon ';' character.,     *,     * @param conn Connection to be used as the script's default connection.,     * @param sqlIn InputStream for the script.,     * @param inputEncoding Encoding of the script.,     * @param sqlOut OutputStream for the script's output,     * @param outputEncoding Output encoding to use.,     * @param loadSystemProperties Whether to use the system properties.,     * @return Number of SQLExceptions thrown during the execution, -1 if not known.,     * @throws UnsupportedEncodingException,     */,     public static int runScript(, 		  Connection conn,, 		  InputStream sqlIn,, 		  String inputEncoding,, 		  OutputStream sqlOut,, 		  String outputEncoding,,           boolean loadSystemProperties), 		  throws UnsupportedEncodingException,     {,         LocalizedOutput lo =,           outputEncoding == null ?,                   LocalizedResource.getInstance().,                     getNewOutput(sqlOut),                  :,                   LocalizedResource.getInstance().,                     getNewEncodedOutput(sqlOut, outputEncoding);, ,         Main ijE = new Main(false);, ,         LocalizedInput li = LocalizedResource.getInstance().,                 getNewEncodedInput(sqlIn, inputEncoding);, ,         utilMain um = ijE.getutilMain(1, lo, loadSystemProperties);, ,         return um.goScript(conn, li);,     }, ,   private ij() { // no instances allowed,   },   ,   public static String getArg(String param, String[] args),   {, 	  return org.apache.derby.impl.tools.ij.util.getArg(param, args);,   }, ,   public static void getPropertyArg(String[] args) throws IOException,   {, 	  org.apache.derby.impl.tools.ij.util.getPropertyArg(args);,   }, ,   public static java.sql.Connection startJBMS(), 	  throws java.sql.SQLException, IllegalAccessException, ClassNotFoundException, InstantiationException,   {			, 		return org.apache.derby.impl.tools.ij.util.startJBMS();],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derby/tools/sysinfo.java,,53-220,[    Main.main(args);,   }, ,   private sysinfo() { // no instances allowed,   }, , 	/**, 		The genus name for the Apache Derby code. Use this to determine the version of the, 		Apache Derby embedded code in derby.jar., 	*/, 	public static final String DBMS="DBMS";, , 	/**, 	 *	The genus name for the tools code. Use this to determine the version of , 		code in derbytools.jar, 	 */, 	public static final String TOOLS="tools";, , 	/**, 	 *	The genus name for the network server code. Use this to determine the version of , 		code in derbynet.jar, 	 */, 	public static final String NET="net";, , 	/**, 	 *	The genus name for the client code. Use this to determine the version of , 		code in derbyclient.jar, 	 */, 	public static final String CLIENT="dnc";, , 	/**, 	 *	The genus name for the optional tools code. Use this to determine the version of , 		code in derbyoptionaltools.jar, 	 */, 	public static final String OPTIONALTOOLS="optionaltools";, , , 	/**, 		gets the major version of the Apache Derby embedded code., 		@return	the major version. Returns -1 if not found., 	 */,   static public int getMajorVersion(),   {,     return getMajorVersion(DBMS);,   }, , , 	/**, 		gets the major version of the specified code library. , 		@param genus	which library to get the version of. Valid inputs include, 			DBMS, TOOLS, NET, CLIENT, 		@return the major version. Return -1 if the information is not found. ,     */		,   static public int getMajorVersion(String genus),   {,         ProductVersionHolder pvh = ProductVersionHolder.getProductVersionHolderFromMyEnv(genus);,         if (pvh == null),         {,             return -1;,         }, ,         return pvh.getMajorVersion();,   }, , , 	/**, 		gets the minor version of the Apache Derby embedded code., 		@return	the minor version. Returns -1 if not found., 	 */,   static public int getMinorVersion(),   {,     return getMinorVersion(DBMS);,   }, , 	/**, 		gets the minor version of the specified code library. , 		@param genus	which library to get the version of. Valid inputs include, 			DBMS, TOOLS, NET, CLIENT., 		@return the minor version. Return -1 if the information is not found. ,     */	,   static public int getMinorVersion(String genus),   {,         ProductVersionHolder pvh = ProductVersionHolder.getProductVersionHolderFromMyEnv(genus);,         if (pvh == null),         {,             return -1;,         }, ,         return pvh.getMinorVersion();,   }, , 	/**, 		gets the build number for the Apache Derby embedded library, 		@return the build number, or -1 if the information is not found., 	*/,   static public String getBuildNumber(),   {,     return getBuildNumber("DBMS");,   }, , 	/**, 		gets the build number for the specified library, 		@param genus which library to get the build number for. Valid inputs are, 			DBMS, TOOLS, NET, CLIENT., 		@return the build number, or ???? if the information is not found., 	*/,   static public String getBuildNumber(String genus),   {,         ProductVersionHolder pvh = ProductVersionHolder.getProductVersionHolderFromMyEnv(genus);,         if (pvh == null),         {,             return "????";,         }, ,         return pvh.getBuildNumber();,   }, , , 	/**, 		gets the product name for the Apache Derby embedded library, 		@return the name, 	*/,   static public String getProductName(),   {,     return getProductName("DBMS");,   }, , 	/**, 		gets the external name for the specified code library., 		@param genus which library to get the name for, 		@return the name., 	*/, ,   static public String getProductName(String genus),   {,         ProductVersionHolder pvh = ProductVersionHolder.getProductVersionHolderFromMyEnv(genus);,         if (pvh == null),         {,             return Main.getTextMessage ("SIF01.K");,         }, ,         return pvh.getProductName();,   }, ,   /**, 	Return the version information string for the specified library including alpha or beta indicators.,   */,   static public String getVersionString() {, 	return getVersionString(DBMS);,   }, ,   /**, 	Return the version information string for the Apache Derby embedded library including alpha or beta indicators.,   */,   static public String getVersionString(String genus) {, ,         ProductVersionHolder pvh = ProductVersionHolder.getProductVersionHolderFromMyEnv(genus);,         if (pvh == null),         {,             return Main.getTextMessage ("SIF01.K");,         }, 		, 		return pvh.getVersionBuildString(false);,   }, ,   public static void getInfo (java.io.PrintWriter out) {,     Main.getMainInfo(out, false);,   }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derby/vti/ForeignTableVTI.java,next,273-273,[            wrapResultSet( _foreignPreparedStatement.executeQuery() );],,next,276-276,[        return getWrappedResultSet().next();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/vti/ForeignTableVTI.java,getForeignConnection,322-322,[            if ( conn != null ) { _connections.put( connectionURL, conn ); }],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/vti/ForeignTableVTI.java,next,272-272,[                ( getForeignConnection( _connectionURL, _foreignConnection ), makeQuery() );],,
SECURITY,SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING,org/apache/derby/vti/ForeignTableVTI.java,prepareStatement,386-386,[        return conn.prepareStatement( text );],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/derby/vti/StringColumnVTI.java,getLong,229-229,[                return Long.valueOf( columnValue ).longValue();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/derby/vti/StringColumnVTI.java,getBytes,277-277,[        if ( columnValue == null ) { return null; }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derby/vti/XmlVTI.java,findColumnValue,429-429,[            if ( (children != null) && (children.getLength() > 0) )],,
CORRECTNESS,DLS_DEAD_STORE_OF_CLASS_LITERAL,org/apache/derbyBuild/ClassSizeCrawler.java,main,86-86,[        Class classSizeClass = ClassSize.class; // Make sure that the garbage collector does not unload it],,
PERFORMANCE,DM_BOOLEAN_CTOR,org/apache/derbyBuild/ClassSizeCrawler.java,<init>,232-232,[        verbose = new Boolean( System.getProperty( "verbose", "false")).booleanValue();],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/ClassSizeCrawler.java,main,177-177,[            PrintWriter out = new PrintWriter( new FileWriter( outputFileName));],,
BAD_PRACTICE,DM_EXIT,org/apache/derbyBuild/ClassSizeCrawler.java,crawl,245-245,[                System.exit(1);],,crawl,251-251,[            System.exit(1);],,crawl,282-282,[                    System.exit(1);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/derbyBuild/ClassSizeCrawler.java,crawl,258-258,[        for( int fileIdx = 0; fileIdx < filenames.length; fileIdx++)],,crawl,253-253,[        String[] filenames = curDir.list( );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derbyBuild/GeneratorBase.java,<init>,115-115,[        int maint = Integer.parseInt(r.getProperty("maint"));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/derbyBuild/GeneratorBase.java,setReleaseId,165-166,[        this.releaseID = releaseID;,     }],,setReleaseID,124-124,[    public void setReleaseID( String releaseID ) { _releaseID = releaseID; }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derbyBuild/GeneratorBase.java,<init>,114-114,[        r.load(new FileInputStream("../ant/properties/release.properties"));],,<init>,115-115,[        int maint = Integer.parseInt(r.getProperty("maint"));],,<init>,116-116,[        branch = r.getProperty("eversion");],,<init>,117-117,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derbyBuild/GeneratorBase.java,<init>,114-114,[        r.load(new FileInputStream("../ant/properties/release.properties"));],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derbyBuild/GeneratorBase.java,,157-157,[        this.outputFileName = outputFileName;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derbyBuild/GeneratorBase.java,,137-137,[                summary.getTextListByTagName(SUM_EXCLUDE_RELEASE_ID);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/derbyBuild/GeneratorBase.java,,131-131,[        this.summaryFileName = summaryFileName;],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/JiraConnector.java,getXMLStreamAndFile,102-102,[			FileWriter fw=new FileWriter(file);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/JiraConnector.java,getXMLStreamAndFile,99-99,[				new BufferedReader( new InputStreamReader(getXMLStream(XMLurl)));],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/derbyBuild/JiraConnector.java,,59-59,[	public static String jira_allBugsSource= "https://issues.apache.org/jira/secure/IssueNavigator.jspa?view=rss&pid=10594&sorter/field=issuekey&sorter/order=DESC&tempMax=6000&reset=true&decorator=none";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/derbyBuild/JiraConnector.java,,53-53,[	public static String jira_fixedBugsSource =],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/derbyBuild/JiraConnector.java,,47-47,[	public static String jira_releaseNotesSource =],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derbyBuild/JiraConnector.java,getXMLStreamAndFile,102-102,[			FileWriter fw=new FileWriter(file);],,getXMLStreamAndFile,103-103,[			while ((inputLine = in.readLine()) != null)],,getXMLStreamAndFile,110-110,[		}catch(IOException e){],,getXMLStreamAndFile,112-112,[			throw e;],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derbyBuild/JiraConnector.java,getXMLStreamAndFile,98-98,[			BufferedReader in = ],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derbyBuild/JiraConnector.java,getXMLStreamAndFile,102-102,[			FileWriter fw=new FileWriter(file);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/JiraIssue.java,createJiraIssueList,75-75,[        BufferedReader in = new BufferedReader(new FileReader(source));],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/derbyBuild/JiraIssue.java,createJiraIssueList,89-89,[            if (line.startsWith("//")) {],,createJiraIssueList,78-78,[        while ((line = in.readLine()) != null && line.startsWith("//")) {],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derbyBuild/JiraIssue.java,createJiraIssueList,75-75,[        BufferedReader in = new BufferedReader(new FileReader(source));],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/MessageBuilder.java,execute,374-374,[            propertiesFW = new FileWriter( targetProperties );],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derbyBuild/MessageBuilder.java,echo,708-709,[        log( text, Project.MSG_WARN );,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/MessageBuilder.java,<init>,163-163,[            _fw = new FileWriter( file );],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derbyBuild/MessageBundleTest.java,testMessageBundleOrphanedMessages,228-228,[            failbuild=true;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derbyBuild/MessageBundleTest.java,testMessageIdOrphanedIds,200-200,[                failbuild=true;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/derbyBuild/MessageBundleTest.java,testSQLStateOrphanedIds,178-178,[                    failbuild=true;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/derbyBuild/MessageVetter.java,main,60-60,[            for (File file : new File(directory).listFiles(filter)) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/ODBCMetadataGenerator.java,<init>,155-155,[		odbcMetaFile = new FileWriter("odbc_metadata.properties");],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derbyBuild/ODBCMetadataGenerator.java,initChanges,197-197,[		changeMap.put("getProcedures",],,initChanges,200-200,[		changeMap.put("getProcedureColumns",],,initChanges,205-205,[		changeMap.put("getColumns",],,initChanges,208-208,[		changeMap.put("getVersionColumns",],,initChanges,211-211,[		changeMap.put("getBestRowIdentifierPrimaryKeyColumns",],,initChanges,214-214,[		changeMap.put("getBestRowIdentifierUniqueKeyColumns",],,initChanges,217-217,[		changeMap.put("getBestRowIdentifierUniqueIndexColumns",],,initChanges,220-220,[		changeMap.put("getBestRowIdentifierAllColumns",],,initChanges,223-223,[		changeMap.put("getTypeInfo",],,initChanges,228-228,[		changeMap.put("getIndexInfo",],,initChanges,231-231,[		changeMap.put("getCrossReference",],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derbyBuild/ODBCMetadataGenerator.java,<init>,151-151,[		odbcFragments.load(this.getClass().getResourceAsStream(],,<init>,155-155,[		odbcMetaFile = new FileWriter("odbc_metadata.properties");],,<init>,157-157,[	}],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derbyBuild/ODBCMetadataGenerator.java,<init>,151-151,[		odbcFragments.load(this.getClass().getResourceAsStream(],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,81-81,[	private final byte ADD_COLUMN_CHANGE = 0x04;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,79-79,[	private final byte COL_RENAME_CHANGE = 0x01;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,112-112,[	private final short FOLLOWING = 1;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,109-109,[	private final String NEW_COL_PLACEHOLDER = "COLUMN_POSITION_HOLDER";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,85-85,[	private final String ODBC_QUERY_NOTICE =],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,100-100,[	private final String ODBC_QUERY_PREFIX = "odbc_";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,113-113,[	private final short PRECEDING = -1;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,106-106,[	private final String SUBQUERY_NAME = "JDBC_SUBQUERY";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,80-80,[	private final byte TYPE_VALUE_CHANGE = 0x02;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/derbyBuild/ODBCMetadataGenerator.java,,82-82,[	private final byte WHERE_CLAUSE_CHANGE = 0x08;],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/derbyBuild/ODBCMetadataGenerator.java,<init>,151-151,[		odbcFragments.load(this.getClass().getResourceAsStream(],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derbyBuild/ReleaseNoteReader.java,main,102-102,[        Element                         details = me.getReleaseNoteDetails( doc );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derbyBuild/ReleaseNoteReader.java,main,101-101,[        Element                           summary = me.getReleaseNoteSummary( doc );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derbyBuild/ReleaseNoteReader.java,forbid,185-185,[        if ( (tags != null) && (tags.getLength() > 0) )],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derbyBuild/ReleaseNotesGenerator.java,parseBugsList,294-294,[        BufferedReader in = new BufferedReader(new InputStreamReader(],,
I18N,DM_CONVERT_CASE,org/apache/derbyBuild/ReleaseNotesTransformer.java,fullReplaceToken,422-422,[        rawString = replaceToken( rawString, token.toLowerCase(), replacement );],,fullReplaceToken,423-423,[        rawString = replaceToken( rawString, token.toUpperCase(), replacement );],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/ReleaseNotesTransformer.java,normalizeText,415-415,[        FileWriter fileWriter = new FileWriter( outputFile );],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/ReleaseNotesTransformer.java,readFileIntoString,518-518,[        FileReader fileReader = new FileReader( inputFile );],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derbyBuild/ReleaseNotesTransformer.java,readFileIntoString,518-518,[        FileReader fileReader = new FileReader( inputFile );],,readFileIntoString,519-519,[        StringWriter stringWriter = new StringWriter();],,readFileIntoString,523-523,[            int nextChar = fileReader.read();],,readFileIntoString,524-524,[            if ( nextChar < 0 ) { break; }],,readFileIntoString,529-529,[        String rawString = stringWriter.toString();],,readFileIntoString,531-531,[        return rawString;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derbyBuild/ReleaseNotesTransformer.java,normalizeText,415-415,[        FileWriter fileWriter = new FileWriter( outputFile );],,normalizeText,416-416,[        fileWriter.append( rawString );],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derbyBuild/ReleaseNotesTransformer.java,transform,243-243,[        InputStream normalizedText = new FileInputStream( _outputFile );],,transform,244-244,[        _inputDoc = _docBldr.parse( normalizedText );],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derbyBuild/ReleaseNotesTransformer.java,readFileIntoString,518-518,[        FileReader fileReader = new FileReader( inputFile );],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derbyBuild/ReleaseNotesTransformer.java,normalizeText,415-415,[        FileWriter fileWriter = new FileWriter( outputFile );],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derbyBuild/ReleaseNotesTransformer.java,transform,243-243,[        InputStream normalizedText = new FileInputStream( _outputFile );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derbyBuild/ReleaseNotesTransformer.java,findHeader,366-366,[        if ( headers == null ) { return null; }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derbyBuild/ReleaseNotesTransformer.java,getFirstDescendant,392-392,[        if ( nl == null ) { return null; }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derbyBuild/ReleaseNotesTransformer.java,removeIssuesTOC,322-322,[            if ( allLists == null ) { return; }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derbyBuild/classlister.java,showAllItemsOneLevel,709-709,[			Hashtable h2 = new Hashtable();],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/classlister.java,run,145-145,[                (new FileWriter(outFile.getPath()), 10000), true );],,
BAD_PRACTICE,DM_EXIT,org/apache/derbyBuild/classlister.java,findDependencies,575-575,[					System.exit(1);],,findDependencies,636-636,[				System.exit(1);],,
BAD_PRACTICE,DM_EXIT,org/apache/derbyBuild/classlister.java,loadClasspath,278-278,[                System.exit(1);],,
BAD_PRACTICE,DM_EXIT,org/apache/derbyBuild/classlister.java,run,150-150,[            System.exit(1);],,run,186-186,[				System.exit(1);],,run,192-192,[            System.exit(1);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/derbyBuild/classlister.java,unrollHashtable,756-756,[	scoreboard.put(key, new Integer(indentLevel));],,unrollHashtable,758-758,[			scoreboard.put(key, new Integer(indentLevel));],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/derbyBuild/classlister.java,,100-100,[	protected static final String[] propFiles = {],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derbyBuild/classlister.java,,71-761,[	protected boolean cloudscapeOnly = false;, 	protected boolean portingOnly = false;, 	protected boolean ignoreWebLogic = false;, 	protected boolean verbose = false;, 	protected boolean skipJava = true;, 	protected boolean skipJavax = true;, 	protected boolean skipOrg = true;, 	protected boolean skipInformix = true;, 	protected boolean skipDB2 = true;, 	protected boolean skipDB2e = true;,         protected boolean skipSun = true;, 	protected boolean showAll = false;, 	protected boolean keepRolling = false;, 	protected boolean showOne = false;, 	protected Hashtable<String, Hashtable<String, String>> masterClassList =,             new Hashtable<String, Hashtable<String, String>>();,     protected String classpath[] = null;,     protected String outputfile;,     protected Hashtable<String, Object> classpathHash;, 	protected int indent = 0;, 	protected int errorCount = 0;, 	protected PrintWriter pwOut;, 	protected PrintStream psOut;, , 	protected boolean db2jtools;, 	protected boolean db2jdrda;, , 	protected boolean keepDependencyHistory;, , 	protected static final String[] propFiles = {, 		"messages.properties",, 		"instructions.properties",,                 "metadata.properties", 	};, , 	public static void main(String args[]) throws IOException {, , 		classlister me = new classlister();, , 		me.sets = args;, , 		me.run();, 		if (me.errorCount > 0), 		{, 			System.out.println(me.errorCount + " errors encountered.");, 			System.exit(1);, 		}, 	}, , 	public classlister() {, 		cloudscapeOnly = Boolean.getBoolean("cloudscapeOnly");, 		portingOnly = Boolean.getBoolean("portingOnly");,         ignoreWebLogic = Boolean.getBoolean("ignoreWebLogic");,         verbose = Boolean.getBoolean("verbose");,         skipJava = ! Boolean.getBoolean("doJava");,         skipJavax = ! Boolean.getBoolean("doJavax");,         skipOrg = ! Boolean.getBoolean("doOrg");,         showAll = Boolean.getBoolean("showAll");,         showOne = Boolean.getBoolean("showOne");,         keepRolling = Boolean.getBoolean("keepRolling");,         outputfile = System.getProperty("outputfile");, 		db2jtools = Boolean.getBoolean("db2jtools");, 		db2jdrda = Boolean.getBoolean("db2jdrda");, , 		keepDependencyHistory = showOne || showAll;, 	}, , 	public void run() , 	{, 		//System.out.println("outputfile: " + outputfile);, 		try, 		{, 		    File outFile = new File(outputfile);, 		    pwOut = new PrintWriter( new BufferedWriter,                 (new FileWriter(outFile.getPath()), 10000), true );,         },         catch (IOException ioe),         {,             System.out.println(ioe);,             System.exit(1);,         }, 	    , 		loadClasspath();, 		//cuf = new ModifyClasses();, , 		foundClasses = new Hashtable<String, String>(3000, 0.8f);, 		, 		for (int i = 0; i < sets.length; i++) , 		{, , 			// If a set name ends in '.class' then take it as a class, 			// name of the form com.acme.foo.MyClass.class., 			try , 			{, , 				String s = sets[i];, , 				if (s.endsWith(".class")) {, , 					findDependencies(s.substring(0, s.length() - 6));, 				} else {, , 					FileInputStream fis = new FileInputStream(s);, , 					Properties pset = new Properties();, , 					pset.load(fis);, , 					findClasses(pset);, 				}, , 			} , 			catch (IOException ioe) , 			{, 				System.err.println(ioe.toString());, 				System.exit(1);, 			}, 		},         if (pwOut == null),         {,             System.out.println("Need to specify an outputfile");,             System.exit(1);,         }, 		for (Enumeration e = foundClasses.keys(); e.hasMoreElements(); ) {, 			String name = (String) e.nextElement();, 			String type = (String) foundClasses.get(name);, 			if (type.equals("class")) {,                 if (ignoreWebLogic) {,                     if (name.startsWith("weblogic")) {,                         continue;,                     },                 }, , , 				if (isCloudscapeCode(name)) {, , 					if (name.startsWith("com.ibm.db2j.porting.")) {, 						if (cloudscapeOnly), 							continue;, 					} else {, 						if (portingOnly), 							continue;, 					}, , 				} else {, 					if (cloudscapeOnly || portingOnly), 						continue;, 				}, 				pwOut.println(name.replace('.', '/') + ".class");, 			}, 			else {, 				// is a file name, 				if (name.startsWith("com/ibm/db2j/")) {, 					if (portingOnly) {, 						continue;, 					}, 				} else {, 					if (cloudscapeOnly || portingOnly), 						continue;, 				}, , 				pwOut.println(name);, 			}, 		}, 		if (showAll), 		{, 			showAllItems();, 		}, 		if (showOne), 		{, 			showAllItemsOneLevel();, 		}, 	}, , , 	protected void findClasses(Properties pset) throws IOException {, , 		for (Enumeration e = pset.propertyNames(); e.hasMoreElements(); ) {, 			String key = (String) e.nextElement();, 			if (key.startsWith("derby.module.")) {, 				if (verbose) {, 					pwOut.println(pset.getProperty(key) + " needs ");, 				}, 				findDependencies(pset.getProperty(key));, 			}, 		}, 	}, ,     protected void loadClasspath(),     {,         classpathHash = new Hashtable<String, Object>();,             try,             {,                 String classpathString = System.getProperty("java.class.path");, 				if (verbose), 					pwOut.println("classpath: " + classpathString);,                 StringTokenizer st = new StringTokenizer(classpathString, File.pathSeparator);,                 int entries = st.countTokens();,                 classpath = new String[entries];,                 for (int i = 0; i < entries; i++),                 {,                     classpath[i] = st.nextToken();,                 },             },             catch (SecurityException se),             {,                 pwOut.println("**error** SecurityException getting classpath");,                 System.exit(1);,             },         for (int i = 0; i < classpath.length; i++),         {,             String pathEntry = classpath[i];,             if (pathEntry.toUpperCase(java.util.Locale.ENGLISH).endsWith(".ZIP") ||,                 pathEntry.toUpperCase(java.util.Locale.ENGLISH).endsWith(".JAR") ),             {,                 ZipFile zipfile = null;,                 try,                 {,                     zipfile = new ZipFile(pathEntry.replace('/', File.separatorChar));,                 },                 catch (IOException ioe),                 {,                     // can't do anything about it; zipfile doesn't exists,                     // it can happen if the person sticks a directory called,                     // foo.zip in the classpath or foo.zip doesn't exist as,                     // a file,                 },                 if (zipfile != null),                 {, ,                     classpathHash.put(pathEntry, zipfile);,                 },                 else,                 {, 					if (verbose), 					{, 	                    pwOut.println("Ignoring <zip> entry: " + pathEntry);, 					}, 	,                 },             },             else,             {,                 File file = new File(pathEntry);, ,                 if (file.exists() && file.isDirectory()),                 {,                     classpathHash.put(pathEntry, file);,                 },                 else,                 {,                    	if (verbose), 					{ ,                     	pwOut.println("Ignoring <dir> entry: " + pathEntry);, 					},                 },             },         },     }, , ,     protected InputStream locateClass(String className, boolean beVerbose),     {,         if (className.startsWith("/")),         {,             className = className.substring(1);,         },         if (beVerbose),         {,             pwOut.println("Looking for " + className);,         }, ,         if (classpath == null),         {,             loadClasspath();,         }, ,         for (int i = 0; i < classpath.length; i++),         {,             String pathEntry = classpath[i];,             Object hash = classpathHash.get(pathEntry);,             if (hash != null),             {,                 if (hash instanceof ZipFile),                 try,                 {,                     ZipFile zipfile = (ZipFile) hash;, ,                     ZipEntry entry = zipfile.getEntry(className);, ,                     if (entry != null),                     {,                         InputStream is = zipfile.getInputStream(entry);,                         DataInputStream dis= new DataInputStream(new BufferedInputStream(is));,                         return dis;,                     },                 },                 catch (IOException ioe),                 {,                     if (beVerbose),                     {,                         pwOut.println("IOException loading ZipFile or creating InputStream " +,                             " from it");,                         pwOut.println(ioe);,                     },                 },                 else if (hash instanceof File),                 {,                     File file = new File((File)hash, className.replace('/', File.separatorChar));,                     if (beVerbose),                     {,                         pwOut.println("looking to load file: " + file.getName());,                     },                     if (file.exists()),                     {,                         if (beVerbose),                         {,                             pwOut.println(" found it!");,                         },                         try,                         {,                             FileInputStream fis = new FileInputStream(file);,                             return new BufferedInputStream(fis, 8192);,                         },                         catch (IOException ioe),                         {,                             if (beVerbose),                             {,                                 pwOut.println("IOException creating FileInputStream");,                                 pwOut.println(ioe);,                                 return null;,                             },                         },                     },                 },             },             //,         }, ,         // could not find it,         if (beVerbose),         {,             pwOut.println("returing null on purpose");,         },         return null;,     }, , 	protected void findDependencies(String className) throws IOException {, 		indent++;, 		try {, 		if (className.startsWith("java.") && skipJava), 		{, 			pwOut.println("Skipping JAVA " + className);, 			return;, 		}, 		if (className.startsWith("javax.") && skipJavax), 		{, 			//System.out.println("Skipping JAVAX " + className);, 		    return;, 		},                 if (className.startsWith("sun.") && skipSun),                 {,                         //System.out.println("Skipping Sun " + className);,                     return;,                 }, 		if (className.startsWith("org.") && skipOrg), 		{, 		    // Allow opensource org.apache.derby classes,                     if (!className.startsWith("org.apache.derby")) , 		    {, 			//System.out.println("Skipping org " + className);, 			return;, 		    }, 		}, 		if (className.startsWith("com.informix.") && skipInformix), 		{, 			//System.out.println("Skipping Informix " + className);, 		    return;, 		}, 		if (className.startsWith("com.ibm.mobileservices.") && skipDB2e), 		{, 			//System.out.println("Skipping DB2e " + className);, 		    return;, 		}, 		if (className.startsWith("common.") && skipDB2), 		{, 			//System.out.println("Skipping DB2 common " + className);, 		    return;, 		}, ,         if (!SanityManager.DEBUG &&,             className.matches("^org\\.apache\\.derby\\..*\\.sanity\\..*")),         {,             // Don't include sanity classes in insane builds.,             return;,         }, ,         if (ignoreWebLogic),         {,             if (className.startsWith("weblogic.")), 			{,                 return;, 			},         }, , 		if (db2jtools || db2jdrda) {, , 			// for tools skip classes that are part of the db2j product api, 			// they should be pulled in from cs.jar or any client.jar, 			if (, 				   className.startsWith("org.apache.derby.authentication."), 				|| className.startsWith("org.apache.derby.catalog."), 				|| className.startsWith("org.apache.derby.iapi.db."), 				|| className.startsWith("org.apache.derby.diag."), 				|| className.startsWith("org.apache.derby.jdbc."), 				|| className.startsWith("org.apache.derby.vti."), 				|| className.startsWith("org.apache.derby.iapi.sql.dictionary."), 				|| className.startsWith("org.apache.derby.iapi.util."), 				), 			{, 				return;, 			}, 		}, , 		// drda explicitly brings in some database engine classes., 		// they must be picked up from derby.jar and not put in, 		// the network server jar., 		if (db2jdrda) {, , 			if (, 				   className.startsWith("org.apache.derby.impl.sql"), 				|| className.startsWith("org.apache.derby.impl.jdbc"), 				|| className.startsWith("org.apache.derby.impl.services"), 				|| className.startsWith("org.apache.derby.iapi."), 				|| className.startsWith("org.apache.derby.security."),                 || (className.startsWith("org.apache.derby.mbeans.") &&,                     !className.startsWith("org.apache.derby.mbeans.drda.")), 				), 			{, 				return;, 			}, 		}, , 		// already seen class, 		if (foundClasses.get(className) != null), 			return;, , 		if (verbose) {, 			for (int i =0; i < indent; i++), 			{, 				System.out.print(".");, 			}, 			System.out.println(className);, 		}, , 		/*, 			org.apache.derby.iapi.reference.ClassName &, 			RegisteredFormatIds has a list of all registered classes, If we pull this in then, 			we will pull in the complete set of classes. So we add this to our list but don't, 			dependency check it., 		*/, 		boolean dontCheckDependencies = false;, 		/*, 		if (className.equals("org.apache.derby.iapi.reference.ClassName") ||, 			className.equals("org.apache.derby.iapi.services.io.RegisteredFormatIds")) {, 			dontCheckDependencies = true;, 		}, 		*/, , , ,         try,         {, 			Hashtable<String, String> localHashtable = null;, 			, 			if (keepDependencyHistory) {, 				localHashtable = masterClassList.get(className);, 				if (localHashtable == null), 				{, 					localHashtable = new Hashtable<String, String>();, 					masterClassList.put(className, localHashtable);, 				}, 			}, , 		    foundClasses.put(className, "class");, , 			if (dontCheckDependencies), 				return;, , 			String fileName = "/" + className.replace('.', '/') + ".class";, , 			InputStream is = locateClass(fileName, false);, , 			if (is == null) {, ,                 //,                 // Until there is a Java 8 whose stubs can be used to build Derby, we will allow,                 // the build to complete without the JDBC 4.2 support.,                 //,                 if ( className.endsWith( "Driver42" ) ) { return; },                 , 				pwOut.println("**error** Got NULL when looking for fileName = " + fileName);, 				if (!keepRolling), 				{, 					System.exit(1);, 				}, 				else, 				{, 					errorCount++;, 				}, 			}, 			//byte[] classData = new byte[is.available()];, 			//is.read(classData);, , 			ClassInvestigator ch = ClassInvestigator.load(is);, 			is.close();, , 		    for (Enumeration e = ch/*.getClassInfo()*/.referencedClasses(); e.hasMoreElements(); ) {, 			    String x = (String) e.nextElement();, 				// skip microsoft classes, 				if (x.startsWith("com.ms.")), 				{, 					continue;, 				}, , 				if (!SanityManager.DEBUG) {, 					if (x.indexOf("SanityManager") != -1) {, , 						boolean printSanityWarning = true;, , 						int ld = className.lastIndexOf(".");, 						if (ld != -1) {, 							if (className.lastIndexOf("T_") == ld + 1), 								printSanityWarning = false;, 							else if (className.lastIndexOf("T_") == ld + 1), 								printSanityWarning = false;, 							else if (className.lastIndexOf("D_") == ld + 1), 								printSanityWarning = false;, 							else if (className.lastIndexOf("TEST_") == ld + 1), 								printSanityWarning = false;, 							else if (className.endsWith("SanityManager")), 								printSanityWarning = false;, 						}, , 						if (printSanityWarning), 							System.out.println("SANITY >>> " + fileName);, 					}, 				}, , 				if (keepDependencyHistory && (localHashtable.get(x) == null)), 				{, 						, 					localHashtable.put(x, "class");, 				}, 			    findDependencies(x);,             }, 		} ,         catch (NullPointerException npe), 		{, 			pwOut.println("**error** Got NullPointerException in findDependencies when looking up ");, 			pwOut.println(className);, 			, 			npe.printStackTrace();, 			if (!keepRolling), 			{, 				System.exit(1);, 			}, 			errorCount++;, 		}, , 		// look for properties only with cloudscape code ..., 		if (!isCloudscapeCode(className)), 			return;, ,                 // The following block of code checks the package of each class,                 // scanned to see if there is a corresponding properties file,                 // from propFiles and adds it to the list of found classes.,                 // derbytools.jar should not contain any of these files, so skip,                 // for that jar. See also DERBY-1537.,                 if (!db2jtools),                 {, 		    String packageName = className.substring(0, className.lastIndexOf('.') + 1);, , 		    for (int i = 0; i < propFiles.length; i++) {, 			String fileName = "/" + packageName.replace('.', '/') + propFiles[i];, 			if (foundClasses.get(fileName) != null), 				continue;, , 			InputStream is = getClass().getResourceAsStream(fileName);, 			if (is == null), 				continue;, 			is.close();, , , 			foundClasses.put(fileName.substring(1), "file");, 		    },                 },         } finally {, 		indent--;, 	}, 	}, 	protected boolean isCloudscapeCode(String name) {, 		return name.startsWith("com.ibm.db2j.") ||, 		       name.startsWith("com.ihost.cs.") ||, 		       name.startsWith("db2j.") ||, 		       name.startsWith("org.apache.derby");, 	}, , , 	protected void showAllItems(), 	{, 		Enumeration e = masterClassList.keys();, 		pwOut.println("------------Printing all dependents--------------");, 		while (e.hasMoreElements()), 		{, 			String kid = (String) e.nextElement();, 			pwOut.println(kid );, 			Hashtable<String, Integer> scoreboard =,                     new Hashtable<String, Integer>();, 			Hashtable<String, String> grandkids = masterClassList.get(kid);, 			unrollHashtable("", grandkids, scoreboard, 1);, 		}, 	}, , , 	protected void showAllItemsOneLevel(), 	{, 		pwOut.println("Showing all dependencies");, 		pwOut.println("One level only");, 		pwOut.println("-----------------------------------");, 		, 		Enumeration e = masterClassList.keys();, 		while (e.hasMoreElements()), 		{, 			String key = (String) e.nextElement();, 			pwOut.println(key);, 			Hashtable h = (Hashtable) masterClassList.get(key);, 			Enumeration e2 = h.keys();, 			Hashtable h2 = new Hashtable();, 			while (e2.hasMoreElements()), 			{, 				String key2 = (String) e2.nextElement();, 				pwOut.println("\t" + key2);, 			}, 		}, 	}, , , 	protected void unrollHashtable(,             String parent,,             Hashtable<String, String> current,,             Hashtable<String, Integer> scoreboard,,             int indentLevel), 	{, 		String indentString = "  ";, 		Enumeration<String> e = current.keys();, 		String key = null;,  , 		while (e.hasMoreElements()), 		{, 			key = e.nextElement();, 			if (key.equals(parent)), 			{, 				continue;, 			}, 			pwOut.print(indentLevel + ":");, , 			Integer value = scoreboard.get(key);, 			if (value != null ), 			{, 				for (int i = 0; i < indentLevel; i++), 				{, 					pwOut.print(indentString);, 				}, 				pwOut.println(key + "*****REPEATED class back at level " + value + "****");, 				return;, 			}, 			for (int i = 0; i < indentLevel; i++), 			{, 				pwOut.print(indentString);, 			}, 			pwOut.println(key);, , 			Hashtable<String, String> currentsChildren =,                     masterClassList.get(key);, 	scoreboard.put(key, new Integer(indentLevel));, 			unrollHashtable(key, currentsChildren, scoreboard, (indentLevel+1));, 			scoreboard.put(key, new Integer(indentLevel));, 			, 		}, 	}],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derbyBuild/classlister.java,run,173-173,[					FileInputStream fis = new FileInputStream(s);],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/derbyBuild/classlister.java,findDependencies,659-659,[			InputStream is = getClass().getResourceAsStream(fileName);],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyBuild/eclipse/DerbyEclipsePlugin.java,createTmpFiles,180-180,[		FileWriter fw=new FileWriter(file);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derbyBuild/eclipse/DerbyEclipsePlugin.java,getProps,143-143,[		InputStream versionStream = getClass().getResourceAsStream(ProductGenusNames.DBMS_INFO);],,getProps,144-144,[		Properties prop=new Properties();],,getProps,145-145,[		prop.load(versionStream);],,getProps,148-148,[		tmpProp.put(PLUGIN_PKG,PLUGIN_PKG_NAME);			//package name],,getProps,149-149,[		tmpProp.put(PLUGIN_ZIP_FILE,PLUGIN_ZIP_FILE_NAME);	//zip file name],,getProps,150-150,[		tmpProp.put(PropertyNames.PRODUCT_VENDOR_NAME,prop.getProperty(PropertyNames.PRODUCT_VENDOR_NAME));],,getProps,151-151,[		int maint=Integer.parseInt(prop.getProperty(PropertyNames.PRODUCT_MAINT_VERSION));],,getProps,152-152,[		version=prop.getProperty(PropertyNames.PRODUCT_MAJOR_VERSION)+"."+prop.getProperty(PropertyNames.PRODUCT_MINOR_VERSION)+"."+maint/MAINT_DIV;],,getProps,153-153,[		tmpProp.put(PLUGIN_VERSION,version);],,getProps,160-160,[		version+="."+maint%MAINT_DIV;],,getProps,161-161,[		tmpProp.put(PLUGIN_VERSION_BUILD_NUMBER,version+" ("+prop.getProperty(PropertyNames.PRODUCT_BUILD_NUMBER)+")");],,getProps,164-164,[		part_1+=version+"\"";],,getProps,165-165,[		part_2+=tmpProp.getProperty(PropertyNames.PRODUCT_VENDOR_NAME)+"\">\n";],,getProps,167-167,[	}],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derbyBuild/eclipse/DerbyEclipsePlugin.java,createTmpFiles,176-176,[		FileOutputStream fo=new FileOutputStream(file);],,createTmpFiles,177-177,[		tmpProp.store(fo,null);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/derbyBuild/eclipse/DerbyEclipsePlugin.java,createTmpFiles,180-180,[		FileWriter fw=new FileWriter(file);],,createTmpFiles,181-181,[		fw.write(part_1+part_2+part_3);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derbyBuild/eclipse/DerbyEclipsePlugin.java,getProps,143-143,[		InputStream versionStream = getClass().getResourceAsStream(ProductGenusNames.DBMS_INFO);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derbyBuild/eclipse/DerbyEclipsePlugin.java,createTmpFiles,176-176,[		FileOutputStream fo=new FileOutputStream(file);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/derbyBuild/eclipse/DerbyEclipsePlugin.java,createTmpFiles,180-180,[		FileWriter fw=new FileWriter(file);],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/derbyBuild/eclipse/DerbyEclipsePlugin.java,getProps,143-143,[		InputStream versionStream = getClass().getResourceAsStream(ProductGenusNames.DBMS_INFO);],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derbyBuild/javadoc/DiskLayoutTaglet.java,toString,132-132,[            result += tags[i].text() + "</td></tr>";],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derbyBuild/javadoc/EndFormatTaglet.java,toString,129-129,[            result += "";],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/derbyBuild/javadoc/EndFormatTaglet.java,,29-29,[    private String ROWNAME = "end_format";],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derbyBuild/javadoc/FormatIdTaglet.java,toString,133-133,[            result += tags[i].text() + "</td></tr>";],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derbyBuild/javadoc/PurposeTaglet.java,toString,132-132,[            result += tags[i].text() + "</td></tr>";],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/derbyBuild/javadoc/UpgradeTaglet.java,toString,132-132,[            result += tags[i].text() + "</td></tr>";],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derbyBuild/maintversion2props.java,,39-59,[public class maintversion2props, {,     public static void main(String[] args) throws Exception,     {,         InputStream is = new FileInputStream(args[0]);,         Properties p = new Properties();,         p.load(is);, 	String maint = "";,         if (args[0].indexOf("DBMS") > 0),         {,           maint = p.getProperty("derby.version.maint");,         } else if (args[0].indexOf("release") > 0),         { ,           maint = p.getProperty("maint");,         },         Properties p2 = new Properties();,         p2.setProperty("interim", Integer.toString(Integer.parseInt(maint) / 1000000));,         p2.setProperty("point", Integer.toString(Integer.parseInt(maint) % 1000000));,         OutputStream os = new FileOutputStream(args[1]);,         p2.store(os, ""); ,     }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derbyBuild/maintversion2props.java,main,57-57,[        OutputStream os = new FileOutputStream(args[1]);],,main,58-58,[        p2.store(os, ""); ],,main,59-59,[    }],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/derbyBuild/maintversion2props.java,main,47-47,[        if (args[0].indexOf("DBMS") > 0)],,main,50-50,[        } else if (args[0].indexOf("release") > 0)],,
BAD_PRACTICE,DM_EXIT,org/apache/derbyBuild/propertyconfig.java,process,148-148,[							System.exit(3);],,process,158-158,[							System.exit(4);],,process,173-173,[					System.exit(2);],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derbyBuild/propertyconfig.java,,61-346,[public class propertyconfig {, , 	public static final String header =, 		"######## This is a generated file, do not edit.\n" +, 		"#\n# This file is generated as by propertyConfig\n" +, 		"#\n";, , 	public static final String footer =, 		"\n######## This is a generated file, do not edit.\n";, , 	public static void main(String[] args) throws IOException, 	{, 		if (args.length != 3), 			printUsageAndExit();, , 		File masterfile = new File(args[0]);, 		File outputfile = new File(args[2]);, , 		if (!masterfile.exists()), 			printUsageAndExit();, , 		// OK, got the input cleared up, now do the processing, 		Properties masterProp = new Properties();, 		FileInputStream is = new FileInputStream(masterfile);, , 		try, 		{, 			masterProp.load(is);, 		}, 		finally, 		{, 			if (is != null), 				is.close();, 		}, , 		process(masterProp, args[1], outputfile);, 	}, , 	/**, 	 * For each module with a particular tag in derby.module.<tag>, see if, 	 * there is any configuration restriction.  If there is no, 	 * cloudscape.config.<tag> property, then this module should be present in, 	 * all configurations.  If there is a cloudscape.config.<tag>, then this, 	 * module should only be present in the configurations listed., 	 *, 	 * <br>If this module should be present or this configuration, then gather, 	 * up all the properties belong to this module and send it to the output, 	 * file., 	 *, 	 */, 	private static void process(Properties moduleList, String config, , 								File outputfile), 					throws IOException, 	{, 		Properties outputProp = new Properties();, , 		// copy this code from, 		// org.apache.derby.impl.services.monitor.BaseMonitor , 		//, 		for (Enumeration e = moduleList.propertyNames(); e.hasMoreElements(); ) , 		{, 			String key = (String) e.nextElement();, 			if (key.startsWith("derby.module.")), 			{, 				String tag = key.substring("derby.module.".length());, , 				// Check to see if it has any configuration requirements , 				String configKey = "cloudscape.config.".concat(tag);, 				String configProp = moduleList.getProperty(configKey);, 				, 				boolean match = false;, , 				if (configProp != null) , 				{, 					StringTokenizer st = new StringTokenizer(configProp, ",");, 					while(st.hasMoreTokens()) , 					{, , 						String s = st.nextToken().trim();, , 						// if config spec says all, it should not have other, 						// configurations, 						if (s.equalsIgnoreCase("all") &&, 							!configProp.trim().equals("all")), 						{, 							System.out.println("illegal config specification ", 											   + key);, 							System.exit(3);, 						}, , 						// if config spec says none, it should not have other, 						// configurations, 						if (s.equalsIgnoreCase("none") &&, 							!configProp.trim().equals("none")), 						{, 							System.out.println("illegal config specification ", 											   + key);, 							System.exit(4);, 						}, , 						if (s.equalsIgnoreCase(config) ||, 							s.equalsIgnoreCase("all")), 						{, 							match = true;, 							break;, 						}, 					}, 				}, 				else, 				{, 					// no config property, this module goes to all configs, 					System.out.println("Need config specification for " + key);, 					System.exit(2);, 				}, , 				if (match), 				{, 					// gather up all relavant properties and put it in, 					// outputProp, , 					// derby.module.<tag>, 					outputProp.put(key, moduleList.getProperty(key));, , 					// don't output cloudscape.config.<tag>, 					// that line only has meaning to this program, , 					// derby.env.classes.<tag>, 					String envKey = "derby.env.classes.".concat(tag);, 					if (moduleList.getProperty(envKey) != null), 						outputProp.put(envKey, moduleList.getProperty(envKey));, , 					// derby.env.jdk.<tag>, 					// , 					// some of the configs only support one java env.  Some modules, 					// have alternate implementation for running on java1 and, 					// java2 platforms.  If we get rid of, say, the java2, 					// implementation, then the monitor won't load the java1, 					// implementation if that module specifies that it should, 					// only be loaded in a java1 environment.  The result is, 					// that some critical modules will be missing and the, 					// database won't boot., 					//, 					// the convention is, for modules that have both java1 and, 					// java2 implementation, they must named the module as, 					// derby.env.jdk.<name>J1 or, 					// derby.env.jdk.<name>J2, 					// in other words, the <tag> must end with J1 or J2., 					//, 					// If a config only use one of the two implementation, then, 					// this program will not put the one env.jdk line to the, 					// output properties.  As a result, this one implementation, 					// will be loaded when run in any environment., 					//, 					// This does not apply to any module that only has one, 					// implementation that runs on a specific jdk environment., 					//, 					//derby.env.jdk.<tag>, 					envKey = "derby.env.jdk.".concat(tag);, , 					if (moduleList.getProperty(envKey) != null), 					{, 						// by default keep the jdk env specification with the, 						// config  , 						boolean saveEnvKey = true;, , 						// figure out if this is a tag of the form <name>J1 or, 						// <name>J2., 						if (tag.endsWith("J1") || tag.endsWith("J2")), 						{, 							// ok, this is a module with alternate, 							// implementation for java 1 and java 2.  If this, 							// config ditches one of them, then do not output, 							// the env line, 							int length = tag.length() - 2;, 							String alternateTag = tag.substring(0, length);, 							, 							if (tag.endsWith("J1")), 								alternateTag += "J2";, 							else, 								alternateTag += "J1";, , 							// see if , 							// 1) this module has an alternate impl for the , 							// other jdk and , 							// 2) this config is not going to pick it up., 							//, 							, 							String alternateImplKey = , 								"derby.module."+ alternateTag;, 							String alternateJDKEnv = , 								"derby.env.jdk."+ alternateTag;, 							String alternateImplConfigKey =, 								"cloudscape.config."+alternateTag;, , 							// if any of of these are not present, then we, 							// don't have a problem because either there is no, 							// alternate implementation, or the alternate, 							// implementation is not based on jdk, or the, 							// alternate jdk based implemenation will also be, 							// present in this configuration, , 							if ((moduleList.getProperty(alternateImplKey) != null) &&, 								(moduleList.getProperty(alternateJDKEnv) != null) && , 								(moduleList.getProperty(alternateImplConfigKey) != null)), 							{, 								// there is an alternate impl that is jdk based, 								// and it has a config tag.  Let's see if it is, 								// part of this config., 								String alternateConfigProp =, 									moduleList.getProperty(alternateImplConfigKey);, , 								// we know that there are, 								// derby.module.<tag>J2 and, 								// derby.module.<tag>J1 and, 								// derby.env.jdk.<tag>J2 and, 								// derby.env.jdk.<tag>J1 and, 								// cloudscape.config.<tag>J2 and , 								// cloudscape.config.<tag>J1, 								StringTokenizer st2 = new, 									StringTokenizer(alternateConfigProp, ",");, , 								boolean ok = false;, 								while(st2.hasMoreTokens()) , 								{, 									String s = st2.nextToken().trim();, , 									if (s.equalsIgnoreCase(config) ||, 										s.equalsIgnoreCase("all")), 									{, 										ok = true;, 										break;, 									}, 								}, 								// the alternate module impl is not part of, 								// this config, do not save the jdk env key, 								if (!ok) , 									saveEnvKey = false;, 							}, 						}, , 						if (saveEnvKey), 							outputProp.put(envKey, moduleList.getProperty(envKey));, 					}, 					, , , 					// NOTE, if other types of properties are added to, 					// modules.properties, be sure to add it here too., 				}, 			}, 		}, , 		FileOutputStream os = new FileOutputStream(outputfile);, 		try, 		{, 			outputProp.store(os,, 							header., 							concat("# config is ").concat(config)., 							concat(footer));, 		}, 		finally, 		{, 			if (os != null), 				os.close();, 		}, 	}, , , 	private static void printUsageAndExit(), 	{, 		StringBuffer buf = new StringBuffer(400);, , 		buf.append("Usage propertyConfig <masterFile> <config> <outputFile>\n"), 			.append("masterFile must be a pre-existing properties file "), 			.append("containing all the modules properites\n"), 			.append("config must be a configuration defined in "), 			.append("org.apache.derby.modules.properties.\n"), 			.append("outputFile must not be a pre-existing properties file.\n\n"), 			.append("propertyConfig will generate the outputFile based on"), 			.append("the masterfile and the configuration specified."), 			.append("\n\nE.g., java propertyConfig dbms.properties cloudsync dbms.cloudsync.properties\n");, 		, , 		System.out.println(buf.toString());, 		System.exit(1);, 	}],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derbyBuild/propertyconfig.java,main,92-92,[			if (is != null)],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derbyBuild/propertyconfig.java,process,323-323,[			if (os != null)],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/derbyBuild/splitmessages.java,,30-246,[public class splitmessages {, 	/**, 		arg[0] is the destination directory, 		arg[1] is the source file., 	*/,     ,     /** ,      *  This is the list of message ids that are shared between,      *  the network client and the engine.  This is used to generate,      *  a set of 'shared' messages.  This avoids us having to maintain,      *  two separate message files.,      *,      *  NOTE: We already assume all message ids starting with XJ are shared.,      *  This covers 90% of the cases.  Only add ids here if you have a ,      *  message id that is not in the XJ class.,      */,     private static TreeSet<String> clientMessageIds = new TreeSet<String>();,     ,     /**,      * Initialize the set of message ids that the network client will use.  ,      * <p>,      * Note that all message ids that start with "XJ" are automatically added, ,      * these are just for message ids that have a different prefix.,      */,     static,     {,         // Add message ids that don't start with XJ here,         clientMessageIds.add(SQLState.NO_CURRENT_CONNECTION);,         clientMessageIds.add(SQLState.NOT_IMPLEMENTED);,         clientMessageIds.add(SQLState.CANNOT_CLOSE_ACTIVE_CONNECTION);,         clientMessageIds.add(SQLState.XACT_SAVEPOINT_RELEASE_ROLLBACK_FAIL);,         clientMessageIds.add(SQLState.UNSUPPORTED_ENCODING);,         clientMessageIds.add(SQLState.LANG_FORMAT_EXCEPTION);,         clientMessageIds.add(SQLState.LANG_DATA_TYPE_GET_MISMATCH);,         clientMessageIds.add(SQLState.LANG_DATA_TYPE_SET_MISMATCH);,         clientMessageIds.add(SQLState.LANG_DATE_SYNTAX_EXCEPTION);,         clientMessageIds.add(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE);,         clientMessageIds.add(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE);,         clientMessageIds.add(SQLState.LANG_STATEMENT_CLOSED_NO_REASON);,         clientMessageIds.add(SQLState.LANG_INVALID_COLUMN_POSITION);,         clientMessageIds.add(SQLState.INVALID_COLUMN_NAME);,         clientMessageIds.add(SQLState.HOLDABLE_RESULT_SET_NOT_AVAILABLE);,         clientMessageIds.add(SQLState.LANG_NULL_INTO_NON_NULL);,         clientMessageIds.add(SQLState.JDBC_METHOD_NOT_IMPLEMENTED);,         clientMessageIds.add(SQLState.JDBC_METHOD_NOT_SUPPORTED_BY_SERVER);,         clientMessageIds.add(SQLState.DRDA_NO_AUTOCOMMIT_UNDER_XA);,         clientMessageIds.add(SQLState.DRDA_INVALID_XA_STATE_ON_COMMIT_OR_ROLLBACK);,         clientMessageIds.add(SQLState.HOLDABLE_RESULT_SET_NOT_AVAILABLE);,         clientMessageIds.add(SQLState.INVALID_RESULTSET_TYPE);,         clientMessageIds.add(SQLState.SCROLL_SENSITIVE_NOT_SUPPORTED);,         clientMessageIds.add(SQLState.UNABLE_TO_OBTAIN_MESSAGE_TEXT_FROM_SERVER );,         clientMessageIds.add(SQLState.NUMBER_OF_ROWS_TOO_LARGE_FOR_INT);,         clientMessageIds.add(SQLState.NOGETCONN_ON_CLOSED_POOLED_CONNECTION);,         clientMessageIds.add(SQLState.LOB_METHOD_ON_CLOSED_CONNECTION);,         clientMessageIds.add(SQLState.QUERY_NOT_QUALIFIED_FOR_UPDATABLE_RESULTSET);,         clientMessageIds.add(SQLState.MULTIPLE_RESULTS_ON_EXECUTE_QUERY);,         clientMessageIds.add(SQLState.USE_EXECUTE_UPDATE_WITH_NO_RESULTS);,         clientMessageIds.add(SQLState.LANG_INVALID_CALL_TO_EXECUTE_UPDATE);,         clientMessageIds.add(SQLState.LANG_CANT_INVALIDATE_OPEN_RESULT_SET);,         clientMessageIds.add(SQLState.YEAR_EXCEEDS_MAXIMUM);,         clientMessageIds.add(SQLState.LANG_INVALID_PARAM_POSITION);,         clientMessageIds.add(SQLState.LANG_MISSING_PARMS);,         clientMessageIds.add(SQLState.LANG_NO_CURRENT_ROW);,         clientMessageIds.add(SQLState.LANG_STREAM_RETRIEVED_ALREADY);,         clientMessageIds.add(SQLState.CONNECTION_FAILED_ON_RESET);,         clientMessageIds.add(SQLState.DECIMAL_TOO_MANY_DIGITS);,         clientMessageIds.add(SQLState.NUMERIC_OVERFLOW);,         clientMessageIds.add(SQLState.UNSUPPORTED_HOLDABILITY_PROPERTY);,         clientMessageIds.add(SQLState.CANCEL_NOT_SUPPORTED_BY_SERVER);,         clientMessageIds.add(SQLState.LANG_INVALID_CALL_STATEMENT);,         clientMessageIds.add(SQLState.LANG_INVALID_SQL_IN_BATCH);,         clientMessageIds.add(SQLState.LANG_RESULT_SET_NOT_OPEN);,         clientMessageIds.add(SQLState.CANT_CONVERT_UNICODE_TO_EBCDIC);,         clientMessageIds.add(SQLState.SECMECH_NOT_SUPPORTED);,         clientMessageIds.add(SQLState.DRDA_COMMAND_NOT_IMPLEMENTED);,         clientMessageIds.add(SQLState.DATA_TYPE_NOT_SUPPORTED);,         clientMessageIds.add(SQLState.JDBC_DRIVER_REGISTER);,         clientMessageIds.add(SQLState.NO_CURRENT_ROW);,         clientMessageIds.add(SQLState.LANG_IDENTIFIER_TOO_LONG);,         clientMessageIds.add(SQLState.DRDA_CURSOR_NOT_OPEN);,         clientMessageIds.add(SQLState.PROPERTY_UNSUPPORTED_CHANGE);,         clientMessageIds.add(SQLState.NET_INVALID_JDBC_TYPE_FOR_PARAM);,         clientMessageIds.add(SQLState.UNRECOGNIZED_JAVA_SQL_TYPE);,         clientMessageIds.add(SQLState.NET_UNRECOGNIZED_JDBC_TYPE);,         clientMessageIds.add(SQLState.NET_SQLCDTA_INVALID_FOR_RDBCOLID);,         clientMessageIds.add(SQLState.NET_SQLCDTA_INVALID_FOR_PKGID);,         clientMessageIds.add(SQLState.NET_PGNAMCSN_INVALID_AT_SQLAM);,         clientMessageIds.add(SQLState.NET_VCM_VCS_LENGTHS_INVALID);,         clientMessageIds.add(SQLState.LANG_STRING_TOO_LONG);,         clientMessageIds.add(SQLState.INVALID_COLUMN_ARRAY_LENGTH);,         clientMessageIds.add(SQLState.PROPERTY_INVALID_VALUE);,         clientMessageIds.add(SQLState.LANG_SUBSTR_START_ADDING_LEN_OUT_OF_RANGE);,         clientMessageIds.add(SQLState.LANG_CURSOR_NOT_FOUND);,     };, , 	public static void main(String[] args) throws Exception {, , 		Properties p = new Properties();, , 		File dir = new File(args[0]);, , 		File source = new File(args[1]);,         , 		String s = source.getName();, 		// loose the suffix, 		s = s.substring(0, s.lastIndexOf('.'));, 		// now get the locale, 		String locale = s.substring(s.indexOf('_'));, , 		boolean addBase = "_en".equals(locale);, , , 		InputStream is = new BufferedInputStream(new FileInputStream(source), 64 * 1024);, , 		p.load(is);, 		is.close();, ,         , 		Properties[] c = new Properties[50];, 		for (int i = 0; i < 50; i++) {, 			c[i] = new Properties();, 		},         ,         Properties clientProps = new Properties();, ,         String clientPropsFileName = "clientmessages" + locale + ".properties";, , 		for (Enumeration e = p.keys(); e.hasMoreElements(); ) {, 			String key = (String) e.nextElement();, , 			c[MessageService.hashString50(key)].put(key, p.getProperty(key));,             ,             // If we have a match, add it to the list of client messages,             if ( isClientMessage(key) ),             {,                 clientProps.put(key, p.getProperty(key));,             }, 		}, , 		for (int i = 0; i < 50; i++) {, 			if (c[i].size() == 0), 				continue;, 			OutputStream fos = new BufferedOutputStream(, 				new FileOutputStream(new File(dir, "m"+i+locale+".properties")), 16 * 1024);, ,             , 			c[i].store(fos, (String) null);, 			fos.flush();, 			fos.close();,             , 			if (addBase) {, 				// add duplicate english file as the base, 				fos = new BufferedOutputStream(, 					new FileOutputStream(new File(dir, "m"+i+".properties")), 16 * 1024);, 				c[i].store(fos, (String) null);, 				fos.flush();, 				fos.close();, 			}, , , 		},         , 		System.out.println("split messages" + locale);, ,         // Save the client messages (the combination of what was already,         // there and what we added from the engine properties file) into,         // the Derby locales directory,         OutputStream clientOutStream = new BufferedOutputStream(,             new FileOutputStream(new File(dir, clientPropsFileName)), ,             16 * 1024);, ,         clientProps.store(clientOutStream, (String)null);,         clientOutStream.flush();,         clientOutStream.close();,         ,         if ( addBase ),         {,             // Save the English messages as the base,             clientOutStream = new BufferedOutputStream(,                 new FileOutputStream(new File(dir, "clientmessages.properties")), ,                 16 * 1024);, ,             clientProps.store(clientOutStream, (String)null);,             clientOutStream.flush();,             clientOutStream.close();            ,         },         System.out.println("Copied client messages for " + locale);, 	},     ,     /**,      * Determine if this is a message that the client is using,      *,      * There are some classes of ids that we assume are client messages,      * (see code below for the definitive list).,      *,      * All other shared message ids should be added to the static array,      * clientMessageIds, defined at the top of this class,      */,     static boolean isClientMessage(String messageId),     {,         // Look for message ids that we assume are likely to be used,         // on the client.  These ones don't need to be explicitly added,         // to clientMessageIds,         if ( messageId.startsWith("XJ") || messageId.startsWith("J")  ||,              messageId.startsWith("XN") || messageId.startsWith("58") ||,              messageId.startsWith("57") || messageId.startsWith("08") ||,              messageId.startsWith( "XBD" ) ),         {,             return true;,         },         ,         if ( clientMessageIds.contains(messageId)),         {,             return true;,         },         ,         return false;],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyPreBuild/PropertyPrompt.java,promptForInput,135-135,[        BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/derbyPreBuild/PropertySetter.java,tryToSetClasspathFromLib,365-365,[        String  classpathPropertyName = vmLevel.getClasspathPropertyName();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/derbyPreBuild/PropertySetter.java,listJars,470-470,[        for ( File jar : jars ) { map.add( jar ); }],,listJars,468-468,[        File[]  jars = dir.listFiles( new JarFilter() );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/derbyPreBuild/PropertySetter.java,listJars,403-403,[        if ( jars != null ) { setProperty( classpathPropertyName, jars ); }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derbyPreBuild/PropertySetter.java,getProperty,507-511,[        String  value = getProperty( name );, ,         if ( value == null ) { value = defaultValue; }, ,         return value;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derbyPreBuild/PropertySetter.java,printProperty,493-498,[        String  value = getProperty( name );, ,         if ( value == null ) { value = "NULL"; }, ,         echo( "${" + name + "} = " + value );,     }],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/derbyPreBuild/PropertySetter.java,verbose,762-765,[        if (VERBOSE_DEBUG_ENABLED) {,             System.out.println("[verbose] " + msg);,         },     }],,
STYLE,EQ_UNUSUAL,org/apache/derbyPreBuild/PropertySetter.java,equals,192-192,[        public  boolean equals( Object other ) { return ( compareTo( other ) == 0 ); }],,
I18N,DM_DEFAULT_ENCODING,org/apache/derbyPreBuild/ReleaseProperties.java,execute,156-156,[            propertiesFW = new FileWriter( target );],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/derbyPreBuild/ReleaseProperties.java,readDRDAMaintID,256-256,[        releaseProperties.load( new FileInputStream( inputFile ) );],,readDRDAMaintID,258-258,[        String  stringValue = releaseProperties.getProperty( DRDA_MAINT );],,readDRDAMaintID,260-260,[        return Integer.parseInt( stringValue );],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/derbyPreBuild/ReleaseProperties.java,readDRDAMaintID,256-256,[        releaseProperties.load( new FileInputStream( inputFile ) );],,
I18N,DM_CONVERT_CASE,org/apache/derbyPreBuild/ReleaseProperties.java,<init>,290-290,[                    if ( tokenizer.nextToken().trim().toLowerCase().equals( "beta" ) )],,
MT_CORRECTNESS,RS_READOBJECT_SYNC,org/osgi/framework/BundlePermission.java,readObject,416-418,[		s.defaultReadObject();, 		init(getMask(actions));, 	}],,
STYLE,SF_SWITCH_FALLTHROUGH,org/osgi/framework/BundlePermission.java,getMask,226-233,[						seencomma = true;, 					/* FALLTHROUGH */, 					case ' ' :, 					case '\r' :, 					case '\n' :, 					case '\f' :, 					case '\t' :, 						break;],,
MT_CORRECTNESS,WS_WRITEOBJECT_SYNC,org/osgi/framework/BundlePermission.java,,86-418,[	private transient int		action_mask			= ACTION_NONE;, , 	/**, 	 * The actions in canonical form., 	 * , 	 * @serial, 	 */, 	private String				actions				= null;, , 	/**, 	 * Defines the authority to provide and/or require and or specify a host, 	 * fragment symbolic name within the OSGi environment., 	 * <p>, 	 * Bundle Permissions are granted over all possible versions of a bundle., 	 * , 	 * A bundle that needs to provide a bundle must have the appropriate, 	 * <code>BundlePermission</code> for the symbolic name; a bundle that, 	 * requires a bundle must have the appropriate <code>BundlePermssion</code>, 	 * for that symbolic name; a bundle that specifies a fragment host must have, 	 * the appropriate <code>BundlePermission</code> for that symbolic name., 	 * , 	 * @param symbolicName the bundle symbolic name., 	 * @param actions <code>PROVIDE</code>,<code>REQUIRE</code>,, 	 *        <code>HOST</code>,<code>FRAGMENT</code> (canonical order)., 	 */, , 	public BundlePermission(String symbolicName, String actions) {, 		this(symbolicName, getMask(actions));, 	}, , 	/**, 	 * Bundle private constructor used by BundlePermissionCollection., 	 * , 	 * @param symbolicName the bundle symbolic name, 	 * @param mask the action mask, 	 */, 	BundlePermission(String symbolicName, int mask) {, 		super(symbolicName);, 		init(mask);, 	}, , 	/**, 	 * Called by constructors and when deserialized., 	 * , 	 * @param mask, 	 */, 	private void init(int mask) {, 		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {, 			throw new IllegalArgumentException("invalid action string");, 		}, , 		action_mask = mask;, 	}, , 	/**, 	 * Parse action string into action mask., 	 * , 	 * @param actions Action string., 	 * @return action mask., 	 */, 	private static int getMask(String actions) {, 		boolean seencomma = false;, , 		int mask = ACTION_NONE;, , 		if (actions == null) {, 			return (mask);, 		}, , 		char[] a = actions.toCharArray();, , 		int i = a.length - 1;, 		if (i < 0), 			return (mask);, , 		while (i != -1) {, 			char c;, , 			// skip whitespace, 			while ((i != -1), 					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n', 							|| c == '\f' || c == '\t')), 				i--;, , 			// check for the known strings, 			int matchlen;, , 			if (i >= 6 && (a[i - 6] == 'p' || a[i - 6] == 'P'), 					&& (a[i - 5] == 'r' || a[i - 5] == 'R'), 					&& (a[i - 4] == 'o' || a[i - 4] == 'O'), 					&& (a[i - 3] == 'v' || a[i - 3] == 'V'), 					&& (a[i - 2] == 'i' || a[i - 2] == 'I'), 					&& (a[i - 1] == 'd' || a[i - 1] == 'D'), 					&& (a[i] == 'e' || a[i] == 'E')) {, 				matchlen = 7;, 				mask |= ACTION_PROVIDE | ACTION_REQUIRE;, 			}, 			else, 				if (i >= 6 && (a[i - 6] == 'r' || a[i - 6] == 'R'), 						&& (a[i - 5] == 'e' || a[i - 5] == 'E'), 						&& (a[i - 4] == 'q' || a[i - 4] == 'Q'), 						&& (a[i - 3] == 'u' || a[i - 3] == 'U'), 						&& (a[i - 2] == 'i' || a[i - 2] == 'I'), 						&& (a[i - 1] == 'r' || a[i - 1] == 'R'), 						&& (a[i] == 'e' || a[i] == 'E')) {, 					matchlen = 7;, 					mask |= ACTION_REQUIRE;, 				}, 				else, 					if (i >= 3 && (a[i - 3] == 'h' || a[i - 3] == 'H'), 							&& (a[i - 2] == 'o' || a[i - 2] == 'O'), 							&& (a[i - 1] == 's' || a[i - 1] == 'S'), 							&& (a[i] == 't' || a[i] == 'T')) {, 						matchlen = 4;, 						mask |= ACTION_HOST;, 					}, 					else, 						if (i >= 7 && (a[i - 7] == 'f' || a[i - 7] == 'F'), 								&& (a[i - 6] == 'r' || a[i - 6] == 'R'), 								&& (a[i - 5] == 'a' || a[i - 5] == 'A'), 								&& (a[i - 4] == 'g' || a[i - 4] == 'G'), 								&& (a[i - 3] == 'm' || a[i - 3] == 'M'), 								&& (a[i - 2] == 'e' || a[i - 2] == 'E'), 								&& (a[i - 1] == 'n' || a[i - 1] == 'N'), 								&& (a[i] == 't' || a[i] == 'T')) {, 							matchlen = 8;, 							mask |= ACTION_FRAGMENT;, 						}, 						else {, 							// parse error, 							throw new IllegalArgumentException(, 									"invalid permission: " + actions);, 						}, , 			// make sure we didn't just match the tail of a word, 			// like "ackbarfrequire". Also, skip to the comma., 			seencomma = false;, 			while (i >= matchlen && !seencomma) {, 				switch (a[i - matchlen]) {, 					case ',' :, 						seencomma = true;, 					/* FALLTHROUGH */, 					case ' ' :, 					case '\r' :, 					case '\n' :, 					case '\f' :, 					case '\t' :, 						break;, 					default :, 						throw new IllegalArgumentException(, 								"invalid permission: " + actions);, 				}, 				i--;, 			}, , 			// point i at the location of the comma minus one (or -1)., 			i -= matchlen;, 		}, , 		if (seencomma) {, 			throw new IllegalArgumentException("invalid permission: " + actions);, 		}, , 		return (mask);, 	}, , 	/**, 	 * Determines if the specified permission is implied by this object., 	 * , 	 * <p>, 	 * This method checks that the symbolic name of the target is implied by the, 	 * symbolic name of this object. The list of <code>BundlePermission</code>, 	 * actions must either match or allow for the list of the target object to, 	 * imply the target <code>BundlePermission</code> action., 	 * <p>, 	 * The permission to provide a bundle implies the permission to require the, 	 * named symbolic name., 	 * , 	 * <pre>, 	 *       x.y.*,&quot;provide&quot; -&gt; x.y.z,&quot;provide&quot; is true, 	 *       *,&quot;require&quot; -&gt; x.y, &quot;require&quot;      is true, 	 *       *,&quot;provide&quot; -&gt; x.y, &quot;require&quot;      is true, 	 *       x.y,&quot;provide&quot; -&gt; x.y.z, &quot;provide&quot;  is false, 	 * </pre>, 	 * , 	 * @param p The target permission to interrogate., 	 * @return <code>true</code> if the specified, 	 *         <code>BundlePermission</code> action is implied by this object;, 	 *         <code>false</code> otherwise., 	 */, , 	public boolean implies(Permission p) {, 		if (p instanceof BundlePermission) {, 			BundlePermission target = (BundlePermission) p;, , 			return (((action_mask & target.action_mask) == target.action_mask) && super, 					.implies(p));, 		}, , 		return (false);, 	}, , 	/**, 	 * Returns the canonical string representation of the, 	 * <code>BundlePermission</code> actions., 	 * , 	 * <p>, 	 * Always returns present <code>BundlePermission</code> actions in the, 	 * following order: <code>PROVIDE</code>,<code>REQUIRE</code>,, 	 * <code>HOST</code>,<code>FRAGMENT., 	 * @return Canonical string representation of the <code>BundlePermission</code> actions., 	 */, , 	public String getActions() {, 		if (actions == null) {, 			StringBuffer sb = new StringBuffer();, 			boolean comma = false;, , 			if ((action_mask & ACTION_PROVIDE) == ACTION_PROVIDE) {, 				sb.append(PROVIDE);, 				comma = true;, 			}, , 			if ((action_mask & ACTION_REQUIRE) == ACTION_REQUIRE) {, 				if (comma), 					sb.append(',');, 				sb.append(REQUIRE);, 				comma = true;, 			}, , 			if ((action_mask & ACTION_HOST) == ACTION_HOST) {, 				if (comma), 					sb.append(',');, 				sb.append(HOST);, 				comma = true;, 			}, , 			if ((action_mask & ACTION_FRAGMENT) == ACTION_FRAGMENT) {, 				if (comma), 					sb.append(',');, 				sb.append(FRAGMENT);, 			}, , 			actions = sb.toString();, 		}, , 		return (actions);, 	}, , 	/**, 	 * Returns a new <code>PermissionCollection</code> object suitable for, 	 * storing <code>BundlePermission</code> objects., 	 * , 	 * @return A new <code>PermissionCollection</code> object., 	 */, 	public PermissionCollection newPermissionCollection() {, 		return (new BundlePermissionCollection());, 	}, , 	/**, 	 * Determines the equality of two <code>BundlePermission</code> objects., 	 * , 	 * This method checks that specified bundle has the same bundle symbolic, 	 * name and <code>BundlePermission</code> actions as this, 	 * <code>BundlePermission</code> object., 	 * , 	 * @param obj The object to test for equality with this, 	 *        <code>BundlePermission</code> object., 	 * @return <code>true</code> if <code>obj</code> is a, 	 *         <code>BundlePermission</code>, and has the same bundle, 	 *         symbolic name and actions as this <code>BundlePermission</code>, 	 *         object; <code>false</code> otherwise., 	 */, 	public boolean equals(Object obj) {, 		if (obj == this) {, 			return (true);, 		}, , 		if (!(obj instanceof BundlePermission)) {, 			return (false);, 		}, , 		BundlePermission p = (BundlePermission) obj;, , 		return ((action_mask == p.action_mask) && getName().equals(p.getName()));, 	}, , 	/**, 	 * Returns the hash code value for this object., 	 * , 	 * @return A hash code value for this object., 	 */, , 	public int hashCode() {, 		return (getName().hashCode() ^ getActions().hashCode());, 	}, , 	/**, 	 * Returns the current action mask., 	 * <p>, 	 * Used by the BundlePermissionCollection class., 	 * , 	 * @return Current action mask., 	 */, 	int getMask() {, 		return (action_mask);, 	}, , 	/**, 	 * WriteObject is called to save the state of the, 	 * <code>BundlePermission</code> object to a stream. The actions are, 	 * serialized, and the superclass takes care of the name., 	 */, , 	private synchronized void writeObject(java.io.ObjectOutputStream s), 			throws IOException {, 		// Write out the actions. The superclass takes care of the name, 		// call getActions to make sure actions field is initialized, 		if (actions == null), 			getActions();, 		s.defaultWriteObject();, 	}, , 	/**, 	 * readObject is called to restore the state of the BundlePermission from a, 	 * stream., 	 */, 	private synchronized void readObject(java.io.ObjectInputStream s), 			throws IOException, ClassNotFoundException {, 		// Read in the action, then initialize the rest, 		s.defaultReadObject();, 		init(getMask(actions));, 	}],,
MT_CORRECTNESS,RS_READOBJECT_SYNC,org/osgi/framework/PackagePermission.java,readObject,377-379,[		s.defaultReadObject();, 		init(getMask(actions));, 	}],,
STYLE,SF_SWITCH_FALLTHROUGH,org/osgi/framework/PackagePermission.java,getMask,200-207,[						seencomma = true;, 					/* FALLTHROUGH */, 					case ' ' :, 					case '\r' :, 					case '\n' :, 					case '\f' :, 					case '\t' :, 						break;],,
MT_CORRECTNESS,WS_WRITEOBJECT_SYNC,org/osgi/framework/PackagePermission.java,,69-379,[	private transient int		action_mask			= ACTION_NONE;, , 	/**, 	 * The actions in canonical form., 	 * , 	 * @serial, 	 */, 	private String				actions				= null;, , 	/**, 	 * Defines the authority to import and/or export a package within the OSGi, 	 * environment., 	 * <p>, 	 * The name is specified as a normal Java package name: a dot-separated, 	 * string. Wildcards may be used. For example:, 	 * , 	 * <pre>, 	 * org.osgi.service.http, 	 * javax.servlet.*, 	 * *, 	 * </pre>, 	 * , 	 * <p>, 	 * Package Permissions are granted over all possible versions of a package., 	 * , 	 * A bundle that needs to export a package must have the appropriate, 	 * <code>PackagePermission</code> for that package; similarly, a bundle, 	 * that needs to import a package must have the appropriate, 	 * <code>PackagePermssion</code> for that package., 	 * <p>, 	 * Permission is granted for both classes and resources., 	 * , 	 * @param name Package name., 	 * @param actions <code>EXPORT</code>,<code>IMPORT</code> (canonical, 	 *        order)., 	 */, , 	public PackagePermission(String name, String actions) {, 		this(name, getMask(actions));, 	}, , 	/**, 	 * Package private constructor used by PackagePermissionCollection., 	 * , 	 * @param name class name, 	 * @param mask action mask, 	 */, 	PackagePermission(String name, int mask) {, 		super(name);, 		init(mask);, 	}, , 	/**, 	 * Called by constructors and when deserialized., 	 * , 	 * @param mask action mask, 	 */, 	private void init(int mask) {, 		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {, 			throw new IllegalArgumentException("invalid action string");, 		}, , 		action_mask = mask;, 	}, , 	/**, 	 * Parse action string into action mask., 	 * , 	 * @param actions Action string., 	 * @return action mask., 	 */, 	private static int getMask(String actions) {, 		boolean seencomma = false;, , 		int mask = ACTION_NONE;, , 		if (actions == null) {, 			return (mask);, 		}, , 		char[] a = actions.toCharArray();, , 		int i = a.length - 1;, 		if (i < 0), 			return (mask);, , 		while (i != -1) {, 			char c;, , 			// skip whitespace, 			while ((i != -1), 					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n', 							|| c == '\f' || c == '\t')), 				i--;, , 			// check for the known strings, 			int matchlen;, , 			if (i >= 5 && (a[i - 5] == 'i' || a[i - 5] == 'I'), 					&& (a[i - 4] == 'm' || a[i - 4] == 'M'), 					&& (a[i - 3] == 'p' || a[i - 3] == 'P'), 					&& (a[i - 2] == 'o' || a[i - 2] == 'O'), 					&& (a[i - 1] == 'r' || a[i - 1] == 'R'), 					&& (a[i] == 't' || a[i] == 'T')) {, 				matchlen = 6;, 				mask |= ACTION_IMPORT;, , 			}, 			else, 				if (i >= 5 && (a[i - 5] == 'e' || a[i - 5] == 'E'), 						&& (a[i - 4] == 'x' || a[i - 4] == 'X'), 						&& (a[i - 3] == 'p' || a[i - 3] == 'P'), 						&& (a[i - 2] == 'o' || a[i - 2] == 'O'), 						&& (a[i - 1] == 'r' || a[i - 1] == 'R'), 						&& (a[i] == 't' || a[i] == 'T')) {, 					matchlen = 6;, 					mask |= ACTION_EXPORT | ACTION_IMPORT;, , 				}, 				else {, 					// parse error, 					throw new IllegalArgumentException("invalid permission: ", 							+ actions);, 				}, , 			// make sure we didn't just match the tail of a word, 			// like "ackbarfimport". Also, skip to the comma., 			seencomma = false;, 			while (i >= matchlen && !seencomma) {, 				switch (a[i - matchlen]) {, 					case ',' :, 						seencomma = true;, 					/* FALLTHROUGH */, 					case ' ' :, 					case '\r' :, 					case '\n' :, 					case '\f' :, 					case '\t' :, 						break;, 					default :, 						throw new IllegalArgumentException(, 								"invalid permission: " + actions);, 				}, 				i--;, 			}, , 			// point i at the location of the comma minus one (or -1)., 			i -= matchlen;, 		}, , 		if (seencomma) {, 			throw new IllegalArgumentException("invalid permission: " + actions);, 		}, , 		return (mask);, 	}, , 	/**, 	 * Determines if the specified permission is implied by this object., 	 * , 	 * <p>, 	 * This method checks that the package name of the target is implied by the, 	 * package name of this object. The list of <code>PackagePermission</code>, 	 * actions must either match or allow for the list of the target object to, 	 * imply the target <code>PackagePermission</code> action., 	 * <p>, 	 * The permission to export a package implies the permission to import the, 	 * named package., 	 * , 	 * <pre>, 	 * x.y.*,&quot;export&quot; -&gt; x.y.z,&quot;export&quot; is true, 	 * *,&quot;import&quot; -&gt; x.y, &quot;import&quot;      is true, 	 * *,&quot;export&quot; -&gt; x.y, &quot;import&quot;      is true, 	 * x.y,&quot;export&quot; -&gt; x.y.z, &quot;export&quot;  is false, 	 * </pre>, 	 * , 	 * @param p The target permission to interrogate., 	 * @return <code>true</code> if the specified, 	 *         <code>PackagePermission</code> action is implied by this, 	 *         object; <code>false</code> otherwise., 	 */, , 	public boolean implies(Permission p) {, 		if (p instanceof PackagePermission) {, 			PackagePermission target = (PackagePermission) p;, , 			return (((action_mask & target.action_mask) == target.action_mask) && super, 					.implies(p));, 		}, , 		return (false);, 	}, , 	/**, 	 * Returns the canonical string representation of the, 	 * <code>PackagePermission</code> actions., 	 * , 	 * <p>, 	 * Always returns present <code>PackagePermission</code> actions in the, 	 * following order: <code>EXPORT</code>,<code>IMPORT</code>., 	 * , 	 * @return Canonical string representation of the, 	 *         <code>PackagePermission</code> actions., 	 */, , 	public String getActions() {, 		if (actions == null) {, 			StringBuffer sb = new StringBuffer();, 			boolean comma = false;, , 			if ((action_mask & ACTION_EXPORT) == ACTION_EXPORT) {, 				sb.append(EXPORT);, 				comma = true;, 			}, , 			if ((action_mask & ACTION_IMPORT) == ACTION_IMPORT) {, 				if (comma), 					sb.append(',');, 				sb.append(IMPORT);, 			}, , 			actions = sb.toString();, 		}, , 		return (actions);, 	}, , 	/**, 	 * Returns a new <code>PermissionCollection</code> object suitable for, 	 * storing <code>PackagePermission</code> objects., 	 * , 	 * @return A new <code>PermissionCollection</code> object., 	 */, 	public PermissionCollection newPermissionCollection() {, 		return (new PackagePermissionCollection());, 	}, , 	/**, 	 * Determines the equality of two <code>PackagePermission</code> objects., 	 * , 	 * This method checks that specified package has the same package name and, 	 * <code>PackagePermission</code> actions as this, 	 * <code>PackagePermission</code> object., 	 * , 	 * @param obj The object to test for equality with this, 	 *        <code>PackagePermission</code> object., 	 * @return <code>true</code> if <code>obj</code> is a, 	 *         <code>PackagePermission</code>, and has the same package name, 	 *         and actions as this <code>PackagePermission</code> object;, 	 *         <code>false</code> otherwise., 	 */, 	public boolean equals(Object obj) {, 		if (obj == this) {, 			return (true);, 		}, , 		if (!(obj instanceof PackagePermission)) {, 			return (false);, 		}, , 		PackagePermission p = (PackagePermission) obj;, , 		return ((action_mask == p.action_mask) && getName().equals(p.getName()));, 	}, , 	/**, 	 * Returns the hash code value for this object., 	 * , 	 * @return A hash code value for this object., 	 */, , 	public int hashCode() {, 		return (getName().hashCode() ^ getActions().hashCode());, 	}, , 	/**, 	 * Returns the current action mask., 	 * <p>, 	 * Used by the PackagePermissionCollection class., 	 * , 	 * @return Current action mask., 	 */, 	int getMask() {, 		return (action_mask);, 	}, , 	/**, 	 * WriteObject is called to save the state of this permission object to a, 	 * stream. The actions are serialized, and the superclass takes care of the, 	 * name., 	 */, , 	private synchronized void writeObject(java.io.ObjectOutputStream s), 			throws IOException {, 		// Write out the actions. The superclass takes care of the name, 		// call getActions to make sure actions field is initialized, 		if (actions == null), 			getActions();, 		s.defaultWriteObject();, 	}, , 	/**, 	 * readObject is called to restore the state of this permission from a, 	 * stream., 	 */, 	private synchronized void readObject(java.io.ObjectInputStream s), 			throws IOException, ClassNotFoundException {, 		// Read in the action, then initialize the rest, 		s.defaultReadObject();, 		init(getMask(actions));, 	}],,
MT_CORRECTNESS,RS_READOBJECT_SYNC,org/osgi/framework/ServicePermission.java,readObject,347-349,[		s.defaultReadObject();, 		init(getMask(actions));, 	}],,
STYLE,SF_SWITCH_FALLTHROUGH,org/osgi/framework/ServicePermission.java,getMask,194-201,[						seencomma = true;, 					/* FALLTHROUGH */, 					case ' ' :, 					case '\r' :, 					case '\n' :, 					case '\f' :, 					case '\t' :, 						break;],,
MT_CORRECTNESS,WS_WRITEOBJECT_SYNC,org/osgi/framework/ServicePermission.java,,61-349,[	private transient int		action_mask			= ACTION_NONE;, , 	/**, 	 * The actions in canonical form., 	 * , 	 * @serial, 	 */, 	private String				actions				= null;, , 	/**, 	 * Create a new ServicePermission., 	 * , 	 * <p>, 	 * The name of the service is specified as a fully qualified class name., 	 * , 	 * <pre>, 	 * ClassName ::= &lt;class name&gt; | &lt;class name ending in &quot;.*&quot;&gt;, 	 * </pre>, 	 * , 	 * Examples:, 	 * , 	 * <pre>, 	 * org.osgi.service.http.HttpService, 	 * org.osgi.service.http.*, 	 * org.osgi.service.snmp.*, 	 * </pre>, 	 * , 	 * <p>, 	 * There are two possible actions: <code>get</code> and, 	 * <code>register</code>. The <code>get</code> permission allows the, 	 * owner of this permission to obtain a service with this name. The, 	 * <code>register</code> permission allows the bundle to register a, 	 * service under that name., 	 * , 	 * @param name class name, 	 * @param actions <code>get</code>,<code>register</code> (canonical, 	 *        order), 	 */, , 	public ServicePermission(String name, String actions) {, 		this(name, getMask(actions));, 	}, , 	/**, 	 * Package private constructor used by ServicePermissionCollection., 	 * , 	 * @param name class name, 	 * @param mask action mask, 	 */, 	ServicePermission(String name, int mask) {, 		super(name);, , 		init(mask);, 	}, , 	/**, 	 * Called by constructors and when deserialized., 	 * , 	 * @param mask action mask, 	 */, 	private void init(int mask) {, 		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {, 			throw new IllegalArgumentException("invalid action string");, 		}, , 		action_mask = mask;, 	}, , 	/**, 	 * Parse action string into action mask., 	 * , 	 * @param actions Action string., 	 * @return action mask., 	 */, 	private static int getMask(String actions) {, 		boolean seencomma = false;, , 		int mask = ACTION_NONE;, , 		if (actions == null) {, 			return mask;, 		}, , 		char[] a = actions.toCharArray();, , 		int i = a.length - 1;, 		if (i < 0), 			return mask;, , 		while (i != -1) {, 			char c;, , 			// skip whitespace, 			while ((i != -1), 					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n', 							|| c == '\f' || c == '\t')), 				i--;, , 			// check for the known strings, 			int matchlen;, , 			if (i >= 2 && (a[i - 2] == 'g' || a[i - 2] == 'G'), 					&& (a[i - 1] == 'e' || a[i - 1] == 'E'), 					&& (a[i] == 't' || a[i] == 'T')) {, 				matchlen = 3;, 				mask |= ACTION_GET;, , 			}, 			else, 				if (i >= 7 && (a[i - 7] == 'r' || a[i - 7] == 'R'), 						&& (a[i - 6] == 'e' || a[i - 6] == 'E'), 						&& (a[i - 5] == 'g' || a[i - 5] == 'G'), 						&& (a[i - 4] == 'i' || a[i - 4] == 'I'), 						&& (a[i - 3] == 's' || a[i - 3] == 'S'), 						&& (a[i - 2] == 't' || a[i - 2] == 'T'), 						&& (a[i - 1] == 'e' || a[i - 1] == 'E'), 						&& (a[i] == 'r' || a[i] == 'R')) {, 					matchlen = 8;, 					mask |= ACTION_REGISTER;, , 				}, 				else {, 					// parse error, 					throw new IllegalArgumentException("invalid permission: ", 							+ actions);, 				}, , 			// make sure we didn't just match the tail of a word, 			// like "ackbarfregister". Also, skip to the comma., 			seencomma = false;, 			while (i >= matchlen && !seencomma) {, 				switch (a[i - matchlen]) {, 					case ',' :, 						seencomma = true;, 					/* FALLTHROUGH */, 					case ' ' :, 					case '\r' :, 					case '\n' :, 					case '\f' :, 					case '\t' :, 						break;, 					default :, 						throw new IllegalArgumentException(, 								"invalid permission: " + actions);, 				}, 				i--;, 			}, , 			// point i at the location of the comma minus one (or -1)., 			i -= matchlen;, 		}, , 		if (seencomma) {, 			throw new IllegalArgumentException("invalid permission: " + actions);, 		}, , 		return mask;, 	}, , 	/**, 	 * Determines if a <code>ServicePermission</code> object "implies" the, 	 * specified permission., 	 * , 	 * @param p The target permission to check., 	 * @return <code>true</code> if the specified permission is implied by, 	 *         this object; <code>false</code> otherwise., 	 */, , 	public boolean implies(Permission p) {, 		if (p instanceof ServicePermission) {, 			ServicePermission target = (ServicePermission) p;, , 			return (((action_mask & target.action_mask) == target.action_mask) && super, 					.implies(p));, 		}, , 		return (false);, 	}, , 	/**, 	 * Returns the canonical string representation of the actions. Always, 	 * returns present actions in the following order: <code>get</code>,, 	 * <code>register</code>., 	 * , 	 * @return The canonical string representation of the actions., 	 */, 	public String getActions() {, 		if (actions == null) {, 			StringBuffer sb = new StringBuffer();, 			boolean comma = false;, , 			if ((action_mask & ACTION_GET) == ACTION_GET) {, 				sb.append(GET);, 				comma = true;, 			}, , 			if ((action_mask & ACTION_REGISTER) == ACTION_REGISTER) {, 				if (comma), 					sb.append(',');, 				sb.append(REGISTER);, 			}, , 			actions = sb.toString();, 		}, , 		return (actions);, 	}, , 	/**, 	 * Returns a new <code>PermissionCollection</code> object for storing, 	 * <code>ServicePermission<code> objects., 	 *, 	 * @return A new <code>PermissionCollection</code> object suitable for storing, 	 * <code>ServicePermission</code> objects., 	 */, 	public PermissionCollection newPermissionCollection() {, 		return (new ServicePermissionCollection());, 	}, , 	/**, 	 * Determines the equalty of two ServicePermission objects., 	 * , 	 * Checks that specified object has the same class name and action as this, 	 * <code>ServicePermission</code>., 	 * , 	 * @param obj The object to test for equality., 	 * @return true if obj is a <code>ServicePermission</code>, and has the, 	 *         same class name and actions as this, 	 *         <code>ServicePermission</code> object; <code>false</code>, 	 *         otherwise., 	 */, 	public boolean equals(Object obj) {, 		if (obj == this) {, 			return (true);, 		}, , 		if (!(obj instanceof ServicePermission)) {, 			return (false);, 		}, , 		ServicePermission p = (ServicePermission) obj;, , 		return ((action_mask == p.action_mask) && getName().equals(p.getName()));, 	}, , 	/**, 	 * Returns the hash code value for this object., 	 * , 	 * @return Hash code value for this object., 	 */, , 	public int hashCode() {, 		return (getName().hashCode() ^ getActions().hashCode());, 	}, , 	/**, 	 * Returns the current action mask. Used by the ServicePermissionCollection, 	 * object., 	 * , 	 * @return The actions mask., 	 */, 	int getMask() {, 		return (action_mask);, 	}, , 	/**, 	 * WriteObject is called to save the state of this permission to a stream., 	 * The actions are serialized, and the superclass takes care of the name., 	 */, , 	private synchronized void writeObject(java.io.ObjectOutputStream s), 			throws IOException {, 		// Write out the actions. The superclass takes care of the name, 		// call getActions to make sure actions field is initialized, 		if (actions == null), 			getActions();, 		s.defaultWriteObject();, 	}, , 	/**, 	 * readObject is called to restore the state of this permission from a, 	 * stream., 	 */, 	private synchronized void readObject(java.io.ObjectInputStream s), 			throws IOException, ClassNotFoundException {, 		// Read in the action, then initialize the rest, 		s.defaultReadObject();, 		init(getMask(actions));, 	}],,

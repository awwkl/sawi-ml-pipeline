BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/AntClassLoader.java,initializeClass,594-594,[                } catch (final Exception e) {],,
MALICIOUS_CODE,DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED,org/apache/tools/ant/AntClassLoader.java,newAntClassLoader,1585-1585,[        return new AntClassLoader(parent, project, path, parentFirst);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/AntClassLoader.java,cleanup,1415-1428,[        for (final Enumeration<JarFile> e = jarFiles.elements(); e.hasMoreElements();) {,             final JarFile jarFile = e.nextElement();,             try {,                 jarFile.close();,             } catch (final IOException ioe) {,                 // ignore,             },         },         jarFiles = new Hashtable<File, JarFile>();,         if (project != null) {,             project.removeBuildListener(this);,         },         project = null;,     }],,cleanUp,151-153,[        descriptorAdded = false;,         super.cleanUp();,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/AntClassLoader.java,setClassPath,356-369,[        pathComponents.removeAllElements();,         if (classpath != null) {,             final Path actualClasspath = classpath.concatSystemClasspath("ignore");,             final String[] pathElements = actualClasspath.list();,             for (int i = 0; i < pathElements.length; ++i) {,                 try {,                     addPathElement(pathElements[i]);,                 } catch (final BuildException e) {,                     // ignore path elements which are invalid,                     // relative to the project,                 },             },         },     }],,setClasspath,78-79,[        createClasspath().append(classpath);,     }],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/AntClassLoader.java,getCertificates,1219-1219,[            return null;],,getCertificates,1223-1223,[            return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/AntClassLoader.java,initializeClass,587-587,[        if (cons != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/AntClassLoader.java,initializeClass,594-594,[                } catch (final Exception e) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/AntClassLoaderTest.java,testInvalidZipException,185-185,[            PrintStream err =],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/AntTypeDefinition.java,getClassName,103-103,[        return className;],,getClassname,503-503,[        return classname;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/AntTypeDefinition.java,setClassName,95-96,[        this.className = className;,     }],,setClassname,162-165,[        if (!"".equals(classname)) {,             this.classname = classname;,         },     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/AntTypeDefinition.java,createAndSet,230-230,[        if (adapterObject == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/AntTypeDefinition.java,createAndSet,220-220,[        if (o == null || adapterClass == null) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/ArgumentProcessorRegistry.java,getProcessorByService,154-154,[                isr = new InputStreamReader(is);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/tools/ant/ArgumentProcessorRegistry.java,getProcessorByService,163-163,[                isr.close();],,getProcessorByService,149-149,[        InputStreamReader isr = null;],,getProcessorByService,152-152,[                isr = new InputStreamReader(is, "UTF-8");],,getProcessorByService,154-154,[                isr = new InputStreamReader(is);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/ant/Project.java,,135-2491,[    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();, ,     /** Name of this project. */,     private String name;,     /** Description for this project (if any). */,     private String description;, , ,     /** Map of references within the project (paths etc) (String to Object). */,     private final Hashtable<String, Object> references = new AntRefTable();, ,     /** Map of id references - used for indicating broken build files */,     private final HashMap<String, Object> idReferences = new HashMap<String, Object>();, ,     /** Name of the project's default target. */,     private String defaultTarget;, ,     /** Map from target names to targets (String to Target). */,     private final Hashtable<String, Target> targets = new Hashtable<String, Target>();,     /** Set of global filters. */,     private final FilterSet globalFilterSet = new FilterSet();,     {,         // Initialize the globalFileSet's project,         globalFilterSet.setProject(this);,     }, ,     /**,      * Wrapper around globalFilterSet. This collection only ever,      * contains one FilterSet, but the wrapper is needed in order to,      * make it easier to use the FileUtils interface.,      */,     private final FilterSetCollection globalFilters,         = new FilterSetCollection(globalFilterSet);, ,     /** Project base directory. */,     private File baseDir;, ,     /** lock object used when adding/removing listeners */,     private final Object listenersLock = new Object();, ,     /** List of listeners to notify of build events. */,     private volatile BuildListener[] listeners = new BuildListener[0];, ,     /** for each thread, record whether it is currently executing,         messageLogged */,     private final ThreadLocal<Boolean> isLoggingMessage = new ThreadLocal<Boolean>() {,             @Override,             protected Boolean initialValue() {,                 return Boolean.FALSE;,             },         };, ,     /**,      * The Ant core classloader--may be <code>null</code> if using,      * parent classloader.,      */,     private ClassLoader coreLoader = null;, ,     /** Records the latest task to be executed on a thread. */,     private final Map<Thread,Task> threadTasks =,         Collections.synchronizedMap(new WeakHashMap<Thread, Task>());, ,     /** Records the latest task to be executed on a thread group. */,     private final Map<ThreadGroup,Task> threadGroupTasks,         = Collections.synchronizedMap(new WeakHashMap<ThreadGroup,Task>());, ,     /**,      * Called to handle any input requests.,      */,     private InputHandler inputHandler = null;, ,     /**,      * The default input stream used to read any input.,      */,     private InputStream defaultInputStream = null;, ,     /**,      * Keep going flag.,      */,     private boolean keepGoingMode = false;, ,     /**,      * Set the input handler.,      *,      * @param handler the InputHandler instance to use for gathering input.,      */,     public void setInputHandler(final InputHandler handler) {,         inputHandler = handler;,     }, ,     /**,      * Set the default System input stream. Normally this stream is set to,      * System.in. This inputStream is used when no task input redirection is,      * being performed.,      *,      * @param defaultInputStream the default input stream to use when input,      *        is requested.,      * @since Ant 1.6,      */,     public void setDefaultInputStream(final InputStream defaultInputStream) {,         this.defaultInputStream = defaultInputStream;,     }, ,     /**,      * Get this project's input stream.,      *,      * @return the InputStream instance in use by this Project instance to,      * read input.,      */,     public InputStream getDefaultInputStream() {,         return defaultInputStream;,     }, ,     /**,      * Retrieve the current input handler.,      *,      * @return the InputHandler instance currently in place for the project,      *         instance.,      */,     public InputHandler getInputHandler() {,         return inputHandler;,     }, ,     /**,      * Create a new Ant project.,      */,     public Project() {,         inputHandler = new DefaultInputHandler();,     }, ,     /**,      * Create and initialize a subproject. By default the subproject will be of,      * the same type as its parent. If a no-arg constructor is unavailable, the,      * <code>Project</code> class will be used.,      * @return a Project instance configured as a subproject of this Project.,      * @since Ant 1.7,      */,     public Project createSubProject() {,         Project subProject = null;,         try {,             subProject = (getClass().newInstance());,         } catch (final Exception e) {,             subProject = new Project();,         },         initSubProject(subProject);,         return subProject;,     }, ,     /**,      * Initialize a subproject.,      * @param subProject the subproject to initialize.,      */,     public void initSubProject(final Project subProject) {,         ComponentHelper.getComponentHelper(subProject),             .initSubProject(ComponentHelper.getComponentHelper(this));,         subProject.setDefaultInputStream(getDefaultInputStream());,         subProject.setKeepGoingMode(this.isKeepGoingMode());,         subProject.setExecutor(getExecutor().getSubProjectExecutor());,     }, ,     /**,      * Initialise the project.,      *,      * This involves setting the default task definitions and loading the,      * system properties.,      *,      * @exception BuildException if the default task list cannot be loaded.,      */,     public void init() throws BuildException {,         initProperties();, ,         ComponentHelper.getComponentHelper(this).initDefaultDefinitions();,     }, ,     /**,      * Initializes the properties.,      * @exception BuildException if an vital property could not be set.,      * @since Ant 1.7,      */,     public void initProperties() throws BuildException {,         setJavaVersionProperty();,         setSystemProperties();,         setPropertyInternal(MagicNames.ANT_VERSION, Main.getAntVersion());,         setAntLib();,     }, ,     /**,      * Set a property to the location of ant.jar.,      * Use the locator to find the location of the Project.class, and,      * if this is not null, set the property {@link MagicNames#ANT_LIB},      * to the result,      */,     private void setAntLib() {,         final File antlib = org.apache.tools.ant.launch.Locator.getClassSource(,             Project.class);,         if (antlib != null) {,             setPropertyInternal(MagicNames.ANT_LIB, antlib.getAbsolutePath());,         },     },     /**,      * Factory method to create a class loader for loading classes from,      * a given path.,      *,      * @param path the path from which classes are to be loaded.,      *,      * @return an appropriate classloader.,      */,     public AntClassLoader createClassLoader(final Path path) {,         return AntClassLoader,             .newAntClassLoader(getClass().getClassLoader(), this, path, true);,     }, ,     /**,      * Factory method to create a class loader for loading classes from,      * a given path.,      *,      * @param parent the parent classloader for the new loader.,      * @param path the path from which classes are to be loaded.,      *,      * @return an appropriate classloader.,      */,     public AntClassLoader createClassLoader(,         final ClassLoader parent, final Path path) {,         return AntClassLoader.newAntClassLoader(parent, this, path, true);,     }, ,     /**,      * Set the core classloader for the project. If a <code>null</code>,      * classloader is specified, the parent classloader should be used.,      *,      * @param coreLoader The classloader to use for the project.,      *                   May be <code>null</code>.,      */,     public void setCoreLoader(final ClassLoader coreLoader) {,         this.coreLoader = coreLoader;,     }, ,     /**,      * Return the core classloader to use for this project.,      * This may be <code>null</code>, indicating that,      * the parent classloader should be used.,      *,      * @return the core classloader to use for this project.,      *,      */,     public ClassLoader getCoreLoader() {,         return coreLoader;,     }, ,     /**,      * Add a build listener to the list. This listener will,      * be notified of build events for this project.,      *,      * @param listener The listener to add to the list.,      *                 Must not be <code>null</code>.,      */,     public void addBuildListener(final BuildListener listener) {,         synchronized (listenersLock) {,             // If the listeners already has this listener, do nothing,             for (int i = 0; i < listeners.length; i++) {,                 if (listeners[i] == listener) {,                     return;,                 },             },             // copy on write semantics,             final BuildListener[] newListeners =,                 new BuildListener[listeners.length + 1];,             System.arraycopy(listeners, 0, newListeners, 0, listeners.length);,             newListeners[listeners.length] = listener;,             listeners = newListeners;,         },     }, ,     /**,      * Remove a build listener from the list. This listener,      * will no longer be notified of build events for this project.,      *,      * @param listener The listener to remove from the list.,      *                 Should not be <code>null</code>.,      */,     public void removeBuildListener(final BuildListener listener) {,         synchronized (listenersLock) {,             // copy on write semantics,             for (int i = 0; i < listeners.length; i++) {,                 if (listeners[i] == listener) {,                     final BuildListener[] newListeners =,                         new BuildListener[listeners.length - 1];,                     System.arraycopy(listeners, 0, newListeners, 0, i);,                     System.arraycopy(listeners, i + 1, newListeners, i,,                                      listeners.length - i - 1);,                     listeners = newListeners;,                     break;,                 },             },         },     }, ,     /**,      * Return a copy of the list of build listeners for the project.,      *,      * @return a list of build listeners for the project,      */,     public Vector<BuildListener> getBuildListeners() {,         synchronized (listenersLock) {,             final Vector<BuildListener> r = new Vector<BuildListener>(listeners.length);,             for (int i = 0; i < listeners.length; i++) {,                 r.add(listeners[i]);,             },             return r;,         },     }, ,     /**,      * Write a message to the log with the default log level,      * of MSG_INFO .,      * @param message The text to log. Should not be <code>null</code>.,      */, ,     public void log(final String message) {,         log(message, MSG_INFO);,     }, ,     /**,      * Write a project level message to the log with the given log level.,      * @param message The text to log. Should not be <code>null</code>.,      * @param msgLevel The log priority level to use.,      */,     public void log(final String message, final int msgLevel) {,         log(message, null, msgLevel);,     }, ,     /**,      * Write a project level message to the log with the given log level.,      * @param message The text to log. Should not be <code>null</code>.,      * @param throwable The exception causing this log, may be <code>null</code>.,      * @param msgLevel The log priority level to use.,      * @since 1.7,      */,     public void log(final String message, final Throwable throwable, final int msgLevel) {,         fireMessageLogged(this, message, throwable, msgLevel);,     }, ,     /**,      * Write a task level message to the log with the given log level.,      * @param task The task to use in the log. Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param msgLevel The log priority level to use.,      */,     public void log(final Task task, final String message, final int msgLevel) {,         fireMessageLogged(task, message, null, msgLevel);,     }, ,     /**,      * Write a task level message to the log with the given log level.,      * @param task The task to use in the log. Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param throwable The exception causing this log, may be <code>null</code>.,      * @param msgLevel The log priority level to use.,      * @since 1.7,      */,     public void log(final Task task, final String message, final Throwable throwable, final int msgLevel) {,         fireMessageLogged(task, message, throwable, msgLevel);,     }, ,     /**,      * Write a target level message to the log with the given log level.,      * @param target The target to use in the log.,      *               Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param msgLevel The log priority level to use.,      */,     public void log(final Target target, final String message, final int msgLevel) {,         log(target, message, null, msgLevel);,     }, ,     /**,      * Write a target level message to the log with the given log level.,      * @param target The target to use in the log.,      *               Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param throwable The exception causing this log, may be <code>null</code>.,      * @param msgLevel The log priority level to use.,      * @since 1.7,      */,     public void log(final Target target, final String message, final Throwable throwable,,             final int msgLevel) {,         fireMessageLogged(target, message, throwable, msgLevel);,     }, ,     /**,      * Return the set of global filters.,      *,      * @return the set of global filters.,      */,     public FilterSet getGlobalFilterSet() {,         return globalFilterSet;,     }, ,     /**,      * Set a property. Any existing property of the same name,      * is overwritten, unless it is a user property.,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      */,     public void setProperty(final String name, final String value) {,         PropertyHelper.getPropertyHelper(this).setProperty(name, value, true);,     }, ,     /**,      * Set a property if no value currently exists. If the property,      * exists already, a message is logged and the method returns with,      * no other effect.,      *,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      * @since 1.5,      */,     public void setNewProperty(final String name, final String value) {,         PropertyHelper.getPropertyHelper(this).setNewProperty(name, value);,     }, ,     /**,      * Set a user property, which cannot be overwritten by,      * set/unset property calls. Any previous value is overwritten.,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      * @see #setProperty(String,String),      */,     public void setUserProperty(final String name, final String value) {,         PropertyHelper.getPropertyHelper(this).setUserProperty(name, value);,     }, ,     /**,      * Set a user property, which cannot be overwritten by set/unset,      * property calls. Any previous value is overwritten. Also marks,      * these properties as properties that have not come from the,      * command line.,      *,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      * @see #setProperty(String,String),      */,     public void setInheritedProperty(final String name, final String value) {,         PropertyHelper.getPropertyHelper(this).setInheritedProperty(name, value);,     }, ,     /**,      * Set a property unless it is already defined as a user property,      * (in which case the method returns silently).,      *,      * @param name The name of the property.,      *             Must not be <code>null</code>.,      * @param value The property value. Must not be <code>null</code>.,      */,     private void setPropertyInternal(final String name, final String value) {,         PropertyHelper.getPropertyHelper(this).setProperty(name, value, false);,     }, ,     /**,      * Return the value of a property, if it is set.,      *,      * @param propertyName The name of the property.,      *             May be <code>null</code>, in which case,      *             the return value is also <code>null</code>.,      * @return the property value, or <code>null</code> for no match,      *         or if a <code>null</code> name is provided.,      */,     public String getProperty(final String propertyName) {,         final Object value = PropertyHelper.getPropertyHelper(this).getProperty(propertyName);,         return value == null ? null : String.valueOf(value);,     }, ,     /**,      * Replace ${} style constructions in the given value with the,      * string value of the corresponding data types.,      *,      * @param value The string to be scanned for property references.,      *              May be <code>null</code>.,      *,      * @return the given string with embedded property names replaced,      *         by values, or <code>null</code> if the given string is,      *         <code>null</code>.,      *,      * @exception BuildException if the given value has an unclosed,      *                           property name, e.g. <code>${xxx</code>.,      */,     public String replaceProperties(final String value) throws BuildException {,         return PropertyHelper.getPropertyHelper(this).replaceProperties(null, value, null);,     }, ,     /**,      * Return the value of a user property, if it is set.,      *,      * @param propertyName The name of the property.,      *             May be <code>null</code>, in which case,      *             the return value is also <code>null</code>.,      * @return the property value, or <code>null</code> for no match,      *         or if a <code>null</code> name is provided.,      */,      public String getUserProperty(final String propertyName) {,         return (String) PropertyHelper.getPropertyHelper(this).getUserProperty(propertyName);,     }, ,     /**,      * Return a copy of the properties table.,      * @return a hashtable containing all properties,      *         (including user properties).,      */,     public Hashtable<String, Object> getProperties() {,         return PropertyHelper.getPropertyHelper(this).getProperties();,     }, ,     /**,      * Return a copy of the user property hashtable.,      * @return a hashtable containing just the user properties.,      */,     public Hashtable<String, Object> getUserProperties() {,         return PropertyHelper.getPropertyHelper(this).getUserProperties();,     }, ,     /**,      * Return a copy of the inherited property hashtable.,      * @return a hashtable containing just the inherited properties.,      * @since Ant 1.8.0,      */,     public Hashtable<String, Object> getInheritedProperties() {,         return PropertyHelper.getPropertyHelper(this).getInheritedProperties();,     }, ,     /**,      * Copy all user properties that have been set on the command,      * line or a GUI tool from this instance to the Project instance,      * given as the argument.,      *,      * <p>To copy all &quot;user&quot; properties, you will also have to call,      * {@link #copyInheritedProperties copyInheritedProperties}.</p>,      *,      * @param other the project to copy the properties to.  Must not be null.,      *,      * @since Ant 1.5,      */,     public void copyUserProperties(final Project other) {,         PropertyHelper.getPropertyHelper(this).copyUserProperties(other);,     }, ,     /**,      * Copy all user properties that have not been set on the,      * command line or a GUI tool from this instance to the Project,      * instance given as the argument.,      *,      * <p>To copy all &quot;user&quot; properties, you will also have to call,      * {@link #copyUserProperties copyUserProperties}.</p>,      *,      * @param other the project to copy the properties to.  Must not be null.,      *,      * @since Ant 1.5,      */,     public void copyInheritedProperties(final Project other) {,         PropertyHelper.getPropertyHelper(this).copyInheritedProperties(other);,     }, ,     /**,      * Set the default target of the project.,      *,      * @param defaultTarget The name of the default target for this project.,      *                      May be <code>null</code>, indicating that there is,      *                      no default target.,      *,      * @deprecated since 1.5.x.,      *             Use setDefault.,      * @see #setDefault(String),      */,     @Deprecated,     public void setDefaultTarget(final String defaultTarget) {,         setDefault(defaultTarget);,     }, ,     /**,      * Return the name of the default target of the project.,      * @return name of the default target or,      *         <code>null</code> if no default has been set.,      */,     public String getDefaultTarget() {,         return defaultTarget;,     }, ,     /**,      * Set the default target of the project.,      *,      * @param defaultTarget The name of the default target for this project.,      *                      May be <code>null</code>, indicating that there is,      *                      no default target.,      */,     public void setDefault(final String defaultTarget) {,         if (defaultTarget != null) {,             setUserProperty(MagicNames.PROJECT_DEFAULT_TARGET, defaultTarget);,         },         this.defaultTarget = defaultTarget;,     }, ,     /**,      * Set the name of the project, also setting the user,      * property <code>ant.project.name</code>.,      *,      * @param name The name of the project.,      *             Must not be <code>null</code>.,      */,     public void setName(final String name) {,         setUserProperty(MagicNames.PROJECT_NAME,  name);,         this.name = name;,     }, ,     /**,      * Return the project name, if one has been set.,      *,      * @return the project name, or <code>null</code> if it hasn't been set.,      */,     public String getName() {,         return name;,     }, ,     /**,      * Set the project description.,      *,      * @param description The description of the project.,      *                    May be <code>null</code>.,      */,     public void setDescription(final String description) {,         this.description = description;,     }, ,     /**,      * Return the project description, if one has been set.,      *,      * @return the project description, or <code>null</code> if it hasn't,      *         been set.,      */,     public String getDescription() {,         if (description == null) {,             description = Description.getDescription(this);,         },         return description;,     }, ,     /**,      * Add a filter to the set of global filters.,      *,      * @param token The token to filter.,      *              Must not be <code>null</code>.,      * @param value The replacement value.,      *              Must not be <code>null</code>.,      * @deprecated since 1.4.x.,      *             Use getGlobalFilterSet().addFilter(token,value),      *,      * @see #getGlobalFilterSet(),      * @see FilterSet#addFilter(String,String),      */,     @Deprecated,     public void addFilter(final String token, final String value) {,         if (token == null) {,             return;,         },         globalFilterSet.addFilter(new FilterSet.Filter(token, value));,     }, ,     /**,      * Return a hashtable of global filters, mapping tokens to values.,      *,      * @return a hashtable of global filters, mapping tokens to values,      *         (String to String).,      *,      * @deprecated since 1.4.x,      *             Use getGlobalFilterSet().getFilterHash().,      *,      * @see #getGlobalFilterSet(),      * @see FilterSet#getFilterHash(),      */,     @Deprecated,     public Hashtable<String, String> getFilters() {,         // we need to build the hashtable dynamically,         return globalFilterSet.getFilterHash();,     }, ,     /**,      * Set the base directory for the project, checking that,      * the given filename exists and is a directory.,      *,      * @param baseD The project base directory.,      *              Must not be <code>null</code>.,      *,      * @exception BuildException if the directory if invalid.,      */,     public void setBasedir(final String baseD) throws BuildException {,         setBaseDir(new File(baseD));,     }, ,     /**,      * Set the base directory for the project, checking that,      * the given file exists and is a directory.,      *,      * @param baseDir The project base directory.,      *                Must not be <code>null</code>.,      * @exception BuildException if the specified file doesn't exist or,      *                           isn't a directory.,      */,     public void setBaseDir(File baseDir) throws BuildException {,         baseDir = FILE_UTILS.normalize(baseDir.getAbsolutePath());,         if (!baseDir.exists()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " does not exist");,         },         if (!baseDir.isDirectory()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " is not a directory");,         },         this.baseDir = baseDir;,         setPropertyInternal(MagicNames.PROJECT_BASEDIR, this.baseDir.getPath());,         final String msg = "Project base dir set to: " + this.baseDir;,         log(msg, MSG_VERBOSE);,     }, ,     /**,      * Return the base directory of the project as a file object.,      *,      * @return the project base directory, or <code>null</code> if the,      *         base directory has not been successfully set to a valid value.,      */,     public File getBaseDir() {,         if (baseDir == null) {,             try {,                 setBasedir(".");,             } catch (final BuildException ex) {,                 ex.printStackTrace();,             },         },         return baseDir;,     }, ,     /**,      * Set &quot;keep-going&quot; mode. In this mode Ant will try to execute,      * as many targets as possible. All targets that do not depend,      * on failed target(s) will be executed.  If the keepGoing settor/getter,      * methods are used in conjunction with the <code>ant.executor.class</code>,      * property, they will have no effect.,      * @param keepGoingMode &quot;keep-going&quot; mode,      * @since Ant 1.6,      */,     public void setKeepGoingMode(final boolean keepGoingMode) {,         this.keepGoingMode = keepGoingMode;,     }, ,     /**,      * Return the keep-going mode.  If the keepGoing settor/getter,      * methods are used in conjunction with the <code>ant.executor.class</code>,      * property, they will have no effect.,      * @return &quot;keep-going&quot; mode,      * @since Ant 1.6,      */,     public boolean isKeepGoingMode() {,         return this.keepGoingMode;,     }, ,     /**,      * Return the version of Java this class is running under.,      * @return the version of Java as a String, e.g. "1.1" .,      * @see org.apache.tools.ant.util.JavaEnvUtils#getJavaVersion,      * @deprecated since 1.5.x.,      *             Use org.apache.tools.ant.util.JavaEnvUtils instead.,      */,     @Deprecated,     public static String getJavaVersion() {,         return JavaEnvUtils.getJavaVersion();,     }, ,     /**,      * Set the <code>ant.java.version</code> property and tests for,      * unsupported JVM versions. If the version is supported,,      * verbose log messages are generated to record the Java version,      * and operating system name.,      *,      * @exception BuildException if this Java version is not supported.,      *,      * @see org.apache.tools.ant.util.JavaEnvUtils#getJavaVersion,      */,     public void setJavaVersionProperty() throws BuildException {,         final String javaVersion = JavaEnvUtils.getJavaVersion();,         setPropertyInternal(MagicNames.ANT_JAVA_VERSION, javaVersion);, ,         // sanity check,         if (!JavaEnvUtils.isAtLeastJavaVersion(JavaEnvUtils.JAVA_1_4))  {,             throw new BuildException("Ant cannot work on Java prior to 1.4");,         },         log("Detected Java version: " + javaVersion + " in: ",             + System.getProperty("java.home"), MSG_VERBOSE);, ,         log("Detected OS: " + System.getProperty("os.name"), MSG_VERBOSE);,     }, ,     /**,      * Add all system properties which aren't already defined as,      * user properties to the project properties.,      */,     public void setSystemProperties() {,         final Properties systemP = System.getProperties();,         final Enumeration<?> e = systemP.propertyNames();,         while (e.hasMoreElements()) {,             final String propertyName = (String) e.nextElement();,             final String value = systemP.getProperty(propertyName);,             if (value != null) {,                 this.setPropertyInternal(propertyName, value);,             },         },     }, ,     /**,      * Add a new task definition to the project.,      * Attempting to override an existing definition with an,      * equivalent one (i.e. with the same classname) results in,      * a verbose log message. Attempting to override an existing definition,      * with a different one results in a warning log message and,      * invalidates any tasks which have already been created with the,      * old definition.,      *,      * @param taskName The name of the task to add.,      *                 Must not be <code>null</code>.,      * @param taskClass The full name of the class implementing the task.,      *                  Must not be <code>null</code>.,      *,      * @exception BuildException if the class is unsuitable for being an Ant,      *                           task. An error level message is logged before,      *                           this exception is thrown.,      *,      * @see #checkTaskClass(Class),      */,     public void addTaskDefinition(final String taskName, final Class<?> taskClass),          throws BuildException {,         ComponentHelper.getComponentHelper(this).addTaskDefinition(taskName,,                 taskClass);,     }, ,     /**,      * Check whether or not a class is suitable for serving as Ant task.,      * Ant task implementation classes must be public, concrete, and have,      * a no-arg constructor.,      *,      * @param taskClass The class to be checked.,      *                  Must not be <code>null</code>.,      *,      * @exception BuildException if the class is unsuitable for being an Ant,      *                           task. An error level message is logged before,      *                           this exception is thrown.,      */,     public void checkTaskClass(final Class<?> taskClass) throws BuildException {,         ComponentHelper.getComponentHelper(this).checkTaskClass(taskClass);, ,         if (!Modifier.isPublic(taskClass.getModifiers())) {,             final String message = taskClass + " is not public";,             log(message, Project.MSG_ERR);,             throw new BuildException(message);,         },         if (Modifier.isAbstract(taskClass.getModifiers())) {,             final String message = taskClass + " is abstract";,             log(message, Project.MSG_ERR);,             throw new BuildException(message);,         },         try {,             taskClass.getConstructor();,             // don't have to check for public, since,             // getConstructor finds public constructors only.,         } catch (final NoSuchMethodException e) {,             final String message = "No public no-arg constructor in ",                 + taskClass;,             log(message, Project.MSG_ERR);,             throw new BuildException(message);,         } catch (final LinkageError e) {,             final String message = "Could not load " + taskClass + ": " + e;,             log(message, Project.MSG_ERR);,             throw new BuildException(message, e);,         },         if (!Task.class.isAssignableFrom(taskClass)) {,             TaskAdapter.checkTaskClass(taskClass, this);,         },     }, ,     /**,      * Return the current task definition hashtable. The returned hashtable is,      * &quot;live&quot; and so should not be modified.,      *,      * @return a map of from task name to implementing class,      *         (String to Class).,      */,     public Hashtable<String, Class<?>> getTaskDefinitions() {,         return ComponentHelper.getComponentHelper(this).getTaskDefinitions();,     }, ,     /**,      * Return the current task definition map. The returned map is a,      * copy of the &quot;live&quot; definitions.,      *,      * @return a map of from task name to implementing class,      *         (String to Class).,      *,      * @since Ant 1.8.1,      */,     public Map<String, Class<?>> getCopyOfTaskDefinitions() {,         return new HashMap<String, Class<?>>(getTaskDefinitions());,     }, ,     /**,      * Add a new datatype definition.,      * Attempting to override an existing definition with an,      * equivalent one (i.e. with the same classname) results in,      * a verbose log message. Attempting to override an existing definition,      * with a different one results in a warning log message, but the,      * definition is changed.,      *,      * @param typeName The name of the datatype.,      *                 Must not be <code>null</code>.,      * @param typeClass The full name of the class implementing the datatype.,      *                  Must not be <code>null</code>.,      */,     public void addDataTypeDefinition(final String typeName, final Class<?> typeClass) {,         ComponentHelper.getComponentHelper(this).addDataTypeDefinition(typeName,,                 typeClass);,     }, ,     /**,      * Return the current datatype definition hashtable. The returned,      * hashtable is &quot;live&quot; and so should not be modified.,      *,      * @return a map of from datatype name to implementing class,      *         (String to Class).,      */,     public Hashtable<String, Class<?>> getDataTypeDefinitions() {,         return ComponentHelper.getComponentHelper(this).getDataTypeDefinitions();,     }, ,     /**,      * Return the current datatype definition map. The returned,      * map is a copy pf the &quot;live&quot; definitions.,      *,      * @return a map of from datatype name to implementing class,      *         (String to Class).,      *,      * @since Ant 1.8.1,      */,     public Map<String, Class<?>> getCopyOfDataTypeDefinitions() {,         return new HashMap<String, Class<?>>(getDataTypeDefinitions());,     }, ,     /**,      * Add a <em>new</em> target to the project.,      *,      * @param target The target to be added to the project.,      *               Must not be <code>null</code>.,      *,      * @exception BuildException if the target already exists in the project,      *,      * @see Project#addOrReplaceTarget(Target),      */,     public void addTarget(final Target target) throws BuildException {,         addTarget(target.getName(), target);,     }, ,     /**,      * Add a <em>new</em> target to the project.,      *,      * @param targetName The name to use for the target.,      *             Must not be <code>null</code>.,      * @param target The target to be added to the project.,      *               Must not be <code>null</code>.,      *,      * @exception BuildException if the target already exists in the project.,      *,      * @see Project#addOrReplaceTarget(String, Target),      */,      public void addTarget(final String targetName, final Target target),          throws BuildException {,          if (targets.get(targetName) != null) {,              throw new BuildException("Duplicate target: `" + targetName + "'");,          },          addOrReplaceTarget(targetName, target);,      }, ,     /**,      * Add a target to the project, or replaces one with the same,      * name.,      *,      * @param target The target to be added or replaced in the project.,      *               Must not be <code>null</code>.,      */,     public void addOrReplaceTarget(final Target target) {,         addOrReplaceTarget(target.getName(), target);,     }, ,     /**,      * Add a target to the project, or replaces one with the same,      * name.,      *,      * @param targetName The name to use for the target.,      *                   Must not be <code>null</code>.,      * @param target The target to be added or replaced in the project.,      *               Must not be <code>null</code>.,      */,     public void addOrReplaceTarget(final String targetName, final Target target) {,         final String msg = " +Target: " + targetName;,         log(msg, MSG_DEBUG);,         target.setProject(this);,         targets.put(targetName, target);,     }, ,     /**,      * Return the hashtable of targets. The returned hashtable,      * is &quot;live&quot; and so should not be modified.,      * @return a map from name to target (String to Target).,      */,     public Hashtable<String, Target> getTargets() {,         return targets;,     }, ,     /**,      * Return the map of targets. The returned map,      * is a copy of the &quot;live&quot; targets.,      * @return a map from name to target (String to Target).,      * @since Ant 1.8.1,      */,     public Map<String, Target> getCopyOfTargets() {,         return new HashMap<String, Target>(targets);,     }, ,     /**,      * Create a new instance of a task, adding it to a list of,      * created tasks for later invalidation. This causes all tasks,      * to be remembered until the containing project is removed,      * @param taskType The name of the task to create an instance of.,      *                 Must not be <code>null</code>.,      *,      * @return an instance of the specified task, or <code>null</code> if,      *         the task name is not recognised.,      *,      * @exception BuildException if the task name is recognised but task,      *                           creation fails.,      */,     public Task createTask(final String taskType) throws BuildException {,         return ComponentHelper.getComponentHelper(this).createTask(taskType);,     }, ,     /**,      * Create a new instance of a data type.,      *,      * @param typeName The name of the data type to create an instance of.,      *                 Must not be <code>null</code>.,      *,      * @return an instance of the specified data type, or <code>null</code> if,      *         the data type name is not recognised.,      *,      * @exception BuildException if the data type name is recognised but,      *                           instance creation fails.,      */,     public Object createDataType(final String typeName) throws BuildException {,         return ComponentHelper.getComponentHelper(this).createDataType(typeName);,     }, ,     /**,      * Set the Executor instance for this Project.,      * @param e the Executor to use.,      */,     public void setExecutor(final Executor e) {,         addReference(MagicNames.ANT_EXECUTOR_REFERENCE, e);,     }, ,     /**,      * Get this Project's Executor (setting it if necessary).,      * @return an Executor instance.,      */,     public Executor getExecutor() {,         Object o = getReference(MagicNames.ANT_EXECUTOR_REFERENCE);,         if (o == null) {,             String classname = getProperty(MagicNames.ANT_EXECUTOR_CLASSNAME);,             if (classname == null) {,                 classname = DefaultExecutor.class.getName();,             },             log("Attempting to create object of type " + classname, MSG_DEBUG);,             try {,                 o = Class.forName(classname, true, coreLoader).newInstance();,             } catch (final ClassNotFoundException seaEnEfEx) {,                 //try the current classloader,                 try {,                     o = Class.forName(classname).newInstance();,                 } catch (final Exception ex) {,                     log(ex.toString(), MSG_ERR);,                 },             } catch (final Exception ex) {,                 log(ex.toString(), MSG_ERR);,             },             if (o == null) {,                 throw new BuildException(,                     "Unable to obtain a Target Executor instance.");,             },             setExecutor((Executor) o);,         },         return (Executor) o;,     }, ,     /**,      * Execute the specified sequence of targets, and the targets,      * they depend on.,      *,      * @param names A vector of target name strings to execute.,      *              Must not be <code>null</code>.,      *,      * @exception BuildException if the build failed.,      */,     public void executeTargets(final Vector<String> names) throws BuildException {,         setUserProperty(MagicNames.PROJECT_INVOKED_TARGETS,,                         CollectionUtils.flattenToString(names));,         getExecutor().executeTargets(this, names.toArray(new String[names.size()]));,     }, ,     /**,      * Demultiplex output so that each task receives the appropriate,      * messages. If the current thread is not currently executing a task,,      * the message is logged directly.,      *,      * @param output Message to handle. Should not be <code>null</code>.,      * @param isWarning Whether the text represents an warning (<code>true</code>),      *        or information (<code>false</code>).,      */,     public void demuxOutput(final String output, final boolean isWarning) {,         final Task task = getThreadTask(Thread.currentThread());,         if (task == null) {,             log(output, isWarning ? MSG_WARN : MSG_INFO);,         } else {,             if (isWarning) {,                 task.handleErrorOutput(output);,             } else {,                 task.handleOutput(output);,             },         },     }, ,     /**,      * Read data from the default input stream. If no default has been,      * specified, System.in is used.,      *,      * @param buffer the buffer into which data is to be read.,      * @param offset the offset into the buffer at which data is stored.,      * @param length the amount of data to read.,      *,      * @return the number of bytes read.,      *,      * @exception IOException if the data cannot be read.,      * @since Ant 1.6,      */,     public int defaultInput(final byte[] buffer, final int offset, final int length),         throws IOException {,         if (defaultInputStream != null) {,             System.out.flush();,             return defaultInputStream.read(buffer, offset, length);,         } else {,             throw new EOFException("No input provided for project");,         },     }, ,     /**,      * Demux an input request to the correct task.,      *,      * @param buffer the buffer into which data is to be read.,      * @param offset the offset into the buffer at which data is stored.,      * @param length the amount of data to read.,      *,      * @return the number of bytes read.,      *,      * @exception IOException if the data cannot be read.,      * @since Ant 1.6,      */,     public int demuxInput(final byte[] buffer, final int offset, final int length),         throws IOException {,         final Task task = getThreadTask(Thread.currentThread());,         if (task == null) {,             return defaultInput(buffer, offset, length);,         } else {,             return task.handleInput(buffer, offset, length);,         },     }, ,     /**,      * Demultiplex flush operations so that each task receives the appropriate,      * messages. If the current thread is not currently executing a task,,      * the message is logged directly.,      *,      * @since Ant 1.5.2,      *,      * @param output Message to handle. Should not be <code>null</code>.,      * @param isError Whether the text represents an error (<code>true</code>),      *        or information (<code>false</code>).,      */,     public void demuxFlush(final String output, final boolean isError) {,         final Task task = getThreadTask(Thread.currentThread());,         if (task == null) {,             fireMessageLogged(this, output, isError ? MSG_ERR : MSG_INFO);,         } else {,             if (isError) {,                 task.handleErrorFlush(output);,             } else {,                 task.handleFlush(output);,             },         },     }, ,     /**,      * Execute the specified target and any targets it depends on.,      *,      * @param targetName The name of the target to execute.,      *                   Must not be <code>null</code>.,      *,      * @exception BuildException if the build failed.,      */,     public void executeTarget(final String targetName) throws BuildException {, ,         // sanity check ourselves, if we've been asked to build nothing,         // then we should complain, ,         if (targetName == null) {,             final String msg = "No target specified";,             throw new BuildException(msg);,         }, ,         // Sort and run the dependency tree.,         // Sorting checks if all the targets (and dependencies),         // exist, and if there is any cycle in the dependency,         // graph.,         executeSortedTargets(topoSort(targetName, targets, false));,     }, ,     /**,      * Execute a <code>Vector</code> of sorted targets.,      * @param sortedTargets   the aforementioned <code>Vector</code>.,      * @throws BuildException on error.,      */,     public void executeSortedTargets(final Vector<Target> sortedTargets),         throws BuildException {,         final Set<String> succeededTargets = new HashSet<String>();,         BuildException buildException = null; // first build exception,         for (final Target curtarget : sortedTargets) {,             boolean canExecute = true;,             for (final Enumeration<String> depIter = curtarget.getDependencies();,                  depIter.hasMoreElements();) {,                 final String dependencyName = depIter.nextElement();,                 if (!succeededTargets.contains(dependencyName)) {,                     canExecute = false;,                     log(curtarget,,                         "Cannot execute '" + curtarget.getName() + "' - '",                         + dependencyName + "' failed or was not executed.",,                         MSG_ERR);,                     break;,                 },             },             if (canExecute) {,                 Throwable thrownException = null;,                 try {,                     curtarget.performTasks();,                     succeededTargets.add(curtarget.getName());,                 } catch (final RuntimeException ex) {,                     if (!(keepGoingMode)) {,                         throw ex; // throw further,                     },                     thrownException = ex;,                 } catch (final Throwable ex) {,                     if (!(keepGoingMode)) {,                         throw new BuildException(ex);,                     },                     thrownException = ex;,                 },                 if (thrownException != null) {,                     if (thrownException instanceof BuildException) {,                         log(curtarget,,                             "Target '" + curtarget.getName(),                             + "' failed with message '",                             + thrownException.getMessage() + "'.", MSG_ERR);,                         // only the first build exception is reported,                         if (buildException == null) {,                             buildException = (BuildException) thrownException;,                         },                     } else {,                         log(curtarget,,                             "Target '" + curtarget.getName(),                             + "' failed with message '",                             + thrownException.getMessage() + "'.", MSG_ERR);,                         thrownException.printStackTrace(System.err);,                         if (buildException == null) {,                             buildException =,                                 new BuildException(thrownException);,                         },                     },                 },             },         },         if (buildException != null) {,             throw buildException;,         },     }, ,     /**,      * Return the canonical form of a filename.,      * <p>,      * If the specified file name is relative it is resolved,      * with respect to the given root directory.,      *,      * @param fileName The name of the file to resolve.,      *                 Must not be <code>null</code>.,      *,      * @param rootDir  The directory respective to which relative file names,      *                 are resolved. May be <code>null</code>, in which case,      *                 the current directory is used.,      *,      * @return the resolved File.,      *,      * @deprecated since 1.4.x,      */,     @Deprecated,     public File resolveFile(final String fileName, final File rootDir) {,         return FILE_UTILS.resolveFile(rootDir, fileName);,     }, ,     /**,      * Return the canonical form of a filename.,      * <p>,      * If the specified file name is relative it is resolved,      * with respect to the project's base directory.,      *,      * @param fileName The name of the file to resolve.,      *                 Must not be <code>null</code>.,      *,      * @return the resolved File.,      *,      */,     public File resolveFile(final String fileName) {,         return FILE_UTILS.resolveFile(baseDir, fileName);,     }, ,     /**,      * Translate a path into its native (platform specific) format.,      * <p>,      * This method uses PathTokenizer to separate the input path,      * into its components. This handles DOS style paths in a relatively,      * sensible way. The file separators are then converted to their platform,      * specific versions.,      *,      * @param toProcess The path to be translated.,      *                  May be <code>null</code>.,      *,      * @return the native version of the specified path or,      *         an empty string if the path is <code>null</code> or empty.,      *,      * @deprecated since 1.7,      *             Use FileUtils.translatePath instead.,      *,      * @see PathTokenizer,      */,     @Deprecated,     public static String translatePath(final String toProcess) {,         return FileUtils.translatePath(toProcess);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination.,      * No filtering is performed.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     @Deprecated,     public void copyFile(final String sourceFile, final String destFile),           throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination,      * specifying if token filtering should be used.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     @Deprecated,     public void copyFile(final String sourceFile, final String destFile, final boolean filtering),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used and if,      * source files may overwrite newer destination files.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     @Deprecated,     public void copyFile(final String sourceFile, final String destFile, final boolean filtering,,                          final boolean overwrite) throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used, if,      * source files may overwrite newer destination files, and if the,      * last modified time of the resulting file should be set to,      * that of the source file.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      * @param preserveLastModified Whether or not the last modified time of,      *                             the resulting file should be set to that,      *                             of the source file.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     @Deprecated,     public void copyFile(final String sourceFile, final String destFile, final boolean filtering,,                          final boolean overwrite, final boolean preserveLastModified),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite, preserveLastModified);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination.,      * No filtering is performed.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     @Deprecated,     public void copyFile(final File sourceFile, final File destFile) throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination,      * specifying if token filtering should be used.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     @Deprecated,     public void copyFile(final File sourceFile, final File destFile, final boolean filtering),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used and if,      * source files may overwrite newer destination files.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      *,      * @exception IOException if the file cannot be copied.,      *,      * @deprecated since 1.4.x,      */,     @Deprecated,     public void copyFile(final File sourceFile, final File destFile, final boolean filtering,,                          final boolean overwrite) throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used, if,      * source files may overwrite newer destination files, and if the,      * last modified time of the resulting file should be set to,      * that of the source file.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      * @param preserveLastModified Whether or not the last modified time of,      *                             the resulting file should be set to that,      *                             of the source file.,      *,      * @exception IOException if the file cannot be copied.,      *,      * @deprecated since 1.4.x,      */,     @Deprecated,     public void copyFile(final File sourceFile, final File destFile, final boolean filtering,,                          final boolean overwrite, final boolean preserveLastModified),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite, preserveLastModified);,     }, ,     /**,      * Call File.setLastModified(long time) on Java above 1.1, and logs,      * a warning on Java 1.1.,      *,      * @param file The file to set the last modified time on.,      *             Must not be <code>null</code>.,      *,      * @param time the required modification time.,      *,      * @deprecated since 1.4.x,      *,      * @exception BuildException if the last modified time cannot be set,      *                           despite running on a platform with a version,      *                           above 1.1.,      */,     @Deprecated,     public void setFileLastModified(final File file, final long time),          throws BuildException {,         FILE_UTILS.setFileLastModified(file, time);,         log("Setting modification time for " + file, MSG_VERBOSE);,     }, ,     /**,      * Return the boolean equivalent of a string, which is considered,      * <code>true</code> if either <code>"on"</code>, <code>"true"</code>,,      * or <code>"yes"</code> is found, ignoring case.,      *,      * @param s The string to convert to a boolean value.,      *,      * @return <code>true</code> if the given string is <code>"on"</code>,,      *         <code>"true"</code> or <code>"yes"</code>, or,      *         <code>false</code> otherwise.,      */,     public static boolean toBoolean(final String s) {,         return ("on".equalsIgnoreCase(s),                 || "true".equalsIgnoreCase(s),                 || "yes".equalsIgnoreCase(s));,     }, ,     /**,      * Get the Project instance associated with the specified object.,      * @param o the object to query.,      * @return Project instance, if any.,      * @since Ant 1.7.1,      */,     public static Project getProject(final Object o) {,         if (o instanceof ProjectComponent) {,             return ((ProjectComponent) o).getProject();,         },         try {,             final Method m = o.getClass().getMethod("getProject", (Class[]) null);,             if (Project.class == m.getReturnType()) {,                 return (Project) m.invoke(o, (Object[]) null);,             },         } catch (final Exception e) {,             //too bad,         },         return null;,     }, ,     /**,      * Topologically sort a set of targets.  Equivalent to calling,      * <code>topoSort(new String[] {root}, targets, true)</code>.,      *,      * @param root The name of the root target. The sort is created in such,      *             a way that the sequence of Targets up to the root,      *             target is the minimum possible such sequence.,      *             Must not be <code>null</code>.,      * @param targetTable A Hashtable mapping names to Targets.,      *                Must not be <code>null</code>.,      * @return a Vector of ALL Target objects in sorted order.,      * @exception BuildException if there is a cyclic dependency among the,      *                           targets, or if a named target does not exist.,      */,     public final Vector<Target> topoSort(final String root, final Hashtable<String, Target> targetTable),         throws BuildException {,         return topoSort(new String[] {root}, targetTable, true);,     }, ,     /**,      * Topologically sort a set of targets.  Equivalent to calling,      * <code>topoSort(new String[] {root}, targets, returnAll)</code>.,      *,      * @param root The name of the root target. The sort is created in such,      *             a way that the sequence of Targets up to the root,      *             target is the minimum possible such sequence.,      *             Must not be <code>null</code>.,      * @param targetTable A Hashtable mapping names to Targets.,      *                Must not be <code>null</code>.,      * @param returnAll <code>boolean</code> indicating whether to return all,      *                  targets, or the execution sequence only.,      * @return a Vector of Target objects in sorted order.,      * @exception BuildException if there is a cyclic dependency among the,      *                           targets, or if a named target does not exist.,      * @since Ant 1.6.3,      */,     public final Vector<Target> topoSort(final String root, final Hashtable<String, Target> targetTable,,                                  final boolean returnAll) throws BuildException {,         return topoSort(new String[] {root}, targetTable, returnAll);,     }, ,     /**,      * Topologically sort a set of targets.,      *,      * @param root <code>String[]</code> containing the names of the root targets.,      *             The sort is created in such a way that the ordered sequence of,      *             Targets is the minimum possible such sequence to the specified,      *             root targets.,      *             Must not be <code>null</code>.,      * @param targetTable A map of names to targets (String to Target).,      *                Must not be <code>null</code>.,      * @param returnAll <code>boolean</code> indicating whether to return all,      *                  targets, or the execution sequence only.,      * @return a Vector of Target objects in sorted order.,      * @exception BuildException if there is a cyclic dependency among the,      *                           targets, or if a named target does not exist.,      * @since Ant 1.6.3,      */,     public final Vector<Target> topoSort(final String[] root, final Hashtable<String, Target> targetTable,,                                  final boolean returnAll) throws BuildException {,         final Vector<Target> ret = new VectorSet<Target>();,         final Hashtable<String, String> state = new Hashtable<String, String>();,         final Stack<String> visiting = new Stack<String>();, ,         // We first run a DFS based sort using each root as a starting node.,         // This creates the minimum sequence of Targets to the root node(s).,         // We then do a sort on any remaining unVISITED targets.,         // This is unnecessary for doing our build, but it catches,         // circular dependencies or missing Targets on the entire,         // dependency tree, not just on the Targets that depend on the,         // build Target., ,         for (int i = 0; i < root.length; i++) {,             final String st = (state.get(root[i]));,             if (st == null) {,                 tsort(root[i], targetTable, state, visiting, ret);,             } else if (st == VISITING) {,                 throw new RuntimeException("Unexpected node in visiting state: ",                     + root[i]);,             },         },         final StringBuffer buf = new StringBuffer("Build sequence for target(s)");, ,         for (int j = 0; j < root.length; j++) {,             buf.append((j == 0) ? " `" : ", `").append(root[j]).append('\'');,         },         buf.append(" is " + ret);,         log(buf.toString(), MSG_VERBOSE);, ,         final Vector<Target> complete = (returnAll) ? ret : new Vector<Target>(ret);,         for (final Enumeration<String> en = targetTable.keys(); en.hasMoreElements();) {,             final String curTarget = en.nextElement();,             final String st = state.get(curTarget);,             if (st == null) {,                 tsort(curTarget, targetTable, state, visiting, complete);,             } else if (st == VISITING) {,                 throw new RuntimeException("Unexpected node in visiting state: ",                     + curTarget);,             },         },         log("Complete build sequence is " + complete, MSG_VERBOSE);,         return ret;,     }, ,     /**,      * Perform a single step in a recursive depth-first-search traversal of,      * the target dependency tree.,      * <p>,      * The current target is first set to the &quot;visiting&quot; state, and,      * pushed onto the &quot;visiting&quot; stack.,      * <p>,      * An exception is then thrown if any child of the current node is in the,      * visiting state, as that implies a circular dependency. The exception,      * contains details of the cycle, using elements of the &quot;visiting&quot;,      * stack.,      * <p>,      * If any child has not already been &quot;visited&quot;, this method is,      * called recursively on it.,      * <p>,      * The current target is then added to the ordered list of targets. Note,      * that this is performed after the children have been visited in order,      * to get the correct order. The current target is set to the,      * &quot;visited&quot; state.,      * <p>,      * By the time this method returns, the ordered list contains the sequence,      * of targets up to and including the current target.,      *,      * @param root The current target to inspect.,      *             Must not be <code>null</code>.,      * @param targetTable A mapping from names to targets (String to Target).,      *                Must not be <code>null</code>.,      * @param state   A mapping from target names to states (String to String).,      *                The states in question are &quot;VISITING&quot; and,      *                &quot;VISITED&quot;. Must not be <code>null</code>.,      * @param visiting A stack of targets which are currently being visited.,      *                 Must not be <code>null</code>.,      * @param ret     The list to add target names to. This will end up,      *                containing the complete list of dependencies in,      *                dependency order.,      *                Must not be <code>null</code>.,      *,      * @exception BuildException if a non-existent target is specified or if,      *                           a circular dependency is detected.,      */,     private void tsort(final String root, final Hashtable<String, Target> targetTable,,                              final Hashtable<String, String> state, final Stack<String> visiting,,                              final Vector<Target> ret),         throws BuildException {,         state.put(root, VISITING);,         visiting.push(root);, ,         final Target target = targetTable.get(root);, ,         // Make sure we exist,         if (target == null) {,             final StringBuilder sb = new StringBuilder("Target \"");,             sb.append(root);,             sb.append("\" does not exist in the project \"");,             sb.append(name);,             sb.append("\". ");,             visiting.pop();,             if (!visiting.empty()) {,                 final String parent = visiting.peek();,                 sb.append("It is used from target \"");,                 sb.append(parent);,                 sb.append("\".");,             },             throw new BuildException(new String(sb));,         },         for (final Enumeration<String> en = target.getDependencies(); en.hasMoreElements();) {,             final String cur = en.nextElement();,             final String m = state.get(cur);,             if (m == null) {,                 // Not been visited,                 tsort(cur, targetTable, state, visiting, ret);,             } else if (m == VISITING) {,                 // Currently visiting this node, so have a cycle,                 throw makeCircularException(cur, visiting);,             },         },         final String p = visiting.pop();,         if (root != p) {,             throw new RuntimeException("Unexpected internal error: expected to ",                 + "pop " + root + " but got " + p);,         },         state.put(root, VISITED);,         ret.addElement(target);,     }, ,     /**,      * Build an appropriate exception detailing a specified circular,      * dependency.,      *,      * @param end The dependency to stop at. Must not be <code>null</code>.,      * @param stk A stack of dependencies. Must not be <code>null</code>.,      *,      * @return a BuildException detailing the specified circular dependency.,      */,     private static BuildException makeCircularException(final String end, final Stack<String> stk) {,         final StringBuilder sb = new StringBuilder("Circular dependency: ");,         sb.append(end);,         String c;,         do {,             c = stk.pop();,             sb.append(" <- ");,             sb.append(c);,         } while (!c.equals(end));,         return new BuildException(sb.toString());,     }, ,     /**,      * Inherit the id references.,      * @param parent the parent project of this project.,      */,     public void inheritIDReferences(final Project parent) {,     }, ,     /**,      * Add an id reference.,      * Used for broken build files.,      * @param id the id to set.,      * @param value the value to set it to (Unknown element in this case.,      */,     public void addIdReference(final String id, final Object value) {,         idReferences.put(id, value);,     }, ,     /**,      * Add a reference to the project.,      *,      * @param referenceName The name of the reference. Must not be <code>null</code>.,      * @param value The value of the reference.,      */,     public void addReference(final String referenceName, final Object value) {,         final Object old = ((AntRefTable) references).getReal(referenceName);,         if (old == value) {,             // no warning, this is not changing anything,             return;,         },         if (old != null && !(old instanceof UnknownElement)) {,             log("Overriding previous definition of reference to " + referenceName,,                 MSG_VERBOSE);,         },         log("Adding reference: " + referenceName, MSG_DEBUG);,         references.put(referenceName, value);,     }, ,     /**,      * Return a map of the references in the project (String to Object).,      * The returned hashtable is &quot;live&quot; and so must not be modified.,      *,      * @return a map of the references in the project (String to Object).,      */,     public Hashtable<String, Object> getReferences() {,         return references;,     }, ,     /**,      * Does the project know this reference?,      *,      * @since Ant 1.8.0,      */,     public boolean hasReference(final String key) {,         return references.containsKey(key);,     }, ,     /**,      * Return a map of the references in the project (String to,      * Object).  The returned hashtable is a copy of the,      * &quot;live&quot; references.,      *,      * @return a map of the references in the project (String to Object).,      *,      * @since Ant 1.8.1,      */,     public Map<String, Object> getCopyOfReferences() {,         return new HashMap<String, Object>(references);,     }, ,     /**,      * Look up a reference by its key (ID).,      *,      * @param key The key for the desired reference.,      *            Must not be <code>null</code>.,      *,      * @return the reference with the specified ID, or <code>null</code> if,      *         there is no such reference in the project, with type inference.,      */,     public <T> T getReference(final String key) {,         @SuppressWarnings("unchecked"),         final T ret = (T) references.get(key);,         if (ret != null) {,             return ret;,         },         if (!key.equals(MagicNames.REFID_PROPERTY_HELPER)) {,             try {,                 if (PropertyHelper.getPropertyHelper(this).containsProperties(key)) {,                     log("Unresolvable reference " + key,                             + " might be a misuse of property expansion syntax.", MSG_WARN);,                 },             } catch (final Exception e) {,                 //ignore,             },         },         return null;,     }, ,     /**,      * Return a description of the type of the given element, with,      * special handling for instances of tasks and data types.,      * <p>,      * This is useful for logging purposes.,      *,      * @param element The element to describe.,      *                Must not be <code>null</code>.,      *,      * @return a description of the element type.,      *,      * @since 1.95, Ant 1.5,      */,     public String getElementName(final Object element) {,         return ComponentHelper.getComponentHelper(this).getElementName(element);,     }, ,     /**,      * Send a &quot;build started&quot; event,      * to the build listeners for this project.,      */,     public void fireBuildStarted() {,         final BuildEvent event = new BuildEvent(this);,         final BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].buildStarted(event);,         },     }, ,     /**,      * Send a &quot;build finished&quot; event to the build listeners,      * for this project.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      */,     public void fireBuildFinished(final Throwable exception) {,         final BuildEvent event = new BuildEvent(this);,         event.setException(exception);,         final BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].buildFinished(event);,         },         // Inform IH to clear the cache,         IntrospectionHelper.clearCache();,     }, ,     /**,      * Send a &quot;subbuild started&quot; event to the build listeners for,      * this project.,      *,      * @since Ant 1.6.2,      */,     public void fireSubBuildStarted() {,         final BuildEvent event = new BuildEvent(this);,         final BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             if (currListeners[i] instanceof SubBuildListener) {,                 ((SubBuildListener) currListeners[i]).subBuildStarted(event);,             },         },     }, ,     /**,      * Send a &quot;subbuild finished&quot; event to the build listeners for,      * this project.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      *,      * @since Ant 1.6.2,      */,     public void fireSubBuildFinished(final Throwable exception) {,         final BuildEvent event = new BuildEvent(this);,         event.setException(exception);,         final BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             if (currListeners[i] instanceof SubBuildListener) {,                 ((SubBuildListener) currListeners[i]).subBuildFinished(event);,             },         },     }, ,     /**,      * Send a &quot;target started&quot; event to the build listeners,      * for this project.,      *,      * @param target The target which is starting to build.,      *               Must not be <code>null</code>.,      */,     protected void fireTargetStarted(final Target target) {,         final BuildEvent event = new BuildEvent(target);,         final BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].targetStarted(event);,         }, ,     }, ,     /**,      * Send a &quot;target finished&quot; event to the build listeners,      * for this project.,      *,      * @param target    The target which has finished building.,      *                  Must not be <code>null</code>.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      */,     protected void fireTargetFinished(final Target target, final Throwable exception) {,         final BuildEvent event = new BuildEvent(target);,         event.setException(exception);,         final BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].targetFinished(event);,         }, ,     }, ,     /**,      * Send a &quot;task started&quot; event to the build listeners,      * for this project.,      *,      * @param task The target which is starting to execute.,      *               Must not be <code>null</code>.,      */,     protected void fireTaskStarted(final Task task) {,         // register this as the current task on the current thread.,         registerThreadTask(Thread.currentThread(), task);,         final BuildEvent event = new BuildEvent(task);,         final BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].taskStarted(event);,         },     }, ,     /**,      * Send a &quot;task finished&quot; event to the build listeners for this,      * project.,      *,      * @param task      The task which has finished executing.,      *                  Must not be <code>null</code>.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      */,     protected void fireTaskFinished(final Task task, final Throwable exception) {,         registerThreadTask(Thread.currentThread(), null);,         System.out.flush();,         System.err.flush();,         final BuildEvent event = new BuildEvent(task);,         event.setException(exception);,         final BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].taskFinished(event);,         }, ,     }, ,     /**,      * Send a &quot;message logged&quot; event to the build listeners,      * for this project.,      *,      * @param event    The event to send. This should be built up with the,      *                 appropriate task/target/project by the caller, so that,      *                 this method can set the message and priority, then send,      *                 the event. Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     private void fireMessageLoggedEvent(final BuildEvent event, String message,,                                         final int priority) {, ,         if (message == null) {,             message = String.valueOf(message);,         },         if (message.endsWith(StringUtils.LINE_SEP)) {,             final int endIndex = message.length() - StringUtils.LINE_SEP.length();,             event.setMessage(message.substring(0, endIndex), priority);,         } else {,             event.setMessage(message, priority);,         },         if (isLoggingMessage.get() != Boolean.FALSE) {,             /*,              * One of the Listeners has attempted to access,              * System.err or System.out.,              *,              * We used to throw an exception in this case, but,              * sometimes Listeners can't prevent it(like our own,              * Log4jListener which invokes getLogger() which in,              * turn wants to write to the console).,              *,              * @see http://marc.theaimsgroup.com/?t=110538624200006&r=1&w=2,              *,              * We now (Ant 1.6.3 and later) simply swallow the message.,              */,             return;,         },         try {,             isLoggingMessage.set(Boolean.TRUE);,             final BuildListener[] currListeners = listeners;,             for (int i = 0; i < currListeners.length; i++) {,                 currListeners[i].messageLogged(event);,             },         } finally {,             isLoggingMessage.set(Boolean.FALSE);,         },     }, ,     /**,      * Send a &quot;message logged&quot; project level event,      * to the build listeners for this project.,      *,      * @param project  The project generating the event.,      *                 Should not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     protected void fireMessageLogged(final Project project, final String message,,                                      final int priority) {,         fireMessageLogged(project, message, null, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; project level event,      * to the build listeners for this project.,      *,      * @param project  The project generating the event.,      *                 Should not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param throwable The exception that caused this message. May be <code>null</code>.,      * @param priority The priority of the message.,      * @since 1.7,      */,     protected void fireMessageLogged(final Project project, final String message,,             final Throwable throwable, final int priority) {,         final BuildEvent event = new BuildEvent(project);,         event.setException(throwable);,         fireMessageLoggedEvent(event, message, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; target level event,      * to the build listeners for this project.,      *,      * @param target   The target generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     protected void fireMessageLogged(final Target target, final String message,,                                      final int priority) {,         fireMessageLogged(target, message, null, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; target level event,      * to the build listeners for this project.,      *,      * @param target   The target generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param throwable The exception that caused this message. May be <code>null</code>.,      * @param priority The priority of the message.,      * @since 1.7,      */,     protected void fireMessageLogged(final Target target, final String message,,             final Throwable throwable, final int priority) {,         final BuildEvent event = new BuildEvent(target);,         event.setException(throwable);,         fireMessageLoggedEvent(event, message, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; task level event,      * to the build listeners for this project.,      *,      * @param task     The task generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     protected void fireMessageLogged(final Task task, final String message, final int priority) {,         fireMessageLogged(task, message, null, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; task level event,      * to the build listeners for this project.,      *,      * @param task     The task generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param throwable The exception that caused this message. May be <code>null</code>.,      * @param priority The priority of the message.,      * @since 1.7,      */,     protected void fireMessageLogged(final Task task, final String message,,             final Throwable throwable, final int priority) {,         final BuildEvent event = new BuildEvent(task);,         event.setException(throwable);,         fireMessageLoggedEvent(event, message, priority);,     }, ,     /**,      * Register a task as the current task for a thread.,      * If the task is null, the thread's entry is removed.,      *,      * @param thread the thread on which the task is registered.,      * @param task the task to be registered.,      * @since Ant 1.5,      */,     public void registerThreadTask(final Thread thread, final Task task) {,         synchronized (threadTasks) {,             if (task != null) {,                 threadTasks.put(thread, task);,                 threadGroupTasks.put(thread.getThreadGroup(), task);,             } else {,                 threadTasks.remove(thread);,                 threadGroupTasks.remove(thread.getThreadGroup());,             },         },     }, ,     /**,      * Get the current task associated with a thread, if any.,      *,      * @param thread the thread for which the task is required.,      * @return the task which is currently registered for the given thread or,      *         null if no task is registered.,      */,     public Task getThreadTask(final Thread thread) {,         synchronized (threadTasks) {,             Task task = threadTasks.get(thread);,             if (task == null) {,                 ThreadGroup group = thread.getThreadGroup();,                 while (task == null && group != null) {,                     task = threadGroupTasks.get(group);,                     group = group.getParent();,                 },             },             return task;,         },     }, , ,     // Should move to a separate public class - and have API to add,     // listeners, etc.,     private static class AntRefTable extends Hashtable<String, Object> {,         private static final long serialVersionUID = 1L;, ,         AntRefTable() {,             super();,         }, ,         /** Returns the unmodified original object.,          * This method should be called internally to,          * get the &quot;real&quot; object.,          * The normal get method will do the replacement,          * of UnknownElement (this is similar with the JDNI,          * refs behavior).,          */,         private Object getReal(final Object key) {,             return super.get(key);,         }, ,         /** Get method for the reference table.,          *  It can be used to hook dynamic references and to modify,          * some references on the fly--for example for delayed,          * evaluation.,          *,          * It is important to make sure that the processing that is,          * done inside is not calling get indirectly.,          *,          * @param key lookup key.,          * @return mapped value.,          */,         @Override,         public Object get(final Object key) {,             Object o = getReal(key);,             if (o instanceof UnknownElement) {,                 // Make sure that,                 final UnknownElement ue = (UnknownElement) o;,                 ue.maybeConfigure();,                 o = ue.getRealThing();,             },             return o;,         },     }, ,     /**,      * Set a reference to this Project on the parameterized object.,      * Need to set the project before other set/add elements,      * are called.,      * @param obj the object to invoke setProject(this) on.,      */,     public final void setProjectReference(final Object obj) {,         if (obj instanceof ProjectComponent) {,             ((ProjectComponent) obj).setProject(this);,             return;,         },         try {,             final Method method =,                 obj.getClass().getMethod(,                     "setProject", new Class[] {Project.class});,             if (method != null) {,                 method.invoke(obj, new Object[] {this});,             },         } catch (final Throwable e) {,             // ignore this if the object does not have,             // a set project method or the method,             // is private/protected.,         },     }, ,     /**,      * Resolve the file relative to the project's basedir and return it as a,      * FileResource.,      * @param name the name of the file to resolve.,      * @return the file resource.,      * @since Ant 1.7,      */,     public Resource getResource(final String name) {,         return new FileResource(getBaseDir(), name);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/ant/Target.java,,45-493,[    private String ifString = "";, ,     /** The "unless" condition to test on execution. */,     private String unlessString = "";, ,     private Condition ifCondition;, ,     private Condition unlessCondition;, ,     /** List of targets this target is dependent on. */,     private List<String> dependencies = null;, ,     /** Children of this target (tasks and data types). */,     private List<Object> children = new ArrayList<Object>();, ,     /** Since Ant 1.6.2 */,     private Location location = Location.UNKNOWN_LOCATION;, ,     /** Project this target belongs to. */,     private Project project;, ,     /** Description of this target, if any. */,     private String description = null;, ,     /** Default constructor. */,     public Target() {,         //empty,     }, ,     /**,      * Cloning constructor.,      * @param other the Target to clone.,      */,     public Target(Target other) {,         this.name = other.name;,         this.ifString = other.ifString;,         this.unlessString = other.unlessString;,         this.ifCondition = other.ifCondition;,         this.unlessCondition = other.unlessCondition;,         this.dependencies = other.dependencies;,         this.location = other.location;,         this.project = other.project;,         this.description = other.description;,         // The children are added to after this cloning,         this.children = other.children;,     }, ,     /**,      * Sets the project this target belongs to.,      *,      * @param project The project this target belongs to.,      *                Must not be <code>null</code>.,      */,     public void setProject(Project project) {,         this.project = project;,     }, ,     /**,      * Returns the project this target belongs to.,      *,      * @return The project this target belongs to, or <code>null</code> if,      *         the project has not been set yet.,      */,     public Project getProject() {,         return project;,     }, ,     /**,      * Sets the location of this target's definition.,      *,      * @param location   <code>Location</code>,      * @since 1.6.2,      */,     public void setLocation(Location location) {,         this.location = location;,     }, ,     /**,      * Get the location of this target's definition.,      *,      * @return <code>Location</code>,      * @since 1.6.2,      */,     public Location getLocation() {,         return location;,     }, ,     /**,      * Sets the list of targets this target is dependent on.,      * The targets themselves are not resolved at this time.,      *,      * @param depS A comma-separated list of targets this target,      *             depends on. Must not be <code>null</code>.,      */,     public void setDepends(String depS) {,         for (String dep : parseDepends(depS, getName(), "depends")) {,             addDependency(dep);,         },     }, ,     public static List<String> parseDepends(String depends,,                                                 String targetName,,                                                 String attributeName) {,         List<String> list = new ArrayList<String>();,         if (depends.length() > 0) {,             StringTokenizer tok =,                 new StringTokenizer(depends, ",", true);,             while (tok.hasMoreTokens()) {,                 String token = tok.nextToken().trim();, ,                 // Make sure the dependency is not empty string,                 if ("".equals(token) || ",".equals(token)) {,                     throw new BuildException("Syntax Error: ",                                              + attributeName,                                              + " attribute of target \"",                                              + targetName,                                              + "\" contains an empty string.");,                 }, ,                 list.add(token);, ,                 // Make sure that depends attribute does not,                 // end in a ,,                 if (tok.hasMoreTokens()) {,                     token = tok.nextToken();,                     if (!tok.hasMoreTokens() || !",".equals(token)) {,                         throw new BuildException("Syntax Error: ",                                                  + attributeName,                                                  + " attribute for target \"",                                                  + targetName,                                                  + "\" ends with a \",\" ",                                                  + "character");,                     },                 },             },         },         return list;,     }, ,     /**,      * Sets the name of this target.,      *,      * @param name The name of this target. Should not be <code>null</code>.,      */,     public void setName(String name) {,         this.name = name;,     }, ,     /**,      * Returns the name of this target.,      *,      * @return the name of this target, or <code>null</code> if the,      *         name has not been set yet.,      */,     public String getName() {,         return name;,     }, ,     /**,      * Adds a task to this target.,      *,      * @param task The task to be added. Must not be <code>null</code>.,      */,     public void addTask(Task task) {,         children.add(task);,     }, ,     /**,      * Adds the wrapper for a data type element to this target.,      *,      * @param r The wrapper for the data type element to be added.,      *          Must not be <code>null</code>.,      */,     public void addDataType(RuntimeConfigurable r) {,         children.add(r);,     }, ,     /**,      * Returns the current set of tasks to be executed by this target.,      *,      * @return an array of the tasks currently within this target,      */,     public Task[] getTasks() {,         List<Task> tasks = new ArrayList<Task>(children.size());,         for (Object o : children) {,             if (o instanceof Task) {,                 tasks.add((Task) o);,             },         },         return tasks.toArray(new Task[tasks.size()]);,     }, ,     /**,      * Adds a dependency to this target.,      *,      * @param dependency The name of a target this target is dependent on.,      *                   Must not be <code>null</code>.,      */,     public void addDependency(String dependency) {,         if (dependencies == null) {,             dependencies = new ArrayList<String>(2);,         },         dependencies.add(dependency);,     }, ,     /**,      * Returns an enumeration of the dependencies of this target.,      *,      * @return an enumeration of the dependencies of this target (enumeration of String),      */,     public Enumeration<String> getDependencies() {,         return Collections,                 .enumeration(dependencies == null ? Collections.<String> emptyList() : dependencies);,     }, ,     /**,      * Does this target depend on the named target?,      * @param other the other named target.,      * @return true if the target does depend on the named target,      * @since Ant 1.6,      */,     public boolean dependsOn(String other) {,         Project p = getProject();,         Hashtable<String, Target> t = p == null ? null : p.getTargets();,         return p != null && p.topoSort(getName(), t, false).contains(t.get(other));,     }, ,     /**,      * Sets the "if" condition to test on execution. This is the,      * name of a property to test for existence - if the property,      * is not set, the task will not execute. The property goes,      * through property substitution once before testing, so if,      * property <code>foo</code> has value <code>bar</code>, setting,      * the "if" condition to <code>${foo}_x</code> will mean that the,      * task will only execute if property <code>bar_x</code> is set.,      *,      * @param property The property condition to test on execution.,      *                 May be <code>null</code>, in which case,      *                 no "if" test is performed.,      */,     public void setIf(String property) {,         ifString = property == null ? "" : property;,         setIf(new IfStringCondition(ifString));,     }, ,     /**,      * Returns the "if" property condition of this target.,      *,      * @return the "if" property condition or <code>null</code> if no,      *         "if" condition had been defined.,      * @since 1.6.2,      */,     public String getIf() {,         return "".equals(ifString) ? null : ifString;,     }, ,     /**,      * Same as {@link #setIf(String)} but requires a {@link Condition} instance,      *,      * @since 1.9,      */,     public void setIf(Condition condition) {,         if (ifCondition == null) {,             ifCondition = condition;,         } else {,             And andCondition = new And();,             andCondition.setProject(getProject());,             andCondition.setLocation(getLocation());,             andCondition.add(ifCondition);,             andCondition.add(condition);,             ifCondition = andCondition;,         },     }, ,     /**,      * Sets the "unless" condition to test on execution. This is the,      * name of a property to test for existence - if the property,      * is set, the task will not execute. The property goes,      * through property substitution once before testing, so if,      * property <code>foo</code> has value <code>bar</code>, setting,      * the "unless" condition to <code>${foo}_x</code> will mean that the,      * task will only execute if property <code>bar_x</code> isn't set.,      *,      * @param property The property condition to test on execution.,      *                 May be <code>null</code>, in which case,      *                 no "unless" test is performed.,      */,     public void setUnless(String property) {,         unlessString = property == null ? "" : property;,         setUnless(new UnlessStringCondition(unlessString));,     }, ,     /**,      * Returns the "unless" property condition of this target.,      *,      * @return the "unless" property condition or <code>null</code>,      *         if no "unless" condition had been defined.,      * @since 1.6.2,      */,     public String getUnless() {,         return "".equals(unlessString) ? null : unlessString;,     }, ,     /**,      * Same as {@link #setUnless(String)} but requires a {@link Condition} instance,      *,      * @since 1.9,      */,     public void setUnless(Condition condition) {,         if (unlessCondition == null) {,             unlessCondition = condition;,         } else {,             Or orCondition = new Or();,             orCondition.setProject(getProject());,             orCondition.setLocation(getLocation());,             orCondition.add(unlessCondition);,             orCondition.add(condition);,             unlessCondition = orCondition;,         },     }, ,     /**,      * Sets the description of this target.,      *,      * @param description The description for this target.,      *                    May be <code>null</code>, indicating that no,      *                    description is available.,      */,     public void setDescription(String description) {,         this.description = description;,     }, ,     /**,      * Returns the description of this target.,      *,      * @return the description of this target, or <code>null</code> if no,      *         description is available.,      */,     public String getDescription() {,         return description;,     }, ,     /**,      * Returns the name of this target.,      *,      * @return the name of this target, or <code>null</code> if the,      *         name has not been set yet.,      */,     public String toString() {,         return name;,     }, ,     /**,      * Executes the target if the "if" and "unless" conditions are,      * satisfied. Dependency checking should be done before calling this,      * method, as it does no checking of its own. If either the "if",      * or "unless" test prevents this target from being executed, a verbose,      * message is logged giving the reason. It is recommended that clients,      * of this class call performTasks rather than this method so that,      * appropriate build events are fired.,      *,      * @exception BuildException if any of the tasks fail or if a data type,      *                           configuration fails.,      *,      * @see #performTasks(),      * @see #setIf(String),      * @see #setUnless(String),      */,     public void execute() throws BuildException {,         if (ifCondition != null && !ifCondition.eval()) {,             project.log(this, "Skipped because property '" + project.replaceProperties(ifString),                     + "' not set.", Project.MSG_VERBOSE);,             return;,         },         if (unlessCondition != null && unlessCondition.eval()) {,             project.log(this, "Skipped because property '",                     + project.replaceProperties(unlessString) + "' set.", Project.MSG_VERBOSE);,             return;,         },         LocalProperties localProperties = LocalProperties.get(getProject());,         localProperties.enterScope();,         try {,             // use index-based approach to avoid ConcurrentModificationExceptions;,             // also account for growing target children,         	// do not optimize this loop by replacing children.size() by a variable,         	// as children can be added dynamically as in RhinoScriptTest where a target is adding work for itself,             for (int i = 0; i < children.size(); i++) {,                 Object o = children.get(i);,                 if (o instanceof Task) {,                     Task task = (Task) o;,                     task.perform();,                 } else {,                     ((RuntimeConfigurable) o).maybeConfigure(project);,                 },             },         } finally {,             localProperties.exitScope();,         },     }, ,     /**,      * Performs the tasks within this target (if the conditions are met),,      * firing target started/target finished messages around a call to,      * execute.,      *,      * @see #execute(),      */,     public final void performTasks() {,         RuntimeException thrown = null;,         project.fireTargetStarted(this);,         try {,             execute();,         } catch (RuntimeException exc) {,             thrown = exc;,             throw exc;,         } finally {,             project.fireTargetFinished(this, thrown);,         },     }, ,     /**,      * Replaces all occurrences of the given task in the list,      * of children with the replacement data type wrapper.,      *,      * @param el The task to replace.,      *           Must not be <code>null</code>.,      * @param o  The data type wrapper to replace <code>el</code> with.,      */,     void replaceChild(Task el, RuntimeConfigurable o) {,         int index;,         while ((index = children.indexOf(el)) >= 0) {,             children.set(index, o);,         },     }, ,     /**,      * Replaces all occurrences of the given task in the list,      * of children with the replacement task.,      *,      * @param el The task to replace.,      *           Must not be <code>null</code>.,      * @param o  The task to replace <code>el</code> with.,      */,     void replaceChild(Task el, Task o) {,         int index;,         while ((index = children.indexOf(el)) >= 0) {,             children.set(index, o);,         },     }],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/ant/Task.java,,85-480,[    public Task() {,     }, ,     /**,      * Sets the target container of this task.,      *,      * @param target Target in whose scope this task belongs.,      *               May be <code>null</code>, indicating a top-level task.,      */,     public void setOwningTarget(Target target) {,         this.target = target;,     }, ,     /**,      * Returns the container target of this task.,      *,      * @return The target containing this task, or <code>null</code> if,      *         this task is a top-level task.,      */,     public Target getOwningTarget() {,         return target;,     }, ,     /**,      * Sets the name to use in logging messages.,      *,      * @param name The name to use in logging messages.,      *             Should not be <code>null</code>.,      */,     public void setTaskName(String name) {,         this.taskName = name;,     }, ,     /**,      * Returns the name to use in logging messages.,      *,      * @return the name to use in logging messages.,      */,     public String getTaskName() {,         return taskName;,     }, ,     /**,      * Sets the name with which the task has been invoked.,      *,      * @param type The name the task has been invoked as.,      *             Should not be <code>null</code>.,      */,     public void setTaskType(String type) {,         this.taskType = type;,     }, ,     /**,      * Called by the project to let the task initialize properly.,      * The default implementation is a no-op.,      *,      * @exception BuildException if something goes wrong with the build,      */,     public void init() throws BuildException {,     }, ,     /**,      * Called by the project to let the task do its work. This method may be,      * called more than once, if the task is invoked more than once.,      * For example,,      * if target1 and target2 both depend on target3, then running,      * "ant target1 target2" will run all tasks in target3 twice.,      *,      * @exception BuildException if something goes wrong with the build.,      */,     public void execute() throws BuildException {,     }, ,     /**,      * Returns the wrapper used for runtime configuration.,      *,      * @return the wrapper used for runtime configuration. This,      *         method will generate a new wrapper (and cache it),      *         if one isn't set already.,      */,     public RuntimeConfigurable getRuntimeConfigurableWrapper() {,         if (wrapper == null) {,             wrapper = new RuntimeConfigurable(this, getTaskName());,         },         return wrapper;,     }, ,     /**,      * Sets the wrapper to be used for runtime configuration.,      *,      * This method should be used only by the ProjectHelper and Ant internals.,      * It is public to allow helper plugins to operate on tasks, normal tasks,      * should never use it.,      *,      * @param wrapper The wrapper to be used for runtime configuration.,      *                May be <code>null</code>, in which case the next call,      *                to getRuntimeConfigurableWrapper will generate a new,      *                wrapper.,      */,     public void setRuntimeConfigurableWrapper(RuntimeConfigurable wrapper) {,         this.wrapper = wrapper;,     }, ,     // TODO: (Jon Skeet) The comment "if it hasn't been done already" may,     // not be strictly true. wrapper.maybeConfigure() won't configure the same,     // attributes/text more than once, but it may well add the children again,,     // unless I've missed something.,     /**,      * Configures this task - if it hasn't been done already.,      * If the task has been invalidated, it is replaced with an,      * UnknownElement task which uses the new definition in the project.,      *,      * @exception BuildException if the task cannot be configured.,      */,     public void maybeConfigure() throws BuildException {,         if (!invalid) {,             if (wrapper != null) {,                 wrapper.maybeConfigure(getProject());,             },         } else {,             getReplacement();,         },     }, ,     /**,      * Force the task to be reconfigured from its RuntimeConfigurable.,      */,     public void reconfigure() {,         if (wrapper != null) {,             wrapper.reconfigure(getProject());,         },     }, ,     /**,      * Handles output by logging it with the INFO priority.,      *,      * @param output The output to log. Should not be <code>null</code>.,      */,     protected void handleOutput(String output) {,         log(output, Project.MSG_INFO);,     }, ,     /**,      * Handles output by logging it with the INFO priority.,      *,      * @param output The output to log. Should not be <code>null</code>.,      *,      * @since Ant 1.5.2,      */,     protected void handleFlush(String output) {,         handleOutput(output);,     }, ,     /**,      * Handle an input request by this task.,      *,      * @param buffer the buffer into which data is to be read.,      * @param offset the offset into the buffer at which data is stored.,      * @param length the amount of data to read.,      *,      * @return the number of bytes read.,      *,      * @exception IOException if the data cannot be read.,      * @since Ant 1.6,      */,     protected int handleInput(byte[] buffer, int offset, int length),         throws IOException {,         return getProject().defaultInput(buffer, offset, length);,     }, ,     /**,      * Handles an error output by logging it with the WARN priority.,      *,      * @param output The error output to log. Should not be <code>null</code>.,      */,     protected void handleErrorOutput(String output) {,         log(output, Project.MSG_WARN);,     }, ,     /**,      * Handles an error line by logging it with the WARN priority.,      *,      * @param output The error output to log. Should not be <code>null</code>.,      *,      * @since Ant 1.5.2,      */,     protected void handleErrorFlush(String output) {,         handleErrorOutput(output);,     }, ,     /**,      * Logs a message with the default (INFO) priority.,      *,      * @param msg The message to be logged. Should not be <code>null</code>.,      */,     public void log(String msg) {,         log(msg, Project.MSG_INFO);,     }, ,     /**,      * Logs a message with the given priority. This delegates,      * the actual logging to the project.,      *,      * @param msg The message to be logged. Should not be <code>null</code>.,      * @param msgLevel The message priority at which this message is to,      *                 be logged.,      */,     public void log(String msg, int msgLevel) {,         if (getProject() != null) {,             getProject().log(this, msg, msgLevel);,         } else {,             super.log(msg, msgLevel);,         },     }, ,     /**,      * Logs a message with the given priority. This delegates,      * the actual logging to the project.,      *,      * @param t The exception to be logged. Should not be <code>null</code>.,      * @param msgLevel The message priority at which this message is to,      *                 be logged.,      * @since 1.7,      */,     public void log(Throwable t, int msgLevel) {,         if (t != null) {,             log(t.getMessage(), t, msgLevel);,         },     }, ,     /**,      * Logs a message with the given priority. This delegates,      * the actual logging to the project.,      *,      * @param msg The message to be logged. Should not be <code>null</code>.,      * @param t The exception to be logged. May be <code>null</code>.,      * @param msgLevel The message priority at which this message is to,      *                 be logged.,      * @since 1.7,      */,     public void log(String msg, Throwable t, int msgLevel) {,         if (getProject() != null) {,             getProject().log(this, msg, t, msgLevel);,         } else {,             super.log(msg, msgLevel);,         },     }, ,     /**,      * Performs this task if it's still valid, or gets a replacement,      * version and performs that otherwise.,      *,      * Performing a task consists of firing a task started event,,      * configuring the task, executing it, and then firing task finished,      * event. If a runtime exception is thrown, the task finished event,      * is still fired, but with the exception as the cause.,      */,     public final void perform() {,         if (!invalid) {,             getProject().fireTaskStarted(this);,             Throwable reason = null;,             try {,                 maybeConfigure();,                 DispatchUtils.execute(this);,             } catch (BuildException ex) {,                 if (ex.getLocation() == Location.UNKNOWN_LOCATION) {,                     ex.setLocation(getLocation());,                 },                 reason = ex;,                 throw ex;,             } catch (Exception ex) {,                 reason = ex;,                 BuildException be = new BuildException(ex);,                 be.setLocation(getLocation());,                 throw be;,             } catch (Error ex) {,                 reason = ex;,                 throw ex;,             } finally {,                 getProject().fireTaskFinished(this, reason);,             },         } else {,             UnknownElement ue = getReplacement();,             Task task = ue.getTask();,             task.perform();,         },     }, ,     /**,      * Marks this task as invalid. Any further use of this task,      * will go through a replacement with the updated definition.,      */,     final void markInvalid() {,         invalid = true;,     }, ,     /**,      * Has this task been marked invalid?,      *,      * @return true if this task is no longer valid. A new task should be,      * configured in this case.,      *,      * @since Ant 1.5,      */,     protected final boolean isInvalid() {,         return invalid;,     }, ,     /**,      * Replacement element used if this task is invalidated.,      */,     private UnknownElement replacement;, ,     /**,      * Creates an UnknownElement that can be used to replace this task.,      * Once this has been created once, it is cached and returned by,      * future calls.,      *,      * @return the UnknownElement instance for the new definition of this task.,      */,     private UnknownElement getReplacement() {,         if (replacement == null) {,             replacement = new UnknownElement(taskType);,             replacement.setProject(getProject());,             replacement.setTaskType(taskType);,             replacement.setTaskName(taskName);,             replacement.setLocation(getLocation());,             replacement.setOwningTarget(target);,             replacement.setRuntimeConfigurableWrapper(wrapper);,             wrapper.setProxy(replacement);,             replaceChildren(wrapper, replacement);,             target.replaceChild(this, replacement);,             replacement.maybeConfigure();,         },         return replacement;,     }, ,     /**,      * Recursively adds an UnknownElement instance for each child,      * element of replacement.,      *,      * @since Ant 1.5.1,      */,     private void replaceChildren(RuntimeConfigurable wrapper,,                                  UnknownElement parentElement) {,         Enumeration<RuntimeConfigurable> e = wrapper.getChildren();,         while (e.hasMoreElements()) {,             RuntimeConfigurable childWrapper = e.nextElement();,             UnknownElement childElement =,                 new UnknownElement(childWrapper.getElementTag());,             parentElement.addChild(childElement);,             childElement.setProject(getProject());,             childElement.setRuntimeConfigurableWrapper(childWrapper);,             childWrapper.setProxy(childElement);,             replaceChildren(childWrapper, childElement);,         },     }, ,     /**,      * Return the type of task.,      *,      * @return the type of task.,      */,     public String getTaskType() {,         return taskType;,     }, ,     /**,      * Return the runtime configurable structure for this task.,      *,      * @return the runtime structure for this task.,      */,     protected RuntimeConfigurable getWrapper() {,         return wrapper;,     }, ,     /**,      * Bind a task to another; use this when configuring a newly created,      * task to do work on behalf of another.,      * Project, OwningTarget, TaskName, Location and Description are all copied,      *,      * Important: this method does not call {@link Task#init()}.,      * If you are creating a task to delegate work to, call {@link Task#init()},      * to initialize it.,      *,      * @param owner owning target,      * @since Ant1.7,      */,     public final void bindToOwner(Task owner) {,         setProject(owner.getProject());,         setOwningTarget(owner.getOwningTarget());,         setTaskName(owner.getTaskName());,         setDescription(owner.getDescription());,         setLocation(owner.getLocation());,         setTaskType(owner.getTaskType());,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/BuildFileRule.java,executeTarget,175-175,[        PrintStream out = new PrintStream(new AntOutputStream(outputBuffer));],,executeTarget,177-177,[        PrintStream err = new PrintStream(new AntOutputStream(errorBuffer));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/BuildFileRule.java,getFullLog,110-110,[        return fullLogBuffer.toString();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/BuildFileRule.java,getLog,99-99,[        return logBuffer.toString();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/BuildFileRule.java,executeTarget,196-196,[                project.executeTarget(targetName);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/BuildFileTest.java,executeTarget,323-323,[            PrintStream out = new PrintStream(new AntOutputStream(outBuffer));],,executeTarget,326-326,[            PrintStream err = new PrintStream(new AntOutputStream(errBuffer));],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/BuildFileTest.java,getResource,484-484,[        URL url = getClass().getResource(resource);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/BuildFileTest.java,getFullLog,227-227,[        return fullLogBuffer.toString();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/BuildFileTest.java,getLog,194-194,[        return logBuffer.toString();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/ComponentHelper.java,getAntTypeTable,504-504,[        return antTypeTable;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/ComponentHelper.java,getDataTypeDefinitions,443-443,[        return typeClassDefinitions;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/ComponentHelper.java,getTaskDefinitions,415-415,[        return taskClassDefinitions;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/DefaultDefinitions.java,componentDef,69-69,[        String n = ProjectHelper.genComponentName(ns, name);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/DefaultLogger.java,setErrorPrintStream,111-111,[        this.err = new PrintStream(err, true);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/DefaultLogger.java,setOutputPrintStream,101-101,[        this.out = new PrintStream(output, true);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/DefaultLoggerTest.java,,54-58,[        Exception x = new Exception("problem") {,             public void printStackTrace(PrintWriter w) {,                 w.println("problem");,                 w.println("  at p.C.m");,             }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/DemuxOutputStream.java,processBuffer,172-172,[        String output = buffer.toString();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/DemuxOutputStream.java,processFlush,186-186,[        String output = buffer.toString();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/Diagnostics.java,doReportTasksAvailability,487-487,[        InputStream is = Main.class.getResourceAsStream(],,doReportTasksAvailability,489-489,[        if (is == null) {],,doReportTasksAvailability,492-492,[            Properties props = new Properties();],,doReportTasksAvailability,494-494,[                props.load(is);],,doReportTasksAvailability,495-495,[                for (Enumeration<?> keys = props.keys(); keys.hasMoreElements();) {],,doReportTasksAvailability,511-511,[                if (props.size() == 0) {],,doReportTasksAvailability,514-514,[                    out.println("A task being missing/unavailable should only "],,doReportTasksAvailability,519-519,[            }],,doReportTasksAvailability,521-521,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/Diagnostics.java,doReportTasksAvailability,487-487,[        InputStream is = Main.class.getResourceAsStream(],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/Diagnostics.java,listLibraries,113-113,[            return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/Diagnostics.java,getSAXParser,199-199,[        if (saxParserFactory == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/Diagnostics.java,getXSLTProcessor,218-218,[        if (transformerFactory == null) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/Diagnostics.java,doReportTempDir,604-604,[            tempFile.delete();],,doReportTempDir,630-630,[                tempFile.delete();],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/DirectoryScanner.java,fillNonPatternSet,1845-1845,[                    ? patterns[i] : patterns[i].toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/DirectoryScanner.java,isExcluded,1533-1533,[            : excludeNonPatterns.containsKey(name.toString().toUpperCase())) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/DirectoryScanner.java,isIncluded,1390-1390,[            : includeNonPatterns.containsKey(path.toString().toUpperCase())) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/DirectoryScanner.java,setSelectors,812-812,[        this.selectors = selectors;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/DirectoryScanner.java,,677-677,[        this.errorOnMissingDir = errorOnMissingDir;],,,879-879,[                        if (errorOnMissingDir) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/DirectoryScanner.java,,846-846,[                if (illegal != null) {],,,847-847,[                    throw illegal;],,,856-856,[                illegal = null;],,,893-893,[                    if (illegal != null) {],,,894-894,[                        throw illegal;],,,880-880,[                            illegal = new IllegalStateException("basedir "],,,888-888,[                        illegal = new IllegalStateException("basedir "],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/DirectoryScanner.java,,149-149,[    protected static final String[] DEFAULTEXCLUDES = {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/DirectoryScanner.java,getBasedir,645-645,[        return basedir;],,getBaseDir,871-878,[        if (baseDir == null) {,             try {,                 setBasedir(".");,             } catch (final BuildException ex) {,                 ex.printStackTrace();,             },         },         return baseDir;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/DirectoryScanner.java,setBasedir,635-636,[        this.basedir = basedir;,     }],,setBaseDir,849-862,[        baseDir = FILE_UTILS.normalize(baseDir.getAbsolutePath());,         if (!baseDir.exists()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " does not exist");,         },         if (!baseDir.isDirectory()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " is not a directory");,         },         this.baseDir = baseDir;,         setPropertyInternal(MagicNames.PROJECT_BASEDIR, this.baseDir.getPath());,         final String msg = "Project base dir set to: " + this.baseDir;,         log(msg, MSG_VERBOSE);,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/DirectoryScanner.java,setCaseSensitive,666-667,[        this.isCaseSensitive = isCaseSensitive;,     }],,setCasesensitive,58-59,[        caseSensitive = b;,     }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/DirectoryScannerTest.java,testAbsolute5,509-509,[        String pattern = new File(File.separator).getAbsolutePath().toUpperCase() + "*";],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/DirectoryScannerTest.java,testIsExcludedDirectoryScanned,430-430,[        assumeFalse("cannot execute testIsExcludedDirectoryScanned when tests are forked, " +],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/tools/ant/DirectoryScannerTest.java,testSetFollowLinks,322-322,[                if (!linkFile.delete()) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/FileUtilities.java,getFileContents,51-51,[                rdr = new FileReader(file);],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/tools/ant/IntrospectionHelper.java,setAttribute,411-411,[            as.setObject(p, element, value);],,setAttribute,383-383,[        if (as == null && value != null) {],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelper.java,set,1158-1158,[                                new Long(StringUtils.parseHumanSizes(value)) });],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelper.java,set,1080-1080,[                    m.invoke(parent, (Object[]) new Character[] {new Character(value.charAt(0))});],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAddTextMethod,98-98,[            m = ih.getAddTextMethod();],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,547-547,[        assertAttrMethod("nineteen", "setNineteen", Double.TYPE,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,543-543,[        assertAttrMethod("seventeen", "setSeventeen", Byte.TYPE,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,539-539,[        assertAttrMethod("fifteen", "setFifteen", Character.TYPE,],,testGetAttributeMethod,541-541,[        assertAttrMethod("sixteen", "setSixteen", Character.class,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,525-525,[        assertAttrMethod("eight", "setEight", Integer.TYPE,],,testGetAttributeMethod,527-527,[        assertAttrMethod("nine", "setNine", Integer.class,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,545-545,[        assertAttrMethod("eightteen", "setEightteen", Short.TYPE,],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/IntrospectionHelperTest.java,createFour,280-280,[        return null;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/Location.java,getFileName,105-105,[        return fileName;],,getFilename,76-76,[        return filename;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/Main.java,processArgs,357-357,[                    logTo = new PrintStream(new FileOutputStream(logFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/Main.java,runBuild,792-792,[                System.setOut(new PrintStream(new DemuxOutputStream(project, false)));],,runBuild,793-793,[                System.setErr(new PrintStream(new DemuxOutputStream(project, true)));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/Main.java,getAntVersion,1085-1085,[                    Main.class.getResourceAsStream("/org/apache/tools/ant/version.txt");],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/Main.java,printTargets,1287-1287,[            spaces += spaces;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/Project.java,addReference,1995-1995,[        final Object old = ((AntRefTable) references).getReal(referenceName);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/Project.java,getReferences,2015-2015,[        return references;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/Project.java,getTargets,1160-1160,[        return targets;],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/tools/ant/Project.java,tsort,1942-1942,[        if (root != p) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/tools/ant/Project.java,topoSort,1837-1837,[            } else if (st == VISITING) {],,topoSort,1856-1856,[            } else if (st == VISITING) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/tools/ant/Project.java,tsort,1936-1936,[            } else if (m == VISITING) {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/Project.java,fireMessageLoggedEvent,2242-2242,[            message = String.valueOf(message);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/Project.java,setProjectReference,2473-2473,[            if (method != null) {],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/tools/ant/Project.java,fireMessageLoggedEvent,2250-2250,[        if (isLoggingMessage.get() != Boolean.FALSE) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/Project.java,getProject,1755-1755,[        } catch (final Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/Project.java,createSubProject,276-276,[        } catch (final Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/Project.java,getReference,2061-2061,[            } catch (final Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/Project.java,,180-183,[    private final ThreadLocal<Boolean> isLoggingMessage = new ThreadLocal<Boolean>() {,             @Override,             protected Boolean initialValue() {,                 return Boolean.FALSE;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/ProjectComponentTest.java,,35-35,[        ProjectComponent pc = new ProjectComponent() {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/ProjectHelperRepository.java,getProjectHelperByService,192-192,[                isr = new InputStreamReader(is);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/ProjectHelperRepository.java,getHelperConstructor,242-242,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/ProjectHelperRepository.java,getProjectHelperByService,202-202,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/ProjectHelperRepository.java,next,327-327,[            } catch (Exception e) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/ProjectTest.java,setUp,61-61,[        root = new File(File.separator).getAbsolutePath().toUpperCase();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/ProjectTest.java,,307-307,[        p.log(new Task() {}, null, new Throwable(), Project.MSG_ERR);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/PropertyFileCLITest.java,testPropertyResolution,56-56,[            String l = FileUtils.safeReadFully(fr = new FileReader(log));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/PropertyFileCLITest.java,testPropertyResolution,43-43,[            fw = new FileWriter(props);],,testPropertyResolution,46-46,[            fw = new FileWriter(build);],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/tools/ant/PropertyHelper.java,copyInheritedProperties,985-985,[                String arg = e.nextElement().toString();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/PropertyHelper.java,,344-344,[        return project;],,,789-789,[        if (project != null) {],,,790-790,[            project.log("Setting ro project property: " + name + " -> "],,,483-483,[        if (project != null && name.startsWith("toString:")) {],,,485-485,[            Object v = project.getReference(name);],,,336-336,[        this.project = p;],,,745-745,[        if (project != null) {],,,746-746,[            project.log("Setting ro project property: "],,,647-647,[            if (project != null && verbose) {],,,641-641,[                if (project != null && verbose) {],,,642-642,[                    project.log("Override ignored for user property \""],,,652-652,[                project.log("Setting project property: " + name + " -> "],,,649-649,[                    project.log("Overriding previous definition of property \""],,,700-700,[            if (project != null && properties.containsKey(name)) {],,,705-705,[            if (project != null) {],,,706-706,[                project.log("Setting project property: " + name],,,701-701,[                project.log("Override ignored for property \"" + name],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/tools/ant/PropertyHelper.java,toBoolean,1169-1169,[        return null;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/tools/ant/PropertyHelper.java,setProperty,640-640,[            if (userProperties.containsKey(name)) {],,setProperty,655-655,[            if (name != null && value != null) {],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/tools/ant/PropertyHelper.java,,175-175,[        private final String PREFIX = "toString:";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/tools/ant/PropertyHelper.java,,239-239,[        private final String PREFIX = "ant.refid:";],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/RuntimeConfigurable.java,,601-601,[        if (r.characters != null) {],,,602-602,[            if (characters == null],,,604-604,[                characters = new StringBuffer(r.characters.toString());],,,424-424,[        return (characters == null) ? new StringBuffer(0) : characters;],,,394-394,[        characters = (characters == null)],,,395-395,[            ? new StringBuffer(data) : characters.append(data);],,,551-551,[        if (characters != null) {],,,552-552,[            ProjectHelper.addText(p, wrappedObject, characters.substring(0));],,,411-411,[        characters = ((characters == null)],,,412-412,[            ? new StringBuffer(count) : characters).append(buf, start, count);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/RuntimeConfigurable.java,,591-591,[        if (r.children != null) {],,,593-593,[            newChildren.addAll(r.children);],,,594-594,[            if (children != null) {],,,597-597,[            children = newChildren;],,,595-595,[                newChildren.addAll(children);],,,380-380,[        return (children == null) ? new CollectionUtils.EmptyEnumeration<RuntimeConfigurable>()],,,358-358,[        children = (children == null) ? new ArrayList<RuntimeConfigurable>() : children;],,,359-359,[        children.add(child);],,,371-371,[        return children.get(index);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/RuntimeConfigurable.java,,179-179,[        if (!namespacedAttribute) {],,,288-288,[            namespacedAttribute = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/RuntimeConfigurable.java,,567-567,[        proxyConfigured = false;],,,117-117,[        proxyConfigured = false;],,,487-487,[        if (proxyConfigured) {],,,558-558,[        proxyConfigured = true;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/TaskAdapter.java,execute,127-127,[            if (setLocationM != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/TaskAdapter.java,execute,142-142,[            if (setProjectM != null) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/UnknownElement.java,similar,621-621,[        if (!qname.equals(other.qname)) {],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/UnknownElementTest.java,XtestTaskFinishedEvent,59-81,[        buildRule.getProject().addBuildListener(new BuildListener() {,                 public void buildStarted(BuildEvent event) {},                 public void buildFinished(BuildEvent event) {},                 public void targetStarted(BuildEvent event) {},                 public void targetFinished(BuildEvent event) {},                 public void taskStarted(BuildEvent event) {,                     assertTaskProperties(event.getTask());,                 },                 public void taskFinished(BuildEvent event) {,                     assertTaskProperties(event.getTask());,                 },                 public void messageLogged(BuildEvent event) {},                 private void assertTaskProperties(Task ue) {,                     assertNotNull(ue);,                     assertTrue(ue instanceof UnknownElement);,                     Task t = ((UnknownElement) ue).getTask();,                     assertNotNull(t);,                     assertEquals("org.apache.tools.ant.taskdefs.Echo",,                                  t.getClass().getName());,                 },             });,         buildRule.executeTarget("echo");,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/UnknownElementTest.java,,59-78,[        buildRule.getProject().addBuildListener(new BuildListener() {,                 public void buildStarted(BuildEvent event) {},                 public void buildFinished(BuildEvent event) {},                 public void targetStarted(BuildEvent event) {},                 public void targetFinished(BuildEvent event) {},                 public void taskStarted(BuildEvent event) {,                     assertTaskProperties(event.getTask());,                 },                 public void taskFinished(BuildEvent event) {,                     assertTaskProperties(event.getTask());,                 },                 public void messageLogged(BuildEvent event) {},                 private void assertTaskProperties(Task ue) {,                     assertNotNull(ue);,                     assertTrue(ue instanceof UnknownElement);,                     Task t = ((UnknownElement) ue).getTask();,                     assertNotNull(t);,                     assertEquals("org.apache.tools.ant.taskdefs.Echo",,                                  t.getClass().getName());,                 }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/UnknownElementTest.java,execute,89-89,[            parent.fromChild();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/XmlLogger.java,setOutputPrintStream,446-446,[        this.outStream = new PrintStream(output, true);],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/dispatch/DispatchUtils.java,execute,57-57,[                        mName = "get" + name.trim().substring(0, 1).toUpperCase();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/dispatch/DispatchUtils.java,execute,102-102,[                if (executeM == null) {],,execute,72-72,[                                    if (executeM == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/dispatch/DispatchUtils.java,execute,63-63,[                        if (actionM != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/dispatch/DispatchUtils.java,execute,67-67,[                                if (s != null && s.trim().length() > 0) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/filters/BaseParamFilterReader.java,setParameters,62-62,[        this.parameters = parameters;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/filters/ConcatFilter.java,initialize,209-209,[            prependReader = new BufferedReader(new FileReader(prepend));],,initialize,215-215,[            appendReader = new BufferedReader(new FileReader(append));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/filters/ExpandProperties.java,,103-106,[                    getProperty = new GetProperty() {, ,                         public Object getProperty(String name) {,                             return props.getProperty(name);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/filters/FixCrLfFilter.java,,282-282,[        initialized = true;],,,296-296,[        if (!initialized) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/tools/ant/filters/FixCrLfFilter.java,read,638-679,[                switch (thisChar) {,                 case CTRLZ:,                     int c = super.read();,                     if (c == -1) {,                         atEnd = true;,                         if (fixLast && !previousWasEOL) {,                             numEOL = 1;,                             push(thisChar);,                         },                     } else {,                         push(c);,                     },                     break;,                 case -1:,                     atEnd = true;,                     if (fixLast && !previousWasEOL) {,                         numEOL = 1;,                     },                     break;,                 case '\n':,                     // EOL was "\n",                     numEOL = 1;,                     break;,                 case '\r':,                     numEOL = 1;,                     int c1 = super.read();,                     int c2 = super.read();, ,                     if (c1 == '\r' && c2 == '\n') {,                         // EOL was "\r\r\n",                     } else if (c1 == '\r') {,                         // EOL was "\r\r" - handle as two consecutive "\r" and,                         // "\r",                         numEOL = 2;,                         push(c2);,                     } else if (c1 == '\n') {,                         // EOL was "\r\n",                         push(c2);,                     } else {,                         // EOL was "\r",                         push(c2);,                         push(c1);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/filters/ReplaceTokens.java,read,119-119,[                resolvedTokens.put(beginToken + key + endToken, hash.get(key));],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/tools/ant/filters/SortFilter.java,compare,365-365,[                            return (-s1.compareTo(s2));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/filters/SortFilter.java,,363-365,[                Collections.sort(lines, new Comparator<String>() {,                         public int compare(String s1, String s2) {,                             return (-s1.compareTo(s2));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/filters/TokenFilterTest.java,getFileString,259-259,[            r = new FileReader(FILE_UTILS.resolveFile(buildRule.getProject().getBaseDir(),filename));],,
CORRECTNESS,GC_UNRELATED_TYPES,org/apache/tools/ant/filters/TokenFilterTest.java,testScriptFilter,231-231,[                buildRule.getProject().getTargets().contains("testScriptFilter"));],,
CORRECTNESS,GC_UNRELATED_TYPES,org/apache/tools/ant/filters/TokenFilterTest.java,testScriptFilter2,239-239,[    	Assume.assumeTrue("Project does not have 'testScriptFilter' target", buildRule.getProject().getTargets().contains("testScriptFilter"));],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/filters/TokenFilterTest.java,filter,274-274,[            return token.substring(0, 1).toUpperCase() +],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/filters/util/ChainReaderHelper.java,,167-178,[            : new FilterReader(finalReader) {,                     public void close() throws IOException {,                         FileUtils.close(in);,                         cleanUpClassLoaders(classLoadersToCleanUp);,                     },                     protected void finalize() throws Throwable {,                         try {,                             close();,                         } finally {,                             super.finalize();,                         },                     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/helper/ProjectHelper2.java,parse,268-268,[            if (uri != null) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/helper/ProjectHelperImpl.java,configureId,1023-1023,[            project.addReference(id, target);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/helper/ProjectHelperImpl.java,handleElement,604-604,[        } else if (helperImpl.project.getDataTypeDefinitions().get(elementName) != null) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/input/DefaultInputHandler.java,handleInput,52-52,[            r = new BufferedReader(new InputStreamReader(getInputStream()));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/input/GreedyInputHandler.java,handleInput,67-67,[            request.setInput(new String(baos.toByteArray()));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/input/InputRequest.java,setDefaultValue,90-91,[        defaultValue = d;,     }],,setDefaultvalue,188-189,[        this.defaultvalue = defaultvalue;,     }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/input/PropertyFileInputHandler.java,,57-57,[        Object o = props.get(request.getPrompt());],,,73-73,[        if (props == null) {],,,82-82,[            props = new Properties();],,,85-85,[                props.load(new FileInputStream(propsFile));],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/input/PropertyFileInputHandler.java,readProps,85-85,[                props.load(new FileInputStream(propsFile));],,readProps,88-88,[            }],,readProps,90-90,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/input/PropertyFileInputHandler.java,readProps,85-85,[                props.load(new FileInputStream(propsFile));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/input/SecureInputHandler.java,handleInput,54-54,[        } catch (Exception e) {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/launch/Launcher.java,,68-68,[    public static boolean launchDiag = false;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/launch/Launcher.java,run,225-225,[                launchDiag = true;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/launch/Locator.java,getToolsJar,428-428,[            } catch (Exception e2) {],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/launch/Locator.java,getLocationURLs,522-522,[        urls = new URL[matches.length];],,getLocationURLs,510-510,[        File[] matches = location.listFiles(],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/listener/AnsiColorLogger.java,setColors,166-166,[                in = getClass().getResourceAsStream(systemColorFile);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/property/ResolvePropertyMap.java,getProperty,102-102,[            return parseProperties.parseProperties((String) map.get(recursiveCallKey));],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,removeCvsPassword,459-459,[            int stop = cmdLine.indexOf("@", start);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,getErrorStream,244-244,[                                           new FileOutputStream(error.getPath(),],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,getOutputStream,205-205,[                                                                 .getPath(),],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,setCvsRoot,482-489,[        if (root != null) {,             if (root.trim().equals("")) {,                 root = null;,             },         }, ,         this.cvsRoot = root;,     }],,setCvsroot,151-152,[        this.cvsRoot = cvsRoot;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,setFailOnError,742-743,[        this.failOnError = failOnError;,     }],,setFailonerror,214-215,[        failOnError = fail;,     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,runCommand,340-340,[            dest.mkdirs();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/AbstractJarSignerTask.java,addFileset,208-209,[        filesets.addElement(set);,     }],,addFileSet,109-110,[        filesets.add(fileset);,     }],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/Ant.java,copyReference,588-588,[        } catch (Exception e) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/Ant.java,execute,461-461,[                } catch (final Exception ex) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Ant.java,initializeProject,209-209,[                out = new PrintStream(new FileOutputStream(outfile));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Ant.java,setInheritAll,152-153,[        inheritAll = value;,     }],,setInheritall,428-429,[        this.inheritAll = b;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Ant.java,setInheritRefs,161-162,[        inheritRefs = value;,     }],,setInheritrefs,438-439,[        this.inheritRefs = b;,     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/Ant.java,copyReference,584-584,[            if (cloneM != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/Ant.java,copyReference,599-599,[                if (setProjectM != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/Ant.java,copyReference,588-588,[        } catch (Exception e) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/AntStructure.java,execute,96-96,[                out = new PrintWriter(new FileWriter(output));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/AntStructure.java,printElementDecl,407-407,[                    } catch (final Exception x) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/AntStructureTest.java,printTail,111-111,[            p.log(TAIL_CALLED);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/AntTest.java,testRefId,283-296,[        Path testPath = new Path(buildRule.getProject());,         testPath.createPath().setPath(System.getProperty("java.class.path"));,         PropertyChecker pc =,             new PropertyChecker("testprop",,                                 new String[] {null,,                                               testPath.toString()});,         buildRule.getProject().addBuildListener(pc);,         buildRule.executeTarget("testRefid");,         AssertionFailedError ae = pc.getError();,         if (ae != null) {,             throw ae;,         },         buildRule.getProject().removeBuildListener(pc);,     }],,testRefid,83-84,[        buildRule.executeTarget("testRefid");,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/AntTest.java,,411-440,[        private int calls = 0;,         private AssertionFailedError error;, ,         BasedirChecker(String[] dirs) {,             expectedBasedirs = dirs;,         }, ,         public void buildStarted(BuildEvent event) {},         public void buildFinished(BuildEvent event) {},         public void targetFinished(BuildEvent event){},         public void taskStarted(BuildEvent event) {},         public void taskFinished(BuildEvent event) {},         public void messageLogged(BuildEvent event) {}, ,         public void targetStarted(BuildEvent event) {,             if (event.getTarget().getName().equals("")) {,                 return;,             },             if (error == null) {,                 try {,                     assertEquals(expectedBasedirs[calls++],,                                  event.getProject().getBaseDir().getAbsolutePath());,                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/AntTest.java,,518-557,[        InputHandlerChecker(InputHandler value) {,             ih = value;,         }, ,         public void buildStarted(BuildEvent event) {,             check(event);,         },         public void buildFinished(BuildEvent event) {,             check(event);,         },         public void targetFinished(BuildEvent event) {,             check(event);,         },         public void taskStarted(BuildEvent event) {,             check(event);,         },         public void taskFinished(BuildEvent event) {,             check(event);,         },         public void messageLogged(BuildEvent event) {,             check(event);,         }, ,         public void targetStarted(BuildEvent event) {,             check(event);,         }, ,         private void check(BuildEvent event) {,             if (error == null) {,                 try {,                     assertNotNull(event.getProject().getInputHandler());,                     assertSame(ih, event.getProject().getInputHandler());,                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/AntTest.java,,565-601,[        private int calls = 0;,         private AssertionFailedError error;, ,         PropertyChecker(String key, String[] values) {,             this.key = key;,             this.expectedValues = values;,         }, ,         public void buildStarted(BuildEvent event) {},         public void buildFinished(BuildEvent event) {},         public void targetFinished(BuildEvent event){},         public void taskStarted(BuildEvent event) {},         public void taskFinished(BuildEvent event) {},         public void messageLogged(BuildEvent event) {}, ,         public void targetStarted(BuildEvent event) {,             if (event.getTarget().getName().equals("")) {,                 return;,             },             if (calls >= expectedValues.length) {,                 error = new AssertionFailedError("Unexpected invocation of",                                                  + " target ",                                                  + event.getTarget().getName());,             }, ,             if (error == null) {,                 try {,                     assertEquals(expectedValues[calls++],,                                  event.getProject().getProperty(key));,                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/AntTest.java,,449-509,[        private int calls = 0;,         private AssertionFailedError error;, ,         ReferenceChecker(String[] keys, boolean[] expectSame, Object value) {,             this.keys = keys;,             this.expectSame = expectSame;,             this.value = value;,         }, ,         public void buildStarted(BuildEvent event) {},         public void buildFinished(BuildEvent event) {},         public void targetFinished(BuildEvent event){},         public void taskStarted(BuildEvent event) {},         public void taskFinished(BuildEvent event) {},         public void messageLogged(BuildEvent event) {}, ,         public void targetStarted(BuildEvent event) {,             if (event.getTarget().getName().equals("")) {,                 return;,             },             if (error == null) {,                 try {,                     String msg =,                         "Call " + calls + " refid=\'" + keys[calls] + "\'";,                     if (value == null) {,                         Object o = event.getProject().getReference(keys[calls]);,                         if (expectSame[calls++]) {,                             assertNull(msg, o);,                         } else {,                             assertNotNull(msg, o);,                         },                     } else {,                         // a rather convoluted equals() test,                         Path expect = (Path) value;,                         Path received = (Path) event.getProject().getReference(keys[calls]);,                         boolean shouldBeEqual = expectSame[calls++];,                         if (received == null) {,                             assertTrue(msg, !shouldBeEqual);,                         } else {,                             String[] l1 = expect.list();,                             String[] l2 = received.list();,                             if (l1.length == l2.length) {,                                 for (int i=0; i<l1.length; i++) {,                                     if (!l1[i].equals(l2[i])) {,                                         assertTrue(msg, !shouldBeEqual);,                                     },                                 },                                 assertTrue(msg, shouldBeEqual);,                             } else {,                                 assertTrue(msg, !shouldBeEqual);,                             },                         },                     },                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Available.java,setClasspathRef,100-101,[        createClasspath().setRefid(r);,     }],,setClasspathref,146-150,[        if (isReference()) {,             throw tooManyAttributes();,         },         createClasspath().setRefid(r);,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Available.java,setIgnoresystemclasses,221-222,[        this.ignoreSystemclasses = ignore;,     }],,setIgnoreSystemClasses,101-102,[        this.ignoreSystemClasses = ignoreSystemClasses;,     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Available.java,checkFile,345-345,[                    && (filename.equals(paths[i])],,checkFile,365-365,[                    && filename.equals(parent.getAbsolutePath())) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Available.java,getValues,492-492,[            return VALUES;],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/BZip2Test.java,testRealTest,81-81,[        originalIn = new CBZip2InputStream(originalIn);],,testRealTest,82-82,[        actualIn   = new CBZip2InputStream(actualIn);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/CVSPass.java,execute,103-103,[                reader = new BufferedReader(new FileReader(passFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/CVSPass.java,execute,119-119,[            writer = new BufferedWriter(new FileWriter(passFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Checksum.java,generateChecksums,539-539,[                                                }).getBytes());],,generateChecksums,540-540,[                        fos.write(StringUtils.LINE_SEP.getBytes());],,generateChecksums,569-569,[                    messageDigest.update(fileName.getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Checksum.java,readChecksum,634-634,[            diskChecksumReader = new BufferedReader(new FileReader(f));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Checksum.java,setForceOverwrite,239-240,[        this.forceOverwrite = forceOverwrite;,     }],,setForceoverwrite,90-91,[        forceOverwrite = force;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Checksum.java,setTodir,174-175,[        this.todir = todir;,     }],,setToDir,209-210,[        this.toDir = toDir;,     }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/Checksum.java,generateChecksums,485-485,[                DigestInputStream dis = new DigestInputStream(fis,],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Checksum.java,getChecksumFile,459-459,[            directory.mkdirs();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/tools/ant/taskdefs/Classloader.java,execute,205-205,[                if (name == null) {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/CommandLauncherTask.java,setVmLauncher,53-54,[        this.vmLauncher = vmLauncher;,     }],,setVMLauncher,582-583,[        this.vmLauncher = vmLauncher;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Concat.java,setDestfile,545-546,[        setDest(new FileResource(destinationFile));,     }],,setDestFile,163-164,[        this.tarFile = destFile;,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Concat.java,getReader,497-497,[            return new BufferedReader(encoding == null],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Concat.java,,503-505,[    private ReaderFactory<Reader> identityReaderFactory = new ReaderFactory<Reader>() {,         public Reader getReader(Reader o) {,             return o;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/tools/ant/types/Resource.java,equals,287-291,[        if (isReference()) {,             return getCheckedRef().equals(other);,         },         return other != null && other.getClass().equals(getClass()),             && compareTo((Resource) other) == 0;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Concat.java,setFile,139-139,[                    reader = new BufferedReader(new FileReader(file));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/ConcatTest.java,test3,112-112,[            file.delete();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/tools/ant/taskdefs/ConcatTest.java,expectFileContainsx,306-312,[        buildRule.executeTarget(target);,         String content = FileUtilities.getFileContents(buildRule.getProject(), filename);,         assertTrue(,             "expecting file " + filename + " to contain " +,             contains +,             " but got " + content, content.indexOf(contains) > -1);,     }],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/Copy.java,<clinit>,72-72,[    static final File NULL_FILE_PLACEHOLDER = new File("/NULL_FILE");],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Copy.java,,828-830,[                                                          new ResourceFactory() {,                                             public Resource getResource(final String name) {,                                                 return new FileResource(toDir, name);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/CopyPath.java,setDestDir,75-76,[        this.destDir = destDir;,     }],,setDestdir,136-137,[        this.destDir = destDir;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/CopyPath.java,setPathRef,107-108,[        createPath().setRefid(r);,     }],,setPathref,148-151,[            Path p = new Path(getProject());,             p.setRefid(value);,             parts = new String[] {p.toString()};,         }],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/CopyPath.java,,66-66,[    private long granularity = FILE_UTILS.getFileTimestampGranularity();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/CopyPath.java,execute,184-184,[            String[] toFiles = (String[]) mapper.mapFileName(sourceFileName);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/CopyPath.java,execute,174-174,[        String[] sourceFiles = path.list();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/CopyTest.java,testFileResourceWithFilter,222-222,[            String file1Content = FileUtils.readFully(new FileReader(file1));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/CopyTest.java,testDirset,253-254,[        buildRule.executeTarget("testDirset");,     }],,testDirSet,556-565,[        Path p = new Path(project);,         DirSet d = new DirSet();,         d.setProject(project);,         d.setDir(project.resolveFile("."));,         d.setIncludes("build");,         p.addDirset(d);,         String[] l = p.list();,         assertEquals(1, l.length);,         assertEquals(project.resolveFile("build").getAbsolutePath(), l[0]);,     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/CopyfileTest.java,test5,85-85,[            f.delete();],,
PERFORMANCE,DMI_COLLECTION_OF_URLS,org/apache/tools/ant/taskdefs/Definer.java,execute,267-267,[                    if (RESOURCE_STACK.get().get(url) != null) {],,execute,272-272,[                            + RESOURCE_STACK.get().get(url),],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Definer.java,fileToURL,322-322,[        if (!(file.exists())) {],,
PERFORMANCE,DMI_COLLECTION_OF_URLS,org/apache/tools/ant/taskdefs/Definer.java,,57-59,[    private static final ThreadLocal<Map<URL, Location>> RESOURCE_STACK = new ThreadLocal<Map<URL, Location>>() {,         protected Map<URL, Location> initialValue() {,             return new HashMap<URL, Location>();],,
PERFORMANCE,DMI_COLLECTION_OF_URLS,org/apache/tools/ant/taskdefs/Definer.java,initialValue,59-59,[            return new HashMap<URL, Location>();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Delete.java,execute,694-694,[                    if (!(f.isDirectory()) || f.list().length == 0) {],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Deltree.java,removeDir,94-94,[        for (int i = 0; i < list.length; i++) {],,removeDir,93-93,[        String[] list = dir.list();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/EchoTest.java,<init>,93-93,[            this.setOutputPrintStream(new PrintStream(new ByteArrayOutputStream(256)));],,<init>,94-94,[            this.setErrorPrintStream(new PrintStream(new ByteArrayOutputStream(256)));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/EchoTest.java,,90-102,[        public EchoTestLogger() {,             super();,             this.setMessageOutputLevel(Project.MSG_DEBUG);,             this.setOutputPrintStream(new PrintStream(new ByteArrayOutputStream(256)));,             this.setErrorPrintStream(new PrintStream(new ByteArrayOutputStream(256)));,         }, ,         /**,          * {@inheritDoc},          */,         protected void log(String message) {,             this.lastLoggedMessage = message;,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Exec.java,run,135-135,[                fos = new PrintWriter(new FileWriter(out));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Exec.java,<init>,249-249,[            this.din = new BufferedReader(new InputStreamReader(is));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/ExecTask.java,setTimeout,128-128,[            (Long) ((value == null) ? null : new Long(value.intValue())));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ExecTask.java,setOutputproperty,245-247,[        redirector.setOutputProperty(outputProp);,         incompatibleWithSpawn = true;,     }],,setOutputProperty,418-425,[        if (outputProperty == null,                 || !(outputProperty.equals(this.outputProperty))) {,             synchronized (outMutex) {,                 this.outputProperty = outputProperty;,                 baos = null;,             },         },     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ExecTaskTest.java,testspawn,70-103,[        buildRule.getProject().executeTarget("setUp");,         Assume.assumeNotNull(buildRule.getProject().getProperty("test.can.run"));,         myBuild = new MonitoredBuild(new File(System.getProperty("root"), BUILD_FILE), "spawn");,         logFile = FILE_UTILS.createTempFile("spawn", "log", new File(buildRule.getProject().getProperty("output")),,                 false, false);,         // this is guaranteed by FileUtils#createTempFile,         assertTrue("log file not existing", !logFile.exists());,         // make the spawned process run 1 seconds,         myBuild.setTimeToWait(TIME_TO_WAIT);,         myBuild.setLogFile(logFile.getAbsolutePath());,         myBuild.addBuildListener(new MonitoredBuildListener());,         myBuild.start();,         GregorianCalendar startwait = new GregorianCalendar();,         // this loop runs parallel to the build,         while (!buildFinished) {,             Thread.sleep(10);,             GregorianCalendar now = new GregorianCalendar();,             // security,             if (now.getTime().getTime() - startwait.getTime().getTime() > MAX_BUILD_TIME) {,                 System.out.println("aborting wait, too long ",                         + (now.getTime().getTime() - startwait.getTime().getTime()),                         + "milliseconds");,                 break;,             },         },         // now wait until the spawned process is finished,         Thread.sleep((TIME_TO_WAIT) * 1000 + SECURITY_MARGIN);,         // time of the build in milli seconds,         long elapsed = myBuild.getTimeElapsed();,         assertTrue("we waited more than the process lasted",,                 TIME_TO_WAIT * 1000 + SECURITY_MARGIN > elapsed);,         logFile = new File(logFile.getAbsolutePath());,         assertTrue("log file found after spawn", logFile.exists());,     }],,testSpawn,235-252,[        File logFile = FILE_UTILS.createTempFile("spawn", "log",,                 new File(buildRule.getProject().getProperty("output")), false, false);,         // this is guaranteed by FileUtils#createTempFile,         assertTrue("log file not existing", !logFile.exists());,         buildRule.getProject().setProperty("logFile", logFile.getAbsolutePath());,         buildRule.getProject().setProperty("timeToWait", Long.toString(TIME_TO_WAIT));,         buildRule.getProject().executeTarget("testSpawn");, ,         Thread.sleep(TIME_TO_WAIT * 1000 + SECURITY_MARGIN);, , ,         // let's be nice with the next generation of developers,         if (!logFile.exists()) {,             System.out.println("suggestion: increase the constant",             + " SECURITY_MARGIN to give more time for java to start.");,         },         assertTrue("log file exists", logFile.exists());,     }],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/Execute.java,getProcEnvCommand,212-212,[            if (new File("/bin/env").canRead()) {],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/Execute.java,getProcEnvCommand,214-214,[            } else if (new File("/usr/bin/env").canRead()) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/Execute.java,patchEnvironment,629-629,[                    if (osEnvItem.toLowerCase().equals(key.toLowerCase())) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Execute.java,toString,257-257,[        return bos.toString();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Execute.java,getCommandline,313-313,[        return cmdl;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/Execute.java,setCommandline,322-322,[        cmdl = commandline;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/Execute.java,setEnvironment,351-351,[        this.env = env;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/taskdefs/Execute.java,getProcEnvCommand,229-229,[            return null;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/Execute.java,getEnvironmentVariables,147-147,[                        var += lineSep + line;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/Execute.java,getVMSLogicals,709-709,[                    logValue += "," + line.substring(4, line.length() - 1);],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/tools/ant/taskdefs/Execute.java,getEnvironmentVariables,128-128,[            if (retval != 0) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Execute.java,,510-514,[        OutputStream dummyOut = new OutputStream() {,             @Override,             public void write(int b) throws IOException {,                 // Method intended to swallow whatever comes at it,             }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/ExecuteJava.java,,155-155,[                thread = new Thread(this, "ExecuteJava");],,,159-159,[                project.registerThreadTask(thread, currentThreadTask);],,,164-164,[                thread.setDaemon(true);],,,168-168,[                    thread.start();],,,179-179,[                        thread = null;],,,242-242,[        if (thread != null) {],,,244-244,[            thread.interrupt();],,
MT_CORRECTNESS,NN_NAKED_NOTIFY,org/apache/tools/ant/taskdefs/ExecuteJava.java,run,231-231,[                notifyAll();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/ExecuteJava.java,execute,144-144,[            if (main == null) {],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/tools/ant/taskdefs/ExecuteJava.java,execute,171-171,[                        wait();],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/tools/ant/taskdefs/ExecuteJava.java,execute,171-171,[                        wait();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ExecuteJavaTest.java,testNoTimeOut,67-71,[        Commandline cmd = getCommandline(TIME_OUT/2);,         ej.setJavaCommand(cmd);,         ej.execute(project);,         assertTrue("process should not have been killed", !ej.killedProcess());,     }],,testNoTimeout,82-84,[       buildRule.executeTarget("notimeout");,    	   assertNull(buildRule.getProject().getProperty("timeout"));,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ExecuteJavaTest.java,testTimeOut,76-89,[        Commandline cmd = getCommandline(TIME_OUT*2);,         ej.setJavaCommand(cmd);,         long now = System.currentTimeMillis();,         ej.execute(project);,         long elapsed = System.currentTimeMillis() - now;,         assertTrue("process should have been killed", ej.killedProcess());, ,         assertTrue("elapse time of "+elapsed,                    +" ms is less than timeout value of "+TIME_OUT_TEST+" ms",,                    elapsed >= TIME_OUT_TEST);,         assertTrue("elapse time of "+elapsed,                    +" ms is greater than run value of "+(TIME_OUT*2)+" ms",,                    elapsed < TIME_OUT*2);,     }],,testTimeout,76-78,[    	buildRule.executeTarget("timeout");,     	assertEquals("true", buildRule.getProject().getProperty("timeout"));,     }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/ExecuteWatchdogTest.java,testTimeOut,113-113,[        int retCode = process.waitFor();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/ExecuteWatchdogTest.java,getErrorOutput,77-77,[        BufferedReader err = new BufferedReader( new InputStreamReader(p.getErrorStream()) );],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/ExecuteWatchdogTest.java,getErrorOutput,77-77,[        BufferedReader err = new BufferedReader( new InputStreamReader(p.getErrorStream()) );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/ExecuteWatchdogTest.java,,137-145,[        Thread thread = new Thread(){,                 public void run(){,                     try {,                         process.waitFor();,                     } catch(InterruptedException e){,                         // not very nice but will do the job,                         throw new AssumptionViolatedException("process interrupted in thread", e);,                     },                 }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Exit.java,setStatus,119-119,[        status = new Integer(i);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Exit.java,testNestedCondition,224-224,[        return result && nestedCondition.eval();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Expand.java,extractFile,329-329,[                dirF.mkdirs();],,extractFile,333-333,[                f.mkdirs();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/FilterTest.java,getFilteredFile,133-133,[                in = new BufferedReader(new FileReader(f));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/FilterTest.java,getFilteredFile,133-133,[                in = new BufferedReader(new FileReader(f));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/FilterTest.java,getFilteredFile,144-144,[        f.delete();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/FixCRLF.java,setSrcdir,127-128,[        this.srcDir = srcDir;,     }],,setSrcDir,98-99,[        this.srcDir = srcDir;,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/FixCRLF.java,<init>,422-422,[                    ((encoding == null) ? new FileReader(srcFile)],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/FixCrLfTest.java,assertEqualContent,243-243,[            inExpect = new BufferedInputStream(new FileInputStream(expect));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/GenerateKey.java,setSigalg,269-270,[        this.sigalg = sigalg;,     }],,setSigAlg,339-340,[        this.sigAlg = sigAlg;,     }],,
STYLE,RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE,org/apache/tools/ant/taskdefs/GenerateKey.java,execute,365-365,[        if (null != storepass) {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Get.java,setUsername,393-394,[        this.uname = u;,     }],,setUserName,159-160,[        this.userName = userName;,     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Get.java,checkAttributes,306-306,[            destination.mkdirs();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Get.java,openConnection,711-711,[                encoding = encoder.encode(up.getBytes());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Get.java,closeStreams,879-879,[                dest.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Get.java,downloadFile,834-834,[                    dest.delete();],,
PERFORMANCE,DMI_BLOCKING_METHODS_ON_URL,org/apache/tools/ant/taskdefs/ImportTask.java,isOneOf,310-310,[                if (up != null && up.getURL().equals(importedURL)) {],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/ImportTest.java,testSymlinkedImports,138-138,[        if (!new File(ln).exists()) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/ImportTest.java,testSymlinkedImports,159-159,[            symlinkFile.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/InitializeClassTest.java,testAll,59-59,[            PrintStream newps = new PrintStream(new FileOutputStream(f2));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/InitializeClassTest.java,tearDown,74-74,[        f1.delete();],,tearDown,75-75,[        f2.delete();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Input.java,getRefid,67-67,[            return refid;],,getRefId,78-78,[        return refid;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Input.java,setRefid,60-61,[            this.refid = refid;,         }],,setRefId,70-71,[        refid = id;,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Input.java,,48-113,[    public class Handler extends DefBase {, ,         private String refid = null;,         private HandlerType type = null;,         private String classname = null;, ,         /**,          * Specify that the handler is a reference on the project;,          * this allows the use of a custom inputhandler.,          * @param refid the String refid.,          */,         public void setRefid(final String refid) {,             this.refid = refid;,         },         /**,          * Get the refid of this Handler.,          * @return String refid.,          */,         public String getRefid() {,             return refid;,         },         /**,          * Set the InputHandler classname.,          * @param classname the String classname.,          */,         public void setClassname(final String classname) {,             this.classname = classname;,         },         /**,          * Get the classname of the InputHandler.,          * @return String classname.,          */,         public String getClassname() {,             return classname;,         },         /**,          * Set the handler type.,          * @param type a HandlerType.,          */,         public void setType(final HandlerType type) {,             this.type = type;,         },         /**,          * Get the handler type.,          * @return a HandlerType object.,          */,         public HandlerType getType() {,             return type;,         },         private InputHandler getInputHandler() {,             if (type != null) {,                return type.getInputHandler();,             },             if (refid != null) {,                try {,                    return (InputHandler) (getProject().getReference(refid));,                } catch (final ClassCastException e) {,                    throw new BuildException(,                        refid + " does not denote an InputHandler", e);,                },             },             if (classname != null) {,                return (InputHandler) (ClasspathUtils.newInstance(classname,,                    createLoader(), InputHandler.class));,             },             throw new BuildException(],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Input.java,getValues,134-134,[            return VALUES;],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/JDBCTask.java,isValidRdbms,269-269,[                String theVendor = dmd.getDatabaseProductName().toLowerCase();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/JDBCTask.java,getUserId,490-490,[        return userId;],,getUserID,59-59,[        return userID;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/JDBCTask.java,setUserid,498-499,[        this.userId = userId;,     }],,setUserId,653-654,[        userId = u;,     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/JDBCTask.java,isValidRdbms,272-272,[                if (theVendor == null || theVendor.indexOf(rdbms) < 0) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/JDBCTask.java,isValidRdbms,282-282,[                if (theVersion == null],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/Jar.java,grabManifests,1178-1178,[            Resource[][] resources = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Jar.java,filesetManifest,734-734,[                        isr = new InputStreamReader(is);],,filesetManifest,757-757,[                        isr = new InputStreamReader(is);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Jar.java,getManifest,311-311,[                isr = new InputStreamReader(fis);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Jar.java,setJarfile,229-230,[        setDestFile(jarFile);,     }],,setJarFile,150-155,[        File parent = jarfile.getParentFile();,         if (!parent.isDirectory()) {,             throw new BuildException("Jar's directory not found: " + parent);,         },         this.dir = parent;,     }],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/tools/ant/taskdefs/Jar.java,setFilesetmanifest,416-416,[        mergeManifestsMain = "merge".equals(config.getValue());],,setFilesetmanifest,418-418,[        if (filesetManifestConfig != null],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JarTest.java,testManifestStaysIntact,192-192,[        r1 = new FileReader(new File(getOutputDir(),],,testManifestStaysIntact,194-194,[        r2 = new FileReader(new File(getOutputDir(),],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/JarTest.java,testRootFilesInIndex,292-292,[            BufferedReader r = new BufferedReader(new InputStreamReader(is,],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Java.java,getCommandLine,953-953,[        return cmdl;],,getCommandline,1958-1962,[        if (commandline == null) {,             commandline = new CommandlineJava();,             commandline.setClassname("org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner");,         },         return commandline;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JavaTest.java,testReleasedInput,313-313,[        out.write("foo\n".getBytes());],,testReleasedInput,316-316,[            out.write("bar\n".getBytes());],,
STYLE,UC_USELESS_OBJECT,org/apache/tools/ant/taskdefs/JavaTest.java,testFlushedInput,338-338,[        final boolean[] timeout = new boolean[1];],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/JavaTest.java,,283-285,[        buildRule.getProject().setInputHandler(new DefaultInputHandler() {,             protected InputStream getInputStream() {,                 return in;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/JavaTest.java,,331-333,[        buildRule.getProject().setInputHandler(new DefaultInputHandler() {,             protected InputStream getInputStream() {,                 return in;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JavaTest.java,run,350-350,[                    out.write("foo-FlushedInput\n".getBytes());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/JavaTest.java,,341-354,[        Thread writingThread = new Thread(new Runnable() {,             public void run() {,                 try {,                     // wait a little bit to have the target executed,                     Thread.sleep(500);,                 } catch (InterruptedException e) {,                     throw new AssumptionViolatedException("Thread interrupted", e);,                 },                 try {,                     out.write("foo-FlushedInput\n".getBytes());,                 } catch (IOException e) {,                     throw new RuntimeException(e);,                 },             }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JavaTest.java,main,470-470,[            String line = new BufferedReader(new InputStreamReader(System.in)).readLine();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JavaTest.java,main,430-430,[                out = new OutputStreamWriter(fos);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/tools/ant/taskdefs/JavaTest.java,main,425-425,[            Thread.sleep(sleepTime * 1000);],,
CORRECTNESS,NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/JavaTest.java,main,434-434,[                try {out.close();} catch (IOException ioe) {}}],,main,424-424,[            OutputStreamWriter out = null;],,main,428-428,[                File dest = new File(logFile);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/JavaTest.java,main,432-432,[            } catch (Exception ex) {}],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Javac.java,lookForPackageInfos,1219-1219,[            packageInfos.put(pkg, new Long(f.lastModified()));],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Javac.java,getFileList,1014-1014,[        return compileList;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,createCompilerClasspath,884-884,[        return facade.getImplementationClasspath(getProject());],,createCompilerclasspath,340-343,[        if (compilerClasspath == null) {,             compilerClasspath = new Path(getProject());,         },         return compilerClasspath.createPath();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,getBootclasspath,373-373,[        return bootclasspath;],,getBootClassPath,641-645,[        final Path bp = new Path(project);,         if (bootclasspath != null) {,             bp.append(bootclasspath);,         },         return bp.concatSystemBootClasspath("ignore");],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,getDestdir,271-271,[        return destDir;],,getDestDir,152-152,[        return destDir;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,getNowarn,731-731,[        return nowarn;],,getNoWarn,217-217,[        return mNwarn;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,getSrcdir,253-253,[        return src;],,getSrcDir,137-137,[        return src;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,setNowarn,723-724,[        this.nowarn = flag;,     }],,setNoWarn,208-209,[        mNwarn = nwarn;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,setSrcdir,241-246,[        if (src == null) {,             src = srcDir;,         } else {,             src.append(srcDir);,         },     }],,setSrcDir,125-130,[        if (src == null) {,             src = srcDir;,         } else {,             src.append(srcDir);,         },     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Javac.java,generateMissingPackageInfoClasses,1233-1233,[            pkgBinDir.mkdirs();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javac.java,,1194-1202,[    public class ImplementationSpecificArgument extends,         org.apache.tools.ant.util.facade.ImplementationSpecificArgument {, ,         /**,          * @param impl the name of the compiler,          */,         public void setCompiler(final String impl) {,             super.setImplementation(impl);,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Javadoc.java,doJava14,2156-2156,[                            final BufferedReader in],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Javadoc.java,execute,1766-1766,[                wr = new FileWriter(tmpList.getAbsolutePath(), true);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Javadoc.java,writeExternalArgs,1962-1962,[                new FileWriter(optionsTmpFile.getAbsolutePath(), true));],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Javadoc.java,parsePackages,2442-2442,[                if (files.length > 0) {],,parsePackages,2434-2434,[                final String[] files = pd.list(new FilenameFilter () {],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/Javadoc.java,doJava14,2156-2156,[                            final BufferedReader in],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/Javadoc.java,postProcess,2538-2538,[                    final OutputStreamWriter w = new OutputStreamWriter(fos, enc);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/Javadoc.java,getPackages,2121-2121,[                if (title == null || packages == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/Javadoc.java,writeExternalArgs,1979-1979,[            if (optionsTmpFile != null) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Javadoc.java,execute,1778-1778,[            tmpList.delete();],,execute,1820-1820,[                tmpList.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Javadoc.java,writeExternalArgs,1980-1980,[                optionsTmpFile.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,98-141,[    public class DocletParam {,         /** The parameter name */,         private String name;, ,         /** The parameter value */,         private String value;, ,         /**,          * Set the name of the parameter.,          *,          * @param name the name of the doclet parameter,          */,         public void setName(final String name) {,             this.name = name;,         }, ,         /**,          * Get the parameter name.,          *,          * @return the parameter's name.,          */,         public String getName() {,             return name;,         }, ,         /**,          * Set the parameter value.,          *,          * Note that only string values are supported. No resolution of file,          * paths is performed.,          *,          * @param value the parameter value.,          */,         public void setValue(final String value) {,             this.value = value;,         }, ,         /**,          * Get the parameter value.,          *,          * @return the parameter value.,          */,         public String getValue() {,             return value;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,1475-1541,[        private final Vector<PackageName> packages = new Vector<PackageName>();, ,         /** Constructor for GroupArgument */,         public GroupArgument() {,             //empty,         }, ,         /**,          * Set the title attribute using a string.,          * @param src a <code>String</code> value,          */,         public void setTitle(final String src) {,             final Html h = new Html();,             h.addText(src);,             addTitle(h);,         },         /**,          * Set the title attribute using a nested Html value.,          * @param text a <code>Html</code> value,          */,         public void addTitle(final Html text) {,             title = text;,         }, ,         /**,          * Get the title.,          * @return the title,          */,         public String getTitle() {,             return title != null ? title.getText() : null;,         }, ,         /**,          * Set the packages to Javadoc on.,          * @param src a comma separated list of packages,          */,         public void setPackages(final String src) {,             final StringTokenizer tok = new StringTokenizer(src, ",");,             while (tok.hasMoreTokens()) {,                 final String p = tok.nextToken();,                 final PackageName pn = new PackageName();,                 pn.setName(p);,                 addPackage(pn);,             },         },         /**,          * Add a package nested element.,          * @param pn a nested element specifying the package.,          */,         public void addPackage(final PackageName pn) {,             packages.addElement(pn);,         }, ,         /**,          * Get the packages as a colon separated list.,          * @return the packages as a string,          */,         public String getPackages() {,             final StringBuffer p = new StringBuffer();,             final int size = packages.size();,             for (int i = 0; i < size; i++) {,                 if (i > 0) {,                     p.append(":");,                 },                 p.append(packages.elementAt(i).toString());,             },             return p.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/tools/ant/taskdefs/Javadoc.java,,2566-2611,[        JavadocOutputStream(final int level) {,             super(Javadoc.this, level);,         }, ,         //,         // Override the logging of output in order to filter out Generating,         // messages.  Generating messages are set to a priority of VERBOSE,         // unless they appear after what could be an informational message.,         //,         private String queuedLine = null;,         private boolean sawWarnings = false;, ,         @Override,         protected void processLine(final String line, final int messageLevel) {,             if (line.contains("warning")) {,                 sawWarnings = true;,             },             if (messageLevel == Project.MSG_INFO,                 && line.startsWith("Generating ")) {,                 if (queuedLine != null) {,                     super.processLine(queuedLine, Project.MSG_VERBOSE);,                 },                 queuedLine = line;,             } else {,                 if (queuedLine != null) {,                     if (line.startsWith("Building ")) {,                         super.processLine(queuedLine, Project.MSG_VERBOSE);,                     } else {,                         super.processLine(queuedLine, Project.MSG_INFO);,                     },                     queuedLine = null;,                 },                 super.processLine(line, messageLevel);,             },         }, , ,         protected void logFlush() {,             if (queuedLine != null) {,                 super.processLine(queuedLine, Project.MSG_VERBOSE);,                 queuedLine = null;,             },         }, ,         public boolean sawWarnings() {,             return sawWarnings;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,1204-1293,[        private boolean offline = false;,         private File packagelistLoc;,         private URL packagelistURL;,         private boolean resolveLink = false;, ,         /** Constructor for LinkArgument */,         public LinkArgument() {,             //empty,         }, ,         /**,          * Set the href attribute.,          * @param hr a <code>String</code> value,          */,         public void setHref(final String hr) {,             href = hr;,         }, ,         /**,          * Get the href attribute.,          * @return the href attribute.,          */,         public String getHref() {,             return href;,         }, ,         /**,          * Set the packetlist location attribute.,          * @param src a <code>File</code> value,          */,         public void setPackagelistLoc(final File src) {,             packagelistLoc = src;,         }, ,         /**,          * Get the packetList location attribute.,          * @return the packetList location attribute.,          */,         public File getPackagelistLoc() {,             return packagelistLoc;,         }, ,         /**,          * Set the packetlist location attribute.,          * @param src an <code>URL</code> value,          */,         public void setPackagelistURL(final URL src) {,             packagelistURL = src;,         }, ,         /**,          * Get the packetList location attribute.,          * @return the packetList location attribute.,          */,         public URL getPackagelistURL() {,             return packagelistURL;,         }, ,         /**,          * Set the offline attribute.,          * @param offline a <code>boolean</code> value,          */,         public void setOffline(final boolean offline) {,             this.offline = offline;,         }, ,         /**,          * Get the linkOffline attribute.,          * @return the linkOffline attribute.,          */,         public boolean isLinkOffline() {,             return offline;,         }, ,         /**,          * Sets whether Ant should resolve the link attribute relative,          * to the current basedir.,          * @param resolve a <code>boolean</code> value,          */,         public void setResolveLink(final boolean resolve) {,             this.resolveLink = resolve;,         }, ,         /**,          * should Ant resolve the link attribute relative to the,          * current basedir?,          * @return the resolveLink attribute.,          */,         public boolean shouldResolveLink() {,             return resolveLink;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,381-396,[    public class ResourceCollectionContainer {,         private final ArrayList<ResourceCollection> rcs = new ArrayList<ResourceCollection>();,         /**,          * Add a resource collection to the container.,          * @param rc the collection to add.,          */,         public void add(final ResourceCollection rc) {,             rcs.add(rc);,         }, ,         /**,          * Get an iterator on the collection.,          * @return an iterator.,          */,         private Iterator<ResourceCollection> iterator() {,             return rcs.iterator();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,1326-1453,[        private String name = null;,         /** Whether or not the tag is enabled. */,         private boolean enabled = true;,         /**,          * Scope string of the tag. This will form the middle,          * argument of the -tag parameter when the tag is enabled,          * (with an X prepended for and is parsed from human-readable form.,          */,         private String scope = "a";, ,         /** Sole constructor. */,         public TagArgument () {,             //empty,         }, ,         /**,          * Sets the name of the tag.,          *,          * @param name The name of the tag.,          *             Must not be <code>null</code> or empty.,          */,         public void setName (final String name) {,             this.name = name;,         }, ,         /**,          * Sets the scope of the tag. This is in comma-separated,          * form, with each element being one of "all" (the default),,          * "overview", "packages", "types", "constructors", "methods",,          * "fields". The elements are treated in a case-insensitive,          * manner.,          *,          * @param verboseScope The scope of the tag.,          *                     Must not be <code>null</code>,,          *                     should not be empty.,          *,          * @exception BuildException if all is specified along with,          * other elements, if any elements are repeated, if no,          * elements are specified, or if any unrecognised elements are,          * specified.,          */,         public void setScope (String verboseScope) throws BuildException {,             verboseScope = verboseScope.toLowerCase(Locale.ENGLISH);, ,             final boolean[] elements = new boolean[SCOPE_ELEMENTS.length];, ,             boolean gotAll = false;,             boolean gotNotAll = false;, ,             // Go through the tokens one at a time, updating the,             // elements array and issuing warnings where appropriate.,             final StringTokenizer tok = new StringTokenizer (verboseScope, ",");,             while (tok.hasMoreTokens()) {,                 final String next = tok.nextToken().trim();,                 if (next.equals("all")) {,                     if (gotAll) {,                         getProject().log ("Repeated tag scope element: all",,                                           Project.MSG_VERBOSE);,                     },                     gotAll = true;,                 } else {,                     int i;,                     for (i = 0; i < SCOPE_ELEMENTS.length; i++) {,                         if (next.equals (SCOPE_ELEMENTS[i])) {,                             break;,                         },                     },                     if (i == SCOPE_ELEMENTS.length) {,                         throw new BuildException ("Unrecognised scope element: ",                                                   + next);,                     } else {,                         if (elements[i]) {,                             getProject().log ("Repeated tag scope element: ",                                               + next, Project.MSG_VERBOSE);,                         },                         elements[i] = true;,                         gotNotAll = true;,                     },                 },             }, ,             if (gotNotAll && gotAll) {,                 throw new BuildException ("Mixture of \"all\" and other scope ",                                           + "elements in tag parameter.");,             },             if (!gotNotAll && !gotAll) {,                 throw new BuildException ("No scope elements specified in tag ",                                           + "parameter.");,             },             if (gotAll) {,                 this.scope = "a";,             } else {,                 final StringBuffer buff = new StringBuffer (elements.length);,                 for (int i = 0; i < elements.length; i++) {,                     if (elements[i]) {,                         buff.append (SCOPE_ELEMENTS[i].charAt(0));,                     },                 },                 this.scope = buff.toString();,             },         }, ,         /**,          * Sets whether or not the tag is enabled.,          *,          * @param enabled Whether or not this tag is enabled.,          */,         public void setEnabled (final boolean enabled) {,             this.enabled = enabled;,         }, ,         /**,          * Returns the -tag parameter this argument represented.,          * @return the -tag parameter as a string,          * @exception BuildException if either the name or description,          *                           is <code>null</code> or empty.,          */,         public String getParameter() throws BuildException {,             if (name == null || name.equals("")) {,                 throw new BuildException ("No name specified for custom tag.");,             },             if (getDescription() != null) {,                 return name + ":" + (enabled ? "" : "X"),                     + scope + ":" + getDescription();,             } else if (!enabled || !"a".equals(scope)) {,                 return name + ":" + (enabled ? "" : "X") + scope;,             } else {,                 return name;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Jikes.java,compile,91-91,[                    out = new BufferedWriter(new FileWriter(tmpFile));],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/JikesOutputParser.java,parseStandardOutput,134-134,[            lower = line.toLowerCase();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JikesOutputParser.java,setProcessOutputStream,73-73,[        br = new BufferedReader(new InputStreamReader(is));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/KeySubst.java,execute,64-64,[            br = new BufferedReader(new FileReader(source));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/KeySubst.java,execute,66-66,[            bw = new BufferedWriter(new FileWriter(dest));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/KeySubst.java,execute,65-65,[            dest.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Length.java,execute,172-172,[            ? (OutputStream) new PropertyOutputStream(getProject(), property)],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Length.java,eval,197-197,[            ell = new Long(getLength(string, getTrim()));],,eval,201-201,[            ell = new Long(h.getAccum());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Length.java,setLength,111-111,[        length = new Long(ell);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Length.java,,232-232,[        for (Resource r : resources) {],,,216-216,[        } else if (resources != null) {],,,208-208,[            if (resources != null) {],,,102-102,[        resources = (resources == null) ? new Resources() : resources;],,,103-103,[        resources.add(c);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Length.java,,203-203,[        return when.evaluate(ell.compareTo(length));],,,130-130,[        when = c;],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/tools/ant/taskdefs/Length.java,getTrim,163-163,[        return trim != null && trim.booleanValue();],,setTrim,155-156,[        this.trim = trim ? Boolean.TRUE : Boolean.FALSE;,     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Length.java,handleResources,232-232,[        for (Resource r : resources) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Length.java,,313-313,[            return accum;],,,320-320,[                accum += size;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Length.java,getValues,257-257,[            return MODES;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/LoadFile.java,setSrcFile,39-40,[        addConfigured(new FileResource(srcFile));,     }],,setSrcfile,105-106,[        this.sourceFile = file;,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/LoadProperties.java,execute,181-181,[                instream = new InputStreamReader(bis);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/LoadProperties.java,,163-163,[        if (src == null) {],,,166-166,[        if (!src.isExists()) {],,,179-179,[            bis = new BufferedInputStream(src.getInputStream());],,,167-167,[            if (src instanceof JavaResource) {],,,172-172,[            throw new BuildException("Source resource does not exist: " + src);],,,169-169,[                log("Unable to find resource " + src, Project.MSG_WARN);],,,240-240,[        if (src == null) {],,,243-243,[        } else if (!(src instanceof JavaResource)) {],,,246-246,[        return (JavaResource) src;],,,241-241,[            src = new JavaResource();],,,242-242,[            src.setProject(getProject());],,,229-229,[        if (src != null) {],,,236-236,[        src = a.iterator().next();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/LoadResource.java,execute,165-165,[                instream = new InputStreamReader(bis);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/MacroDef.java,getNestedTask,187-187,[        final int size = nestedSequential.getNested().size();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/MacroDef.java,sameOrSimilar,747-747,[        if (!nestedSequential.similar(other.nestedSequential)) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/MacroDef.java,sameDefinition,822-822,[            MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/MacroDef.java,similarDefinition,838-838,[            MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/MakeUrlTest.java,testFileset,124-127,[        buildRule.executeTarget("testFileset");,         assertPropertyContains("testFileset", ".xml ");,         assertPropertyEndsWith("testFileset", ".xml");,     }],,testFileSet,543-552,[        Path p = new Path(project);,         FileSet f = new FileSet();,         f.setProject(project);,         f.setDir(project.resolveFile("."));,         f.setIncludes("build.xml");,         p.addFileset(f);,         String[] l = p.list();,         assertEquals(1, l.length);,         assertEquals(project.resolveFile("build.xml").getAbsolutePath(), l[0]);,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Manifest.java,getDefaultManifest,829-829,[                insr = new InputStreamReader(in);],,
BAD_PRACTICE,NP_TOSTRING_COULD_RETURN_NULL,org/apache/tools/ant/taskdefs/Manifest.java,toString,1069-1069,[            return null;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/Manifest.java,getValue,283-283,[                fullValue += value + " ";],,
BAD_PRACTICE,CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE,org/apache/tools/ant/taskdefs/Manifest.java,clone,725-734,[            Section cloned = new Section();,             cloned.setName(name);,             Enumeration<String> e = getAttributeKeys();,             while (e.hasMoreElements()) {,                 String key = e.nextElement();,                 Attribute attribute = getAttribute(key);,                 cloned.storeAttribute(new Attribute(attribute.getName(),,                                                     attribute.getValue()));,             },             return cloned;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ManifestClassPath.java,addClassPath,177-178,[        this.path = path;,     }],,addClasspath,630-634,[        if (classpath != null) {,             throw new BuildException("<classpath> can be set only once.");,         },         classpath = path;,     }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/ManifestClassPathTest.java,testDifferentWindowsDrive,223-223,[            driveLetter = tmpCanonicalPath.substring(0, 1).toUpperCase();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/ManifestTest.java,getManifest,470-470,[        FileReader r = new FileReader(file);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/ManifestTest.java,testLongLine,292-292,[        FileReader fin = new FileReader(expandedManifest);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/ManifestTest.java,testLongLine,294-294,[            BufferedReader in = new BufferedReader(fin);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/MatchingTask.java,XsetIgnore,162-171,[        log("The ignore attribute is deprecated.",             + "Please use the excludes attribute.", Project.MSG_WARN);,         if (ignoreString != null && ignoreString.length() > 0) {,             StringTokenizer tok = new StringTokenizer(ignoreString, ", ",,                                                       false);,             while (tok.hasMoreTokens()) {,                 createExclude().setName("**/" + tok.nextToken().trim() + "/**");,             },         },     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/MatchingTask.java,XsetItems,129-143,[        log("The items attribute is deprecated. ",             + "Please use the includes attribute.", Project.MSG_WARN);,         if (itemString == null || itemString.equals("*"),             || itemString.equals(".")) {,             createInclude().setName("**");,         } else {,             StringTokenizer tok = new StringTokenizer(itemString, ", ");,             while (tok.hasMoreTokens()) {,                 String pattern = tok.nextToken().trim();,                 if (pattern.length() > 0) {,                     createInclude().setName(pattern + "/**");,                 },             },         },     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/MkdirTest.java,test3,67-67,[            f.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Move.java,renameFile,365-365,[            parent.mkdirs();],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/Move.java,doFileOperations,110-110,[                File toDir = (File) completeDirMap.get(fromDir);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/Move.java,doFileOperations,171-171,[                String[] toDirNames = (String[]) dirCopyMap.get(fromDirName);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/Move.java,doFileOperations,142-142,[                    String[] toFiles = (String[]) fileCopyMap.get(fromFile);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Nice.java,setNewPriority,96-96,[        this.newPriority = new Integer(newPriority);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/Pack.java,,81-81,[            source = fp.getFile();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Pack.java,execute,136-136,[        } else if (zipFile.lastModified() < s.getLastModified()) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/Parallel.java,spinThreads,389-389,[                throw (BuildException) firstException;],,
MT_CORRECTNESS,ESync_EMPTY_SYNC,org/apache/tools/ant/taskdefs/Parallel.java,spinThreads,289-289,[        }],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/tools/ant/taskdefs/Parallel.java,run,315-315,[                            wait(timeout);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Parallel.java,interrupt,485-485,[            thread.interrupt();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/ParallelTest.java,testDemux,156-156,[            System.setOut(new PrintStream(new DemuxOutputStream(p, false)));],,testDemux,157-157,[            System.setErr(new PrintStream(new DemuxOutputStream(p, true)));],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/tools/ant/taskdefs/PathConvert.java,mapElement,436-436,[                if (newElem != elem) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/PathConvert.java,apply,151-151,[                onWindows ? elem.toLowerCase().replace('\\', '/') : elem;],,apply,153-153,[                onWindows ? from.toLowerCase().replace('\\', '/') : from;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/PathConvert.java,,112-159,[    public class MapEntry {, ,         // Members,         private String from = null;,         private String to = null;, ,         /**,          * Set the &quot;from&quot; attribute of the map entry.,          * @param from the prefix string to search for; required.,          * Note that this value is case-insensitive when the build is,          * running on a Windows platform and case-sensitive when running on,          * a Unix platform.,          */,         public void setFrom(String from) {,             this.from = from;,         }, ,         /**,          * Set the replacement text to use when from is matched; required.,          * @param to new prefix.,          */,         public void setTo(String to) {,             this.to = to;,         }, ,         /**,          * Apply this map entry to a given path element.,          *,          * @param elem Path element to process.,          * @return String Updated path element after mapping.,          */,         public String apply(String elem) {,             if (from == null || to == null) {,                 throw new BuildException("Both 'from' and 'to' must be set ",                      + "in a map entry");,             },             // If we're on windows, then do the comparison ignoring case,             // and treat the two directory characters the same,             String cmpElem =,                 onWindows ? elem.toLowerCase().replace('\\', '/') : elem;,             String cmpFrom =,                 onWindows ? from.toLowerCase().replace('\\', '/') : from;, ,             // If the element starts with the configured prefix, then,             // convert the prefix to the configured 'to' value., ,             return cmpElem.startsWith(cmpFrom),                 ? to + elem.substring(from.length()) : elem;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/PreSetDef.java,sameDefinition,255-255,[            return (other != null && other.getClass() == getClass() && parent != null],,sameDefinition,256-256,[                && parent.sameDefinition(((PreSetDefinition) other).parent, project)],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/PreSetDef.java,similarDefinition,269-269,[            return (other != null && other.getClass().getName().equals(],,similarDefinition,271-271,[                && parent.similarDefinition(((PreSetDefinition) other).parent, project)],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Property.java,getUrl,268-268,[        return url;],,getURL,83-94,[        if (isReference()) {,             return ((JavaResource) getCheckedRef()).getURL();,         },         AbstractClasspathResource.ClassLoaderWithFlag classLoader =,             getClassLoader();,         if (classLoader.getLoader() == null) {,             return ClassLoader.getSystemResource(getName());,         } else {,             try {,                 return classLoader.getLoader().getResource(getName());,             } finally {,                 classLoader.cleanup();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Property.java,setUrl,260-261,[        this.url = url;,     }],,setURL,94-96,[        checkAttributesAllowed();,         url = u;,     }],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/Property.java,addProperties,679-679,[                addProperty(propertyName, m.get(k));],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/PropertyHelperTask.java,,111-111,[        if (propertyHelper == null && delegates == null) {],,,122-122,[            if (delegates != null) {],,,123-123,[                for (Iterator iter = delegates.iterator(); iter.hasNext();) {],,,140-140,[        if (delegates == null) {],,,143-143,[        return delegates;],,,141-141,[            delegates = new ArrayList();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Recorder.java,getValues,186-186,[            return VALUES;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/RecorderEntry.java,openFileImpl,359-359,[                out = new PrintStream(new FileOutputStream(filename, append));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,createStreams,684-684,[                inputStream = new ByteArrayInputStream(inputString.getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,handleErrorFlush,865-865,[                errorPrintStream = new PrintStream(errorStream);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,handleErrorOutput,850-850,[                errorPrintStream = new PrintStream(errorStream);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,handleFlush,834-834,[                outPrintStream = new PrintStream(outputStream);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,handleOutput,792-792,[                outPrintStream = new PrintStream(outputStream);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Replace.java,<init>,371-371,[                reader = new BufferedReader(encoding != null ? new InputStreamReader(is, encoding) : new InputStreamReader(is));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/tools/ant/taskdefs/Replace.java,,366-409,[        FileInput(File source) throws IOException {,             outputBuffer = new StringBuffer();,             buffer = new char[BUFF_SIZE];,             is = new FileInputStream(source);,             try {,                 reader = new BufferedReader(encoding != null ? new InputStreamReader(is, encoding) : new InputStreamReader(is));,             } finally {,                 if (reader == null) {,                     is.close();,                 },             },         }, ,         /**,          * Retrieves the output buffer of this filter. The component guarantees,          * that data is only appended to the end of this StringBuffer.,          * @return The StringBuffer containing the output of this filter.,          */,         StringBuffer getOutputBuffer() {,             return outputBuffer;,         }, ,         /**,          * Reads some data from the file.,          * @return true when the end of the file has not been reached.,          * @throws IOException When the file cannot be read from.,          */,         boolean readChunk() throws IOException {,             int bufferLength = 0;,             bufferLength = reader.read(buffer);,             if (bufferLength < 0) {,                 return false;,             },             outputBuffer.append(new String(buffer, 0, bufferLength));,             return true;,         }, ,         /**,          * Closes the file.,          * @throws IOException When the file cannot be closed.,          */,         public void close() throws IOException {,             is.close();,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Replace.java,<init>,431-431,[                writer = new BufferedWriter(encoding != null ? new OutputStreamWriter(os, encoding) : new OutputStreamWriter(os));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/tools/ant/taskdefs/Replace.java,,428-479,[        FileOutput(File out) throws IOException {,             os = new FileOutputStream(out);,             try {,                 writer = new BufferedWriter(encoding != null ? new OutputStreamWriter(os, encoding) : new OutputStreamWriter(os));,             } finally {,                 if (writer == null) {,                     os.close();,                 },             },         }, ,         /**,          * Sets the input buffer for this component.,          * The filter expects from the component providing the input that data,          * is only added by that component to the end of this StringBuffer.,          * This StringBuffer will be modified by this filter, and expects that,          * another component will only append to this StringBuffer.,          * @param input The input for this filter.,          */,         void setInputBuffer(StringBuffer input) {,             inputBuffer = input;,         }, ,         /**,          * Writes the buffer as far as possible.,          * @return false to be inline with the Replacefilter.,          * (Yes defining an interface crossed my mind, but would publish the,          * internal behavior.),          * @throws IOException when the output cannot be written.,          */,         boolean process() throws IOException {,             writer.write(inputBuffer.toString());,             inputBuffer.delete(0, inputBuffer.length());,             return false;,         }, ,         /**,          * Processes the buffer to the end.,          * @throws IOException when the output cannot be flushed.,          */,         void flush() throws IOException {,             process();,             writer.flush();,         }, ,         /**,          * Closes the file.,          * @throws IOException When the file cannot be closed.,          */,         public void close() throws IOException {,             os.close();,         }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Replace.java,process,459-459,[            writer.write(inputBuffer.toString());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Replace.java,replace,338-338,[            final int replaceValueLength = replaceValue.length();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Replace.java,getToken,214-214,[            return token.getText();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Replace.java,getValue,231-231,[            return value.getText();],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/ReplaceTest.java,assertEqualContent,162-162,[            inExpect = new BufferedInputStream(new FileInputStream(expect));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/ResourceCount.java,eval,96-96,[        return when.evaluate(new Integer(rc.size()).compareTo(count));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/ResourceCount.java,setCount,104-104,[        count = new Integer(c);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Retry.java,,88-88,[                nestedTask.perform();],,,94-94,[                    exceptionMessage.append("Task [").append(nestedTask.getTaskName());],,,52-52,[        if (nestedTask != null) {],,,57-57,[        nestedTask = t;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Retry.java,execute,88-88,[                nestedTask.perform();],,execute,94-94,[                    exceptionMessage.append("Task [").append(nestedTask.getTaskName());],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Rmic.java,,314-314,[        return compileClasspath;],,,294-294,[        if (compileClasspath == null) {],,,297-297,[        return compileClasspath.createPath();],,,295-295,[            compileClasspath = new Path(getProject());],,,282-282,[        if (compileClasspath == null) {],,,285-285,[            compileClasspath.append(classpath);],,,283-283,[            compileClasspath = classpath;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Rmic.java,,481-481,[        return extDirs;],,,457-457,[        if (this.extDirs == null) {],,,460-460,[            this.extDirs.append(extDirs);],,,458-458,[            this.extDirs = extDirs;],,,469-469,[        if (extDirs == null) {],,,472-472,[        return extDirs.createPath();],,,470-470,[            extDirs = new Path(getProject());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Rmic.java,moveGeneratedFile,733-733,[                oldFile.delete();],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/tools/ant/taskdefs/Rmic.java,getClasspath,314-314,[        return compileClasspath;],,setClasspath,282-287,[        if (compileClasspath == null) {,             compileClasspath = classpath;,         } else {,             compileClasspath.append(classpath);,         },     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/tools/ant/taskdefs/Rmic.java,getExtdirs,481-481,[        return extDirs;],,setExtdirs,457-462,[        if (this.extDirs == null) {,             this.extDirs = extDirs;,         } else {,             this.extDirs.append(extDirs);,         },     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Rmic.java,,839-851,[    public class ImplementationSpecificArgument extends,                                                     org.apache.tools.ant.util.facade.ImplementationSpecificArgument {,         /**,          * Only pass the specified argument if the,          * chosen compiler implementation matches the,          * value of this attribute. Legal values are,          * the same as those in the above list of,          * valid compilers.),          * @param impl the compiler to be used.,          */,         public void setCompiler(String impl) {,             super.setImplementation(impl);,         }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/RmicAdvancedTest.java,NotestFailingAdapter,283-288,[            buildRule.executeTarget("testFailingAdapter");,             fail("Expected failures to propogate");,         } catch (BuildException ex) {,             AntAssert.assertContains(Rmic.ERROR_RMIC_FAILED, ex.getMessage());,         },     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/RmicAdvancedTest.java,NotestForking,160-161,[        buildRule.executeTarget("testForking");,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/RmicAdvancedTest.java,XtestWlrmic,142-143,[        buildRule.executeTarget("testWlrmic");,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/RmicAdvancedTest.java,XtestWlrmicJArg,151-152,[        buildRule.executeTarget("testWlrmicJArg");,     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/RmicTest.java,testCompilerArg,71-71,[        project.setProperty("build.rmic", "sun");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/RmicTest.java,testCompilerAttribute,93-93,[        project.setNewProperty("build.rmic", "weblogic");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/RmicTest.java,testCompilerArg,52-52,[        String[] args = rmic.getCurrentCompilerArgs();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/RmicTest.java,testCompilerAttribute,89-89,[        String compiler = rmic.getCompiler();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/SQLExec.java,execute,664-664,[                            out = new PrintStream(new BufferedOutputStream(os));],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/SQLExec.java,getStatement,695-695,[                    if (getStatement() != null) {],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/tools/ant/taskdefs/SQLExec.java,execSQL,794-794,[            ret = getStatement().execute(sql);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/tools/ant/taskdefs/SQLExec.java,runStatements,770-770,[            execSQL(sql.toString(), out);],,runStatements,764-764,[                execSQL(sql.substring(0, lastDelimPos), out);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/SQLExec.java,runTransaction,1075-1075,[                    reader = (encoding == null) ? new InputStreamReader(is)],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/StreamPumper.java,,121-121,[        final byte[] buf = new byte[bufferSize];],,,212-212,[        return bufferSize;],,,204-204,[        this.bufferSize = bufferSize;],,
MT_CORRECTNESS,NN_NAKED_NOTIFY,org/apache/tools/ant/taskdefs/StreamPumper.java,run,171-171,[                notifyAll();],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/tools/ant/taskdefs/StreamPumper.java,waitForInput,246-246,[                    this.wait(POLL_INTERVAL);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/SubAntTest.java,,126-155,[        private int calls = 0;,         private AssertionFailedError error;, ,         BasedirChecker(String[] dirs) {,             expectedBasedirs = dirs;,         }, ,         public void buildStarted(BuildEvent event) {},         public void buildFinished(BuildEvent event) {},         public void targetFinished(BuildEvent event){},         public void taskStarted(BuildEvent event) {},         public void taskFinished(BuildEvent event) {},         public void messageLogged(BuildEvent event) {}, ,         public void targetStarted(BuildEvent event) {,             if (event.getTarget().getName().equals("")) {,                 return;,             },             if (error == null) {,                 try {,                     assertEquals(expectedBasedirs[calls++],,                             event.getProject().getBaseDir().getAbsolutePath());,                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Sync.java,execute,112-112,[        boolean noRemovalNecessary = !toDir.exists() || toDir.list().length < 1;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Sync.java,removeEmptyDirectories,303-303,[            if (children.length < 1 && removeIfEmpty],,removeEmptyDirectories,301-301,[                children = dir.listFiles();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Sync.java,removeEmptyDirectories,289-289,[            for (int i = 0; i < children.length; ++i) {],,removeEmptyDirectories,288-288,[            File[] children = dir.listFiles();],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/tools/ant/taskdefs/Sync.java,execute,138-138,[            || getExplicitPreserveEmptyDirs() == Boolean.FALSE) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Sync.java,removeEmptyDirectories,306-306,[                dir.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Sync.java,removeEmptyDirectories,334-334,[                f.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Sync.java,removeOrphanFiles,233-233,[            f.delete();],,removeOrphanFiles,247-247,[                f.delete();],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_INT_VALUE,org/apache/tools/ant/taskdefs/Tar.java,tarResource,455-455,[            if (r.size() > TarConstants.MAXSIZE) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Tar.java,getFiles,820-820,[            return files;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Tar.java,getValues,888-888,[            return validModes;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/TestProcess.java,,35-35,[        if (!done)],,,42-42,[                while (!done)],,,71-71,[            done = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,128-128,[        if (this.dateTime != null) {],,,131-131,[        this.dateTime = dateTime;],,,234-234,[        if (dateTime != null && !dateTimeConfigured) {],,,236-236,[            if ("now".equalsIgnoreCase(dateTime)) {],,,242-242,[                    workmillis = df.parse(dateTime).getTime();],,,249-249,[                            workmillis = df.parse(dateTime).getTime();],,,259-259,[                    throw new BuildException("Date of " + dateTime],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,132-132,[        dateTimeConfigured = false;],,,234-234,[        if (dateTime != null && !dateTimeConfigured) {],,,269-269,[            dateTimeConfigured = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,161-161,[        dfFactory = new DateFormatFactory() {],,,239-239,[                DateFormat df = dfFactory.getPrimaryFormat();],,,244-244,[                    df = dfFactory.getFallbackFormat();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,108-108,[        this.file = file;],,,291-291,[        if (file != null) {],,,292-292,[            touch(new FileResource(file.getParentFile(), file.getName()),],,,227-227,[        if (file == null && resources == null) {],,,231-231,[        if (file != null && file.exists() && file.isDirectory()) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,295-295,[        if (resources == null) {],,,299-299,[        for (Resource r : resources) {],,,227-227,[        if (file == null && resources == null) {],,,217-217,[        resources = resources == null ? new Union() : resources;],,,218-218,[        resources.add(rc);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Touch.java,setDatetime,128-133,[        if (this.dateTime != null) {,             log("Resetting datetime attribute to " + dateTime, Project.MSG_VERBOSE);,         },         this.dateTime = dateTime;,         dateTimeConfigured = false;,     }],,setDateTime,70-72,[        dateTime = s;,         millis = null;,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Touch.java,,161-166,[        dfFactory = new DateFormatFactory() {,             public DateFormat getPrimaryFormat() {,                 return new SimpleDateFormat(pattern);,             },             public DateFormat getFallbackFormat() {,                 return null;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/TouchTest.java,testFilelist,115-116,[        touchFile("testFilelist", 662256000000L);,     }],,testFileList,530-539,[        Path p = new Path(project);,         FileList f = new FileList();,         f.setProject(project);,         f.setDir(project.resolveFile("."));,         f.setFiles("build.xml");,         p.addFilelist(f);,         String[] l = p.list();,         assertEquals(1, l.length);,         assertEquals(project.resolveFile("build.xml").getAbsolutePath(), l[0]);,     }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Truncate.java,<clinit>,43-43,[    private static final Long ZERO = new Long(0L);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Truncate.java,,125-125,[        if (path == null) {],,,128-128,[        for (Resource r : path) {],,,199-199,[        if (path == null) {],,,202-202,[        return path;],,,200-200,[            path = new Path(getProject());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Truncate.java,process,162-162,[                ? len + adjust.longValue() : length.longValue();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Tstamp.java,<init>,312-312,[            calendarFields.put(MILLISECOND,],,<init>,314-314,[            calendarFields.put(SECOND, new Integer(Calendar.SECOND));],,<init>,315-315,[            calendarFields.put(MINUTE, new Integer(Calendar.MINUTE));],,<init>,316-316,[            calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY));],,<init>,317-317,[            calendarFields.put(DAY, new Integer(Calendar.DATE));],,<init>,318-318,[            calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR));],,<init>,319-319,[            calendarFields.put(MONTH, new Integer(Calendar.MONTH));],,<init>,320-320,[            calendarFields.put(YEAR, new Integer(Calendar.YEAR));],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Tstamp.java,getValues,338-338,[            return UNITS;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/TypeAdapterTest.java,execute,103-103,[            project.log("MyExec called");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/TypeAdapterTest.java,run,114-114,[            project.log("MyRunnable called");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/TypeAdapterTest.java,execute,159-159,[            Method executeMethod = getExecuteMethod(proxy.getClass());],,execute,163-163,[                log("Error in " + proxy.getClass(), Project.MSG_ERR);],,execute,171-171,[                log("Error in " + proxy.getClass(), Project.MSG_ERR);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/BUnzip2.java,extract,69-69,[                fis = srcResource.getInputStream();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/GUnzip.java,extract,64-64,[                fis = srcResource.getInputStream();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/UpToDate.java,execute,241-241,[                log("File \"" + targetFile.getAbsolutePath()],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/UpToDate.java,getMapper,270-270,[            mm.setTo(targetFile.getAbsolutePath());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/WaitFor.java,<init>,251-251,[            timeTable.put(MILLISECOND, new Long(1L));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/WaitFor.java,<init>,250-257,[        public Unit() {,             timeTable.put(MILLISECOND, new Long(1L));,             timeTable.put(SECOND,      new Long(ONE_SECOND));,             timeTable.put(MINUTE,      new Long(ONE_MINUTE));,             timeTable.put(HOUR,        new Long(ONE_HOUR));,             timeTable.put(DAY,         new Long(ONE_DAY));,             timeTable.put(WEEK,        new Long(ONE_WEEK));,         }],,<init>,947-949,[],,valueOf,837-840,[],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/WaitFor.java,getValues,274-274,[            return UNITS;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/XSLTProcess.java,execute,441-441,[                        for (int i = 0; i < list.length; ++i) {],,execute,440-440,[                        list = new File(baseDir, dirs[j]).list();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/XSLTProcess.java,process,832-832,[            } else if (outFileName == null || outFileName.length > 1) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/XSLTProcess.java,configureLiaison,1313-1313,[        } catch (final Exception ex) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/XSLTProcess.java,process,886-886,[                outFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/XSLTProcess.java,process,851-851,[                outF.delete();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/XSLTProcess.java,setDynamicAttribute,1558-1558,[                            this.value = new Integer(value);],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,getGoldfile,308-308,[        String baseName = input.getName().toLowerCase();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,getFiles,367-367,[        for (int i=0;i<files.length;i++) {],,getFiles,366-366,[        File[] files = startingDir.listFiles(filter);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,doTest,193-193,[            props.load(new FileInputStream(propertyFile));],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,printProperties,271-277,[        Enumeration keyEnum = xmlproperties.keys();,         while (keyEnum.hasMoreElements()) {,             String currentKey = keyEnum.nextElement().toString();,             System.out.println(currentKey + " = ",                                + xmlproperties.get(currentKey));,         },     }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,accept,361-361,[                            file.getPath().toLowerCase().endsWith(".xml") );],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,accept,360-360,[                    return (file.getPath().indexOf("taskdefs") > 0 &&],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/taskdefs/Zip.java,executeMain,713-713,[                    ((ZipScanner) ds).setEncoding(encoding);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Zip.java,setFallBackToUTF8,554-555,[        fallBackToUTF8 = b;,     }],,setFallbackToUTF8,395-396,[        fallbackToUTF8 = b;,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Zip.java,,1637-1639,[            Collections.sort(dirs, new Comparator<Resource>() {,                     public int compare(final Resource r1, final Resource r2) {,                         return r1.getName().compareTo(r2.getName());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Zip.java,,2063-2065,[                               new ResourceSelector() {,                                    public boolean isSelected(final Resource r) {,                                        return r.isDirectory();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Zip.java,getResourcesToAdd,2150-2150,[            return resourcesToAdd;],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/ZipExtraFieldTest.java,testExtraField,58-58,[        f.delete();],,testExtraField,105-105,[                f.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/ZipExtraFieldTest.java,,62-79,[            final ZipResource r = new ZipResource() {,                     public String getName() {,                         return "x";,                     },                     public boolean isExists() {,                         return true;,                     },                     public boolean isDirectory() {,                         return false;,                     },                     public long getLastModified() {,                         return 1;,                     },                     public InputStream getInputStream() {,                         return new ByteArrayInputStream(new byte[0]);,                     },                     public ZipExtraField[] getExtraFields() {,                         return new ZipExtraField[] {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/ZipExtraFieldTest.java,,84-88,[            testInstance.add(new ResourceCollection() {,                     public boolean isFilesystemOnly() { return false; },                     public int size() { return 1; },                     public Iterator<Resource> iterator() {,                         return Collections.<Resource>singleton(r).iterator();],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/ZipTest.java,testZipgroupfileset,139-139,[        ZipFile zipFile = new ZipFile(new File(buildRule.getProject().getProperty("output"), "zipgroupfileset.zip"));],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/taskdefs/compilers/AptCompilerAdapter.java,getApt,93-93,[        return (Apt) getJavac();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/taskdefs/compilers/AptExternalCompilerAdapter.java,getApt,41-41,[        return (Apt) getJavac();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/compilers/DefaultCompilerAdapter.java,executeExternalCompile,469-469,[                    out = new BufferedWriter(new FileWriter(tmpFile));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/compilers/DefaultCompilerAdapter.java,executeExternalCompile,514-514,[                tmpFile.delete();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/compilers/Javac13.java,execute,61-61,[        } catch (Exception ex) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/condition/Contains.java,eval,74-74,[            : string.toLowerCase().indexOf(subString.toLowerCase()) > -1;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/condition/IsLastModified.java,getMillis,147-147,[        if (pe != null) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/condition/IsLastModified.java,,71-76,[        dfFactory = new Touch.DateFormatFactory() {,             public DateFormat getPrimaryFormat() {,                 return new SimpleDateFormat(pattern);,             },             public DateFormat getFallbackFormat() {,                 return null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/condition/IsReachable.java,eval,182-182,[            params[0] = new Integer(timeout * SECOND);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/condition/IsReachableTest.java,NotestFile,100-105,[            buildRule.executeTarget("testFile");,             fail("Build exception expected: error on file URL");,         } catch(BuildException ex) {,             assertEquals(IsReachable.ERROR_NO_HOST_IN_URL, ex.getMessage());,         },     }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/condition/IsSigned.java,isSigned,90-90,[                        + name.toUpperCase()],,isSigned,96-96,[                    + name.substring(0, SHORT_SIG_LIMIT).toUpperCase()],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/condition/Matches.java,setMultiline,91-92,[        multiLine = b;,     }],,setMultiLine,100-101,[        multiLine = b;,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/condition/ParserSupportsTest.java,NotestPropertyInvalid,87-88,[        buildRule.executeTarget("testPropertyInvalid");,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/condition/ParserSupportsTest.java,NotestXercesProperty,93-94,[        buildRule.executeTarget("testXercesProperty");,     }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,eval,155-155,[                contents = contents.toLowerCase();],,eval,156-156,[                sub = sub.toLowerCase();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,eval,151-151,[            reader = new BufferedReader(new InputStreamReader(resource.getInputStream()));],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,,114-114,[        this.casesensitive = casesensitive;],,,154-154,[            if (!casesensitive) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,,66-66,[        this.resource = new FileResource(new File(r));],,,118-118,[        if (resource != null && refid != null) {],,,121-121,[        if (resource == null && refid != null) {],,,124-124,[        if (resource == null || substring == null) {],,,145-145,[        if (resource.getSize() == 0) {],,,151-151,[            reader = new BufferedReader(new InputStreamReader(resource.getInputStream()));],,,160-160,[            throw new BuildException("There was a problem accessing resource : " + resource);],,,95-95,[            this.resource = (Resource) o;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,,106-106,[        this.substring = substring;],,,124-124,[        if (resource == null || substring == null) {],,,138-138,[        if (substring.length() == 0) {],,,153-153,[            String sub = substring;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,eval,138-138,[        if (substring.length() == 0) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/condition/ResourceExists.java,eval,54-54,[        return resource.isExists();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/cvslib/CVSEntry.java,getDate,69-69,[        return date;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/cvslib/CVSEntry.java,<init>,40-40,[        this.date = date;],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogParser.java,parseDate,303-303,[                return CVS1129_INPUT_DATE.parse(date);],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogParser.java,parseDate,300-300,[            return INPUT_DATE.parse(date);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java,setEnd,172-172,[        this.endDate = endDate;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java,setStart,162-162,[        this.startDate = start;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java,loadUserlist,389-389,[                userList.load(new FileInputStream(usersFile));],,loadUserlist,392-392,[            }],,loadUserlist,394-394,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java,loadUserlist,389-389,[                userList.load(new FileInputStream(usersFile));],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogWriter.java,printEntry,90-90,[                                   OUTPUT_DATE.format(entry.getDate()));],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogWriter.java,printEntry,92-92,[                                   OUTPUT_TIME.format(entry.getDate()));],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogWriterTest.java,characters,69-69,[            String debug = new String(ch, start, length);],,
STYLE,UC_USELESS_VOID_METHOD,org/apache/tools/ant/taskdefs/cvslib/ChangeLogWriterTest.java,characters,70-70,[        }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/cvslib/CvsTagDiff.java,parseRDiff,302-302,[            reader = new BufferedReader(new FileReader(tmpFile));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/cvslib/CvsTagDiff.java,execute,284-284,[                tmpFile.delete();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/cvslib/CvsUser.java,getDisplayname,69-69,[        return displayName;],,getDisplayName,226-226,[        return displayName;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/cvslib/CvsVersion.java,execute,118-118,[        String output = bos.toString();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/email/EmailTask.java,setMailport,164-164,[        this.port = new Integer(port);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/email/EmailTask.java,setIncludefilenames,409-410,[        this.includeFileNames = includeFileNames;,     }],,setIncludeFileNames,223-224,[        this.includeFileNames = b;,     }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/email/EmailTask.java,execute,587-587,[        } catch (Exception e) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/email/Message.java,getReader,200-200,[        return new FileReader(f);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/email/Message.java,print,124-124,[            out],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/email/Message.java,print,132-132,[                    BufferedReader in = new BufferedReader(freader);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/email/MessageTest.java,testPrintStreamDoesNotGetClosed,46-46,[            ms.print(new PrintStream(fis));],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/email/PlainMailer.java,attach,153-153,[            BufferedInputStream in = new BufferedInputStream(finstr, buf.length);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/launcher/OS2CommandLauncher.java,exec,61-61,[                return exec(project, cmd, env);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/launcher/PerlScriptCommandLauncher.java,exec,59-59,[                return exec(project, cmd, env);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/launcher/ScriptCommandLauncher.java,exec,59-59,[                return exec(project, cmd, env);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/launcher/VmsCommandLauncher.java,createCommandFile,103-103,[            out = new BufferedWriter(new FileWriter(script));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/launcher/VmsCommandLauncher.java,,133-142,[        new Thread() {,             @Override,             public void run() {,                 try {,                     p.waitFor();,                 } catch(InterruptedException e) {,                     // ignore,                 },                 FileUtils.delete(f);,             }],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/launcher/WinNTCommandLauncher.java,exec,59-59,[                return exec(project, cmd, env);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/AbstractXSLTLiaisonTest.java,testEncoding,95-95,[            out.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/AbstractXSLTLiaisonTest.java,testTransform,77-77,[            out.delete();],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/taskdefs/optional/AbstractXSLTLiaisonTest.java,getFile,58-58,[        URL url = getClass().getResource(name);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/Cab.java,createListFile,186-186,[            writer = new BufferedWriter(new FileWriter(listFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/Cab.java,execute,284-284,[                out.write(sb.toString().getBytes());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/Cab.java,execute,347-347,[                    outFile.delete();],,execute,350-350,[                listFile.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/Cab.java,execute,262-262,[            sb.append("\n").append(cabFile.getAbsolutePath()).append("\n");],,execute,250-250,[        log("Building " + archiveType + ": " + cabFile.getAbsolutePath());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/Cab.java,isUpToDate,163-163,[                    > cabFile.lastModified()) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/EchoProperties.java,execute,333-333,[                log(os.toString(), Project.MSG_INFO);],,
BAD_PRACTICE,DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS,org/apache/tools/ant/taskdefs/optional/EchoProperties.java,entrySet,406-406,[                    t.addAll(result);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/EchoProperties.java,,391-409,[        Properties props = new Properties() {,             private static final long serialVersionUID = 5090936442309201654L;,             public Enumeration keys() {,                 return CollectionUtils.asEnumeration(keyList.iterator());,             },             public Set entrySet() {,                 Set result = super.entrySet();,                 if (JavaEnvUtils.isKaffe()) {,                     TreeSet t = new TreeSet(new Comparator() {,                         public int compare(Object o1, Object o2) {,                             String key1 = (String) ((Map.Entry) o1).getKey();,                             String key2 = (String) ((Map.Entry) o2).getKey();,                             return key1.compareTo(key2);,                         },                     });,                     t.addAll(result);,                     result = t;,                 },                 return result;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/optional/EchoProperties.java,getValues,250-250,[            return formats;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/tools/ant/taskdefs/optional/EchoProperties.java,compareTo,446-447,[            Tuple that = (Tuple) o;,             return key.compareTo(that.key);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/EchoPropertiesTest.java,testEchoToGoodFileXml,138-138,[        FileReader fr = new FileReader(f);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/optional/Javah.java,,121-137,[        public ClassArgument() {,         }, ,         /**,          * Set the name attribute.,          * @param name the name attribute.,          */,         public void setName(String name) {,             this.name = name;,         }, ,         /**,          * Get the name attribute.,          * @return the name attribute.,          */,         public String getName() {,             return name;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,readFile,198-198,[                    BufferedInputStream bis = new BufferedInputStream(fis);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,readFile,210-210,[                    out = new FileOutputStream(propertyfile.getAbsolutePath());],,readFile,192-192,[            if (propertyfile.exists()) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,getCalendarField,715-715,[            String key = getValue().toLowerCase();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,<init>,699-699,[            calendarFields.put(MILLISECOND,],,<init>,701-701,[            calendarFields.put(SECOND, new Integer(Calendar.SECOND));],,<init>,702-702,[            calendarFields.put(MINUTE, new Integer(Calendar.MINUTE));],,<init>,703-703,[            calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY));],,<init>,704-704,[            calendarFields.put(DAY, new Integer(Calendar.DATE));],,<init>,705-705,[            calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR));],,<init>,706-706,[            calendarFields.put(MONTH, new Integer(Calendar.MONTH));],,<init>,707-707,[            calendarFields.put(YEAR, new Integer(Calendar.YEAR));],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,getValues,723-723,[            return UNITS;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,getTestProperties,167-167,[        FileInputStream propsFile = new FileInputStream(new File(buildRule.getOutputDir(), testPropsFilePath));],,getTestProperties,168-168,[        testProps.load(propsFile);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,initBuildPropFile,197-197,[        FileOutputStream fos = new FileOutputStream(new File(buildRule.getOutputDir(), buildPropsFilePath));],,initBuildPropFile,198-198,[        buildProps.store(fos, null);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,initTestPropFile,181-181,[        FileOutputStream fos = new FileOutputStream(new File(buildRule.getOutputDir(), testPropsFilePath));],,initTestPropFile,182-182,[        testProps.store(fos, "defaults");],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,getTestProperties,167-167,[        FileInputStream propsFile = new FileInputStream(new File(buildRule.getOutputDir(), testPropsFilePath));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,initBuildPropFile,197-197,[        FileOutputStream fos = new FileOutputStream(new File(buildRule.getOutputDir(), buildPropsFilePath));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,initTestPropFile,181-181,[        FileOutputStream fos = new FileOutputStream(new File(buildRule.getOutputDir(), testPropsFilePath));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,testNonExistingFile,71-71,[        file.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java,doReplace,361-361,[                Reader r = encoding != null ? new InputStreamReader(is, encoding) : new InputStreamReader(is);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java,doReplace,364-364,[                    Writer w = encoding != null ? new OutputStreamWriter(os, encoding) : new OutputStreamWriter(os);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java,doReplace,373-373,[                        r = new BufferedReader(r);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java,doReplace,457-457,[                temp.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/Rpm.java,execute,155-155,[                    outputstream = new PrintStream(bos);],,execute,168-168,[                    errorstream = new PrintStream(bos);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/RpmTest.java,,57-62,[            return new Execute() {,                     public int execute() {,                         // 2 is != 0 and even, so it is considered,                         // failure on any platform currently supported,                         // by Execute#isFailure.,                         return 2;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/SchemaValidate.java,setNoNamespaceFile,199-199,[        this.anonymousSchema.setFile(defaultSchemaFile);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/SchemaValidate.java,setNoNamespaceURL,190-190,[        this.anonymousSchema.setUrl(defaultSchemaURL);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/TraXLiaison.java,configure,632-632,[        if (xmlCatalog != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/TraXLiaison.java,createTransformer,347-347,[                } catch (final Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/TraXLiaison.java,getFactory,419-419,[            } catch (final Exception e) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/TraXLiaison.java,readTemplates,299-299,[                = new BufferedInputStream(stylesheet.getInputStream());],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,testSystemId,118-118,[            file = new File("/user/local/bin");],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,testSystemId,116-116,[            file = new File("d:\\jdk");],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,tearDown,49-49,[            f.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,testMultipleTransform,107-107,[                out.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,testXalan2Redirect,87-87,[            out.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,,74-80,[            Thread.currentThread().setContextClassLoader(new ClassLoader(ClassLoader.getSystemClassLoader().getParent()) {,                 public InputStream getResourceAsStream(String name) {,                     if (name.startsWith("META-INF/services/")) {,                         // work around JAXP #6723276 in JDK 6,                         return new ByteArrayInputStream(new byte[0]);,                     },                     return super.getResourceAsStream(name);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,,84-84,[            System.setSecurityManager(new SecurityManager() {public void checkPermission(Permission perm) {}});],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java,getMessage,653-653,[                    } catch (Exception ex) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java,,593-593,[        protected File currentFile = null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java,,594-594,[        protected String lastErrorMessage = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ccm/CCMCreateTask.java,setProcessErrorStream,298-298,[        BufferedReader reader = new BufferedReader(new InputStreamReader(is));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ccm/CCMCreateTask.java,setProcessOutputStream,314-314,[            BufferedReader reader = new BufferedReader(new InputStreamReader(is));],,
CORRECTNESS,NM_VERY_CONFUSING,org/apache/tools/ant/taskdefs/optional/clearcase/CCLock.java,setObjselect,271-272,[        mObjselect = objselect;,     }],,setObjSelect,112-113,[        mobjSelect = objSelect;,     }],,
CORRECTNESS,NM_VERY_CONFUSING,org/apache/tools/ant/taskdefs/optional/clearcase/CCLock.java,getObjselect,280-280,[        return mObjselect;],,getObjSelect,121-121,[        return mobjSelect;],,
CORRECTNESS,NM_VERY_CONFUSING,org/apache/tools/ant/taskdefs/optional/clearcase/CCUnlock.java,getObjselect,194-194,[        return getObjSelect();],,getObjSelect,121-121,[        return mobjSelect;],,
CORRECTNESS,NM_VERY_CONFUSING,org/apache/tools/ant/taskdefs/optional/clearcase/CCUnlock.java,setObjselect,175-176,[        setObjSelect(objselect);,     }],,setObjSelect,112-113,[        mobjSelect = objSelect;,     }],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/clearcase/ClearCase.java,runS,149-149,[        String   outV  = "opts.cc.runS.output" + pcnt++;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/ClassFile.java,getClassRefs,94-94,[        final int size = constantPool.size();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,readCachedDependencies,190-190,[            in = new BufferedReader(new FileReader(depFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,writeCachedDependencies,225-225,[                pw = new BufferedWriter(new FileWriter(depFile));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,execute,737-737,[        } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,deleteAffectedFiles,517-517,[            affectedClassInfo.absoluteFile.delete();],,deleteAffectedFiles,541-541,[                    topLevelClassInfo.absoluteFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,deleteAllAffectedFiles,478-478,[                    classInfo.absoluteFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,execute,716-716,[                cache.mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,writeCachedDependencies,222-222,[                cache.mkdirs();],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,isRmiStub,590-591,[        return isStub(affectedClass, className, DefaultRmicAdapter.RMI_STUB_SUFFIX),             || isStub(affectedClass, className, DefaultRmicAdapter.RMI_SKEL_SUFFIX)],,isRmiStub,591-593,[            || isStub(affectedClass, className, DefaultRmicAdapter.RMI_SKEL_SUFFIX),             || isStub(affectedClass, className, WLRmic.RMI_STUB_SUFFIX),             || isStub(affectedClass, className, WLRmic.RMI_SKEL_SUFFIX);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,getCheckClassPath,257-257,[        String[] destPathElements = destPath.list();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,determineOutOfDateClasses,644-644,[        for (int i = 0; i < srcPathList.length; i++) {],,determineOutOfDateClasses,645-645,[            File srcDir = getProject().resolveFile(srcPathList[i]);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,findSourceFile,817-817,[        for (int i = 0; i < srcPathList.length; ++i) {],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/ConstantPool.java,addEntry,104-104,[            utf8Indexes.put(utf8Info.getValue(), new Integer(index));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/DoubleCPInfo.java,read,45-45,[        setValue(new Double(cpStream.readDouble()));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/FloatCPInfo.java,read,43-43,[        setValue(new Float(cpStream.readFloat()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/IntegerCPInfo.java,read,43-43,[        setValue(new Integer(cpStream.readInt()));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/InvokeDynamicCPInfo.java,toString,62-62,[            value = "Name = " + nameAndTypeCPInfo.getName() + ", type = " + nameAndTypeCPInfo.getType();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/LongCPInfo.java,read,43-43,[        setValue(new Long(cpStream.readLong()));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/MethodHandleCPInfo.java,toString,83-83,[            value = "MethodHandle : " + reference.toString();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,setProcessErrorStream,552-552,[        BufferedReader reader = new BufferedReader(new InputStreamReader(is));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,setProcessOutputStream,529-529,[            BufferedReader reader = new BufferedReader(new InputStreamReader(is));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,,211-224,[            new DescriptorHandler(getTask(), srcDir) {,                     protected void processElement() {,                         if (currentElement.equals("type-storage")) {,                             // Get the filename of vendor specific descriptor,                             String fileNameWithMETA = currentText;,                             //trim the META_INF\ off of the file name,                             String fileName,                                 = fileNameWithMETA.substring(META_DIR.length(),,                                     fileNameWithMETA.length());,                             File descriptorFile = new File(srcDir, fileName);, ,                             ejbFiles.put(fileNameWithMETA, descriptorFile);,                         },                     }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/optional/ejb/DescriptorHandler.java,getFiles,234-234,[        return (ejbFiles == null) ? new Hashtable() : ejbFiles;],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/taskdefs/optional/ejb/DescriptorHandler.java,registerDTD,157-157,[        if (getClass().getResource(location) != null) {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/ejb/EjbJar.java,setGenericjarsuffix,516-517,[        this.genericJarSuffix = inString;,     }],,setGenericJarSuffix,198-199,[        this.genericJarSuffix = inString;,     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,buildBorlandStubs,425-425,[        commandline.createArgument().setValue(getConfig().srcDir.getAbsolutePath());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,setProcessOutputStream,535-535,[                        getConfig().srcDir.getAbsolutePath().length() + 1);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,createAnalyzer,284-284,[                config.srcDir.getPath()));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,783-783,[            jarfile.createNewFile();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,780-780,[                jarfile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,782-782,[            jarfile.getParentFile().mkdirs();],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,793-793,[                    in = this.getClass().getResourceAsStream(defaultManifest);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,821-821,[                File entryFile = (File) files.get(entryName);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetDeploymentTool.java,,280-280,[        displayName    = ejbc.getDisplayName();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetDeploymentTool.java,getIasDescriptorName,389-389,[                endOfBaseName = descriptorName.lastIndexOf('.') - 1;],,getIasDescriptorName,369-369,[        int startOfFileName = descriptorName.lastIndexOf(File.separatorChar);],,getIasDescriptorName,395-395,[            basename = descriptorName.substring(startOfFileName + 1,],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,getEjbFiles,217-217,[        return ejbFiles;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,,157-157,[                    = (String[]) elements.toArray(new String[elements.size()]);],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,setBeantype,988-988,[            this.beantype = beantype.toLowerCase();],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,toString,1341-1341,[                s += "\n\r              CMP Descriptor: " + i.next();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,classesToGenerate,1284-1284,[            final String homePkg       = home.getPackageName() + ".";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,sourceClassesModified,1155-1155,[            homeFile = home.getClassFile(buildDir);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,classesToGenerate,1286-1286,[            final String implPkg       = implementation.getPackageName() + ".";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,sourceClassesModified,1189-1189,[            implFile = implementation.getClassFile(buildDir);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,classesToGenerate,1282-1282,[            final String remotePkg     = remote.getPackageName() + ".";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,sourceClassesModified,1144-1144,[            remoteFile = remote.getClassFile(buildDir);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,,596-598,[        public EjbcException(String msg) {,             super(msg);,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,run,1476-1476,[            BufferedReader reader = new BufferedReader(],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,addAllFiles,823-823,[            for (int i = 0; i < files.length; i++) {],,addAllFiles,822-822,[            File[] files = file.listFiles();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,deleteAllFiles,799-799,[            for (int i = 0; i < someFiles.length; i++) {],,deleteAllFiles,797-797,[            File[] someFiles = aFile.listFiles();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,addGenICGeneratedFiles,662-662,[                genericJarFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,addGenICGeneratedFiles,563-563,[            f.getParentFile().mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,createTempDir,782-782,[        tmpDir.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,deleteAllFiles,803-803,[        aFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,writeJar,364-364,[            genericJarFile.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,getJonasDescriptorName,445-445,[        baseName = descriptorName.substring(startOfFileName + 1, endOfBaseName + 1);],,getJonasDescriptorName,409-409,[        int startOfFileName = descriptorName.lastIndexOf(File.separatorChar);],,getJonasDescriptorName,436-436,[            endOfBaseName = descriptorName.lastIndexOf('.') - 1;],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,getWeblogicDescriptorHandler,438-438,[        handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, DEFAULT_WL51_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,getWeblogicDescriptorHandler,439-439,[        handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, DEFAULT_WL60_51_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,getWeblogicDescriptorHandler,440-440,[        handler.registerDTD(PUBLICID_WEBLOGIC_EJB600, DEFAULT_WL60_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,getWeblogicDescriptorHandler,441-441,[        handler.registerDTD(PUBLICID_WEBLOGIC_EJB700, DEFAULT_WL70_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,registerKnownDTDs,408-408,[        handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL51_EJB11_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,registerKnownDTDs,409-409,[        handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL60_EJB11_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,registerKnownDTDs,411-411,[        handler.registerDTD(PUBLICID_EJB20, DEFAULT_WL60_EJB20_DTD_LOCATION);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,addVendorFiles,511-511,[            } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,buildWeblogicJar,639-639,[        } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,buildWeblogicJar,546-546,[                    sourceJar.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,isRebuildRequired,810-810,[                        newWLJarFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,writeJar,672-672,[            genericJarFile.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,,422-435,[            new DescriptorHandler(getTask(), srcDir) {,                 protected void processElement() {,                     if (currentElement.equals("type-storage")) {,                         // Get the filename of vendor specific descriptor,                         String fileNameWithMETA = currentText;,                         //trim the META_INF\ off of the file name,                         String fileName,                              = fileNameWithMETA.substring(META_DIR.length(),,                             fileNameWithMETA.length());,                         File descriptorFile = new File(srcDir, fileName);, ,                         ejbFiles.put(fileNameWithMETA, descriptorFile);,                     },                 }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java,isRebuildRequired,775-775,[                        newwasJarFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java,writeJar,628-628,[                genericJarFile.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java,,391-393,[            new DescriptorHandler(getTask(), srcDir) {,                 protected void processElement() {,                 }],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/tools/ant/taskdefs/optional/extension/DeweyDecimal.java,,41-53,[        super(components);,     }, ,     /**,      * Construct a DeweyDecimal from string in DeweyDecimal format.,      *,      * @param string the string in dewey decimal format,      * @exception NumberFormatException if string is malformed,      */,     public DeweyDecimal(final String string),         throws NumberFormatException {,         super(string);,     }],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/extension/Extension.java,getAvailable,207-207,[            final Attributes attributes = (Attributes) entries.get(key);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/extension/Extension.java,getListed,581-581,[            final Attributes attributes = (Attributes) entries.get(key);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/extension/ExtensionUtil.java,getManifest,205-205,[            final JarFile jarFile = new JarFile(file);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/extension/ExtensionUtil.java,loadExtensions,134-134,[            final JarFile jarFile = new JarFile(file);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/extension/JarLibAvailableTask.java,execute,104-104,[        final Extension test = requiredExtension.toExtension();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/extension/JarLibManifestTask.java,execute,172-172,[            log("Generating manifest " + destFile.getAbsoluteFile(), Project.MSG_INFO);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/taskdefs/optional/extension/Specification.java,getSections,328-328,[            return null;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/extension/Specification.java,getSpecifications,179-179,[            final Attributes attributes = (Attributes) entries.get(key);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/extension/resolvers/AntResolver.java,resolve,76-76,[        ant.setAntfile(antfile.getName());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/extension/resolvers/URLResolver.java,getDest,92-92,[            final String file = url.getFile();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,processBundle,412-412,[            ins = new FileInputStream(propsFile);],,processBundle,413-413,[            loaded = true;],,processBundle,414-414,[            bundleLastModified[i] = propsFile.lastModified();],,processBundle,415-415,[            log("Using " + propsFile, Project.MSG_DEBUG);],,processBundle,416-416,[            loadResourceMap(ins);],,processBundle,425-425,[        }],,processBundle,426-426,[    }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,loadResourceMap,477-477,[            if (in != null) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,execute,319-319,[            toDir.mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,translate,511-511,[                            destDir.mkdirs();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,translateOneFile,614-614,[                                + line.substring(endIndex + endToken.length());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,translateOneFile,570-570,[                       && (startIndex + startToken.length()) <= line.length()) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/taskdefs/optional/i18n/TranslateTest.java,compareFiles,72-72,[        FileInputStream fis1 = new FileInputStream(file1);],,compareFiles,73-73,[        FileInputStream fis2 = new FileInputStream(file2);],,compareFiles,74-74,[        int index = 0;],,compareFiles,75-75,[        int read = 0;],,compareFiles,76-76,[        while ((read = fis1.read(buffer1)) != -1) {],,compareFiles,84-84,[        return true;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/i18n/TranslateTest.java,compareFiles,72-72,[        FileInputStream fis1 = new FileInputStream(file1);],,compareFiles,73-73,[        FileInputStream fis2 = new FileInputStream(file2);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/tools/ant/taskdefs/optional/i18n/TranslateTest.java,compareFiles,77-77,[            fis2.read(buffer2);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/j2ee/AbstractHotDeploymentTool.java,getUserName,151-151,[        return userName;],,getUsername,264-264,[        return sosUsername;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/j2ee/AbstractHotDeploymentTool.java,createClasspath,67-67,[            classpath = new Path(task.getProject());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/j2ee/AbstractHotDeploymentTool.java,validateAttributes,91-91,[        if (task.getAction() == null) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/taskdefs/optional/j2ee/JonasHotDeploymentTool.java,,41-249,[public class JonasHotDeploymentTool extends GenericHotDeploymentTool implements HotDeploymentTool {, ,     /**,      *  Description of the Field,      */,     protected static final String DEFAULT_ORB = "RMI";, ,     /**,      *  The classname of the tool to run *,      */,     private static final String JONAS_DEPLOY_CLASS_NAME = "org.objectweb.jonas.adm.JonasAdmin";, ,     /**,      *  All the valid actions that weblogic.deploy permits *,      */,     private static final String[] VALID_ACTIONS,         = {ACTION_DELETE, ACTION_DEPLOY, ACTION_LIST, ACTION_UNDEPLOY, ACTION_UPDATE};, ,     /**,      *  Description of the Field,      */,     private File jonasroot;, ,     /**,      *  Description of the Field,      */,     private String orb = null;, ,     /**,      *  Description of the Field,      */,     private String davidHost;, ,     /**,      *  Description of the Field,      */,     private int davidPort;, , ,     /**,      *  Set the host for the David ORB; required if,      *  ORB==david.,      *,      *@param  inValue  The new davidhost value,      */,     public void setDavidhost(final String inValue) {,         davidHost = inValue;,     }, , ,     /**,      *  Set the port for the David ORB; required if,      *  ORB==david.,      *,      *@param  inValue  The new davidport value,      */,     public void setDavidport(final int inValue) {,         davidPort = inValue;,     }, , ,     /**,      *  set the jonas root directory (-Dinstall.root=). This,      *  element is required.,      *,      *@param  inValue  The new jonasroot value,      */,     public void setJonasroot(final File inValue) {,         jonasroot = inValue;,     }, , ,     /**,      *,      * Choose your ORB : RMI, JEREMIE, DAVID, ...; optional.,      * If omitted, it defaults,      * to the one present in classpath. The corresponding JOnAS JAR is,      * automatically added to the classpath. If your orb is DAVID (RMI/IIOP) you must,      * specify davidhost and davidport properties.,      *,      *@param  inValue  RMI, JEREMIE, DAVID,...,      */,     public void setOrb(final String inValue) {,         orb = inValue;,     }, , ,     /**,      *  gets the classpath field.,      *,      *@return    A Path representing the "classpath" attribute.,      */,     public Path getClasspath() {, ,         Path aClassPath = super.getClasspath();, ,         if (aClassPath == null) {,             aClassPath = new Path(getTask().getProject());,         },         if (orb != null) {,             String aOrbJar = new File(jonasroot, "lib/" + orb + "_jonas.jar").toString();,             String aConfigDir = new File(jonasroot, "config/").toString();,             Path aJOnASOrbPath = new Path(aClassPath.getProject(),,                     aOrbJar + File.pathSeparator + aConfigDir);,             aClassPath.append(aJOnASOrbPath);,         },         return aClassPath;,     }, , ,     /**,      *  Validates the passed in attributes. <p>,      *,      *  The rules are:,      *  <ol>,      *    <li> If action is "deploy" or "update" the "application",      *    and "source" attributes must be supplied.,      *    <li> If action is "delete" or "undeploy" the,      *    "application" attribute must be supplied.,      *,      *@exception  BuildException                       Description,      *      of Exception,      */,     public void validateAttributes() throws BuildException {,         // super.validateAttributes(); // don't want to call this method, ,         Java java = getJava();, ,         String action = getTask().getAction();,         if (action == null) {,             throw new BuildException("The \"action\" attribute must be set");,         }, ,         if (!isActionValid()) {,             throw new BuildException("Invalid action \"" + action + "\" passed");,         }, ,         if (getClassName() == null) {,             setClassName(JONAS_DEPLOY_CLASS_NAME);,         }, ,         if (jonasroot == null || jonasroot.isDirectory()) {,             java.createJvmarg().setValue("-Dinstall.root=" + jonasroot);,             java.createJvmarg().setValue("-Djava.security.policy=" + jonasroot,                 + "/config/java.policy");, ,             if ("DAVID".equals(orb)) {,                 java.createJvmarg().setValue("-Dorg.omg.CORBA.ORBClass",                     + "=org.objectweb.david.libs.binding.orbs.iiop.IIOPORB");,                 java.createJvmarg().setValue("-Dorg.omg.CORBA.ORBSingletonClass=",                     + "org.objectweb.david.libs.binding.orbs.ORBSingletonClass");,                 java.createJvmarg().setValue("-Djavax.rmi.CORBA.StubClass=",                     + "org.objectweb.david.libs.stub_factories.rmi.StubDelegate");,                 java.createJvmarg().setValue("-Djavax.rmi.CORBA.PortableRemoteObjectClass=",                     + "org.objectweb.david.libs.binding.rmi.ORBPortableRemoteObjectDelegate");,                 java.createJvmarg().setValue("-Djavax.rmi.CORBA.UtilClass=",                     + "org.objectweb.david.libs.helpers.RMIUtilDelegate");,                 java.createJvmarg().setValue("-Ddavid.CosNaming.default_method=0");,                 java.createJvmarg().setValue("-Ddavid.rmi.ValueHandlerClass=",                     + "com.sun.corba.se.internal.io.ValueHandlerImpl");,                 if (davidHost != null) {,                     java.createJvmarg().setValue("-Ddavid.CosNaming.default_host=",                         + davidHost);,                 },                 if (davidPort != 0) {,                     java.createJvmarg().setValue("-Ddavid.CosNaming.default_port=",                         + davidPort);,                 },             },         }, ,         if (getServer() != null) {,             java.createArg().setLine("-n " + getServer());,         }, ,         if (action.equals(ACTION_DEPLOY),             || action.equals(ACTION_UPDATE),             || action.equals("redeploy")) {,             java.createArg().setLine("-a " + getTask().getSource());,         } else if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {,             java.createArg().setLine("-r " + getTask().getSource());,         } else if (action.equals(ACTION_LIST)) {,             java.createArg().setValue("-l");,         },     }, , ,     /**,      *  Determines if the action supplied is valid. <p>,      *,      *  Valid actions are contained in the static array,      *  VALID_ACTIONS,      *,      *@return    true if the action attribute is valid, false if,      *      not.,      */,     protected boolean isActionValid() {,         boolean valid = false;, ,         String action = getTask().getAction();, ,         for (int i = 0; i < VALID_ACTIONS.length; i++) {,             if (action.equals(VALID_ACTIONS[i])) {,                 valid = true;,                 break;,             },         }, ,         return valid;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/taskdefs/optional/j2ee/WebLogicHotDeploymentTool.java,,37-246,[public class WebLogicHotDeploymentTool extends AbstractHotDeploymentTool,                                        implements HotDeploymentTool {,     private static final int STRING_BUFFER_SIZE = 1024;,     /** The classname of the tool to run **/,     private static final String WEBLOGIC_DEPLOY_CLASS_NAME = "weblogic.deploy";, ,     /** All the valid actions that weblogic.deploy permits **/,     private static final String[] VALID_ACTIONS,         = {ACTION_DELETE, ACTION_DEPLOY, ACTION_LIST, ACTION_UNDEPLOY, ACTION_UPDATE};, ,     /** Represents the "-debug" flag from weblogic.deploy **/,     private boolean debug;, ,     /** The application name that is being deployed **/,     private String application;, ,     /** The component name:target(s) for the "-component" argument of weblogic.deploy **/,     private String component;, ,     /**,      *  Perform the actual deployment.,      *  For this implementation, a JVM is spawned and the weblogic.deploy,      *  tools is executed.,      *  @exception org.apache.tools.ant.BuildException if the attributes are invalid or incomplete.,      */,     public void deploy() {,         Java java = new Java(getTask());,         java.setFork(true);,         java.setFailonerror(true);,         java.setClasspath(getClasspath());, ,         java.setClassname(WEBLOGIC_DEPLOY_CLASS_NAME);,         java.createArg().setLine(getArguments());,         java.execute();,     }, ,     /**,      *  Validates the passed in attributes.,      *  <p>The rules are:,      *  <ol><li>If action is "deploy" or "update" the "application" and "source",      *  attributes must be supplied.,      *  <li>If action is "delete" or "undeploy" the "application" attribute must,      *  be supplied.,      *  @exception org.apache.tools.ant.BuildException if the attributes are invalid or incomplete,      */,     public void validateAttributes() throws BuildException {,         super.validateAttributes();, ,         String action = getTask().getAction();, ,         // check that the password has been set,         if ((getPassword() == null)) {,             throw new BuildException("The password attribute must be set.");,         }, ,         // check for missing application on deploy & update,         if ((action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE)),             && application == null) {,             throw new BuildException("The application attribute must be set ",                 + "if action = " + action);,         }, ,         // check for missing source on deploy & update,         if ((action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE)),             && getTask().getSource() == null) {,             throw new BuildException("The source attribute must be set if ",                 + "action = " + action);,         }, ,         // check for missing application on delete & undeploy,         if ((action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)),             && application == null) {,             throw new BuildException("The application attribute must be set if ",                 + "action = " + action);,         },     }, ,     /**,      *  Builds the arguments to pass to weblogic.deploy according to the,      *  supplied action.,      *  @return A String containing the arguments for the weblogic.deploy tool.,      * @throws BuildException if there is an error.,      */,     public String getArguments() throws BuildException {,         String action = getTask().getAction();,         String args = null;, ,         if (action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE)) {,             args = buildDeployArgs();,         } else if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {,             args = buildUndeployArgs();,         } else if (action.equals(ACTION_LIST)) {,             args = buildListArgs();,         }, ,         return args;,     }, ,     /**,      *  Determines if the action supplied is valid.,      *  <p>Valid actions are contained in the static array VALID_ACTIONS,      *  @return true if the action attribute is valid, false if not.,      */,     protected boolean isActionValid() {,         boolean valid = false;, ,         String action = getTask().getAction();, ,         for (int i = 0; i < VALID_ACTIONS.length; i++) {,             if (action.equals(VALID_ACTIONS[i])) {,                 valid = true;,                 break;,             },         }, ,         return valid;,     }, ,     /**,      *  Builds the prefix arguments to pass to weblogic.deploy.,      *  These arguments are generic across all actions.,      *  @return A StringBuffer containing the prefix arguments.,      *  The action-specific build methods will append to this StringBuffer.,      */,     protected StringBuffer buildArgsPrefix() {,         ServerDeploy task = getTask();,         // constructs the "-url <url> -debug <action> <password>" portion,         // of the commmand line,         return new StringBuffer(STRING_BUFFER_SIZE),                 .append((getServer() != null),                     ? "-url " + getServer(),                     : ""),                 .append(" "),                 .append(debug ? "-debug " : ""),                 .append((getUserName() != null),                     ? "-username " + getUserName(),                     : ""),                 .append(" "),                 .append(task.getAction()).append(" "),                 .append(getPassword()).append(" ");,     }, ,     /**,      *  Builds the arguments to pass to weblogic.deploy for deployment actions,      *  ("deploy" and "update").,      *  @return A String containing the full argument string for weblogic.deploy.,      */,     protected String buildDeployArgs() {,         String args = buildArgsPrefix(),                 .append(application).append(" "),                 .append(getTask().getSource()),                 .toString();, ,         if (component != null) {,             args = "-component " + component + " " + args;,         }, ,         return args;,     }, ,     /**,      *  Builds the arguments to pass to weblogic.deploy for undeployment actions,      *  ("undeploy" and "delete").,      *  @return A String containing the full argument string for weblogic.deploy.,      */,     protected String buildUndeployArgs() {,         return buildArgsPrefix(),                 .append(application).append(" "),                 .toString();,     }, ,     /**,      *  Builds the arguments to pass to weblogic.deploy for the list action,      *  @return A String containing the full argument string for weblogic.deploy.,      */,     protected String buildListArgs() {,         return buildArgsPrefix(),                 .toString();,     }, ,     /**,      *  If set to true, additional information will be,      *  printed during the deployment process; optional.,      *  @param debug A boolean representing weblogic.deploy "-debug" flag.,      */,     public void setDebug(boolean debug) {,         this.debug = debug;,     }, ,     /**,      *  The name of the application being deployed; required.,      *  @param application A String representing the application portion of the,      *  weblogic.deploy command line.,      */,     public void setApplication(String application) {,         this.application = application;,     }, ,     /**,      * the component string for the deployment targets; optional.,      * It is in the form <code>&lt;component&gt;:&lt;target1&gt;,&lt;target2&gt;...</code>,      * Where component is the archive name (minus the .jar, .ear, .war,      * extension).  Targets are the servers where the components will be deployed, ,      *  @param component A String representing the value of the "-component",      *  argument of the weblogic.deploy command line argument.,      */,     public void setComponent(String component) {,         this.component = component;,     }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/javacc/JavaCC.java,setChoiceambiguitycheck,122-122,[        optionalAttrs.put(CHOICE_AMBIGUITY_CHECK, new Integer(choiceAmbiguityCheck));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/javacc/JavaCC.java,setLookahead,114-114,[        optionalAttrs.put(LOOKAHEAD, new Integer(lookahead));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/javacc/JavaCC.java,setOtherambiguityCheck,130-130,[        optionalAttrs.put(OTHER_AMBIGUITY_CHECK, new Integer(otherAmbiguityCheck));],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/taskdefs/optional/javacc/JavaCC.java,,80-80,[    protected static final String[] ARCHIVE_LOCATIONS =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/taskdefs/optional/javacc/JavaCC.java,,88-88,[    protected static final int[] ARCHIVE_LOCATIONS_VS_MAJOR_VERSION =],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,67-68,[                values[i] = new Integer(data.readInt());,                 break;],,<init>,93-94,[                values[i] = new Integer(data.readInt());,                 break;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,80-80,[                values[i] = new Double(data.readDouble());],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,71-71,[                values[i] = new Float(data.readFloat());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,67-67,[                values[i] = new Integer(data.readInt());],,<init>,86-86,[                values[i] = new Integer(data.readUnsignedShort());],,<init>,93-93,[                values[i] = new Integer(data.readInt());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,75-75,[                values[i] = new Long(data.readLong());],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/optional/jlink/jlink.java,,46-452,[public class jlink {,     private static final int BUFFER_SIZE = 8192;,     private static final int VECTOR_INIT_SIZE = 10;, ,     private String outfile = null;, ,     private Vector mergefiles = new Vector(VECTOR_INIT_SIZE);, ,     private Vector addfiles = new Vector(VECTOR_INIT_SIZE);, ,     private boolean compression = false;, ,     // CheckStyle:VisibilityModifier OFF - bc, ,     byte[] buffer = new byte[BUFFER_SIZE];, ,     // CheckStyle:VisibilityModifier OFF - bc, ,     /** The file that will be created by this instance of jlink.,      * @param outfile the file to create.,      */,     public void setOutfile(String outfile) {,         if (outfile == null) {,             return;,         },         this.outfile = outfile;,     }, , ,     /**,      * Adds a file to be merged into the output.,      * @param fileToMerge the file to merge into the output.,      */,     public void addMergeFile(String fileToMerge) {,         if (fileToMerge == null) {,             return;,         },         mergefiles.addElement(fileToMerge);,     }, , ,     /** Adds a file to be added into the output.,      * @param fileToAdd the file to add to the output.,      */,     public void addAddFile(String fileToAdd) {,         if (fileToAdd == null) {,             return;,         },         addfiles.addElement(fileToAdd);,     }, , ,     /**,      * Adds several files to be merged into the output.,      * @param filesToMerge an array of files to merge into the output.,      */,     public void addMergeFiles(String[] filesToMerge) {,         if (filesToMerge == null) {,             return;,         },         for (int i = 0; i < filesToMerge.length; i++) {,             addMergeFile(filesToMerge[i]);,         },     }, , ,     /**,      * Adds several file to be added into the output.,      * @param filesToAdd an array of files to add to the output.,      */,     public void addAddFiles(String[] filesToAdd) {,         if (filesToAdd == null) {,             return;,         },         for (int i = 0; i < filesToAdd.length; i++) {,             addAddFile(filesToAdd[i]);,         },     }, , ,     /**,      * Determines whether output will be compressed.,      * @param compress if true use compression.,      */,     public void setCompression(boolean compress) {,         this.compression = compress;,     }, , ,     /**,      * Performs the linking of files. Addfiles are added to the output as-is.,      * For example, a jar file is added to the output as a jar file. However,,      * mergefiles are first examined for their type. If it is a jar or zip,      * file, the contents will be extracted from the mergefile and entered,      * into the output. If a zip or jar file is encountered in a subdirectory,      * it will be added, not merged. If a directory is encountered, it becomes,      * the root entry of all the files below it. Thus, you can provide,      * multiple, disjoint directories, as addfiles: they will all be added in,      * a rational manner to outfile.,      * @throws Exception on error.,      */,     public void link() throws Exception {,         ZipOutputStream output = new ZipOutputStream(new FileOutputStream(outfile));, ,         if (compression) {,             output.setMethod(ZipOutputStream.DEFLATED);,             output.setLevel(Deflater.DEFAULT_COMPRESSION);,         } else {,             output.setMethod(ZipOutputStream.STORED);,         }, ,         Enumeration merges = mergefiles.elements();, ,         while (merges.hasMoreElements()) {,             String path = (String) merges.nextElement();,             File f = new File(path);, ,             if (f.getName().endsWith(".jar") || f.getName().endsWith(".zip")) {,                 //Do the merge,                 mergeZipJarContents(output, f);,             } else {,                 //Add this file to the addfiles Vector and add it,                 //later at the top level of the output file.,                 addAddFile(path);,             },         }, ,         Enumeration adds = addfiles.elements();, ,         while (adds.hasMoreElements()) {,             String name = (String) adds.nextElement();,             File f = new File(name);, ,             if (f.isDirectory()) {,                 //System.out.println("in jlink: adding directory contents of " + f.getPath());,                 addDirContents(output, f, f.getName() + '/', compression);,             } else {,                 addFile(output, f, "", compression);,             },         },         FileUtils.close(output);,     }, , ,     /**,      * The command line entry point for jlink.,      * @param args an array of arguments,      */,     public static void main(String[] args) {,         // jlink output input1 ... inputN,         if (args.length < 2) {,             System.out.println("usage: jlink output input1 ... inputN");,             System.exit(1);,         },         jlink linker = new jlink();, ,         linker.setOutfile(args[0]);,         // To maintain compatibility with the command-line version,,         // we will only add files to be merged.,         for (int i = 1; i < args.length; i++) {,             linker.addMergeFile(args[i]);,         },         try {,             linker.link();,         } catch (Exception ex) {,             System.err.print(ex.getMessage());,         },     }, , ,     /*,      * Actually performs the merging of f into the output.,      * f should be a zip or jar file.,      */,     private void mergeZipJarContents(ZipOutputStream output, File f) throws IOException {,         //Check to see that the file with name "name" exists.,         if (!f.exists()) {,             return;,         },         ZipFile zipf = new ZipFile(f);,         Enumeration entries = zipf.entries();, ,         while (entries.hasMoreElements()) {,             ZipEntry inputEntry = (ZipEntry) entries.nextElement();,             //Ignore manifest entries.  They're bound to cause conflicts between,             //files that are being merged.  User should supply their own,             //manifest file when doing the merge.,             String inputEntryName = inputEntry.getName();,             int index = inputEntryName.indexOf("META-INF");, ,             if (index < 0) {,                 //META-INF not found in the name of the entry. Go ahead and process it.,                 try {,                     output.putNextEntry(processEntry(zipf, inputEntry));,                 } catch (ZipException ex) {,                     //If we get here, it could be because we are trying to put a,                     //directory entry that already exists.,                     //For example, we're trying to write "com", but a previous,                     //entry from another mergefile was called "com".,                     //In that case, just ignore the error and go on to the,                     //next entry.,                     String mess = ex.getMessage();, ,                     if (mess.indexOf("duplicate") >= 0) {,                         //It was the duplicate entry.,                         continue;,                     } else {,                         // I hate to admit it, but we don't know what happened,                         // here.  Throw the Exception.,                         throw ex;,                     },                 }, ,                 InputStream in = zipf.getInputStream(inputEntry);,                 int len = buffer.length;,                 int count = -1;, ,                 while ((count = in.read(buffer, 0, len)) > 0) {,                     output.write(buffer, 0, count);,                 },                 in.close();,                 output.closeEntry();,             },         },         zipf.close();,     }, , ,     /*,      * Adds contents of a directory to the output.,      */,     private void addDirContents(ZipOutputStream output, File dir, String prefix,,                                 boolean compress) throws IOException {,         String[] contents = dir.list();, ,         for (int i = 0; i < contents.length; ++i) {,             String name = contents[i];,             File file = new File(dir, name);, ,             if (file.isDirectory()) {,                 addDirContents(output, file, prefix + name + '/', compress);,             } else {,                 addFile(output, file, prefix, compress);,             },         },     }, , ,     /*,      * Gets the name of an entry in the file.  This is the real name,      * which for a class is the name of the package with the class,      * name appended.,      */,     private String getEntryName(File file, String prefix) {,         String name = file.getName();, ,         if (!name.endsWith(".class")) {,             // see if the file is in fact a .class file, and determine its actual name.,             InputStream input = null;,             try {,                 input = new FileInputStream(file);,                 String className = ClassNameReader.getClassName(input);, ,                 if (className != null) {,                     return className.replace('.', '/') + ".class";,                 },             } catch (IOException ioe) {,                 //do nothing,             } finally {,                 if (input != null) {,                     try {,                         input.close();,                     } catch (IOException e) {,                         //do nothing,                     },                 },             },         },         System.out.println("From " + file.getPath() + " and prefix " + prefix,                            + ", creating entry " + prefix + name);,         return (prefix + name);,     }, , ,     /*,      * Adds a file to the output stream.,      */,     private void addFile(ZipOutputStream output, File file, String prefix,,                          boolean compress) throws IOException {,         //Make sure file exists,         if (!file.exists()) {,             return;,         },         ZipEntry entry = new ZipEntry(getEntryName(file, prefix));, ,         entry.setTime(file.lastModified());,         entry.setSize(file.length());,         if (!compress) {,             entry.setCrc(calcChecksum(file));,         },         FileInputStream input = new FileInputStream(file);, ,         addToOutputStream(output, input, entry);,     }, , ,     /*,      * A convenience method that several other methods might call.,      */,     private void addToOutputStream(ZipOutputStream output, InputStream input,,                                    ZipEntry ze) throws IOException {,         try {,             output.putNextEntry(ze);,         } catch (ZipException zipEx) {,             //This entry already exists. So, go with the first one.,             input.close();,             return;,         }, ,         int numBytes = -1;, ,         while ((numBytes = input.read(buffer)) > 0) {,             output.write(buffer, 0, numBytes);,         },         output.closeEntry();,         input.close();,     }, , ,     /*,      * A method that does the work on a given entry in a mergefile.,      * The big deal is to set the right parameters in the ZipEntry,      * on the output stream.,      */,     private ZipEntry processEntry(ZipFile zip, ZipEntry inputEntry) {,         /*,           First, some notes.,           On MRJ 2.2.2, getting the size, compressed size, and CRC32 from the,           ZipInputStream does not work for compressed (deflated) files.  Those calls return -1.,           For uncompressed (stored) files, those calls do work.,           However, using ZipFile.getEntries() works for both compressed and,           uncompressed files., ,           Now, from some simple testing I did, it seems that the value of CRC-32 is,           independent of the compression setting. So, it should be easy to pass this,           information on to the output entry.,         */,         String name = inputEntry.getName();, ,         if (!(inputEntry.isDirectory() || name.endsWith(".class"))) {,             try {,                 InputStream input = zip.getInputStream(zip.getEntry(name));,                 String className = ClassNameReader.getClassName(input);, ,                 input.close();,                 if (className != null) {,                     name = className.replace('.', '/') + ".class";,                 },             } catch (IOException ioe) {,                 //do nothing,             },         },         ZipEntry outputEntry = new ZipEntry(name);, ,         outputEntry.setTime(inputEntry.getTime());,         outputEntry.setExtra(inputEntry.getExtra());,         outputEntry.setComment(inputEntry.getComment());,         outputEntry.setTime(inputEntry.getTime());,         if (compression) {,             outputEntry.setMethod(ZipEntry.DEFLATED);,             //Note, don't need to specify size or crc for compressed files.,         } else {,             outputEntry.setMethod(ZipEntry.STORED);,             outputEntry.setCrc(inputEntry.getCrc());,             outputEntry.setSize(inputEntry.getSize());,         },         return outputEntry;,     }, , ,     /*,      * Necessary in the case where you add a entry that,      * is not compressed.,      */,     private long calcChecksum(File f) throws IOException {,         BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));, ,         return calcChecksum(in);,     }, , ,     /*,      * Necessary in the case where you add a entry that,      * is not compressed.,      */,     private long calcChecksum(InputStream in) throws IOException {,         CRC32 crc = new CRC32();,         int len = buffer.length;,         int count = -1;,         int haveRead = 0;, ,         while ((count = in.read(buffer, 0, len)) > 0) {,             haveRead += count;,             crc.update(buffer, 0, count);,         },         in.close();,         return crc.getValue();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/jlink/jlink.java,addDirContents,281-281,[        for (int i = 0; i < contents.length; ++i) {],,addDirContents,279-279,[        String[] contents = dir.list();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/taskdefs/optional/jlink/jlink.java,addFile,346-346,[        FileInputStream input = new FileInputStream(file);],,addFile,348-348,[        addToOutputStream(output, input, entry);],,addFile,349-349,[    }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/jsp/JspC.java,deleteEmptyJavaFiles,673-673,[                    file.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/jsp/JspC.java,getActualDestDir,533-533,[            String path = destDir.getPath() + File.separatorChar],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/taskdefs/optional/jsp/JspNameMangler.java,,36-36,[    public static final String[] keywords = {],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/optional/jsp/JspNameMangler.java,mapJspToBaseName,80-80,[                className += "%";],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java,replaceString,330-330,[            localString += test;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java,execute,108-108,[        if (!destinationDirectory.isDirectory()) {],,execute,154-154,[        args[j++] = destinationDirectory.getAbsolutePath().trim();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java,execute,113-113,[        if (!sourceDirectory.isDirectory()) {],,execute,156-156,[        args[j++] = sourceDirectory.getAbsolutePath().trim();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,,123-123,[       dbfactory = privateDBFactory;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,setXmlfile,178-178,[        } catch (Exception e) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,transform,254-254,[            String tempFileProperty = getClass().getName() + String.valueOf(counter++);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,,159-159,[        this.document = doc;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,,123-123,[       dbfactory = privateDBFactory;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,transform,268-268,[        paramx.setExpression(toDir.getAbsolutePath());],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/junit/BaseTest.java,,34-34,[    protected String ifProperty = null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/junit/BaseTest.java,,35-35,[    protected String unlessProperty = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/BriefJUnitResultFormatter.java,setOutput,94-94,[        output = new BufferedWriter(new java.io.OutputStreamWriter(out));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/optional/junit/DOMUtilTest.java,,45-50,[    public class FooNodeFilter implements DOMUtil.NodeFilter {,         public boolean accept(Node node) {,             if (node.getNodeName().equals("foo")) {,                 return true;,             },             return false;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java,writeJavaClass,256-256,[            writer = new BufferedWriter(new FileWriter(sourceFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitReportTest.java,testStackTraceLineBreaks,100-100,[            r = new FileReader(new File(buildRule.getOutputDir(), "html/sampleproject/coins/0_CoinTest.html"));],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,checkForkedPath,1386-1386,[            } catch (final Exception ex) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,execute,1066-1066,[            writer = new BufferedWriter(new FileWriter(casesFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,execute,1070-1070,[            final PrintStream logWriter =],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,executeAsForked,1265-1265,[                    br = new BufferedReader(new FileReader(vmWatcher));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,executeAsForked,1220-1220,[            final FileOutputStream outstream = new FileOutputStream(propsFile);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,logVmExit,1856-1856,[                    if (formatter != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,checkForkedPath,1386-1386,[            } catch (final Exception ex) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,createMirror,763-763,[        } catch (final Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,executeAsForked,1273-1273,[            } catch (final Exception e) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskMirrorImpl.java,,45-45,[        this.task = task;],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskMirrorImpl.java,,83-106,[        VmExitErrorTest(String aMessage, JUnitTest anOriginalTest, String aTestCase) {,             message = aMessage;,             test = anOriginalTest;,             testCase = aTestCase;,         }, ,         public int countTestCases() {,             return 1;,         }, ,         public void run(TestResult r) {,             throw new AssertionFailedError(message);,         }, ,         public String getName() {,             return testCase;,         }, ,         String getClassName() {,             return test.getName();,         }, ,         public String toString() {,             return test.getName() + ":" + testCase;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskTest.java,assertOutput,296-296,[        FileReader inner = new FileReader(new File(buildRule.getOutputDir(),],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskTest.java,assertOutput,298-298,[        BufferedReader reader = new BufferedReader(inner);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,createEmptyStream,311-311,[        return new PrintStream(],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,createTeePrint,320-320,[        return new PrintStream(new TeeOutputStream(ps1, ps2));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,main,976-976,[                final java.io.BufferedReader reader =],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,registerNonCrash,1194-1194,[                out = new FileWriter(crashFile);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,registerTestCase,1208-1208,[                    out = new FileWriter(crashFile);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,run,566-566,[                    out = new String(outStrm.toByteArray());],,run,571-571,[                    err = new String(errStrm.toByteArray());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,setupIOStreams,325-325,[        systemOut = new PrintStream(o);],,setupIOStreams,326-326,[        systemError = new PrintStream(e);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,filterStack,1151-1151,[        } catch (final Exception e) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,<init>,297-297,[        JUnitTestRunner.filtertrace = filtertrace; // TODO clumsy, should use instance field somehow],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,,312-315,[            new OutputStream() {,                 @Override,                 public void write(final int b) {,                 }],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunnerTest.java,,193-194,[            super(name);,             throw new NullPointerException("thrown on purpose");],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/junit/JUnitVersionHelper.java,getTestCaseName,105-105,[                if (getNameMethod != null],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/taskdefs/optional/junit/JUnitVersionHelperTest.java,,98-99,[    public static class Foo5 extends TestCase {,         public String getName() {return "overridden getName";}],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/PlainJUnitResultFormatter.java,startTestSuite,107-107,[            out.write(sb.toString().getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/PlainJUnitResultFormatter.java,write,311-311,[            out.write(text.getBytes());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/junit/PlainJUnitResultFormatter.java,startTest,185-185,[        testStarts.put(t, new Long(System.currentTimeMillis()));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/SummaryJUnitResultFormatter.java,endTestSuite,202-202,[            writeOutputLine(sb.toString().getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/SummaryJUnitResultFormatter.java,startTestSuite,95-95,[        writeOutputLine(sb.toString().getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/XMLFormatterWithCDATAOnSystemOut.java,testBuildfile,70-70,[                reader = new FileReader(f);],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/tools/ant/taskdefs/optional/junit/XMLFormatterWithCDATAOnSystemOut.java,testBuildfile,72-72,[                assertTrue(content.indexOf("</RESPONSE>&#x5d;&#x5d;&gt;"],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/junit/XMLFormatterWithCDATAOnSystemOut.java,testBuildfile,78-78,[                f.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,endTest,254-254,[            rootElement.appendChild(currentTest);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,endTestSuite,186-186,[        rootElement.setAttribute(ATTR_TESTS, "" + suite.runCount());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,formatOutput,327-327,[        rootElement.appendChild(nested);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/XMLResultAggregatorTest.java,testFrames,51-51,[        PrintWriter pw = new PrintWriter(new FileOutputStream(xml));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/junit/XMLResultAggregatorTest.java,,47-47,[            new Delete() {{removeDir(d);}}; // is there no utility method for this?],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/junit/XMLResultAggregatorTest.java,,88-88,[        System.setSecurityManager(new SecurityManager() {public void checkPermission(Permission perm) {}});],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java,createFolders,302-302,[            in = new BufferedReader(new FileReader(file));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java,massagePCLI,360-360,[            inReader = new BufferedReader(new FileReader(in));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java,massagePCLI,361-361,[            outWriter = new BufferedWriter(new FileWriter(out));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java,execute,288-288,[                tmp.delete();],,execute,291-291,[                tmp2.delete();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/sos/SOS.java,getLocalPath,360-374,[        if (localPath == null) {,             return getProject().getBaseDir().getAbsolutePath();,         } else {,             // make sure localDir exists, create it if it doesn't,             File dir = getProject().resolveFile(localPath);,             if (!dir.exists()) {,                 boolean done = dir.mkdirs() || dir.isDirectory();,                 if (!done) {,                     String msg = "Directory " + localPath + " creation was not ",                         + "successful for an unknown reason";,                     throw new BuildException(msg, getLocation());,                 },                 getProject().log("Created dir: " + dir.getAbsolutePath());,             },             return dir.getAbsolutePath();],,getLocalpath,485-500,[        String lclPath = ""; //set to empty str if no local path return,         if (localPath != null) {,             //make sure m_LocalDir exists, create it if it doesn't,             File dir = getProject().resolveFile(localPath);,             if (!dir.exists()) {,                 boolean done = dir.mkdirs();,                 if (!done) {,                     String msg = "Directory " + localPath + " creation was not ",                             + "successful for an unknown reason";,                     throw new BuildException(msg, getLocation());,                 },                 getProject().log("Created dir: " + dir.getAbsolutePath());,             },             lclPath = FLAG_OVERRIDE_WORKING_DIR + localPath;,         },         return lclPath;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/sos/SOS.java,setLocalPath,168-169,[        localPath = path.toString();,     }],,setLocalpath,120-121,[        this.localPath = localPath.toString();,     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/sos/SOSTest.java,tearDown,72-72,[            file.delete();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/optional/sound/SoundTask.java,getSource,170-170,[                this.source = nofile;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/sound/SoundTask.java,getSource,152-152,[                    for (int i = 0; i < entries.length; i++) {],,getSource,150-150,[                    String[] entries = source.list();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java,init,78-78,[        JPanel pan = (JPanel) getContentPane();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java,messageLogged,165-165,[                    int i = Math.min(new Integer(gr).intValue() * 2, MAX);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java,messageLogged,165-165,[                    int i = Math.min(new Integer(gr).intValue() * 2, MAX);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java,messageLogged,162-162,[            if (matcher != null && matcher.matches()) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/splash/SplashTask.java,execute,251-251,[                    splash = new SplashScreen(img, progressRegExp, displayText);],,execute,271-271,[                splash = new SplashScreen("Image Unavailable.", progressRegExp,],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/splash/SplashTask.java,execute,166-166,[            splash = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/unix/Symlink.java,loadLinks,585-585,[                lnks.list(new PrintStream(],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/unix/Symlink.java,record,270-270,[                Vector linksInDir = (Vector) byDir.get(dir);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/vss/MSVSSTest.java,testGetCommandLine,84-112,[        String[] sTestCmdLine = {MSVSS.SS_EXE, MSVSS.COMMAND_GET, DS_VSS_PROJECT_PATH,,                 MSVSS.FLAG_OVERRIDE_WORKING_DIR + project.getBaseDir(),                         .getAbsolutePath(),                  + File.separator + LOCAL_PATH, MSVSS.FLAG_AUTORESPONSE_DEF,,                 MSVSS.FLAG_RECURSION, MSVSS.FLAG_VERSION + VERSION, MSVSS.FLAG_LOGIN,                  + VSS_USERNAME + "," + VSS_PASSWORD, FLAG_FILETIME_UPDATED, FLAG_SKIP_WRITABLE};, ,         // Set up a VSSGet task,         MSVSSGET vssGet = new MSVSSGET();,         vssGet.setProject(project);,         vssGet.setRecursive(true);,         vssGet.setLocalpath(new Path(project, LOCAL_PATH));,         vssGet.setLogin(VSS_USERNAME + "," + VSS_PASSWORD);,         vssGet.setVersion(VERSION);,         vssGet.setQuiet(false);,         vssGet.setDate(DATE);,         vssGet.setLabel(SRC_LABEL);,         vssGet.setVsspath(VSS_PROJECT_PATH);,         MSVSS.CurrentModUpdated cmu = new MSVSS.CurrentModUpdated();,         cmu.setValue(TIME_UPDATED);,         vssGet.setFileTimeStamp(cmu);,         MSVSS.WritableFiles wf = new MSVSS.WritableFiles();,         wf.setValue(WRITABLE_SKIP);,         vssGet.setWritableFiles(wf);, ,         commandline = vssGet.buildCmdLine();, ,         checkCommandLines(sTestCmdLine, commandline.getCommandline());,     }],,testGetCommandline,65-103,[        CommandlineJava c = new CommandlineJava();,         c.createArgument().setValue("org.apache.tools.ant.CommandlineJavaTest");,         c.setClassname("junit.textui.TestRunner");,         c.createVmArgument().setValue("-Djava.compiler=NONE");,         String[] s = c.getCommandline();,         assertEquals("no classpath", 4, s.length);,         /*,          * After changing CommandlineJava to search for the java,          * executable, I don't know, how to tests the value returned,          * here without using the same logic as applied in the class,          * itself.,          *,          * assertTrue("no classpath", "java", s[0]);,          */,         assertEquals("no classpath", "-Djava.compiler=NONE", s[1]);,         assertEquals("no classpath", "junit.textui.TestRunner", s[2]);,         assertEquals("no classpath",,                      "org.apache.tools.ant.CommandlineJavaTest", s[3]);,         try {,             c.clone();,         } catch (NullPointerException ex) {,             fail("cloning should work without classpath specified");,         }, ,         c.createClasspath(project).setLocation(project.resolveFile("build.xml"));,         c.createClasspath(project).setLocation(project.resolveFile(,             System.getProperty(MagicNames.ANT_HOME)+"/lib/ant.jar"));,         s = c.getCommandline();,         assertEquals("with classpath", 6, s.length);,         //        assertEquals("with classpath", "java", s[0]);,         assertEquals("with classpath", "-Djava.compiler=NONE", s[1]);,         assertEquals("with classpath", "-classpath", s[2]);,         assertTrue("build.xml contained",,                s[3].indexOf("build.xml"+java.io.File.pathSeparator) >= 0);,         assertTrue("ant.jar contained", s[3].endsWith("ant.jar"));,         assertEquals("with classpath", "junit.textui.TestRunner", s[4]);,         assertEquals("with classpath",,                      "org.apache.tools.ant.CommandlineJavaTest", s[5]);,     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/vss/MSVSSTest.java,tearDown,78-78,[            file.delete();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/taskdefs/rmic/DefaultRmicAdapter.java,mapFileName,390-390,[                return null;],,mapFileName,399-399,[                return null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/AbstractFileSet.java,,113-113,[        if (dir != null || defaultPatterns.hasPatterns(getProject())) {],,,157-157,[        return dir;],,,527-527,[        ds.setBasedir(dir);],,,530-530,[        p.log(getDataTypeName() + ": Setup scanner in dir " + dir],,,134-134,[        this.dir = dir;],,,479-479,[                if (dir == null) {],,,483-483,[                if (!dir.exists() && errorOnMissingDir) {],,,488-488,[                if (!dir.isDirectory() && dir.exists()) {],,,484-484,[                    throw new BuildException(dir.getAbsolutePath()],,,489-489,[                    throw new BuildException(dir.getAbsolutePath()],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/AbstractFileSet.java,,65-921,[    private PatternSet defaultPatterns = new PatternSet();,     private List<PatternSet> additionalPatterns = new ArrayList<PatternSet>();,     private List<FileSelector> selectors = new ArrayList<FileSelector>();, ,     private File dir;,     private boolean useDefaultExcludes = true;,     private boolean caseSensitive = true;,     private boolean followSymlinks = true;,     private boolean errorOnMissingDir = true;,     private int maxLevelsOfSymlinks = DirectoryScanner.MAX_LEVELS_OF_SYMLINKS;, ,     /* cached DirectoryScanner instance for our own Project only */,     private DirectoryScanner directoryScanner = null;, ,     /**,      * Construct a new <code>AbstractFileSet</code>.,      */,     public AbstractFileSet() {,         super();,     }, ,     /**,      * Construct a new <code>AbstractFileSet</code>, shallowly cloned,      * from the specified <code>AbstractFileSet</code>.,      * @param fileset the <code>AbstractFileSet</code> to use as a template.,      */,     protected AbstractFileSet(AbstractFileSet fileset) {,         this.dir = fileset.dir;,         this.defaultPatterns = fileset.defaultPatterns;,         this.additionalPatterns = fileset.additionalPatterns;,         this.selectors = fileset.selectors;,         this.useDefaultExcludes = fileset.useDefaultExcludes;,         this.caseSensitive = fileset.caseSensitive;,         this.followSymlinks = fileset.followSymlinks;,         this.errorOnMissingDir = fileset.errorOnMissingDir;,         this.maxLevelsOfSymlinks = fileset.maxLevelsOfSymlinks;,         setProject(fileset.getProject());,     }, ,     /**,      * Makes this instance in effect a reference to another instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      * @param r the <code>Reference</code> to use.,      * @throws BuildException on error,      */,     public void setRefid(Reference r) throws BuildException {,         if (dir != null || defaultPatterns.hasPatterns(getProject())) {,             throw tooManyAttributes();,         },         if (!additionalPatterns.isEmpty()) {,             throw noChildrenAllowed();,         },         if (!selectors.isEmpty()) {,             throw noChildrenAllowed();,         },         super.setRefid(r);,     }, ,     /**,      * Sets the base-directory for this instance.,      * @param dir the directory's <code>File</code> instance.,      * @throws BuildException on error,      */,     public synchronized void setDir(File dir) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.dir = dir;,         directoryScanner = null;,     }, ,     /**,      * Retrieves the base-directory for this instance.,      * @return <code>File</code>.,      */,     public File getDir() {,         return getDir(getProject());,     }, ,     /**,      * Retrieves the base-directory for this instance.,      * @param p the <code>Project</code> against which the,      *          reference is resolved, if set.,      * @return <code>File</code>.,      */,     public synchronized File getDir(Project p) {,         if (isReference()) {,             return getRef(p).getDir(p);,         },         dieOnCircularReference();,         return dir;,     }, ,     /**,      * Creates a nested patternset.,      * @return <code>PatternSet</code>.,      */,     public synchronized PatternSet createPatternSet() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         PatternSet patterns = new PatternSet();,         additionalPatterns.add(patterns);,         directoryScanner = null;,         return patterns;,     }, ,     /**,      * Add a name entry to the include list.,      * @return <code>PatternSet.NameEntry</code>.,      */,     public synchronized PatternSet.NameEntry createInclude() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         directoryScanner = null;,         return defaultPatterns.createInclude();,     }, ,     /**,      * Add a name entry to the include files list.,      * @return <code>PatternSet.NameEntry</code>.,      */,     public synchronized PatternSet.NameEntry createIncludesFile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         directoryScanner = null;,         return defaultPatterns.createIncludesFile();,     }, ,     /**,      * Add a name entry to the exclude list.,      * @return <code>PatternSet.NameEntry</code>.,      */,     public synchronized PatternSet.NameEntry createExclude() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         directoryScanner = null;,         return defaultPatterns.createExclude();,     }, ,     /**,      * Add a name entry to the excludes files list.,      * @return <code>PatternSet.NameEntry</code>.,      */,     public synchronized PatternSet.NameEntry createExcludesFile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         directoryScanner = null;,         return defaultPatterns.createExcludesFile();,     }, ,     /**,      * Creates a single file fileset.,      * @param file the single <code>File</code> included in this,      *             <code>AbstractFileSet</code>.,      */,     public synchronized void setFile(File file) {,         if (isReference()) {,             throw tooManyAttributes();,         },         setDir(file.getParentFile());,         createInclude().setName(file.getName());,     }, ,     /**,      * Appends <code>includes</code> to the current list of include,      * patterns.,      *,      * <p>Patterns may be separated by a comma or a space.</p>,      *,      * @param includes the <code>String</code> containing the include patterns.,      */,     public synchronized void setIncludes(String includes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         defaultPatterns.setIncludes(includes);,         directoryScanner = null;,     }, ,     /**,      * Appends <code>includes</code> to the current list of include,      * patterns.,      *,      * @param includes array containing the include patterns.,      * @since Ant 1.7,      */,     public synchronized void appendIncludes(String[] includes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (includes != null) {,             for (int i = 0; i < includes.length; i++) {,                 defaultPatterns.createInclude().setName(includes[i]);,             },             directoryScanner = null;,         },     }, ,     /**,      * Appends <code>excludes</code> to the current list of exclude,      * patterns.,      *,      * <p>Patterns may be separated by a comma or a space.</p>,      *,      * @param excludes the <code>String</code> containing the exclude patterns.,      */,     public synchronized void setExcludes(String excludes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         defaultPatterns.setExcludes(excludes);,         directoryScanner = null;,     }, ,     /**,      * Appends <code>excludes</code> to the current list of include,      * patterns.,      *,      * @param excludes array containing the exclude patterns.,      * @since Ant 1.7,      */,     public synchronized void appendExcludes(String[] excludes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (excludes != null) {,             for (int i = 0; i < excludes.length; i++) {,                 defaultPatterns.createExclude().setName(excludes[i]);,             },             directoryScanner = null;,         },     }, ,     /**,      * Sets the <code>File</code> containing the includes patterns.,      *,      * @param incl <code>File</code> instance.,      * @throws BuildException on error,      */,     public synchronized void setIncludesfile(File incl) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         defaultPatterns.setIncludesfile(incl);,         directoryScanner = null;,     }, ,     /**,      * Sets the <code>File</code> containing the excludes patterns.,      *,      * @param excl <code>File</code> instance.,      * @throws BuildException on error,      */,     public synchronized void setExcludesfile(File excl) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         defaultPatterns.setExcludesfile(excl);,         directoryScanner = null;,     }, ,     /**,      * Sets whether default exclusions should be used or not.,      *,      * @param useDefaultExcludes <code>boolean</code>.,      */,     public synchronized void setDefaultexcludes(boolean useDefaultExcludes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.useDefaultExcludes = useDefaultExcludes;,         directoryScanner = null;,     }, ,     /**,      * Whether default exclusions should be used or not.,      * @return the default exclusions value.,      * @since Ant 1.6.3,      */,     public synchronized boolean getDefaultexcludes() {,         if (isReference()) {,             return getRef(getProject()).getDefaultexcludes();,         },         dieOnCircularReference();,         return useDefaultExcludes;,     }, ,     /**,      * Sets case sensitivity of the file system.,      *,      * @param caseSensitive <code>boolean</code>.,      */,     public synchronized void setCaseSensitive(boolean caseSensitive) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.caseSensitive = caseSensitive;,         directoryScanner = null;,     }, ,     /**,      * Find out if the fileset is case sensitive.,      *,      * @return <code>boolean</code> indicating whether the fileset is,      * case sensitive.,      *,      * @since Ant 1.7,      */,     public synchronized boolean isCaseSensitive() {,         if (isReference()) {,             return getRef(getProject()).isCaseSensitive();,         },         dieOnCircularReference();,         return caseSensitive;,     }, ,     /**,      * Sets whether or not symbolic links should be followed.,      *,      * @param followSymlinks whether or not symbolic links should be followed.,      */,     public synchronized void setFollowSymlinks(boolean followSymlinks) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.followSymlinks = followSymlinks;,         directoryScanner = null;,     }, ,     /**,      * Find out if the fileset wants to follow symbolic links.,      *,      * @return <code>boolean</code> indicating whether symbolic links,      *         should be followed.,      *,      * @since Ant 1.6,      */,     public synchronized boolean isFollowSymlinks() {,         if (isReference()) {,             return getRef(getProject()).isCaseSensitive();,         },         dieOnCircularReference();,         return followSymlinks;,     }, ,     /**,      * The maximum number of times a symbolic link may be followed,      * during a scan.,      *,      * @since Ant 1.8.0,      */,     public void setMaxLevelsOfSymlinks(int max) {,         maxLevelsOfSymlinks = max;,     }, ,     /**,      * The maximum number of times a symbolic link may be followed,      * during a scan.,      *,      * @since Ant 1.8.0,      */,     public int getMaxLevelsOfSymlinks() {,         return maxLevelsOfSymlinks;,     }, ,     /**,      * Sets whether an error is thrown if a directory does not exist.,      *,      * @param errorOnMissingDir true if missing directories cause errors,,      *                        false if not.,      */,      public void setErrorOnMissingDir(boolean errorOnMissingDir) {,          this.errorOnMissingDir = errorOnMissingDir;,      }, ,     /**,      * Gets whether an error is/should be thrown if the base directory,      * does not exist.,      * @since Ant 1.8.2,      */,      public boolean getErrorOnMissingDir() {,          return errorOnMissingDir;,      }, ,     /**,      * Returns the directory scanner needed to access the files to process.,      * @return a <code>DirectoryScanner</code> instance.,      */,     public DirectoryScanner getDirectoryScanner() {,         return getDirectoryScanner(getProject());,     }, ,     /**,      * Returns the directory scanner needed to access the files to process.,      * @param p the Project against which the DirectoryScanner should be configured.,      * @return a <code>DirectoryScanner</code> instance.,      */,     public DirectoryScanner getDirectoryScanner(Project p) {,         if (isReference()) {,             return getRef(p).getDirectoryScanner(p);,         },         dieOnCircularReference();,         DirectoryScanner ds = null;,         synchronized (this) {,             if (directoryScanner != null && p == getProject()) {,                 ds = directoryScanner;,             } else {,                 if (dir == null) {,                     throw new BuildException("No directory specified for ",                                              + getDataTypeName() + ".");,                 },                 if (!dir.exists() && errorOnMissingDir) {,                     throw new BuildException(dir.getAbsolutePath(),                                              + DirectoryScanner,                                              .DOES_NOT_EXIST_POSTFIX);,                 },                 if (!dir.isDirectory() && dir.exists()) {,                     throw new BuildException(dir.getAbsolutePath(),                                              + " is not a directory.");,                 },                 ds = new DirectoryScanner();,                 setupDirectoryScanner(ds, p);,                 ds.setFollowSymlinks(followSymlinks);,                 ds.setErrorOnMissingDir(errorOnMissingDir);,                 ds.setMaxLevelsOfSymlinks(maxLevelsOfSymlinks);,                 directoryScanner = (p == getProject()) ? ds : directoryScanner;,             },         },         ds.scan();,         return ds;,     }, ,     /**,      * Set up the specified directory scanner against this,      * AbstractFileSet's Project.,      * @param ds a <code>FileScanner</code> instance.,      */,     public void setupDirectoryScanner(FileScanner ds) {,         setupDirectoryScanner(ds, getProject());,     }, ,     /**,      * Set up the specified directory scanner against the specified project.,      * @param ds a <code>FileScanner</code> instance.,      * @param p an Ant <code>Project</code> instance.,      */,     public synchronized void setupDirectoryScanner(FileScanner ds, Project p) {,         if (isReference()) {,             getRef(p).setupDirectoryScanner(ds, p);,             return;,         },         dieOnCircularReference(p);,         if (ds == null) {,             throw new IllegalArgumentException("ds cannot be null");,         },         ds.setBasedir(dir);, ,         PatternSet ps = mergePatterns(p);,         p.log(getDataTypeName() + ": Setup scanner in dir " + dir,             + " with " + ps, Project.MSG_DEBUG);, ,         ds.setIncludes(ps.getIncludePatterns(p));,         ds.setExcludes(ps.getExcludePatterns(p));,         if (ds instanceof SelectorScanner) {,             SelectorScanner ss = (SelectorScanner) ds;,             ss.setSelectors(getSelectors(p));,         },         if (useDefaultExcludes) {,             ds.addDefaultExcludes();,         },         ds.setCaseSensitive(caseSensitive);,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced FileSet.,      * @param p the current project,      * @return the referenced FileSet,      */,     protected AbstractFileSet getRef(Project p) {,         return (AbstractFileSet) getCheckedRef(p);,     }, ,     // SelectorContainer methods, ,     /**,      * Indicates whether there are any selectors here.,      *,      * @return whether any selectors are in this container.,      */,     public synchronized boolean hasSelectors() {,         if (isReference()) {,             return getRef(getProject()).hasSelectors();,         },         dieOnCircularReference();,         return !(selectors.isEmpty());,     }, ,     /**,      * Indicates whether there are any patterns here.,      *,      * @return whether any patterns are in this container.,      */,     public synchronized boolean hasPatterns() {,         if (isReference() && getProject() != null) {,             return getRef(getProject()).hasPatterns();,         },         dieOnCircularReference();,         if (defaultPatterns.hasPatterns(getProject())) {,             return true;,         },         for (PatternSet ps : additionalPatterns) {,             if (ps.hasPatterns(getProject())) {,                 return true;,             },         },         return false;,     }, ,     /**,      * Gives the count of the number of selectors in this container.,      *,      * @return the number of selectors in this container as an <code>int</code>.,      */,     public synchronized int selectorCount() {,         if (isReference()) {,             return getRef(getProject()).selectorCount();,         },         dieOnCircularReference();,         return selectors.size();,     }, ,     /**,      * Returns the set of selectors as an array.,      * @param p the current project,      * @return a <code>FileSelector[]</code> of the selectors in this container.,      */,     public synchronized FileSelector[] getSelectors(Project p) {,         if (isReference()) {,             return getRef(getProject()).getSelectors(p);,         },         dieOnCircularReference(p);,         return (FileSelector[]) (selectors.toArray(,             new FileSelector[selectors.size()]));,     }, ,     /**,      * Returns an enumerator for accessing the set of selectors.,      *,      * @return an <code>Enumeration</code> of selectors.,      */,     public synchronized Enumeration<FileSelector> selectorElements() {,         if (isReference()) {,             return getRef(getProject()).selectorElements();,         },         dieOnCircularReference();,         return Collections.enumeration(selectors);,     }, ,     /**,      * Add a new selector into this container.,      *,      * @param selector the new <code>FileSelector</code> to add.,      */,     public synchronized void appendSelector(FileSelector selector) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         selectors.add(selector);,         directoryScanner = null;,         setChecked(false);,     }, ,     /* Methods below all add specific selectors */, ,     /**,      * Add a "Select" selector entry on the selector list.,      * @param selector the <code>SelectSelector</code> to add.,      */,     public void addSelector(SelectSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add an "And" selector entry on the selector list.,      * @param selector the <code>AndSelector</code> to add.,      */,     public void addAnd(AndSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add an "Or" selector entry on the selector list.,      * @param selector the <code>OrSelector</code> to add.,      */,     public void addOr(OrSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a "Not" selector entry on the selector list.,      * @param selector the <code>NotSelector</code> to add.,      */,     public void addNot(NotSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a "None" selector entry on the selector list.,      * @param selector the <code>NoneSelector</code> to add.,      */,     public void addNone(NoneSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a majority selector entry on the selector list.,      * @param selector the <code>MajoritySelector</code> to add.,      */,     public void addMajority(MajoritySelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a selector date entry on the selector list.,      * @param selector the <code>DateSelector</code> to add.,      */,     public void addDate(DateSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a selector size entry on the selector list.,      * @param selector the <code>SizeSelector</code> to add.,      */,     public void addSize(SizeSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a DifferentSelector entry on the selector list.,      * @param selector the <code>DifferentSelector</code> to add.,      */,     public void addDifferent(DifferentSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a selector filename entry on the selector list.,      * @param selector the <code>FilenameSelector</code> to add.,      */,     public void addFilename(FilenameSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a selector type entry on the selector list.,      * @param selector the <code>TypeSelector</code> to add.,      */,     public void addType(TypeSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add an extended selector entry on the selector list.,      * @param selector the <code>ExtendSelector</code> to add.,      */,     public void addCustom(ExtendSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a contains selector entry on the selector list.,      * @param selector the <code>ContainsSelector</code> to add.,      */,     public void addContains(ContainsSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a present selector entry on the selector list.,      * @param selector the <code>PresentSelector</code> to add.,      */,     public void addPresent(PresentSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a depth selector entry on the selector list.,      * @param selector the <code>DepthSelector</code> to add.,      */,     public void addDepth(DepthSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a depends selector entry on the selector list.,      * @param selector the <code>DependSelector</code> to add.,      */,     public void addDepend(DependSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a regular expression selector entry on the selector list.,      * @param selector the <code>ContainsRegexpSelector</code> to add.,      */,     public void addContainsRegexp(ContainsRegexpSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add the modified selector.,      * @param selector the <code>ModifiedSelector</code> to add.,      * @since ant 1.6,      */,     public void addModified(ModifiedSelector selector) {,         appendSelector(selector);,     }, ,     public void addReadable(ReadableSelector r) {,         appendSelector(r);,     }, ,     public void addWritable(WritableSelector w) {,         appendSelector(w);,     }, ,     /**,      * Add an arbitrary selector.,      * @param selector the <code>FileSelector</code> to add.,      * @since Ant 1.6,      */,     public void add(FileSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Returns included files as a list of semicolon-separated filenames.,      *,      * @return a <code>String</code> of included filenames.,      */,     public String toString() {,         if (isReference()) {,             return getRef(getProject()).toString();,         },         dieOnCircularReference();,         DirectoryScanner ds = getDirectoryScanner(getProject());,         String[] files = ds.getIncludedFiles();,         StringBuffer sb = new StringBuffer();, ,         for (int i = 0; i < files.length; i++) {,             if (i > 0) {,                 sb.append(';');,             },             sb.append(files[i]);,         },         return sb.toString();,     }, ,     /**,      * Creates a deep clone of this instance, except for the nested,      * selectors (the list of selectors is a shallow clone of this,      * instance's list).,      * @return the cloned object,      * @since Ant 1.6,      */,     public synchronized Object clone() {,         if (isReference()) {,             return (getRef(getProject())).clone();,         } else {,             try {,                 AbstractFileSet fs = (AbstractFileSet) super.clone();,                 fs.defaultPatterns = (PatternSet) defaultPatterns.clone();,                 fs.additionalPatterns = new ArrayList<PatternSet>(additionalPatterns.size());,                 for (PatternSet ps : additionalPatterns) {,                     fs.additionalPatterns.add((PatternSet) ps.clone());,                 },                 fs.selectors = new ArrayList<FileSelector>(selectors);,                 return fs;,             } catch (CloneNotSupportedException e) {,                 throw new BuildException(e);,             },         },     }, ,     /**,      * Get the merged include patterns for this AbstractFileSet.,      * @param p the project to use.,      * @return the include patterns of the default pattern set and all,      * nested patternsets.,      *,      * @since Ant 1.7,      */,     public String[] mergeIncludes(Project p) {,         return mergePatterns(p).getIncludePatterns(p);,     }, ,     /**,      * Get the merged exclude patterns for this AbstractFileSet.,      * @param p the project to use.,      * @return the exclude patterns of the default pattern set and all,      * nested patternsets.,      *,      * @since Ant 1.7,      */,     public String[] mergeExcludes(Project p) {,         return mergePatterns(p).getExcludePatterns(p);,     }, ,     /**,      * Get the merged patterns for this AbstractFileSet.,      * @param p the project to use.,      * @return the default patternset merged with the additional sets,      * in a new PatternSet instance.,      *,      * @since Ant 1.7,      */,     public synchronized PatternSet mergePatterns(Project p) {,         if (isReference()) {,             return getRef(p).mergePatterns(p);,         },         dieOnCircularReference();,         PatternSet ps = (PatternSet) defaultPatterns.clone();,         final int count = additionalPatterns.size();,         for (int i = 0; i < count; i++) {,             ps.append(additionalPatterns.get(i), p);,         },         return ps;,     }, ,     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             for (FileSelector fileSelector : selectors) {,                 if (fileSelector instanceof DataType) {,                     pushAndInvokeCircularReferenceCheck((DataType) fileSelector, stk, p);,                 },             },             for (PatternSet ps : additionalPatterns) {,                 pushAndInvokeCircularReferenceCheck(ps, stk, p);,             },             setChecked(true);,         },     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/tools/ant/types/AbstractFileSet.java,getDir,143-143,[        return getDir(getProject());],,setDir,131-136,[        if (isReference()) {,             throw tooManyAttributes();,         },         this.dir = dir;,         directoryScanner = null;,     }],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/AbstractFileSetTest.java,testEmptyElementIfIsReference,105-105,[            f.setIncludesfile(new File("/a"));],,testEmptyElementIfIsReference,123-123,[            f.setExcludesfile(new File("/a"));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/AbstractFileSetTest.java,testCircularReferenceCheck,190-190,[        project.addReference("dummy", f);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/AbstractFileSetTest.java,testEmptyElementIfIsReference,132-132,[            f.setDir(project.resolveFile("."));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/AddTypeTest.java,eval,172-172,[            project.log("My Condition eval");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/AddTypeTest.java,execute,176-176,[            project.log("My Condition execution");],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/AntFilterReader.java,,30-177,[public final class AntFilterReader,     extends DataType implements Cloneable {, ,     private String className;, ,     private final Vector<Parameter> parameters = new Vector<Parameter>();, ,     private Path classpath;, ,     /**,      * Set the className attribute.,      *,      * @param className a <code>String</code> value,      */,     public void setClassName(final String className) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.className = className;,     }, ,     /**,      * Get the className attribute.,      *,      * @return a <code>String</code> value,      */,     public String getClassName() {,         if (isReference()) {,             return ((AntFilterReader) getCheckedRef()).getClassName();,         },         dieOnCircularReference();,         return className;,     }, ,     /**,      * Add a Parameter.,      *,      * @param param a <code>Parameter</code> value,      */,     public void addParam(final Parameter param) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         parameters.addElement(param);,     }, ,     /**,      * Set the classpath to load the FilterReader through (attribute).,      * @param classpath a classpath,      */,     public void setClasspath(Path classpath) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (this.classpath == null) {,             this.classpath = classpath;,         } else {,             this.classpath.append(classpath);,         },         setChecked(false);,     }, ,     /**,      * Set the classpath to load the FilterReader through (nested element).,      * @return a classpath to be configured,      */,     public Path createClasspath() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (this.classpath == null) {,             this.classpath = new Path(getProject());,         },         setChecked(false);,         return this.classpath.createPath();,     }, ,     /**,      * Get the classpath.,      * @return the classpath,      */,     public Path getClasspath() {,         if (isReference()) {,             ((AntFilterReader) getCheckedRef()).getClasspath();,         },         dieOnCircularReference();,         return classpath;,     }, ,     /**,      * Set the classpath to load the FilterReader through via,      * reference (attribute).,      * @param r a reference to a classpath,      */,     public void setClasspathRef(Reference r) {,         if (isReference()) {,             throw tooManyAttributes();,         },         createClasspath().setRefid(r);,     }, ,     /**,      * The parameters for this filter.,      *,      * @return a <code>Parameter[]</code> value,      */,     public Parameter[] getParams() {,         if (isReference()) {,             ((AntFilterReader) getCheckedRef()).getParams();,         },         dieOnCircularReference();,         Parameter[] params = new Parameter[parameters.size()];,         parameters.copyInto(params);,         return params;,     }, ,     /**,      * Makes this instance in effect a reference to another AntFilterReader,      * instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      *,      * @param r the reference to which this instance is associated,      * @exception BuildException if this instance already has been configured.,      */,     public void setRefid(Reference r) throws BuildException {,         if (!parameters.isEmpty() || className != null,                 || classpath != null) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (classpath != null) {,                 pushAndInvokeCircularReferenceCheck(classpath, stk, p);,             },             setChecked(true);,         },     }],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/types/ArchiveFileSet.java,iterator,320-320,[        ArchiveScanner as = (ArchiveScanner) getDirectoryScanner(getProject());],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/types/ArchiveFileSet.java,size,336-336,[        ArchiveScanner as = (ArchiveScanner) getDirectoryScanner(getProject());],,
BAD_PRACTICE,NP_TOSTRING_COULD_RETURN_NULL,org/apache/tools/ant/types/ArchiveFileSet.java,toString,495-495,[        return src == null ? null : src.getName();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/ArchiveScanner.java,scanme,326-326,[        if (!src.isExists() && !errorOnMissingArchive) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/Assertions.java,,68-251,[public class Assertions extends DataType implements Cloneable {, ,     /**,      * enable/disable sys assertions; null means undefined,      */,     private Boolean enableSystemAssertions;, ,     /**,      * list of type BaseAssertion,      */,     private ArrayList<BaseAssertion> assertionList = new ArrayList<BaseAssertion>();, , ,     /**,      * enable assertions,      * @param assertion an enable assertion nested element,      */,     public void addEnable(EnabledAssertion assertion) {,         checkChildrenAllowed();,         assertionList.add(assertion);,     }, ,     /**,      * disable assertions,      * @param assertion a disable assertion nested element,      */,     public void addDisable(DisabledAssertion assertion) {,         checkChildrenAllowed();,         assertionList.add(assertion);,     }, ,     /**,      * enable or disable system assertions.,      * Default is not set (neither -enablesystemassersions or -disablesytemassertions,      * are used on the command line).,      * @param enableSystemAssertions if true enable system assertions,      */,     public void setEnableSystemAssertions(Boolean enableSystemAssertions) {,         checkAttributesAllowed();,         this.enableSystemAssertions = enableSystemAssertions;,     }, ,     /**,      * Set the value of the refid attribute.,      *,      * <p>Subclasses may need to check whether any other attributes,      * have been set as well or child elements have been created and,      * thus override this method. if they do the must call,      * <code>super.setRefid</code>.</p>,      * @param ref the reference to use,      */,     public void setRefid(Reference ref) {,         if (assertionList.size() > 0 || enableSystemAssertions != null) {,             throw tooManyAttributes();,         },         super.setRefid(ref);,     }, ,     /**,      * get whatever we are referencing to. This could be ourself.,      * @return the object that contains the assertion info,      */,     private Assertions getFinalReference() {,         if (getRefid() == null) {,             return this;,         } else {,             Object o = getRefid().getReferencedObject(getProject());,             if (!(o instanceof Assertions)) {,                 throw new BuildException("reference is of wrong type");,             },             return (Assertions) o;,         },     }, ,     /**,      * how many assertions are made...will resolve references before returning,      * @return total # of commands to make,      */,     public int size() {,         Assertions clause = getFinalReference();,         return clause.getFinalSize();,     }, , ,     /**,      * what is the final size of this object,      * @return,      */,     private int getFinalSize() {,         return assertionList.size() + (enableSystemAssertions != null ? 1 : 0);,     }, ,     /**,      * add the assertions to a list in a format suitable,      * for adding to a command line,      * @param commandList the command line to format,      */,     public void applyAssertions(List<String> commandList) {,         getProject().log("Applying assertions", Project.MSG_DEBUG);,         Assertions clause = getFinalReference();,         //do the system assertions,         if (Boolean.TRUE.equals(clause.enableSystemAssertions)) {,             getProject().log("Enabling system assertions", Project.MSG_DEBUG);,             commandList.add("-enablesystemassertions");,         } else if (Boolean.FALSE.equals(clause.enableSystemAssertions)) {,             getProject().log("disabling system assertions", Project.MSG_DEBUG);,             commandList.add("-disablesystemassertions");,         }, ,         //now any inner assertions,         for (BaseAssertion assertion : clause.assertionList) {,             String arg = assertion.toCommand();,             getProject().log("adding assertion " + arg, Project.MSG_DEBUG);,             commandList.add(arg);,         },     }, ,     /**,      * apply all the assertions to the command.,      * @param command the command line to format,      */,     public void applyAssertions(CommandlineJava command) {,         Assertions clause = getFinalReference();,         //do the system assertions,         if (Boolean.TRUE.equals(clause.enableSystemAssertions)) {,             addVmArgument(command, "-enablesystemassertions");,         } else if (Boolean.FALSE.equals(clause.enableSystemAssertions)) {,             addVmArgument(command, "-disablesystemassertions");,         }, ,         //now any inner assertions,         for (BaseAssertion assertion : clause.assertionList) {,             String arg = assertion.toCommand();,             addVmArgument(command, arg);,         },     }, ,     /**,      * add the assertions to a list in a format suitable,      * for adding to a command line,      * @param commandIterator list of commands,      */,     public void applyAssertions(final ListIterator<String> commandIterator) {,         getProject().log("Applying assertions", Project.MSG_DEBUG);,         Assertions clause = getFinalReference();,         //do the system assertions,         if (Boolean.TRUE.equals(clause.enableSystemAssertions)) {,             getProject().log("Enabling system assertions", Project.MSG_DEBUG);,             commandIterator.add("-enablesystemassertions");,         } else if (Boolean.FALSE.equals(clause.enableSystemAssertions)) {,             getProject().log("disabling system assertions", Project.MSG_DEBUG);,             commandIterator.add("-disablesystemassertions");,         }, ,         //now any inner assertions,         for (BaseAssertion assertion : clause.assertionList) {,             String arg = assertion.toCommand();,             getProject().log("adding assertion " + arg, Project.MSG_DEBUG);,             commandIterator.add(arg);,         },     }, ,     /**,      * helper method to add a string JVM argument to a command,      * @param command,      * @param arg,      */,     private static void addVmArgument(CommandlineJava command, String arg) {,         Commandline.Argument argument;,         argument = command.createVmArgument();,         argument.setValue(arg);,     }, ,     /**,      * clone the objects.,      * This is not a full depth clone; the list of assertions is cloned,,      * but it does not clone the underlying assertions.,      * @return a cli,      * @throws CloneNotSupportedException if the super class does not support cloning,      */,     public Object clone() throws CloneNotSupportedException {,         Assertions that = (Assertions) super.clone();,         that.assertionList = new ArrayList<BaseAssertion>(assertionList);,         return that;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/Commandline.java,getParts,192-192,[                return parts;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/CommandlineJava.java,getVariables,95-95,[                return null;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/tools/ant/types/CommandlineJava.java,setSystem,142-142,[                    String value = sys.getProperty(name);],,setSystem,143-143,[                    if (name != null && value != null) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/CommandlineJavaTest.java,testGetCommandline,89-89,[        c.createClasspath(project).setLocation(project.resolveFile("build.xml"));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/CommandlineJavaTest.java,testSysproperties,131-131,[        project.setProperty("key2", "value2");],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/Comparison.java,getValues,77-77,[        return VALUES;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/DataType.java,,40-364,[public abstract class DataType extends ProjectComponent implements Cloneable {,     // CheckStyle:VisibilityModifier OFF, ,     /**,      * Value to the refid attribute.,      *,      * @deprecated since 1.7.,      *             The user should not be directly referencing,      *             variable. Please use {@link #getRefid} instead.,      */,     protected Reference ref;, ,     /**,      * Are we sure we don't hold circular references?,      *,      * <p>Subclasses are responsible for setting this value to false,      * if we'd need to investigate this condition (usually because a,      * child element has been added that is a subclass of,      * DataType).</p>,      *,      * @deprecated since 1.7.,      *             The user should not be directly referencing,      *             variable. Please use {@link #setChecked} or,      *             {@link #isChecked} instead.,      */,     protected boolean checked = true;,     // CheckStyle:VisibilityModifier ON, ,     /**,      * Has the refid attribute of this element been set?,      * @return true if the refid attribute has been set,      */,     public boolean isReference() {,         return ref != null;,     }, ,     /**,      * Set the value of the refid attribute.,      *,      * <p>Subclasses may need to check whether any other attributes,      * have been set as well or child elements have been created and,      * thus override this method. if they do the must call,      * <code>super.setRefid</code>.</p>,      * @param ref the reference to use,      */,     public void setRefid(final Reference ref) {,         this.ref = ref;,         checked = false;,     }, ,     /**,      * Gets as descriptive as possible a name used for this datatype instance.,      * @return <code>String</code> name.,      */,     protected String getDataTypeName() {,         return ComponentHelper.getElementName(getProject(), this, true);,     }, ,     /**,      * Convenience method.,      * @since Ant 1.7,      */,     protected void dieOnCircularReference() {,         dieOnCircularReference(getProject());,     }, ,     /**,      * Convenience method.,      * @param p the Ant Project instance against which to resolve references.,      * @since Ant 1.7,      */,     protected void dieOnCircularReference(Project p) {,         if (checked || !isReference()) {,             return;,         },         dieOnCircularReference(new IdentityStack<Object>(this), p);,     }, ,     /**,      * Check to see whether any DataType we hold references to is,      * included in the Stack (which holds all DataType instances that,      * directly or indirectly reference this instance, including this,      * instance itself).,      *,      * <p>If one is included, throw a BuildException created by {@link,      * #circularReference circularReference}.</p>,      *,      * <p>This implementation is appropriate only for a DataType that,      * cannot hold other DataTypes as children.</p>,      *,      * <p>The general contract of this method is that it shouldn't do,      * anything if {@link #checked <code>checked</code>} is true and,      * set it to true on exit.</p>,      * @param stack the stack of references to check.,      * @param project the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected void dieOnCircularReference(final Stack<Object> stack,,                                           final Project project),         throws BuildException {, ,         if (checked || !isReference()) {,             return;,         },         Object o = ref.getReferencedObject(project);, ,         if (o instanceof DataType) {,             IdentityStack<Object> id = IdentityStack.getInstance(stack);, ,             if (id.contains(o)) {,                 throw circularReference();,             } else {,                 id.push(o);,                 ((DataType) o).dieOnCircularReference(id, project);,                 id.pop();,             },         },         checked = true;,     }, ,     /**,      * Allow DataTypes outside org.apache.tools.ant.types to indirectly call,      * dieOnCircularReference on nested DataTypes.,      * @param dt the DataType to check.,      * @param stk the stack of references to check.,      * @param p the project to use to dereference the references.,      * @throws BuildException on error.,      * @since Ant 1.7,      */,     public static void invokeCircularReferenceCheck(DataType dt, Stack<Object> stk,,                                                     Project p) {,         dt.dieOnCircularReference(stk, p);,     }, ,     /**,      * Allow DataTypes outside org.apache.tools.ant.types to indirectly call,      * dieOnCircularReference on nested DataTypes.,      *,      * <p>Pushes dt on the stack, runs dieOnCircularReference and pops,      * it again.</p>,      * @param dt the DataType to check.,      * @param stk the stack of references to check.,      * @param p the project to use to dereference the references.,      * @throws BuildException on error.,      * @since Ant 1.8.0,      */,     public static void pushAndInvokeCircularReferenceCheck(DataType dt,,                                                            Stack<Object> stk,,                                                            Project p) {,         stk.push(dt);,         dt.dieOnCircularReference(stk, p);,         stk.pop();,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced object.,      * @return the dereferenced object.,      * @throws BuildException if the reference is invalid (circular ref, wrong class, etc).,      * @since Ant 1.7,      */,     protected Object getCheckedRef() {,         return getCheckedRef(getProject());,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced object.,      * @param p the Ant Project instance against which to resolve references.,      * @return the dereferenced object.,      * @throws BuildException if the reference is invalid (circular ref, wrong class, etc).,      * @since Ant 1.7,      */,     protected Object getCheckedRef(Project p) {,         return getCheckedRef(getClass(), getDataTypeName(), p);,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced object.,      * @param requiredClass the class that this reference should be a subclass of.,      * @param dataTypeName  the name of the datatype that the reference should be,      *                      (error message use only).,      * @return the dereferenced object.,      * @throws BuildException if the reference is invalid (circular ref, wrong class, etc).,      */,     protected <T> T getCheckedRef(final Class<T> requiredClass,,                                    final String dataTypeName) {,         return getCheckedRef(requiredClass, dataTypeName, getProject());,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced object.  This version allows the fallback Project instance to be specified.,      * @param requiredClass the class that this reference should be a subclass of.,      * @param dataTypeName  the name of the datatype that the reference should be,      *                      (error message use only).,      * @param project       the fallback Project instance for dereferencing.,      * @return the dereferenced object.,      * @throws BuildException if the reference is invalid (circular ref, wrong class, etc),,      *                        or if <code>project</code> is <code>null</code>.,      * @since Ant 1.7,      */,     protected <T> T getCheckedRef(final Class<T> requiredClass,,                                   final String dataTypeName, final Project project) {,         if (project == null) {,             throw new BuildException("No Project specified");,         },         dieOnCircularReference(project);,         Object o = ref.getReferencedObject(project);,         if (!(requiredClass.isAssignableFrom(o.getClass()))) {,             log("Class " + displayName(o.getClass()),                     + " is not a subclass of ",                     + displayName(requiredClass),,                     Project.MSG_VERBOSE);,             String msg = ref.getRefId() + " doesn\'t denote a " + dataTypeName;,             throw new BuildException(msg);,         },         @SuppressWarnings("unchecked"),         final T result = (T) o;,         return result;,     }, ,     /**,      * Creates an exception that indicates that refid has to be the,      * only attribute if it is set.,      * @return the exception to throw,      */,     protected BuildException tooManyAttributes() {,         return new BuildException("You must not specify more than one ",             + "attribute when using refid");,     }, ,     /**,      * Creates an exception that indicates that this XML element must,      * not have child elements if the refid attribute is set.,      * @return the exception to throw,      */,     protected BuildException noChildrenAllowed() {,         return new BuildException("You must not specify nested elements ",             + "when using refid");,     }, ,     /**,      * Creates an exception that indicates the user has generated a,      * loop of data types referencing each other.,      * @return the exception to throw,      */,     protected BuildException circularReference() {,         return new BuildException("This data type contains a circular ",             + "reference.");,     }, ,     /**,      * The flag that is used to indicate that circular references have been checked.,      * @return true if circular references have been checked,      */,     protected boolean isChecked() {,         return checked;,     }, ,     /**,      * Set the flag that is used to indicate that circular references have been checked.,      * @param checked if true, if circular references have been checked,      */,     protected void setChecked(final boolean checked) {,         this.checked = checked;,     }, ,     /**,      * get the reference set on this object,      * @return the reference or null,      */,     public Reference getRefid() {,         return ref;,     }, ,     /**,      * check that it is ok to set attributes, i.e that no reference is defined,      * @since Ant 1.6,      * @throws BuildException if not allowed,      */,     protected void checkAttributesAllowed() {,         if (isReference()) {,             throw tooManyAttributes();,         },     }, ,     /**,      * check that it is ok to add children, i.e that no reference is defined,      * @since Ant 1.6,      * @throws BuildException if not allowed,      */,     protected void checkChildrenAllowed() {,         if (isReference()) {,             throw noChildrenAllowed();,         },     }, ,     /**,      * Basic DataType toString().,      * @return this DataType formatted as a String.,      */,     public String toString() {,         String d = getDescription();,         return d == null ? getDataTypeName() : getDataTypeName() + " " + d;,     }, ,     /**,      * @since Ant 1.7,      * @return a shallow copy of this DataType.,      * @throws CloneNotSupportedException if there is a problem.,      */,     public Object clone() throws CloneNotSupportedException {,         DataType dt = (DataType) super.clone();,         dt.setDescription(getDescription());,         if (getRefid() != null) {,             dt.setRefid(getRefid());,         },         dt.setChecked(isChecked());,         return dt;,     }, ,     private String displayName(Class<?> clazz) {,         return clazz.getName() + " (loaded via " + clazz.getClassLoader() +")";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/DataType.java,dieOnCircularReference,144-144,[        Object o = ref.getReferencedObject(project);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/DataType.java,getCheckedRef,249-249,[        Object o = ref.getReferencedObject(project);],,getCheckedRef,255-255,[            String msg = ref.getRefId() + " doesn\'t denote a " + dataTypeName;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/Description.java,concatDescriptions,99-99,[            if (descComp != null) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/DirSetTest.java,testToString,69-69,[            tmp.delete();],,testToString,84-84,[            new File(tmp, "a/x").delete();],,testToString,85-85,[            new File(tmp, "a").delete();],,testToString,86-86,[            new File(tmp, "b/c/x").delete();],,testToString,87-87,[            new File(tmp, "b/c").delete();],,testToString,88-88,[            new File(tmp, "b/x").delete();],,testToString,89-89,[            new File(tmp, "b").delete();],,testToString,90-90,[            tmp.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/DirSetTest.java,testToString,71-71,[            a.mkdirs();],,testToString,74-74,[            bc.mkdirs();],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/types/EnumeratedAttributeTest.java,testContains,42-42,[            assertTrue(expected[i].toUpperCase()+" is in TestNormal",],,testContains,43-43,[                   !t1.containsValue(expected[i].toUpperCase()));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/EnumeratedAttributeTest.java,getValues,96-96,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/Environment.java,getVariables,159-159,[            return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/Environment.java,getContent,118-118,[            StringBuffer sb = new StringBuffer(key.trim());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/Environment.java,getContent,119-119,[            sb.append("=").append(value.trim());],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/FilterChain.java,,48-417,[public class FilterChain extends DataType,     implements Cloneable {, ,     private Vector<Object> filterReaders = new Vector<Object>();, ,     /**,      * Add an AntFilterReader filter.,      *,      * @param filterReader an <code>AntFilterReader</code> value,      */,     public void addFilterReader(final AntFilterReader filterReader) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filterReader);,     }, ,     /**,      * Return the filters.,      *,      * @return a <code>Vector</code> value containing the filters,      */,     public Vector<Object> getFilterReaders() {,         if (isReference()) {,             return ((FilterChain) getCheckedRef()).getFilterReaders();,         },         dieOnCircularReference();,         return filterReaders;,     }, ,     /**,      * Add a ClassConstants filter.,      *,      * @param classConstants a <code>ClassConstants</code> value,      */,     public void addClassConstants(final ClassConstants classConstants) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(classConstants);,     }, ,     /**,      * Add an ExpandProperties filter.,      *,      * @param expandProperties an <code>ExpandProperties</code> value,      */,     public void addExpandProperties(final ExpandProperties expandProperties) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(expandProperties);,     }, ,     /**,      * Add a HeadFilter filter.,      *,      * @param headFilter a <code>HeadFilter</code> value,      */,     public void addHeadFilter(final HeadFilter headFilter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(headFilter);,     }, ,     /**,      * Add a LineContains filter.,      *,      * @param lineContains a <code>LineContains</code> value,      */,     public void addLineContains(final LineContains lineContains) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(lineContains);,     }, ,     /**,      * Add a LineContainsRegExp filter.,      *,      * @param lineContainsRegExp a <code>LineContainsRegExp</code> value,      */,     public void addLineContainsRegExp(final LineContainsRegExp,                                                 lineContainsRegExp) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(lineContainsRegExp);,     }, ,     /**,      * Add a PrefixLines filter.,      *,      * @param prefixLines a <code>PrefixLines</code> value,      */,     public void addPrefixLines(final PrefixLines prefixLines) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(prefixLines);,     }, ,     /**,      * Add a SuffixLines filter.,      *,      * @param suffixLines a <code>SuffixLines</code> value,      * @since Ant 1.8.0,      */,     public void addSuffixLines(final SuffixLines suffixLines) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(suffixLines);,     }, ,     /**,      * Add a ReplaceTokens filter.,      *,      * @param replaceTokens a <code>ReplaceTokens</code> value,      */,     public void addReplaceTokens(final ReplaceTokens replaceTokens) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(replaceTokens);,     }, ,     /**,      * Add a StripJavaCommands filter.,      *,      * @param stripJavaComments a <code>StripJavaComments</code> value,      */,     public void addStripJavaComments(final StripJavaComments,                                                 stripJavaComments) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(stripJavaComments);,     }, ,     /**,      * Add a StripLineBreaks filter.,      *,      * @param stripLineBreaks a <code>StripLineBreaks</code> value,      */,     public void addStripLineBreaks(final StripLineBreaks,                                                 stripLineBreaks) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(stripLineBreaks);,     }, ,     /**,      * Add a StripLineComments filter.,      *,      * @param stripLineComments a <code>StripLineComments</code> value,      */,     public void addStripLineComments(final StripLineComments,                                                 stripLineComments) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(stripLineComments);,     }, ,     /**,      * Add a TabsToSpaces filter.,      *,      * @param tabsToSpaces a <code>TabsToSpaces</code> value,      */,     public void addTabsToSpaces(final TabsToSpaces tabsToSpaces) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(tabsToSpaces);,     }, ,     /**,      * Add a TailFilter filter.,      *,      * @param tailFilter a <code>TailFilter</code> value,      */,     public void addTailFilter(final TailFilter tailFilter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(tailFilter);,     }, ,     /**,      * Add an EscapeUnicode filter.,      *,      * @param escapeUnicode an <code>EscapeUnicode</code> value,      * @since Ant 1.6,      */,     public void addEscapeUnicode(final EscapeUnicode escapeUnicode) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(escapeUnicode);,     }, ,     /**,      * Add a TokenFilter filter.,      *,      * @param tokenFilter a <code>TokenFilter</code> value,      * @since Ant 1.6,      */,     public void addTokenFilter(final TokenFilter tokenFilter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(tokenFilter);,     }, ,     /**,      * Add a delete characters filter.,      *,      * @param filter a <code>TokenFilter.DeleteCharacters</code> value,      * @since Ant 1.6,      */,     public void addDeleteCharacters(TokenFilter.DeleteCharacters filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add a containsregex filter.,      *,      * @param filter a <code>TokenFilter.ContainsRegex</code> value,      * @since Ant 1.6,      */,     public void addContainsRegex(TokenFilter.ContainsRegex filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add a replaceregex filter.,      *,      * @param filter a <code>TokenFilter.ReplaceRegex</code> value,      */,     public void addReplaceRegex(TokenFilter.ReplaceRegex filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add a trim filter.,      *,      * @param filter a <code>TokenFilter.Trim</code> value,      * @since Ant 1.6,      */,     public void addTrim(TokenFilter.Trim filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add a replacestring filter.,      *,      * @param filter a <code>TokenFilter.ReplaceString</code> value,      * @since Ant 1.6,      */,     public void addReplaceString(,         TokenFilter.ReplaceString filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add an ignoreBlank filter.,      *,      * @param filter a <code>TokenFilter.IgnoreBlank</code> value,      * @since Ant 1.6,      */,     public void addIgnoreBlank(,         TokenFilter.IgnoreBlank filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, , ,     /**,      * Makes this instance in effect a reference to another FilterChain,      * instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      *,      * @param r the reference to which this instance is associated,      * @exception BuildException if this instance already has been configured.,      */,     @Override,     public void setRefid(Reference r) throws BuildException {,         if (!filterReaders.isEmpty()) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Add a chainfilter filter.,      *,      * @param filter a <code>ChainableReader</code> value,      * @since Ant 1.6,      */, ,     public void add(ChainableReader filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     @Override,     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             for (Iterator<Object> i = filterReaders.iterator(); i.hasNext();) {,                 Object o = i.next();,                 if (o instanceof DataType) {,                     pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);,                 },             },             setChecked(true);,         },     }],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/tools/ant/types/FilterSet.java,replaceTokens,614-614,[                + passedTokens.lastElement().toString() + endToken);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/FilterSet.java,getFilterHash,267-267,[        return filterHash;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/FilterSet.java,readFiltersFromFile,383-383,[           } catch (Exception ex) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/FilterSet.java,,40-650,[public class FilterSet extends DataType implements Cloneable {, ,     /**,      * Individual filter component of filterset.,      *,      */,     public static class Filter {,         // CheckStyle:VisibilityModifier OFF - bc,         /** Token which will be replaced in the filter operation. */,         String token;, ,         /** The value which will replace the token in the filtering operation. */,         String value;,         // CheckStyle:VisibilityModifier ON, ,         /**,          * Constructor for the Filter object.,          *,          * @param token  The token which will be replaced when filtering.,          * @param value  The value which will replace the token when filtering.,          */,         public Filter(String token, String value) {,            setToken(token);,            setValue(value);,         }, ,         /**,          * No-argument constructor.,          */,         public Filter() {,         }, ,         /**,          * Sets the Token attribute of the Filter object.,          *,          * @param token  The new Token value.,          */,         public void setToken(String token) {,            this.token = token;,         }, ,         /**,          * Sets the Value attribute of the Filter object.,          *,          * @param value  The new Value value.,          */,         public void setValue(String value) {,            this.value = value;,         }, ,         /**,          * Gets the Token attribute of the Filter object.,          *,          * @return   The Token value.,          */,         public String getToken() {,            return token;,         }, ,         /**,          * Gets the Value attribute of the Filter object.,          *,          * @return   The Value value.,          */,         public String getValue() {,            return value;,         },      }, ,     /**,      * The filtersfile nested element.,      *,      */,     public class FiltersFile {, ,         /**,          * Constructor for the FiltersFile object.,          */,         public FiltersFile() {,         }, ,         /**,          * Sets the file from which filters will be read.,          *,          * @param file the file from which filters will be read.,          */,         public void setFile(File file) {,            filtersFiles.add(file);,         },     }, ,     /**,      * EnumeratedAttribute to set behavior WRT missing filtersfiles:,      * "fail" (default), "warn", "ignore".,      * @since Ant 1.7,      */,     public static class OnMissing extends EnumeratedAttribute {,         private static final String[] VALUES,             = new String[] {"fail", "warn", "ignore"};, ,         /** Fail value */,         public static final OnMissing FAIL = new OnMissing("fail");,         /** Warn value */,         public static final OnMissing WARN = new OnMissing("warn");,         /** Ignore value */,         public static final OnMissing IGNORE = new OnMissing("ignore");, ,         private static final int FAIL_INDEX = 0;,         private static final int WARN_INDEX = 1;,         private static final int IGNORE_INDEX = 2;, ,         /**,          * Default constructor.,          */,         public OnMissing() {,         }, ,         /**,          * Convenience constructor.,          * @param value the value to set.,          */,         public OnMissing(String value) {,             setValue(value);,         }, ,         //inherit doc,         /** {@inheritDoc}. */,         @Override,         public String[] getValues() {,             return VALUES;,         },     }, ,     /** The default token start string */,     public static final String DEFAULT_TOKEN_START = "@";, ,     /** The default token end string */,     public static final String DEFAULT_TOKEN_END = "@";, ,     private String startOfToken = DEFAULT_TOKEN_START;,     private String endOfToken = DEFAULT_TOKEN_END;, ,     /** Contains a list of parsed tokens */,     private Vector<String> passedTokens;,     /** if a duplicate token is found, this is set to true */,     private boolean duplicateToken = false;, ,     private boolean recurse = true;,     private Hashtable<String, String> filterHash = null;,     private Vector<File> filtersFiles = new Vector<File>();,     private OnMissing onMissingFiltersFile = OnMissing.FAIL;,     private boolean readingFiles = false;, ,     private int recurseDepth = 0;, ,     /**,      * List of ordered filters and filter files.,      */,     private Vector<Filter> filters = new Vector<Filter>();, ,     /**,      * Default constructor.,      */,     public FilterSet() {,     }, ,     /**,      * Create a Filterset from another filterset.,      *,      * @param filterset the filterset upon which this filterset will be based.,      */,     protected FilterSet(FilterSet filterset) {,         super();,         @SuppressWarnings("unchecked"),         Vector<Filter> clone = (Vector<Filter>) filterset.getFilters().clone();,         this.filters = clone;,     }, ,     /**,      * Get the filters in the filter set.,      *,      * @return a Vector of Filter instances.,      */,     protected synchronized Vector<Filter> getFilters() {,         if (isReference()) {,             return getRef().getFilters();,         },         dieOnCircularReference();,         //silly hack to avoid stack overflow...,         if (!readingFiles) {,             readingFiles = true;,             final int size = filtersFiles.size();,             for (int i = 0; i < size; i++) {,                 readFiltersFromFile(filtersFiles.get(i));,             },             filtersFiles.clear();,             readingFiles = false;,         },         return filters;,     }, ,     /**,      * Get the referenced filter set.,      *,      * @return the filterset from the reference.,      */,     protected FilterSet getRef() {,         return getCheckedRef(FilterSet.class, "filterset");,     }, ,     /**,      * Gets the filter hash of the FilterSet.,      *,      * @return   The hash of the tokens and values for quick lookup.,      */,     public synchronized Hashtable<String, String> getFilterHash() {,         if (isReference()) {,             return getRef().getFilterHash();,         },         dieOnCircularReference();,         if (filterHash == null) {,             filterHash = new Hashtable<String, String>(getFilters().size());,             for (Enumeration<Filter> e = getFilters().elements(); e.hasMoreElements();) {,                Filter filter = e.nextElement();,                filterHash.put(filter.getToken(), filter.getValue());,             },         },         return filterHash;,     }, ,     /**,      * Set the file containing the filters for this filterset.,      *,      * @param filtersFile sets the filter file from which to read filters,      *        for this filter set.,      * @throws BuildException if there is an error.,      */,     public void setFiltersfile(File filtersFile) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         filtersFiles.add(filtersFile);,     }, ,     /**,      * Set the string used to id the beginning of a token.,      *,      * @param startOfToken  The new Begintoken value.,      */,     public void setBeginToken(String startOfToken) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (startOfToken == null || "".equals(startOfToken)) {,             throw new BuildException("beginToken must not be empty");,         },         this.startOfToken = startOfToken;,     }, ,     /**,      * Get the begin token for this filterset.,      *,      * @return the filter set's begin token for filtering.,      */,     public String getBeginToken() {,         if (isReference()) {,             return getRef().getBeginToken();,         },         return startOfToken;,     }, ,     /**,      * Set the string used to id the end of a token.,      *,      * @param endOfToken  The new Endtoken value.,      */,     public void setEndToken(String endOfToken) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (endOfToken == null || "".equals(endOfToken)) {,             throw new BuildException("endToken must not be empty");,         },         this.endOfToken = endOfToken;,     }, ,     /**,      * Get the end token for this filterset.,      *,      * @return the filter set's end token for replacement delimiting.,      */,     public String getEndToken() {,         if (isReference()) {,             return getRef().getEndToken();,         },         return endOfToken;,     }, ,     /**,      * Set whether recursive token expansion is enabled.,      * @param recurse <code>boolean</code> whether to recurse.,      */,     public void setRecurse(boolean recurse) {,         this.recurse = recurse;,     }, ,     /**,      * Get whether recursive token expansion is enabled.,      * @return <code>boolean</code> whether enabled.,      */,     public boolean isRecurse() {,         return recurse;,     }, ,     /**,      * Read the filters from the given file.,      *,      * @param filtersFile        the file from which filters are read.,      * @exception BuildException when the file cannot be read.,      */,     public synchronized void readFiltersFromFile(File filtersFile) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (!filtersFile.exists()) {,            handleMissingFile("Could not read filters from file ",                                      + filtersFile + " as it doesn't exist.");,         },         if (filtersFile.isFile()) {,            log("Reading filters from " + filtersFile, Project.MSG_VERBOSE);,            FileInputStream in = null;,            try {,               Properties props = new Properties();,               in = new FileInputStream(filtersFile);,               props.load(in);, ,               Enumeration<?> e = props.propertyNames();,               Vector<Filter> filts = getFilters();,               while (e.hasMoreElements()) {,                  String strPropName = (String) e.nextElement();,                  String strValue = props.getProperty(strPropName);,                  filts.addElement(new Filter(strPropName, strValue));,               },            } catch (Exception ex) {,               throw new BuildException("Could not read filters from file: ",                   + filtersFile, ex);,            } finally {,               FileUtils.close(in);,            },         } else {,            handleMissingFile(,                "Must specify a file rather than a directory in ",                + "the filtersfile attribute:" + filtersFile);,         },         filterHash = null;,     }, ,     /**,      * Does replacement on the given string with token matching.,      * This uses the defined begintoken and endtoken values which default,      * to @ for both.,      * This resets the passedTokens and calls iReplaceTokens to,      * do the actual replacements.,      *,      * @param line  The line in which to process embedded tokens.,      * @return      The input string after token replacement.,      */,     public synchronized String replaceTokens(String line) {,         return iReplaceTokens(line);,     }, ,     /**,      * Add a new filter.,      *,      * @param filter the filter to be added.,      */,     public synchronized void addFilter(Filter filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         filters.addElement(filter);,         filterHash = null;,     }, ,     /**,      * Create a new FiltersFile.,      *,      * @return The filtersfile that was created.,      */,     public FiltersFile createFiltersfile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return new FiltersFile();,     }, ,     /**,      * Add a new filter made from the given token and value.,      *,      * @param token The token for the new filter.,      * @param value The value for the new filter.,      */,     public synchronized void addFilter(String token, String value) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         addFilter(new Filter(token, value));,     }, ,     /**,      * Add a Filterset to this filter set.,      *,      * @param filterSet the filterset to be added to this filterset,      */,     public synchronized void addConfiguredFilterSet(FilterSet filterSet) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         for (Filter filter : filterSet.getFilters()) {,             addFilter(filter);,         },     }, ,     /**,      * Adds the properties provided by the specified PropertySet to this filterset.,      *,      * @param propertySet the propertyset to be added to this propertyset,      */,     public synchronized void addConfiguredPropertySet(PropertySet propertySet) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         Properties p = propertySet.getProperties();,         Set<Map.Entry<Object,Object>> entries = p.entrySet();,         for (Map.Entry<Object, Object> entry : entries) {,             addFilter(new Filter(String.valueOf(entry.getKey()),,                                  String.valueOf(entry.getValue())));,         },     }, ,     /**,      * Test to see if this filter set has filters.,      *,      * @return Return true if there are filters in this set.,      */,     public synchronized boolean hasFilters() {,         return getFilters().size() > 0;,     }, ,     /**,      * Clone the filterset.,      *,      * @return a deep clone of this filterset.,      *,      * @throws BuildException if the clone cannot be performed.,      */,     @Override,     public synchronized Object clone() throws BuildException {,         if (isReference()) {,             return getRef().clone();,         },         try {,             FilterSet fs = (FilterSet) super.clone();,             @SuppressWarnings("unchecked"),             Vector<Filter> clonedFilters = (Vector<Filter>) getFilters().clone();,             fs.filters = clonedFilters;,             fs.setProject(getProject());,             return fs;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Set the behavior WRT missing filtersfiles.,      * @param onMissingFiltersFile the OnMissing describing the behavior.,      */,     public void setOnMissingFiltersFile(OnMissing onMissingFiltersFile) {,         this.onMissingFiltersFile = onMissingFiltersFile;,     }, ,     /**,      * Get the onMissingFiltersFile setting.,      * @return the OnMissing instance.,      */,     public OnMissing getOnMissingFiltersFile() {,         return onMissingFiltersFile;,     }, ,     /**,      * Does replacement on the given string with token matching.,      * This uses the defined begintoken and endtoken values which default,      * to @ for both.,      *,      * @param line  The line to process the tokens in.,      * @return      The string with the tokens replaced.,      */,     private synchronized String iReplaceTokens(String line) {,         String beginToken = getBeginToken();,         String endToken = getEndToken();,         int index = line.indexOf(beginToken);, ,         if (index > -1) {,             Hashtable<String, String> tokens = getFilterHash();,             try {,                 StringBuilder b = new StringBuilder();,                 int i = 0;,                 String token = null;,                 String value = null;, ,                 while (index > -1) {,                     //can't have zero-length token,                     int endIndex = line.indexOf(endToken,,                         index + beginToken.length() + 1);,                     if (endIndex == -1) {,                         break;,                     },                     token,                         = line.substring(index + beginToken.length(), endIndex);,                     b.append(line.substring(i, index));,                     if (tokens.containsKey(token)) {,                         value = tokens.get(token);,                         if (recurse && !value.equals(token)) {,                             // we have another token, let's parse it.,                             value = replaceTokens(value, token);,                         },                         log("Replacing: " + beginToken + token + endToken,                             + " -> " + value, Project.MSG_VERBOSE);,                         b.append(value);,                         i = index + beginToken.length() + token.length(),                             + endToken.length();,                     } else {,                         // just append first character of beginToken,                         // and search further,                         // we can't skip the complete beginToken since,                         // it may contain the start of another,                         // candidate begin token (Bugzilla 45094),                         b.append(beginToken.charAt(0));,                         i = index + 1;,                     },                     index = line.indexOf(beginToken, i);,                 }, ,                 b.append(line.substring(i));,                 return b.toString();,             } catch (StringIndexOutOfBoundsException e) {,                 return line;,             },         } else {,            return line;,         },     }, ,     /**,      * This parses tokens which point to tokens.,      * It also maintains a list of currently used tokens, so we cannot,      * get into an infinite loop.,      * @param line the value / token to parse.,      * @param parent the parent token (= the token it was parsed from).,      */,     private synchronized String replaceTokens(String line, String parent),         throws BuildException {,         String beginToken = getBeginToken();,         String endToken = getEndToken();,         if (recurseDepth == 0) {,             passedTokens = new VectorSet<String>();,         },         recurseDepth++;,         if (passedTokens.contains(parent) && !duplicateToken) {,             duplicateToken = true;,             System.out.println(,                 "Infinite loop in tokens. Currently known tokens : ",                 + passedTokens.toString() + "\nProblem token : " + beginToken,                 + parent + endToken + " called from " + beginToken,                 + passedTokens.lastElement().toString() + endToken);,             recurseDepth--;,             return parent;,         },         passedTokens.addElement(parent);,         String value = iReplaceTokens(line);,         if (value.indexOf(beginToken) == -1 && !duplicateToken,                 && recurseDepth == 1) {,             passedTokens = null;,         } else if (duplicateToken) {,             // should always be the case...,             if (passedTokens.size() > 0) {,                 value = passedTokens.remove(passedTokens.size() - 1);,                 if (passedTokens.size() == 0) {,                     value = beginToken + value + endToken;,                     duplicateToken = false;,                 },             },         } else if (passedTokens.size() > 0) {,             // remove last seen token when crawling out of recursion,             passedTokens.remove(passedTokens.size() - 1);,         },         recurseDepth--;,         return value;,     }, ,     private void handleMissingFile(String message) {,         switch (onMissingFiltersFile.getIndex()) {,         case OnMissing.IGNORE_INDEX:,             return;,         case OnMissing.FAIL_INDEX:,             throw new BuildException(message);,         case OnMissing.WARN_INDEX:,             log(message, Project.MSG_WARN);,             return;,         default:,             throw new BuildException("Invalid value for onMissingFiltersFile");],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/FilterSet.java,getValues,169-169,[            return VALUES;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/types/FilterSetTest.java,compareFiles,224-224,[        FileInputStream fis1 = new FileInputStream(file1);],,compareFiles,225-225,[        FileInputStream fis2 = new FileInputStream(file2);],,compareFiles,226-226,[        int index = 0;],,compareFiles,227-227,[        int read = 0;],,compareFiles,228-228,[        while ((read = fis1.read(buffer1)) != -1) {],,compareFiles,236-236,[        return true;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/types/FilterSetTest.java,compareFiles,224-224,[        FileInputStream fis1 = new FileInputStream(file1);],,compareFiles,225-225,[        FileInputStream fis2 = new FileInputStream(file2);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/tools/ant/types/FilterSetTest.java,compareFiles,229-229,[            fis2.read(buffer2);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/FlexIntegerTest.java,execute,72-72,[        taskProject.setNewProperty(propName, value.toString());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/Mapper.java,getImplementation,213-213,[            String od = o == null ? "null" : o.getClass().getName();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/Mapper.java,,36-278,[    protected MapperType type = null;,     protected String classname = null;,     protected Path classpath = null;,     protected String from = null;,     protected String to = null;, ,     // CheckStyle:VisibilityModifier ON, ,     private ContainerMapper container = null;, ,     /**,      * Construct a new <code>Mapper</code> element.,      * @param p   the owning Ant <code>Project</code>.,      */,     public Mapper(Project p) {,         setProject(p);,     }, ,     /**,      * Set the type of <code>FileNameMapper</code> to use.,      * @param type   the <code>MapperType</code> enumerated attribute.,      */,     public void setType(MapperType type) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.type = type;,     }, ,     /**,      * Cannot mix add and addconfigured in same type, so,      * provide this to override the add method.,      * @param fileNameMapper   the <code>FileNameMapper</code> to add.,      */,     public void addConfigured(FileNameMapper fileNameMapper) {,         add(fileNameMapper);,     }, ,     /**,      * Add a nested <code>FileNameMapper</code>.,      * @param fileNameMapper   the <code>FileNameMapper</code> to add.,      */,     public void add(FileNameMapper fileNameMapper) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (container == null) {,             if (type == null && classname == null) {,                 container = new CompositeMapper();,             } else {,                 FileNameMapper m = getImplementation();,                 if (m instanceof ContainerMapper) {,                     container = (ContainerMapper) m;,                 } else {,                     throw new BuildException(String.valueOf(m),                         + " mapper implementation does not support nested mappers!");,                 },             },         },         container.add(fileNameMapper);,         setChecked(false);,     }, ,     /**,      * Add a Mapper,      * @param mapper the mapper to add,      */,     public void addConfiguredMapper(Mapper mapper) {,         add(mapper.getImplementation());,     }, ,     /**,      * Set the class name of the FileNameMapper to use.,      * @param classname the name of the class,      */,     public void setClassname(String classname) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.classname = classname;,     }, ,     /**,      * Set the classpath to load the FileNameMapper through (attribute).,      * @param classpath the classpath,      */,     public void setClasspath(Path classpath) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (this.classpath == null) {,             this.classpath = classpath;,         } else {,             this.classpath.append(classpath);,         },     }, ,     /**,      * Set the classpath to load the FileNameMapper through (nested element).,      * @return a path object to be configured,      */,     public Path createClasspath() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (this.classpath == null) {,             this.classpath = new Path(getProject());,         },         setChecked(false);,         return this.classpath.createPath();,     }, ,     /**,      * Set the classpath to load the FileNameMapper through via,      * reference (attribute).,      * @param ref the reference to the FileNameMapper,      */,     public void setClasspathRef(Reference ref) {,         if (isReference()) {,             throw tooManyAttributes();,         },         createClasspath().setRefid(ref);,     }, ,     /**,      * Set the argument to FileNameMapper.setFrom,      * @param from the from attribute to pass to the FileNameMapper,      */,     public void setFrom(String from) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.from = from;,     }, ,     /**,      * Set the argument to FileNameMapper.setTo,      * @param to the to attribute to pass to the FileNameMapper,      */,     public void setTo(String to) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.to = to;,     }, ,     /**,      * Make this Mapper instance a reference to another Mapper.,      *,      * <p>You must not set any other attribute if you make it a,      * reference.</p>,      * @param r the reference to another mapper,      * @throws BuildException if other attributes are set,      */,     public void setRefid(Reference r) throws BuildException {,         if (type != null || from != null || to != null) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Returns a fully configured FileNameMapper implementation.,      * @return a FileNameMapper object to be configured,      * @throws BuildException on error,      */,     public FileNameMapper getImplementation() throws BuildException {,         if (isReference()) {,             dieOnCircularReference();,             Reference r = getRefid();,             Object o = r.getReferencedObject(getProject());,             if (o instanceof FileNameMapper) {,                 return (FileNameMapper) o;,             },             if (o instanceof Mapper) {,                 return ((Mapper) o).getImplementation();,             },             String od = o == null ? "null" : o.getClass().getName();,             throw new BuildException(od + " at reference '",                 + r.getRefId() + "' is not a valid mapper reference.");,         }, ,         if (type == null && classname == null && container == null) {,             throw new BuildException(,                 "nested mapper or ",                 + "one of the attributes type or classname is required");,         }, ,         if (container != null) {,             return container;,         }, ,         if (type != null && classname != null) {,             throw new BuildException(,                 "must not specify both type and classname attribute");,         }, ,         try {,             FileNameMapper m = getImplementationClass().newInstance();,             final Project p = getProject();,             if (p != null) {,                 p.setProjectReference(m);,             },             m.setFrom(from);,             m.setTo(to);, ,             return m;,         } catch (BuildException be) {,             throw be;,         } catch (Throwable t) {,             throw new BuildException(t);,         },     }, ,      /**,      * Gets the Class object associated with the mapper implementation.,      * @return <code>Class</code>.,      * @throws ClassNotFoundException if the class cannot be found,      */,     protected Class<? extends FileNameMapper> getImplementationClass() throws ClassNotFoundException {, ,         String cName = this.classname;,         if (type != null) {,             cName = type.getImplementation();,         }, ,         ClassLoader loader = (classpath == null),             ? getClass().getClassLoader(),             // Memory leak in line below,             : getProject().createClassLoader(classpath);, ,         return Class.forName(cName, true, loader).asSubclass(FileNameMapper.class);,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced Mapper.,      * @deprecated since Ant 1.7.1 because a mapper might ref a,      *             FileNameMapper implementation directly.,      * @return the referenced Mapper,      */,     protected Mapper getRef() {,         return getCheckedRef(Mapper.class, getDataTypeName());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/MapperTest.java,testCircularReferenceCheck,104-104,[        project.addReference("dummy", m);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/types/Path.java,,80-80,[        new Path(null, System.getProperty("sun.boot.class.path"));],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/types/Path.java,,71-71,[        new Path(null, System.getProperty("java.class.path"));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/Path.java,delegateIteratorToList,753-753,[        } catch (Exception e) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/Path.java,,70-772,[    public static Path systemClasspath =,         new Path(null, System.getProperty("java.class.path"));, , ,     /**,      * The system bootclasspath as a Path object.,      *,      * @since Ant 1.6.2,      */,     public static Path systemBootClasspath =,         new Path(null, System.getProperty("sun.boot.class.path"));, ,     // CheckStyle:VisibilityModifier OFF - bc, ,     /**,      * Helper class, holds the nested <code>&lt;pathelement&gt;</code> values.,      */,     public class PathElement implements ResourceCollection {,         private String[] parts;, ,         /**,          * Set the location.,          *,          * @param loc a <code>File</code> value,          */,         public void setLocation(File loc) {,             parts = new String[] {translateFile(loc.getAbsolutePath())};,         }, ,         /**,          * Set the path.,          *,          * @param path a <code>String</code> value,          */,         public void setPath(String path) {,             parts = Path.translatePath(getProject(), path);,         }, ,         /**,          * Return the converted pathelements.,          *,          * @return a <code>String[]</code> value,          */,         public String[] getParts() {,             return parts;,         }, ,         /**,          * Create an iterator.,          * @return an iterator.,          */,         public Iterator<Resource> iterator() {,             return new FileResourceIterator(getProject(), null, parts);,         }, ,         /**,          * Check if this resource is only for filesystems.,          * @return true.,          */,         public boolean isFilesystemOnly() {,             return true;,         }, ,         /**,          * Get the number of resources.,          * @return the number of parts.,          */,         public int size() {,             return parts == null ? 0 : parts.length;,         }, ,     }, ,     private Boolean preserveBC;, ,     private Union union = null;,     private boolean cache = false;, ,     /**,      * Invoked by IntrospectionHelper for <code>setXXX(Path p)</code>,      * attribute setters.,      * @param p the <code>Project</code> for this path.,      * @param path the <code>String</code> path definition.,      */,     public Path(Project p, String path) {,         this(p);,         createPathElement().setPath(path);,     }, ,     /**,      * Construct an empty <code>Path</code>.,      * @param project the <code>Project</code> for this path.,      */,     public Path(Project project) {,         setProject(project);,     }, ,     /**,      * Adds a element definition to the path.,      * @param location the location of the element to add (must not be,      * <code>null</code> nor empty.,      * @throws BuildException on error,      */,     public void setLocation(File location) throws BuildException {,         checkAttributesAllowed();,         createPathElement().setLocation(location);,     }, ,     /**,      * Parses a path definition and creates single PathElements.,      * @param path the <code>String</code> path definition.,      * @throws BuildException on error,      */,     public void setPath(String path) throws BuildException {,         checkAttributesAllowed();,         createPathElement().setPath(path);,     }, ,     /**,      * Makes this instance in effect a reference to another Path instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      * @param r the reference to another Path,      * @throws BuildException on error,      */,     public void setRefid(Reference r) throws BuildException {,         if (union != null) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Creates the nested <code>&lt;pathelement&gt;</code> element.,      * @return the <code>PathElement</code> to be configured,      * @throws BuildException on error,      */,     public PathElement createPathElement() throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         PathElement pe = new PathElement();,         add(pe);,         return pe;,     }, ,     /**,      * Adds a nested <code>&lt;fileset&gt;</code> element.,      * @param fs a <code>FileSet</code> to be added to the path,      * @throws BuildException on error,      */,     public void addFileset(FileSet fs) throws BuildException {,         if (fs.getProject() == null) {,             fs.setProject(getProject());,         },         add(fs);,     }, ,     /**,      * Adds a nested <code>&lt;filelist&gt;</code> element.,      * @param fl a <code>FileList</code> to be added to the path,      * @throws BuildException on error,      */,     public void addFilelist(FileList fl) throws BuildException {,         if (fl.getProject() == null) {,             fl.setProject(getProject());,         },         add(fl);,     }, ,     /**,      * Adds a nested <code>&lt;dirset&gt;</code> element.,      * @param dset a <code>DirSet</code> to be added to the path,      * @throws BuildException on error,      */,     public void addDirset(DirSet dset) throws BuildException {,         if (dset.getProject() == null) {,             dset.setProject(getProject());,         },         add(dset);,     }, ,     /**,      * Adds a nested path,      * @param path a <code>Path</code> to be added to the path,      * @throws BuildException on error,      * @since Ant 1.6,      */,     public void add(Path path) throws BuildException {,         if (path == this) {,             throw circularReference();,         },         if (path.getProject() == null) {,             path.setProject(getProject());,         },         add((ResourceCollection) path);,     }, ,     /**,      * Add a nested <code>ResourceCollection</code>.,      * @param c the ResourceCollection to add.,      * @since Ant 1.7,      */,     public void add(ResourceCollection c) {,         checkChildrenAllowed();,         if (c == null) {,             return;,         },         if (union == null) {,             union = new Union();,             union.setProject(getProject());,             union.setCache(cache);,         },         union.add(c);,         setChecked(false);,     }, ,     /**,      * Creates a nested <code>&lt;path&gt;</code> element.,      * @return a <code>Path</code> to be configured,      * @throws BuildException on error,      */,     public Path createPath() throws BuildException {,         Path p = new Path(getProject());,         add(p);,         return p;,     }, ,     /**,      * Append the contents of the other Path instance to this.,      * @param other a <code>Path</code> to be added to the path,      */,     public void append(Path other) {,         if (other == null) {,             return;,         },         add(other);,     }, ,     /**,      * Adds the components on the given path which exist to this,      * Path. Components that don't exist aren't added.,      *,      * @param source - source path whose components are examined for existence,      */,      public void addExisting(Path source) {,          addExisting(source, false);,      }, ,     /**,      * Same as addExisting, but support classpath behavior if tryUserDir,      * is true. Classpaths are relative to user dir, not the project base.,      * That used to break jspc test,      *,      * @param source the source path,      * @param tryUserDir  if true try the user directory if the file is not present,      */,     public void addExisting(Path source, boolean tryUserDir) {,         String[] list = source.list();,         File userDir = (tryUserDir) ? new File(System.getProperty("user.dir")),                 : null;, ,         for (int i = 0; i < list.length; i++) {,             File f = resolveFile(getProject(), list[i]);, ,             // probably not the best choice, but it solves the problem of,             // relative paths in CLASSPATH,             if (tryUserDir && !f.exists()) {,                 f = new File(userDir, list[i]);,             },             if (f.exists()) {,                 setLocation(f);,             } else if (f.getParentFile() != null && f.getParentFile().exists(),                        && containsWildcards(f.getName())) {,                 setLocation(f);,                 log("adding " + f + " which contains wildcards and may not",                     + " do what you intend it to do depending on your OS or",                     + " version of Java", Project.MSG_VERBOSE);,             } else {,                 log("dropping " + f + " from path as it doesn't exist",,                     Project.MSG_VERBOSE);,             },         },     }, ,     /**,      * Whether to cache the current path.,      * @since Ant 1.8.0,      */,     public void setCache(boolean b) {,         checkAttributesAllowed();,         cache = b;,         if (union != null) {,             union.setCache(b);,         },     }, ,     /**,      * Returns all path elements defined by this and nested path objects.,      * @return list of path elements.,      */,     public String[] list() {,         if (isReference()) {,             return ((Path) getCheckedRef()).list();,         },         return assertFilesystemOnly(union) == null,             ? new String[0] : union.list();,     }, ,     /**,      * Returns a textual representation of the path, which can be used as,      * CLASSPATH or PATH environment variable definition.,      * @return a textual representation of the path.,      */,     public String toString() {,         return isReference() ? getCheckedRef().toString(),             : union == null ? "" : union.toString();,     }, ,     /**,      * Splits a PATH (with : or ; as separators) into its parts.,      * @param project the project to use,      * @param source a <code>String</code> value,      * @return an array of strings, one for each path element,      */,     public static String[] translatePath(Project project, String source) {,         final Vector<String> result = new Vector<String>();,         if (source == null) {,             return new String[0];,         },         PathTokenizer tok = new PathTokenizer(source);,         StringBuffer element = new StringBuffer();,         while (tok.hasMoreTokens()) {,             String pathElement = tok.nextToken();,             try {,                 element.append(resolveFile(project, pathElement).getPath());,             } catch (BuildException e) {,                 project.log("Dropping path element " + pathElement,                     + " as it is not valid relative to the project",,                     Project.MSG_VERBOSE);,             },             for (int i = 0; i < element.length(); i++) {,                 translateFileSep(element, i);,             },             result.addElement(element.toString());,             element = new StringBuffer();,         },         return result.toArray(new String[result.size()]);,     }, ,     /**,      * Returns its argument with all file separator characters,      * replaced so that they match the local OS conventions.,      * @param source the path to convert,      * @return the converted path,      */,     public static String translateFile(String source) {,         if (source == null) {,           return "";,         },         final StringBuffer result = new StringBuffer(source);,         for (int i = 0; i < result.length(); i++) {,             translateFileSep(result, i);,         },         return result.toString();,     }, ,     /**,      * Translates occurrences at a position of / or \ to correct separator of the,      * current platform and returns whether it had to do a,      * replacement.,      * @param buffer a buffer containing a string,      * @param pos the position in the string buffer to convert,      * @return true if the character was a / or \,      */,     protected static boolean translateFileSep(StringBuffer buffer, int pos) {,         if (buffer.charAt(pos) == '/' || buffer.charAt(pos) == '\\') {,             buffer.setCharAt(pos, File.separatorChar);,             return true;,         },         return false;,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return number of elements as int.,      */,     public synchronized int size() {,         if (isReference()) {,             return ((Path) getCheckedRef()).size();,         },         dieOnCircularReference();,         return union == null ? 0 : assertFilesystemOnly(union).size();,     }, ,     /**,      * Clone this Path.,      * @return Path with shallowly cloned Resource children.,      */,     public Object clone() {,         try {,             Path result = (Path) super.clone();,             result.union = union == null ? union : (Union) union.clone();,             return result;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (union != null) {,                 pushAndInvokeCircularReferenceCheck(union, stk, p);,             },             setChecked(true);,         },     }, ,     /**,      * Resolve a filename with Project's help - if we know one that is.,      */,     private static File resolveFile(Project project, String relativeName) {,         return FileUtils.getFileUtils().resolveFile(,             (project == null) ? null : project.getBaseDir(), relativeName);,     }, ,     /**,      * Concatenates the system class path in the order specified by,      * the ${build.sysclasspath} property - using &quot;last&quot; as,      * default value.,      * @return the concatenated path,      */,     public Path concatSystemClasspath() {,         return concatSystemClasspath("last");,     }, ,     /**,      * Concatenates the system class path in the order specified by,      * the ${build.sysclasspath} property - using the supplied value,      * if ${build.sysclasspath} has not been set.,      * @param defValue the order ("first", "last", "only"),      * @return the concatenated path,      */,     public Path concatSystemClasspath(String defValue) {,         return concatSpecialPath(defValue, Path.systemClasspath);,     }, ,     /**,      * Concatenates the system boot class path in the order specified,      * by the ${build.sysclasspath} property - using the supplied,      * value if ${build.sysclasspath} has not been set.,      * @param defValue the order ("first", "last", "only"),      * @return the concatenated path,      */,     public Path concatSystemBootClasspath(String defValue) {,         return concatSpecialPath(defValue, Path.systemBootClasspath);,     }, ,     /**,      * Concatenates a class path in the order specified by the,      * ${build.sysclasspath} property - using the supplied value if,      * ${build.sysclasspath} has not been set.,      */,     private Path concatSpecialPath(String defValue, Path p) {,         Path result = new Path(getProject());, ,         String order = defValue;,         String o = getProject() != null,             ? getProject().getProperty(MagicNames.BUILD_SYSCLASSPATH),             : System.getProperty(MagicNames.BUILD_SYSCLASSPATH);,         if (o != null) {,             order = o;,         },         if (order.equals("only")) {,             // only: the developer knows what (s)he is doing,             result.addExisting(p, true);, ,         } else if (order.equals("first")) {,             // first: developer could use a little help,             result.addExisting(p, true);,             result.addExisting(this);, ,         } else if (order.equals("ignore")) {,             // ignore: don't trust anyone,             result.addExisting(this);, ,         } else {,             // last: don't trust the developer,             if (!order.equals("last")) {,                 log("invalid value for " + MagicNames.BUILD_SYSCLASSPATH,                     + ": " + order,,                     Project.MSG_WARN);,             },             result.addExisting(this);,             result.addExisting(p, true);,         },         return result;,     }, ,     /**,      * Add the Java Runtime classes to this Path instance.,      */,     public void addJavaRuntime() {,         if (JavaEnvUtils.isKaffe()) {,             // newer versions of Kaffe (1.1.1+) won't have this,,             // but this will be sorted by FileSet anyway.,             File kaffeShare = new File(System.getProperty("java.home"),                                        + File.separator + "share",                                        + File.separator + "kaffe");,             if (kaffeShare.isDirectory()) {,                 FileSet kaffeJarFiles = new FileSet();,                 kaffeJarFiles.setDir(kaffeShare);,                 kaffeJarFiles.setIncludes("*.jar");,                 addFileset(kaffeJarFiles);,             },         } else if ("GNU libgcj".equals(System.getProperty("java.vm.name"))) {,             addExisting(systemBootClasspath);,         }, ,         if (System.getProperty("java.vendor").toLowerCase(Locale.ENGLISH).indexOf("microsoft") >= 0) {,             // TODO is this code still necessary? is there any 1.2+ port?,             // Pull in *.zip from packages directory,             FileSet msZipFiles = new FileSet();,             msZipFiles.setDir(new File(System.getProperty("java.home"),                 + File.separator + "Packages"));,             msZipFiles.setIncludes("*.ZIP");,             addFileset(msZipFiles);,         } else {,             // JDK 1.2+ seems to set java.home to the JRE directory.,             addExisting(new Path(null,,                                  System.getProperty("java.home"),                                  + File.separator + "lib",                                  + File.separator + "rt.jar"));,             // Just keep the old version as well and let addExisting,             // sort it out.,             addExisting(new Path(null,,                                  System.getProperty("java.home"),                                  + File.separator + "jre",                                  + File.separator + "lib",                                  + File.separator + "rt.jar"));, ,             // Sun's and Apple's 1.4 have JCE and JSSE in separate jars.,             String[] secJars = {"jce", "jsse"};,             for (int i = 0; i < secJars.length; i++) {,                 addExisting(new Path(null,,                                      System.getProperty("java.home"),                                      + File.separator + "lib",                                      + File.separator + secJars[i] + ".jar"));,                 addExisting(new Path(null,,                                      System.getProperty("java.home"),                                      + File.separator + "..",                                      + File.separator + "Classes",                                      + File.separator + secJars[i] + ".jar"));,             }, ,             // IBM's 1.4 has rt.jar split into 4 smaller jars and a combined,             // JCE/JSSE in security.jar.,             String[] ibmJars,                 = {"core", "graphics", "security", "server", "xml"};,             for (int i = 0; i < ibmJars.length; i++) {,                 addExisting(new Path(null,,                                      System.getProperty("java.home"),                                      + File.separator + "lib",                                      + File.separator + ibmJars[i] + ".jar"));,             }, ,             // Added for MacOS X,             addExisting(new Path(null,,                                  System.getProperty("java.home"),                                  + File.separator + "..",                                  + File.separator + "Classes",                                  + File.separator + "classes.jar"));,             addExisting(new Path(null,,                                  System.getProperty("java.home"),                                  + File.separator + "..",                                  + File.separator + "Classes",                                  + File.separator + "ui.jar"));,         },     }, ,     /**,      * Emulation of extdirs feature in java >= 1.2.,      * This method adds all files in the given,      * directories (but not in sub-directories!) to the classpath,,      * so that you don't have to specify them all one by one.,      * @param extdirs - Path to append files to,      */,     public void addExtdirs(Path extdirs) {,         if (extdirs == null) {,             String extProp = System.getProperty("java.ext.dirs");,             if (extProp != null) {,                 extdirs = new Path(getProject(), extProp);,             } else {,                 return;,             },         }, ,         String[] dirs = extdirs.list();,         for (int i = 0; i < dirs.length; i++) {,             File dir = resolveFile(getProject(), dirs[i]);,             if (dir.exists() && dir.isDirectory()) {,                 FileSet fs = new FileSet();,                 fs.setDir(dir);,                 fs.setIncludes("*");,                 addFileset(fs);,             },         },     }, ,     /**,      * Fulfill the ResourceCollection contract. The Iterator returned,      * will throw ConcurrentModificationExceptions if ResourceCollections,      * are added to this container while the Iterator is in use.,      * @return a "fail-fast" Iterator.,      */,     public final synchronized Iterator<Resource> iterator() {,         if (isReference()) {,             return ((Path) getCheckedRef()).iterator();,         },         dieOnCircularReference();,         if (getPreserveBC()) {,             return new FileResourceIterator(getProject(), null, list());,         },         return union == null ? Collections.<Resource> emptySet().iterator(),             : assertFilesystemOnly(union).iterator();,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return whether this is a filesystem-only resource collection.,      */,     public synchronized boolean isFilesystemOnly() {,         if (isReference()) {,             return ((Path) getCheckedRef()).isFilesystemOnly();,         },         dieOnCircularReference();,         assertFilesystemOnly(union);,         return true;,     }, ,     /**,      * Verify the specified ResourceCollection is filesystem-only.,      * @param rc the ResourceCollection to check.,      * @throws BuildException if <code>rc</code> is not filesystem-only.,      * @return the passed in ResourceCollection.,      */,     protected ResourceCollection assertFilesystemOnly(ResourceCollection rc) {,         if (rc != null && !(rc.isFilesystemOnly())) {,             throw new BuildException(getDataTypeName(),                 + " allows only filesystem resources.");,         },         return rc;,     }, ,     /**,      * Helps determine whether to preserve BC by calling <code>list()</code> on subclasses.,      * The default behavior of this method is to return <code>true</code> for any subclass,      * that implements <code>list()</code>; this can, of course, be avoided by overriding,      * this method to return <code>false</code>. It is not expected that the result of this,      * method should change over time, thus it is called only once.,      * @return <code>true</code> if <code>iterator()</code> should delegate to <code>list()</code>.,      */,     protected boolean delegateIteratorToList() {,         if (getClass().equals(Path.class)) {,             return false;,         },         try {,             Method listMethod = getClass().getMethod("list", (Class[]) null);,             return !listMethod.getDeclaringClass().equals(Path.class);,         } catch (Exception e) {,             //shouldn't happen, but,             return false;,         },     }, ,     private synchronized boolean getPreserveBC() {,         if (preserveBC == null) {,             preserveBC = delegateIteratorToList() ? Boolean.TRUE : Boolean.FALSE;,         },         return preserveBC.booleanValue();,     }, ,     /**,      * Does the given file name contain wildcards?,      * @since Ant 1.8.2,      */,     private static boolean containsWildcards(String path) {,         return path != null,             && (path.indexOf("*") > -1 || path.indexOf("?") > -1);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/Path.java,getParts,114-114,[            return parts;],,
STYLE,DB_DUPLICATE_BRANCHES,org/apache/tools/ant/types/PathTest.java,testRelativePathUnixStyle,83-85,[           assertTrue("test resolved relative to src/etc",,                  l[0].endsWith("\\src"));,            assertTrue("test resolved relative to src/etc",],,testRelativePathUnixStyle,88-90,[           assertTrue("test resolved relative to src/etc",,                  l[0].endsWith("\\src"));,            assertTrue("test resolved relative to src/etc",],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PathTest.java,testAppending,347-347,[        p.setLocation(new File("/c"));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PathTest.java,testAppending,356-356,[        p.createPath().setLocation(new File("/g"));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PathTest.java,testCircularReferenceCheck,515-515,[        p3.setLocation(new File("/a"));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PathTest.java,testEmptyElementIfIsReference,409-409,[        p.setLocation(new File("/a"));],,testEmptyElementIfIsReference,423-423,[            p.setLocation(new File("/a"));],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/types/PathTest.java,,42-42,[    public static boolean isNetWare = Os.isFamily("netware");],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/types/PathTest.java,,41-41,[    public static boolean isUnixStyle = File.pathSeparatorChar == ':';],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/PatternSet.java,readPatterns,364-364,[            patternReader = new BufferedReader(new FileReader(patternfile));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/PatternSet.java,makeArray,464-464,[            return null;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/PatternSet.java,,41-540,[    private List<NameEntry> includeList = new ArrayList<NameEntry>();,     private List<NameEntry> excludeList = new ArrayList<NameEntry>();,     private List<NameEntry> includesFileList = new ArrayList<NameEntry>();,     private List<NameEntry> excludesFileList = new ArrayList<NameEntry>();, ,     /**,      * inner class to hold a name on list.  "If" and "Unless" attributes,      * may be used to invalidate the entry based on the existence of a,      * property (typically set thru the use of the Available task),      * or value of an expression.,      */,     public class NameEntry {,         private String name;,         private Object ifCond;,         private Object unlessCond;, ,         /**,          * Sets the name pattern.,          *,          * @param name The pattern string.,          */,         public void setName(String name) {,             this.name = name;,         }, ,         /**,          * Sets the if attribute. This attribute and the "unless",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to false or no property of,          *             its value is present, the name is invalid.,          * @since Ant 1.8.0,          */,         public void setIf(Object cond) {,             ifCond = cond;,         }, ,         /**,          * Sets the if attribute. This attribute and the "unless",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to false or no property of,          *             its value is present, the name is invalid.,          */,         public void setIf(String cond) {,             setIf((Object) cond);,         }, ,         /**,          * Sets the unless attribute. This attribute and the "if",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to true or a property of,          *             its value is present, the name is invalid.,          * @since Ant 1.8.0,          */,         public void setUnless(Object cond) {,             unlessCond = cond;,         }, ,         /**,          * Sets the unless attribute. This attribute and the "if",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to true or a property of,          *             its value is present, the name is invalid.,          */,         public void setUnless(String cond) {,             setUnless((Object) cond);,         }, ,         /**,          * @return the name attribute.,          */,         public String getName() {,             return name;,         }, ,         /**,          * This validates the name - checks the if and unless,          * properties.,          *,          * @param p the current project, used to check the presence or,          *          absence of a property.,          * @return  the name attribute or null if the "if" or "unless",          *          properties are not/are set.,          */,         public String evalName(Project p) {,             return valid(p) ? name : null;,         }, ,         private boolean valid(Project p) {,             PropertyHelper ph = PropertyHelper.getPropertyHelper(p);,             return ph.testIfCondition(ifCond),                 && ph.testUnlessCondition(unlessCond);,         }, ,         /**,          * @return a printable form of this object.,          */,         public String toString() {,             StringBuffer buf = new StringBuffer();,             if (name == null) {,                 buf.append("noname");,             } else {,                 buf.append(name);,             },             if ((ifCond != null) || (unlessCond != null)) {,                 buf.append(":");,                 String connector = "";, ,                 if (ifCond != null) {,                     buf.append("if->");,                     buf.append(ifCond);,                     connector = ";";,                 },                 if (unlessCond != null) {,                     buf.append(connector);,                     buf.append("unless->");,                     buf.append(unlessCond);,                 },             },             return buf.toString();,         },     }, ,     private static final class InvertedPatternSet extends PatternSet {,         private InvertedPatternSet(PatternSet p) {,             setProject(p.getProject());,             addConfiguredPatternset(p);,         },         public String[] getIncludePatterns(Project p) {,             return super.getExcludePatterns(p);,         },         public String[] getExcludePatterns(Project p) {,             return super.getIncludePatterns(p);,         },     }, ,     /**,      * Creates a new <code>PatternSet</code> instance.,      */,     public PatternSet() {,         super();,     }, ,     /**,      * Makes this instance in effect a reference to another PatternSet,      * instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      * @param r the reference to another patternset.,      * @throws BuildException on error.,      */,     public void setRefid(Reference r) throws BuildException {,         if (!includeList.isEmpty() || !excludeList.isEmpty()) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * This is a patternset nested element.,      *,      * @param p a configured patternset nested element.,      */,     public void addConfiguredPatternset(PatternSet p) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         String[] nestedIncludes = p.getIncludePatterns(getProject());,         String[] nestedExcludes = p.getExcludePatterns(getProject());, ,         if (nestedIncludes != null) {,             for (int i = 0; i < nestedIncludes.length; i++) {,                 createInclude().setName(nestedIncludes[i]);,             },         },         if (nestedExcludes != null) {,             for (int i = 0; i < nestedExcludes.length; i++) {,                 createExclude().setName(nestedExcludes[i]);,             },         },     }, ,     /**,      * add a name entry on the include list,      * @return a nested include element to be configured.,      */,     public NameEntry createInclude() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return addPatternToList(includeList);,     }, ,     /**,      * add a name entry on the include files list,      * @return a nested includesfile element to be configured.,      */,     public NameEntry createIncludesFile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return addPatternToList(includesFileList);,     }, ,     /**,      * add a name entry on the exclude list,      * @return a nested exclude element to be configured.,      */,     public NameEntry createExclude() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return addPatternToList(excludeList);,     }, ,     /**,      * add a name entry on the exclude files list,      * @return a nested excludesfile element to be configured.,      */,     public NameEntry createExcludesFile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return addPatternToList(excludesFileList);,     }, ,     /**,      * Appends <code>includes</code> to the current list of include patterns.,      * Patterns may be separated by a comma or a space.,      *,      * @param includes the string containing the include patterns,      */,     public void setIncludes(String includes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (includes != null && includes.length() > 0) {,             StringTokenizer tok = new StringTokenizer(includes, ", ", false);,             while (tok.hasMoreTokens()) {,                 createInclude().setName(tok.nextToken());,             },         },     }, ,     /**,      * Appends <code>excludes</code> to the current list of exclude patterns.,      * Patterns may be separated by a comma or a space.,      *,      * @param excludes the string containing the exclude patterns,      */,     public void setExcludes(String excludes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (excludes != null && excludes.length() > 0) {,             StringTokenizer tok = new StringTokenizer(excludes, ", ", false);,             while (tok.hasMoreTokens()) {,                 createExclude().setName(tok.nextToken());,             },         },     }, ,     /**,      * add a name entry to the given list,      */,     private NameEntry addPatternToList(List<NameEntry> list) {,         NameEntry result = new NameEntry();,         list.add(result);,         return result;,     }, ,     /**,      * Sets the name of the file containing the includes patterns.,      *,      * @param includesFile The file to fetch the include patterns from.,      * @throws BuildException on error.,      */,      public void setIncludesfile(File includesFile) throws BuildException {,          if (isReference()) {,              throw tooManyAttributes();,          },          createIncludesFile().setName(includesFile.getAbsolutePath());,      }, ,     /**,      * Sets the name of the file containing the excludes patterns.,      *,      * @param excludesFile The file to fetch the exclude patterns from.,      * @throws BuildException on error.,      */,      public void setExcludesfile(File excludesFile) throws BuildException {,          if (isReference()) {,              throw tooManyAttributes();,          },          createExcludesFile().setName(excludesFile.getAbsolutePath());,      }, ,     /**,      *  Reads path matching patterns from a file and adds them to the,      *  includes or excludes list (as appropriate).,      */,     private void readPatterns(File patternfile, List<NameEntry> patternlist, Project p),             throws BuildException {, ,         BufferedReader patternReader = null;,         try {,             // Get a FileReader,             patternReader = new BufferedReader(new FileReader(patternfile));, ,             // Create one NameEntry in the appropriate pattern list for each,             // line in the file.,             String line = patternReader.readLine();,             while (line != null) {,                 if (line.length() > 0) {,                     line = p.replaceProperties(line);,                     addPatternToList(patternlist).setName(line);,                 },                 line = patternReader.readLine();,             },         } catch (IOException ioe)  {,             throw new BuildException("An error occurred while reading from pattern file: ",                     + patternfile, ioe);,         } finally {,             FileUtils.close(patternReader);,         },     }, ,     /**,      * Adds the patterns of the other instance to this set.,      * @param other the other PatternSet instance.,      * @param p the current project.,      */,     public void append(PatternSet other, Project p) {,         if (isReference()) {,             throw new BuildException("Cannot append to a reference");,         },         dieOnCircularReference(p);,         String[] incl = other.getIncludePatterns(p);,         if (incl != null) {,             for (int i = 0; i < incl.length; i++) {,                 createInclude().setName(incl[i]);,             },         },         String[] excl = other.getExcludePatterns(p);,         if (excl != null) {,             for (int i = 0; i < excl.length; i++) {,                 createExclude().setName(excl[i]);,             },         },     }, ,     /**,      * Returns the filtered include patterns.,      * @param p the current project.,      * @return the filtered included patterns.,      */,     public String[] getIncludePatterns(Project p) {,         if (isReference()) {,             return getRef(p).getIncludePatterns(p);,         },         dieOnCircularReference(p);,         readFiles(p);,         return makeArray(includeList, p);,     }, ,     /**,      * Returns the filtered include patterns.,      * @param p the current project.,      * @return the filtered excluded patterns.,      */,     public String[] getExcludePatterns(Project p) {,         if (isReference()) {,             return getRef(p).getExcludePatterns(p);,         },         dieOnCircularReference(p);,         readFiles(p);,         return makeArray(excludeList, p);,     }, ,     /**,      * Helper for FileSet classes.,      * Check if there are patterns defined.,      * @param p the current project.,      * @return true if there are patterns.,      */,     public boolean hasPatterns(Project p) {,         if (isReference()) {,             return getRef(p).hasPatterns(p);,         },         dieOnCircularReference(p);,         return includesFileList.size() > 0 || excludesFileList.size() > 0,                 || includeList.size() > 0 || excludeList.size() > 0;,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced PatternSet.,      */,     private PatternSet getRef(Project p) {,         return (PatternSet) getCheckedRef(p);,     }, ,     /**,      * Convert a vector of NameEntry elements into an array of Strings.,      */,     private String[] makeArray(List<NameEntry> list, Project p) {,         if (list.size() == 0) {,             return null;,         },         ArrayList<String> tmpNames = new ArrayList<String>();,         for (NameEntry ne : list) {,             String pattern = ne.evalName(p);,             if (pattern != null && pattern.length() > 0) {,                 tmpNames.add(pattern);,             },         },         return tmpNames.toArray(new String[tmpNames.size()]);,     }, ,     /**,      * Read includesfile ot excludesfile if not already done so.,      */,     private void readFiles(Project p) {,         if (includesFileList.size() > 0) {,             for (NameEntry ne : includesFileList) {,                 String fileName = ne.evalName(p);,                 if (fileName != null) {,                     File inclFile = p.resolveFile(fileName);,                     if (!inclFile.exists()) {,                         throw new BuildException("Includesfile " + inclFile.getAbsolutePath(),                                 + " not found.");,                     },                     readPatterns(inclFile, includeList, p);,                 },             },             includesFileList.clear();,         },         if (excludesFileList.size() > 0) {,             for (NameEntry ne : excludesFileList) {,                 String fileName = ne.evalName(p);,                 if (fileName != null) {,                     File exclFile = p.resolveFile(fileName);,                     if (!exclFile.exists()) {,                         throw new BuildException("Excludesfile " + exclFile.getAbsolutePath(),                                 + " not found.");,                     },                     readPatterns(exclFile, excludeList, p);,                 },             },             excludesFileList.clear();,         },     }, ,     /**,      * @return a printable form of this object.,      */,     public String toString() {,         return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }";,     }, ,     /**,      * @since Ant 1.6,      * @return a clone of this patternset.,      */,     public Object clone() {,         try {,             PatternSet ps = (PatternSet) super.clone();,             ps.includeList = new ArrayList<NameEntry>(includeList);,             ps.excludeList = new ArrayList<NameEntry>(excludeList);,             ps.includesFileList = new ArrayList<NameEntry>(includesFileList);,             ps.excludesFileList = new ArrayList<NameEntry>(excludesFileList);,             return ps;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Add an inverted patternset.,      * @param p the pattern to invert and add.,      */,     public void addConfiguredInvert(PatternSet p) {,         addConfiguredPatternset(new InvertedPatternSet(p));,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/PatternSet.java,,52-175,[    public class NameEntry {,         private String name;,         private Object ifCond;,         private Object unlessCond;, ,         /**,          * Sets the name pattern.,          *,          * @param name The pattern string.,          */,         public void setName(String name) {,             this.name = name;,         }, ,         /**,          * Sets the if attribute. This attribute and the "unless",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to false or no property of,          *             its value is present, the name is invalid.,          * @since Ant 1.8.0,          */,         public void setIf(Object cond) {,             ifCond = cond;,         }, ,         /**,          * Sets the if attribute. This attribute and the "unless",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to false or no property of,          *             its value is present, the name is invalid.,          */,         public void setIf(String cond) {,             setIf((Object) cond);,         }, ,         /**,          * Sets the unless attribute. This attribute and the "if",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to true or a property of,          *             its value is present, the name is invalid.,          * @since Ant 1.8.0,          */,         public void setUnless(Object cond) {,             unlessCond = cond;,         }, ,         /**,          * Sets the unless attribute. This attribute and the "if",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to true or a property of,          *             its value is present, the name is invalid.,          */,         public void setUnless(String cond) {,             setUnless((Object) cond);,         }, ,         /**,          * @return the name attribute.,          */,         public String getName() {,             return name;,         }, ,         /**,          * This validates the name - checks the if and unless,          * properties.,          *,          * @param p the current project, used to check the presence or,          *          absence of a property.,          * @return  the name attribute or null if the "if" or "unless",          *          properties are not/are set.,          */,         public String evalName(Project p) {,             return valid(p) ? name : null;,         }, ,         private boolean valid(Project p) {,             PropertyHelper ph = PropertyHelper.getPropertyHelper(p);,             return ph.testIfCondition(ifCond),                 && ph.testUnlessCondition(unlessCond);,         }, ,         /**,          * @return a printable form of this object.,          */,         public String toString() {,             StringBuffer buf = new StringBuffer();,             if (name == null) {,                 buf.append("noname");,             } else {,                 buf.append(name);,             },             if ((ifCond != null) || (unlessCond != null)) {,                 buf.append(":");,                 String connector = "";, ,                 if (ifCond != null) {,                     buf.append("if->");,                     buf.append(ifCond);,                     connector = ";";,                 },                 if (unlessCond != null) {,                     buf.append(connector);,                     buf.append("unless->");,                     buf.append(unlessCond);,                 },             },             return buf.toString();],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PatternSetTest.java,testEmptyElementIfIsReference,73-73,[            p.setIncludesfile(new File("/a"));],,testEmptyElementIfIsReference,87-87,[            p.setExcludesfile(new File("/a"));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/PatternSetTest.java,testCircularReferenceCheck,126-126,[        project.addReference("dummy", p);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/Permissions.java,,206-206,[            if (active) {],,,170-170,[        active = false;],,,102-102,[        active = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/Permissions.java,,217-217,[                    if (!permOK && origSm != null) {],,,218-218,[                        origSm.checkPermission(perm);],,,171-171,[        System.setSecurityManager(origSm);],,,99-99,[        origSm = System.getSecurityManager();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/Permissions.java,createPermission,159-159,[        } catch (final Exception e) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/Permissions.java,matches,305-305,[            if (!className.equals(perm.getClass().getName())) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/Quantifier.java,getValues,113-113,[        return VALUES;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/RedirectorElement.java,toFileArray,571-571,[            return null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/Resource.java,<clinit>,48-48,[    protected static final int MAGIC = getMagicNumber("Resource".getBytes());],,<clinit>,50-50,[    private static final int NULL_NAME = getMagicNumber("null name".getBytes());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/types/Resource.java,setLastModified,203-203,[        this.lastmodified = new Long(lastmodified);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/types/Resource.java,setSize,234-234,[        this.size = new Long(size > UNKNOWN_SIZE ? size : UNKNOWN_SIZE);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/TimeComparison.java,getValues,62-62,[        return VALUES;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/XMLCatalog.java,,121-786,[public class XMLCatalog extends DataType,     implements Cloneable, EntityResolver, URIResolver {, ,     /** helper for some File.toURL connversions */,     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();, ,     //-- Fields ----------------------------------------------------------------, ,     /** Holds dtd/entity objects until needed. */,     private Vector<ResourceLocation> elements = new Vector<ResourceLocation>();, ,     /**,      * Classpath in which to attempt to resolve resources.,      */,     private Path classpath;, ,     /**,      * Path listing external catalog files to search when resolving entities,      */,     private Path catalogPath;, ,     /**,      * The name of the bridge to the Apache xml-commons resolver,      * class, used to determine whether resolver.jar is present in the,      * classpath.,      */,     public static final String APACHE_RESOLVER,         = "org.apache.tools.ant.types.resolver.ApacheCatalogResolver";, ,     /**,      * Resolver base class,      */,     public static final String CATALOG_RESOLVER,         = "org.apache.xml.resolver.tools.CatalogResolver";, ,         //-- Methods ---------------------------------------------------------------, ,     /**,      * Default constructor,      */,     public XMLCatalog() {,         setChecked(false);,     }, ,     /**,      * Returns the elements of the catalog - ResourceLocation objects.,      *,      * @return the elements of the catalog - ResourceLocation objects,      */,     private Vector<ResourceLocation> getElements() {,         return getRef().elements;,     }, ,     /**,      * Returns the classpath in which to attempt to resolve resources.,      *,      * @return the classpath,      */,     private Path getClasspath() {,         return getRef().classpath;,     }, ,     /**,      * Allows nested classpath elements. Not allowed if this catalog,      * is itself a reference to another catalog -- that is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * other attributes.,      *,      * @return a Path instance to be configured.,      */,     public Path createClasspath() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (this.classpath == null) {,             this.classpath = new Path(getProject());,         },         setChecked(false);,         return this.classpath.createPath();,     }, ,     /**,      * Allows simple classpath string.  Not allowed if this catalog is,      * itself a reference to another catalog -- that is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * other attributes.,      *,      * @param classpath the classpath to use to look up entities.,      */,     public void setClasspath(Path classpath) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (this.classpath == null) {,             this.classpath = classpath;,         } else {,             this.classpath.append(classpath);,         },         setChecked(false);,     }, ,     /**,      * Allows classpath reference.  Not allowed if this catalog is,      * itself a reference to another catalog -- that is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * other attributes.,      *,      * @param r an Ant reference containing a classpath.,      */,     public void setClasspathRef(Reference r) {,         if (isReference()) {,             throw tooManyAttributes();,         },         createClasspath().setRefid(r);,         setChecked(false);,     }, ,     /** Creates a nested <code>&lt;catalogpath&gt;</code> element.,      * Not allowed if this catalog is itself a reference to another,      * catalog -- that is, a catalog cannot both refer to another,      * <em>and</em> contain elements or other attributes.,      *,      * @return a path to be configured as the catalog path.,      * @exception BuildException,      * if this is a reference and no nested elements are allowed.,      */,     public Path createCatalogPath() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (this.catalogPath == null) {,             this.catalogPath = new Path(getProject());,         },         setChecked(false);,         return this.catalogPath.createPath();,     }, ,     /**,      * Allows catalogpath reference.  Not allowed if this catalog is,      * itself a reference to another catalog -- that is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * other attributes.,      *,      * @param r an Ant reference containing a classpath to be used as,      * the catalog path.,      */,     public void setCatalogPathRef(Reference r) {,         if (isReference()) {,             throw tooManyAttributes();,         },         createCatalogPath().setRefid(r);,         setChecked(false);,     }, , ,     /**,      * Returns the catalog path in which to attempt to resolve DTDs.,      *,      * @return the catalog path,      */,     public Path getCatalogPath() {,         return getRef().catalogPath;,     }, , ,     /**,      * Creates the nested <code>&lt;dtd&gt;</code> element.  Not,      * allowed if this catalog is itself a reference to another,      * catalog -- that is, a catalog cannot both refer to another,      * <em>and</em> contain elements or other attributes.,      *,      * @param dtd the information about the PUBLIC resource mapping to,      *            be added to the catalog,      * @exception BuildException if this is a reference and no nested,      *       elements are allowed.,      */,     public void addDTD(ResourceLocation dtd) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         }, ,         getElements().addElement(dtd);,         setChecked(false);,     }, ,     /**,      * Creates the nested <code>&lt;entity&gt;</code> element.    Not,      * allowed if this catalog is itself a reference to another,      * catalog -- that is, a catalog cannot both refer to another,      * <em>and</em> contain elements or other attributes.,      *,      * @param entity the information about the URI resource mapping to be,      *       added to the catalog.,      * @exception BuildException if this is a reference and no nested,      *       elements are allowed.,      */,     public void addEntity(ResourceLocation entity) throws BuildException {,         addDTD(entity);,     }, ,     /**,      * Loads a nested <code>&lt;xmlcatalog&gt;</code> into our,      * definition.  Not allowed if this catalog is itself a reference,      * to another catalog -- that is, a catalog cannot both refer to,      * another <em>and</em> contain elements or other attributes.,      *,      * @param catalog Nested XMLCatalog,      */,     public void addConfiguredXMLCatalog(XMLCatalog catalog) {,         if (isReference()) {,             throw noChildrenAllowed();,         }, ,         // Add all nested elements to our catalog,         getElements().addAll(catalog.getElements());, ,         // Append the classpath of the nested catalog,         Path nestedClasspath = catalog.getClasspath();,         createClasspath().append(nestedClasspath);, ,         // Append the catalog path of the nested catalog,         Path nestedCatalogPath = catalog.getCatalogPath();,         createCatalogPath().append(nestedCatalogPath);,         setChecked(false);,     }, ,     /**,      * Makes this instance in effect a reference to another XMLCatalog,      * instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.  That is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * attributes.</p>,      *,      * @param r the reference to which this catalog instance is associated,      * @exception BuildException if this instance already has been configured.,      */,     public void setRefid(Reference r) throws BuildException {,         if (!elements.isEmpty()) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Implements the EntityResolver.resolveEntity() interface method.,      * @param publicId the public id to resolve.,      * @param systemId the system id to resolve.,      * @throws SAXException if there is a parsing problem.,      * @throws IOException if there is an IO problem.,      * @return the resolved entity.,      * @see org.xml.sax.EntityResolver#resolveEntity,      */,     public InputSource resolveEntity(String publicId, String systemId),         throws SAXException, IOException {, ,         if (isReference()) {,             return getRef().resolveEntity(publicId, systemId);,         }, ,         dieOnCircularReference();, ,         log("resolveEntity: '" + publicId + "': '" + systemId + "'",,             Project.MSG_DEBUG);, ,         InputSource inputSource =,             getCatalogResolver().resolveEntity(publicId, systemId);, ,         if (inputSource == null) {,             log("No matching catalog entry found, parser will use: '",                 + systemId + "'", Project.MSG_DEBUG);,         }, ,         return inputSource;,     }, ,     /**,      * Implements the URIResolver.resolve() interface method.,      * @param href an href attribute.,      * @param base the base URI.,      * @return a Source object, or null if href cannot be resolved.,      * @throws TransformerException if an error occurs.,      * @see javax.xml.transform.URIResolver#resolve,      */,     public Source resolve(String href, String base),         throws TransformerException {, ,         if (isReference()) {,             return getRef().resolve(href, base);,         }, ,         dieOnCircularReference();, ,         SAXSource source = null;, ,         String uri = removeFragment(href);, ,         log("resolve: '" + uri + "' with base: '" + base + "'", Project.MSG_DEBUG);, ,         source = (SAXSource) getCatalogResolver().resolve(uri, base);, ,         if (source == null) {,             log("No matching catalog entry found, parser will use: '",                 + href + "'", Project.MSG_DEBUG);,             //,             // Cannot return a null source, because we have to call,             // setEntityResolver (see setEntityResolver javadoc comment),             //,             source = new SAXSource();,             URL baseURL = null;,             try {,                 if (base == null) {,                     baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());,                 } else {,                     baseURL = new URL(base);,                 },                 URL url = (uri.length() == 0 ? baseURL : new URL(baseURL, uri));,                 source.setInputSource(new InputSource(url.toString()));,             } catch (MalformedURLException ex) {,                 // At this point we are probably in failure mode, but,                 // try to use the bare URI as a last gasp,                 source.setInputSource(new InputSource(uri));,             },         }, ,         setEntityResolver(source);,         return source;,     }, ,     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (classpath != null) {,                 pushAndInvokeCircularReferenceCheck(classpath, stk, p);,             },             if (catalogPath != null) {,                 pushAndInvokeCircularReferenceCheck(catalogPath, stk, p);,             },             setChecked(true);,         },     }, ,     /**,      * @since Ant 1.6,      */,     private XMLCatalog getRef() {,         if (!isReference()) {,             return this;,         },         return getCheckedRef(XMLCatalog.class, "xmlcatalog");,     }, ,     /**,      * The instance of the CatalogResolver strategy to use.,      */,     private CatalogResolver catalogResolver = null;, ,     /**,      * Factory method for creating the appropriate CatalogResolver,      * strategy implementation.,      * <p> Until we query the classpath, we don't know whether the Apache,      * resolver (Norm Walsh's library from xml-commons) is available or not.,      * This method determines whether the library is available and creates the,      * appropriate implementation of CatalogResolver based on the answer.</p>,      * <p>This is an application of the Gang of Four Strategy Pattern,      * combined with Template Method.</p>,      */,     private CatalogResolver getCatalogResolver() {, ,         if (catalogResolver == null) {, ,             AntClassLoader loader = null;,             // Memory-Leak in line below,             loader = getProject().createClassLoader(Path.systemClasspath);, ,             try {,                 Class<?> clazz = Class.forName(APACHE_RESOLVER, true, loader);, ,                 // The Apache resolver is present - Need to check if it can,                 // be seen by the catalog resolver class. Start by getting,                 // the actual loader,                 ClassLoader apacheResolverLoader = clazz.getClassLoader();, ,                 // load the base class through this loader.,                 Class<?> baseResolverClass,                     = Class.forName(CATALOG_RESOLVER, true, apacheResolverLoader);, ,                 // and find its actual loader,                 ClassLoader baseResolverLoader,                     = baseResolverClass.getClassLoader();, ,                 // We have the loader which is being used to load the,                 // CatalogResolver. Can it see the ApacheResolver? The,                 // base resolver will only be able to create the ApacheResolver,                 // if it can see it - doesn't use the context loader.,                 clazz = Class.forName(APACHE_RESOLVER, true, baseResolverLoader);, ,                 Object obj  = clazz.newInstance();,                 //,                 // Success!  The xml-commons resolver library is,                 // available, so use it.,                 //,                 catalogResolver = new ExternalResolver(clazz, obj);,             } catch (Throwable ex) {,                 //,                 // The xml-commons resolver library is not,                 // available, so we can't use it.,                 //,                 catalogResolver = new InternalResolver();,                 if (getCatalogPath() != null,                     && getCatalogPath().list().length != 0) {,                         log("Warning: XML resolver not found; external catalogs",                             + " will be ignored", Project.MSG_WARN);,                     },                 log("Failed to load Apache resolver: " + ex, Project.MSG_DEBUG);,             },         },         return catalogResolver;,     }, ,     /**,      * <p>This is called from the URIResolver to set an EntityResolver,      * on the SAX parser to be used for new XML documents that are,      * encountered as a result of the document() function, xsl:import,,      * or xsl:include.  This is done because the XSLT processor calls,      * out to the SAXParserFactory itself to create a new SAXParser to,      * parse the new document.  The new parser does not automatically,      * inherit the EntityResolver of the original (although arguably,      * it should).  See below:</p>,      *,      * <tt>"If an application wants to set the ErrorHandler or,      * EntityResolver for an XMLReader used during a transformation,,      * it should use a URIResolver to return the SAXSource which,      * provides (with getXMLReader) a reference to the XMLReader"</tt>,      *,      * <p>...quoted from page 118 of the Java API for XML,      * Processing 1.1 specification</p>,      *,      */,     private void setEntityResolver(SAXSource source) throws TransformerException {, ,         XMLReader reader = source.getXMLReader();,         if (reader == null) {,             SAXParserFactory spFactory = SAXParserFactory.newInstance();,             spFactory.setNamespaceAware(true);,             try {,                 reader = spFactory.newSAXParser().getXMLReader();,             } catch (ParserConfigurationException ex) {,                 throw new TransformerException(ex);,             } catch (SAXException ex) {,                 throw new TransformerException(ex);,             },         },         reader.setEntityResolver(this);,         source.setXMLReader(reader);,     }, ,     /**,      * Find a ResourceLocation instance for the given publicId.,      *,      * @param publicId the publicId of the Resource for which local information,      *        is required.,      * @return a ResourceLocation instance with information on the local location,      *         of the Resource or null if no such information is available.,      */,     private ResourceLocation findMatchingEntry(String publicId) {,         for (ResourceLocation element : getElements()) {,             if (element.getPublicId().equals(publicId)) {,                 return element;,             },         },         return null;,     }, ,     /**,      * Utility method to remove trailing fragment from a URI.,      * For example,,      * <code>http://java.sun.com/index.html#chapter1</code>,      * would return <code>http://java.sun.com/index.html</code>.,      *,      * @param uri The URI to process.  It may or may not contain a,      *            fragment.,      * @return The URI sans fragment.,      */,     private String removeFragment(String uri) {,         String result = uri;,         int hashPos = uri.indexOf("#");,         if (hashPos >= 0) {,             result = uri.substring(0, hashPos);,         },         return result;,     }, ,     /**,      * Utility method to lookup a ResourceLocation in the filesystem.,      *,      * @return An InputSource for reading the file, or <code>null</code>,      *     if the file does not exist or is not readable.,      */,     private InputSource filesystemLookup(ResourceLocation matchingEntry) {, ,         String uri = matchingEntry.getLocation();,         // the following line seems to be necessary on Windows under JDK 1.2,         uri = uri.replace(File.separatorChar, '/');,         URL baseURL = null;, ,         //,         // The ResourceLocation may specify a relative path for its,         // location attribute.  This is resolved using the appropriate,         // base.,         //,         if (matchingEntry.getBase() != null) {,             baseURL = matchingEntry.getBase();,         } else {,             try {,                 baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());,             } catch (MalformedURLException ex) {,                 throw new BuildException("Project basedir cannot be converted to a URL");,             },         }, ,         InputSource source = null;,         URL url = null;,         try {,             url = new URL(baseURL, uri);,         } catch (MalformedURLException ex) {,             // this processing is useful under Windows when the location of the DTD,             // has been given as an absolute path,             // see Bugzilla Report 23913,             File testFile = new File(uri);,             if (testFile.exists() && testFile.canRead()) {,                 log("uri : '",                     + uri + "' matches a readable file", Project.MSG_DEBUG);,                 try {,                     url = FILE_UTILS.getFileURL(testFile);,                 } catch (MalformedURLException ex1) {,                     throw new BuildException(,                         "could not find an URL for :" + testFile.getAbsolutePath());,                 },             } else {,                 log("uri : '",                     + uri + "' does not match a readable file", Project.MSG_DEBUG);, ,             },         }, ,         if (url != null && url.getProtocol().equals("file")) {,             String fileName = FILE_UTILS.fromURI(url.toString());,             if (fileName != null) {,                 log("fileName " + fileName, Project.MSG_DEBUG);,                 File resFile = new File(fileName);,                 if (resFile.exists() && resFile.canRead()) {,                     try {,                         source = new InputSource(new FileInputStream(resFile));,                         String sysid = JAXPUtils.getSystemId(resFile);,                         source.setSystemId(sysid);,                         log("catalog entry matched a readable file: '",                             + sysid + "'", Project.MSG_DEBUG);,                     } catch (IOException ex) {,                         // ignore,                     },                 },             },         },         return source;,     }, ,     /**,      * Utility method to lookup a ResourceLocation in the classpath.,      *,      * @return An InputSource for reading the resource, or <code>null</code>,      *    if the resource does not exist in the classpath or is not readable.,      */,     private InputSource classpathLookup(ResourceLocation matchingEntry) {, ,         InputSource source = null;, ,         AntClassLoader loader = null;,         Path cp = classpath;,         if (cp != null) {,             cp = classpath.concatSystemClasspath("ignore");,         } else {,             cp = (new Path(getProject())).concatSystemClasspath("last");,         },         loader = getProject().createClassLoader(cp);, ,         //,         // for classpath lookup we ignore the base directory,         //,         InputStream is,             = loader.getResourceAsStream(matchingEntry.getLocation());, ,         if (is != null) {,             source = new InputSource(is);,             URL entryURL = loader.getResource(matchingEntry.getLocation());,             String sysid = entryURL.toExternalForm();,             source.setSystemId(sysid);,             log("catalog entry matched a resource in the classpath: '",                 + sysid + "'", Project.MSG_DEBUG);,         }, ,         return source;,     }, ,     /**,      * Utility method to lookup a ResourceLocation in URL-space.,      *,      * @return An InputSource for reading the resource, or <code>null</code>,      *    if the resource does not identify a valid URL or is not readable.,      */,     private InputSource urlLookup(ResourceLocation matchingEntry) {, ,         String uri = matchingEntry.getLocation();,         URL baseURL = null;, ,         //,         // The ResourceLocation may specify a relative url for its,         // location attribute.  This is resolved using the appropriate,         // base.,         //,         if (matchingEntry.getBase() != null) {,             baseURL = matchingEntry.getBase();,         } else {,             try {,                 baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());,             } catch (MalformedURLException ex) {,                 throw new BuildException("Project basedir cannot be converted to a URL");,             },         }, ,         InputSource source = null;,         URL url = null;, ,         try {,             url = new URL(baseURL, uri);,         } catch (MalformedURLException ex) {,             // ignore,         }, ,         if (url != null) {,             try {,                 InputStream is = null;,                 URLConnection conn = url.openConnection();,                 if (conn != null) {,                     conn.setUseCaches(false);,                     is = conn.getInputStream();,                 },                 if (is != null) {,                     source = new InputSource(is);,                     String sysid = url.toExternalForm();,                     source.setSystemId(sysid);,                     log("catalog entry matched as a URL: '",                         + sysid + "'", Project.MSG_DEBUG);,                 },             } catch (IOException ex) {,                 // ignore,             },         }, ,         return source;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/types/XMLCatalogTest.java,testCircularReferenceCheck,178-178,[            InputSource result = catalog.resolveEntity("PUBLIC ID ONE",],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/XMLCatalogTest.java,testEmptyCatalog,99-99,[        } catch (Exception e) {],,
STYLE,UC_USELESS_OBJECT,org/apache/tools/ant/types/XMLCatalogTest.java,testNonExistentEntry,124-124,[        ResourceLocation dtd = new ResourceLocation();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/mappers/CutDirsMapper.java,mapFileName,72-72,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/mappers/FilterMapper.java,mapFileName,77-77,[                return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/ScriptMapper.java,mapFileName,86-86,[            return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/optional/ScriptMapper.java,addMappedName,63-63,[        files.add(mapping);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/optional/ScriptMapper.java,mapFileName,85-85,[        if (files.size() == 0) {],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/tools/ant/types/optional/depend/ClassfileSet.java,clone,164-165,[        return new ClassfileSet(isReference(),             ? (ClassfileSet) (getRef(getProject())) : this);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/optional/depend/DependScanner.java,,88-88,[            files[i] = (String) included.elementAt(i);],,,107-107,[        included = new Vector<String>();],,,142-142,[                included.addElement(filename);],,,95-95,[        if (included == null) {],,,98-98,[        return included.size();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/depend/DependScanner.java,getExcludedDirectories,158-158,[        return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/depend/DependScanner.java,getExcludedFiles,166-166,[        return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/depend/DependScanner.java,getNotIncludedDirectories,190-190,[        return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/depend/DependScanner.java,getNotIncludedFiles,198-198,[        return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/optional/depend/DependScanner.java,getIncludedFiles,88-88,[            files[i] = (String) included.elementAt(i);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/optional/depend/DependScanner.java,scan,124-124,[        for (Enumeration<String> e = rootClasses.elements(); e.hasMoreElements();) {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/types/resources/AbstractClasspathResource.java,isExists,161-161,[            FileUtils.close(is);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/types/resources/AbstractClasspathResource.java,,179-190,[            : new FilterInputStream(openInputStream(classLoader.getLoader())) {,                     public void close() throws IOException {,                         FileUtils.close(in);,                         classLoader.cleanup();,                     },                     protected void finalize() throws Throwable {,                         try {,                             close();,                         } finally {,                             super.finalize();,                         },                     }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/resources/AbstractResourceCollectionWrapper.java,,35-206,[public abstract class AbstractResourceCollectionWrapper,     extends DataType implements ResourceCollection, Cloneable {,     private static final String ONE_NESTED_MESSAGE,         = " expects exactly one nested resource collection.";, ,     private ResourceCollection rc;,     private boolean cache = true;, ,     /**,      * Set whether to cache collections.,      * @param b boolean cache flag.,      */,     public synchronized void setCache(boolean b) {,         cache = b;,     }, ,     /**,      * Learn whether to cache collections. Default is <code>true</code>.,      * @return boolean cache flag.,      */,     public synchronized boolean isCache() {,         return cache;,     }, ,     /**,      * Add a ResourceCollection to the container.,      * @param c the ResourceCollection to add.,      * @throws BuildException on error.,      */,     public synchronized void add(ResourceCollection c) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (c == null) {,             return;,         },         if (rc != null) {,             throw oneNested();,         },         rc = c;,         if (Project.getProject(rc) == null) {,             Project p = getProject();,             if (p != null) {,                 p.setProjectReference(rc);,             },         },         setChecked(false);,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return an Iterator of Resources.,      */,     public final synchronized Iterator<Resource> iterator() {,         if (isReference()) {,             return ((AbstractResourceCollectionWrapper) getCheckedRef()).iterator();,         },         dieOnCircularReference();,         return new FailFast(this, createIterator());,     }, ,     /**,      * Do create an iterator on the resource collection. The creation,      * of the iterator is allowed to not be thread safe whereas the iterator,      * itself should. The returned iterator will be wrapped into the FailFast,      * one.,      *,      * @return the iterator on the resource collection,      */,     protected abstract Iterator<Resource> createIterator();, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return number of elements as int.,      */,     public synchronized int size() {,         if (isReference()) {,             return ((AbstractResourceCollectionWrapper) getCheckedRef()).size();,         },         dieOnCircularReference();,         return getSize();,     }, ,     /**,      * Do compute the size of the resource collection. The implementation of,      * this function is allowed to be not thread safe.,      *,      * @return size of resource collection.,      */,     protected abstract int getSize();, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return whether this is a filesystem-only resource collection.,      */,     public synchronized boolean isFilesystemOnly() {,         if (isReference()) {,             return ((BaseResourceCollectionContainer) getCheckedRef()).isFilesystemOnly();,         },         dieOnCircularReference();, ,         if (rc == null || rc.isFilesystemOnly()) {,             return true;,         },         /* now check each Resource in case the child only,            lets through files from any children IT may have: */,         for (Resource r : this) {,             if (r.as(FileProvider.class) == null) {,                 return false;,             },         },         return true;,     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (rc instanceof DataType) {,                 pushAndInvokeCircularReferenceCheck((DataType) rc, stk, p);,             },             setChecked(true);,         },     }, ,     /**,      * Get the nested ResourceCollection.,      * @return a ResourceCollection.,      * @throws BuildException if no nested ResourceCollection has been provided.,      */,     protected final synchronized ResourceCollection getResourceCollection() {,         dieOnCircularReference();,         if (rc == null) {,             throw oneNested();,         },         return rc;,     }, ,     /**,      * Format this BaseResourceCollectionWrapper as a String.,      * @return a descriptive <code>String</code>.,      */,     public synchronized String toString() {,         if (isReference()) {,             return getCheckedRef().toString();,         },         if (getSize() == 0) {,             return "";,         },         StringBuilder sb = new StringBuilder();,         for (Resource resource : this) {,             if (sb.length() > 0) {,                 sb.append(File.pathSeparatorChar);,             },             sb.append(resource);,         },         return sb.toString();,     }, ,     private BuildException oneNested() {,         return new BuildException(super.toString() + ONE_NESTED_MESSAGE);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/ArchiveResource.java,<clinit>,35-35,[        = Resource.getMagicNumber("null archive".getBytes());],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/resources/Archives.java,,42-192,[public class Archives extends DataType,     implements ResourceCollection, Cloneable {, ,     private Union zips = new Union();,     private Union tars = new Union();, ,     /**,      * Wrapper to identify nested resource collections as ZIP,      * archives.,      */,     public Union createZips() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         return zips;,     }, ,     /**,      * Wrapper to identify nested resource collections as ZIP,      * archives.,      */,     public Union createTars() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         return tars;,     }, ,     /**,      * Sums the sizes of nested archives.,      */,     public int size() {,         if (isReference()) {,             return ((Archives) getCheckedRef()).size();,         },         dieOnCircularReference();,         int total = 0;,         for (final Iterator<ArchiveFileSet> i = grabArchives(); i.hasNext();) {,             total += i.next().size();,         },         return total;,     }, ,     /**,      * Merges the nested collections.,      */,     public Iterator<Resource> iterator() {,         if (isReference()) {,             return ((Archives) getCheckedRef()).iterator();,         },         dieOnCircularReference();,         final List<Resource> l = new LinkedList<Resource>();,         for (final Iterator<ArchiveFileSet> i = grabArchives(); i.hasNext();) {,             l.addAll(CollectionUtils,                      .asCollection(i.next().iterator()));,         },         return l.iterator();,     }, ,     /**,      * @return false,      */,     public boolean isFilesystemOnly() {,         if (isReference()) {,             return ((Archives) getCheckedRef()).isFilesystemOnly();,         },         dieOnCircularReference();,         return false;,     }, ,     /**,      * Overrides the base version.,      * @param r the Reference to set.,      */,     @Override,     public void setRefid(final Reference r) {,         if (zips.getResourceCollections().size() > 0,             || tars.getResourceCollections().size() > 0) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Implement clone.  The nested resource collections are cloned as,      * well.,      * @return a cloned instance.,      */,     @Override,     public Object clone() {,         try {,             final Archives a = (Archives) super.clone();,             a.zips = (Union) zips.clone();,             a.tars = (Union) tars.clone();,             return a;,         } catch (final CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     // TODO this is a pretty expensive operation and so the result,     // should be cached.,     /**,      * Turns all nested resources into corresponding ArchiveFileSets,      * and returns an iterator over the collected archives.,      */,     protected Iterator<ArchiveFileSet> grabArchives() {,         final List<ArchiveFileSet> l = new LinkedList<ArchiveFileSet>();,         for (final Resource r : zips) {,             l.add(configureArchive(new ZipFileSet(), r));,         },         for (final Resource r : tars) {,             l.add(configureArchive(new TarFileSet(), r));,         },         return l.iterator();,     }, ,     /**,      * Configures the archivefileset based on this type's settings,,      * set the source.,      */,     protected ArchiveFileSet configureArchive(final ArchiveFileSet afs,,                                               final Resource src) {,         afs.setProject(getProject());,         afs.setSrcResource(src);,         return afs;,     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     @Override,     protected synchronized void dieOnCircularReference(final Stack<Object> stk, final Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             pushAndInvokeCircularReferenceCheck(zips, stk, p);,             pushAndInvokeCircularReferenceCheck(tars, stk, p);,             setChecked(true);,         },     }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/resources/BaseResourceCollectionContainer.java,,40-265,[    private List<ResourceCollection> rc = new ArrayList<ResourceCollection>();,     private Collection<Resource> coll = null;,     private boolean cache = true;, ,     /**,      * Create a new BaseResourceCollectionContainer.,      */,     public BaseResourceCollectionContainer() {,         // TODO Auto-generated constructor stub,     }, ,     /**,      * Create a new BaseResourceCollectionContainer.,      * @since Ant 1.8,      */,     public BaseResourceCollectionContainer(Project project) {,         setProject(project);,     }, ,     /**,      * Set whether to cache collections.,      * @param b boolean cache flag.,      */,     public synchronized void setCache(boolean b) {,         cache = b;,     }, ,     /**,      * Learn whether to cache collections. Default is <code>true</code>.,      * @return boolean cache flag.,      */,     public synchronized boolean isCache() {,         return cache;,     }, ,     /**,      * Clear the container.,      * @throws BuildException on error.,      */,     public synchronized void clear() throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         rc.clear();,         FailFast.invalidate(this);,         coll = null;,         setChecked(false);,     }, ,     /**,      * Add a ResourceCollection to the container.,      * @param c the ResourceCollection to add.,      * @throws BuildException on error.,      */,     public synchronized void add(ResourceCollection c) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (c == null) {,             return;,         },         if (Project.getProject(c) == null) {,             Project p = getProject();,             if (p != null) {,                 p.setProjectReference(c);,             },         },         rc.add(c);,         FailFast.invalidate(this);,         coll = null;,         setChecked(false);,     }, ,     /**,      * Add the Collection of ResourceCollections to the container.,      * @param c the Collection whose elements to add.,      * @throws BuildException on error.,      */,     public synchronized void addAll(Collection<? extends ResourceCollection> c) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         try {,             for (ResourceCollection resourceCollection : c) {,                 add(resourceCollection);,             },         } catch (ClassCastException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Fulfill the ResourceCollection contract. The Iterator returned,      * will throw ConcurrentModificationExceptions if ResourceCollections,      * are added to this container while the Iterator is in use.,      * @return a "fail-fast" Iterator.,      */,     public final synchronized Iterator<Resource> iterator() {,         if (isReference()) {,             return ((BaseResourceCollectionContainer) getCheckedRef()).iterator();,         },         dieOnCircularReference();,         return new FailFast(this, cacheCollection().iterator());,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return number of elements as int.,      */,     public synchronized int size() {,         if (isReference()) {,             return getCheckedRef(BaseResourceCollectionContainer.class, getDataTypeName()).size();,         },         dieOnCircularReference();,         return cacheCollection().size();,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return whether this is a filesystem-only resource collection.,      */,     public synchronized boolean isFilesystemOnly() {,         if (isReference()) {,             return ((BaseResourceCollectionContainer) getCheckedRef()).isFilesystemOnly();,         },         dieOnCircularReference();,         //first the easy way, if all children are filesystem-only, return true:,         boolean goEarly = true;,         for (Iterator<ResourceCollection> i = rc.iterator(); goEarly && i.hasNext();) {,             goEarly = i.next().isFilesystemOnly();,         },         if (goEarly) {,             return true;,         },         /* now check each Resource in case the child only,            lets through files from any children IT may have: */,         for (Resource r : cacheCollection()) {,             if (r.as(FileProvider.class) == null) {,                 return false;,             },         },         return true;,     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             for (ResourceCollection resourceCollection : rc) {,                 if (resourceCollection instanceof DataType) {,                     pushAndInvokeCircularReferenceCheck((DataType) resourceCollection, stk, p);,                 },             },             setChecked(true);,         },     }, ,     /**,      * Get the nested ResourceCollections.,      * @return List.,      */,     public final synchronized List<ResourceCollection> getResourceCollections() {,         dieOnCircularReference();,         return Collections.unmodifiableList(rc);,     }, ,     /**,      * Template method for subclasses to return a Collection object of Resources.,      * @return Collection.,      */,     protected abstract Collection<Resource> getCollection();, ,     /**,      * Implement clone.  The set of nested resource,      * collections is shallowly cloned.,      * @return a cloned instance.,      */,     public Object clone() {,         try {,             BaseResourceCollectionContainer c,                 = (BaseResourceCollectionContainer) super.clone();,             c.rc = new ArrayList<ResourceCollection>(rc);,             c.coll = null;,             return c;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Format this BaseResourceCollectionContainer as a String.,      * @return a descriptive <code>String</code>.,      */,     public synchronized String toString() {,         if (isReference()) {,             return getCheckedRef().toString();,         },         if (cacheCollection().size() == 0) {,             return "";,         },         StringBuilder sb = new StringBuilder();,         for (Resource resource : coll) {,             if (sb.length() > 0) {,                 sb.append(File.pathSeparatorChar);,             },             sb.append(resource);,         },         return sb.toString();,     }, ,     private synchronized Collection<Resource> cacheCollection() {,         if (coll == null || !isCache()) {,             coll = getCollection();,         },         return coll;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/FileResource.java,<clinit>,43-43,[        = Resource.getMagicNumber("null file".getBytes());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/resources/FileResource.java,getOutputStream,251-251,[                f.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/resources/FileResource.java,getOutputStream,256-256,[                p.mkdirs();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/types/resources/LazyResourceCollectionTest.java,testCaching,139-139,[        StringResource r = (StringResource) it1.next();],,testCaching,144-144,[        r = (StringResource) it2.next();],,testCaching,150-150,[        r = (StringResource) it2.next();],,testCaching,155-155,[        r = (StringResource) it1.next();],,testCaching,161-161,[        r = (StringResource) it2.next();],,testCaching,166-166,[        r = (StringResource) it1.next();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/types/resources/LazyResourceCollectionTest.java,testLazyLoading,90-90,[        StringResource r = (StringResource) it.next();],,testLazyLoading,96-96,[        r = (StringResource) it.next();],,testLazyLoading,102-102,[        r = (StringResource) it.next();],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/tools/ant/types/resources/LazyResourceCollectionTest.java,next,65-69,[            if (cursor < 3) {,                 cursor++;,                 return new StringResource("r" + cursor);,             },             return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/resources/LazyResourceCollectionTest.java,,57-73,[    private class StringResourceIterator implements Iterator {,         int cursor = 0;, ,         public void remove() {,             throw new UnsupportedOperationException();,         }, ,         public Object next() {,             if (cursor < 3) {,                 cursor++;,                 return new StringResource("r" + cursor);,             },             return null;,         }, ,         public boolean hasNext() {,             return cursor < 3;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/tools/ant/types/Resource.java,equals,287-291,[        if (isReference()) {,             return getCheckedRef().equals(other);,         },         return other != null && other.getClass().equals(getClass()),             && compareTo((Resource) other) == 0;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,118-118,[        this.cache = cache;],,,218-218,[        if (cachedColl == null || !cache) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,85-85,[        cachedColl = null;],,,218-218,[        if (cachedColl == null || !cache) {],,,221-221,[        return cachedColl;],,,219-219,[            cachedColl = getCollection();],,,66-66,[        cachedColl = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,79-79,[        if (mapper != null) {],,,84-84,[        mapper = new Mapper(getProject());],,,86-86,[        return mapper;],,,160-160,[        if (nested != null || mapper != null) {],,,199-199,[            if (mapper != null) {],,,200-200,[                pushAndInvokeCircularReferenceCheck(mapper, stk, p);],,,226-226,[        FileNameMapper m =],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,160-160,[        if (nested != null || mapper != null) {],,,210-210,[        if (nested == null) {],,,202-202,[            if (nested instanceof DataType) {],,,203-203,[                pushAndInvokeCircularReferenceCheck((DataType) nested, stk, p);],,,60-60,[        if (nested != null) {],,,67-67,[        nested = c;],,,228-228,[        for (Resource r : nested) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,42-264,[public class MappedResourceCollection,         extends DataType implements ResourceCollection, Cloneable {, ,     private ResourceCollection nested = null;,     private Mapper mapper = null;,     private boolean enableMultipleMappings = false;,     private boolean cache = false;,     private Collection<Resource> cachedColl = null;, ,     /**,      * Adds the required nested ResourceCollection.,      * @param c the ResourceCollection to add.,      * @throws BuildException on error.,      */,     public synchronized void add(ResourceCollection c) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (nested != null) {,             throw new BuildException("Only one resource collection can be",                                      + " nested into mappedresources",,                                      getLocation());,         },         setChecked(false);,         cachedColl = null;,         nested = c;,     }, ,     /**,      * Define the mapper to map source to destination files.,      * @return a mapper to be configured.,      * @exception BuildException if more than one mapper is defined.,      */,     public Mapper createMapper() throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (mapper != null) {,             throw new BuildException("Cannot define more than one mapper",,                                      getLocation());,         },         setChecked(false);,         mapper = new Mapper(getProject());,         cachedColl = null;,         return mapper;,     }, ,     /**,      * Add a nested filenamemapper.,      * @param fileNameMapper the mapper to add.,      * @since Ant 1.6.3,      */,     public void add(FileNameMapper fileNameMapper) {,         createMapper().add(fileNameMapper);,     }, ,     /**,      * Set method of handling mappers that return multiple,      * mappings for a given source path.,      * @param enableMultipleMappings If true the type will,      *        use all the mappings for a given source path, if,      *        false, only the first mapped name is,      *        processed.,      *        By default, this setting is false to provide backward,      *        compatibility with earlier releases.,      * @since Ant 1.8.1,      */,     public void setEnableMultipleMappings(boolean enableMultipleMappings) {,         this.enableMultipleMappings = enableMultipleMappings;,     }, ,     /**,      * Set whether to cache collections.,      * @since Ant 1.8.1,      */,     public void setCache(boolean cache) {,         this.cache = cache;,     }, ,     /**,      * {@inheritDoc},      */,     public boolean isFilesystemOnly() {,         if (isReference()) {,             return ((MappedResourceCollection) getCheckedRef()),                 .isFilesystemOnly();,         },         checkInitialized();,         return false;,     }, ,     /**,      * {@inheritDoc},      */,     public int size() {,         if (isReference()) {,             return ((MappedResourceCollection) getCheckedRef()).size();,         },         checkInitialized();,         return cacheCollection().size();,     }, ,     /**,      * {@inheritDoc},      */,     public Iterator<Resource> iterator() {,         if (isReference()) {,             return ((MappedResourceCollection) getCheckedRef()).iterator();,         },         checkInitialized();,         return cacheCollection().iterator();,     }, ,     /**,      * Overrides the base version.,      * @param r the Reference to set.,      */,     public void setRefid(Reference r) {,         if (nested != null || mapper != null) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Implement clone.  The nested resource collection and mapper are copied.,      * @return a cloned instance.,      */,     public Object clone() {,         try {,             MappedResourceCollection c =,                 (MappedResourceCollection) super.clone();,             c.nested = nested;,             c.mapper = mapper;,             c.cachedColl = null;,             return c;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             checkInitialized();,             if (mapper != null) {,                 pushAndInvokeCircularReferenceCheck(mapper, stk, p);,             },             if (nested instanceof DataType) {,                 pushAndInvokeCircularReferenceCheck((DataType) nested, stk, p);,             },             setChecked(true);,         },     }, ,     private void checkInitialized() {,         if (nested == null) {,             throw new BuildException("A nested resource collection element is",                                      + " required", getLocation());,         },         dieOnCircularReference();,     }, ,     private synchronized Collection<Resource> cacheCollection() {,         if (cachedColl == null || !cache) {,             cachedColl = getCollection();,         },         return cachedColl;,     }, ,     private Collection<Resource> getCollection() {,         Collection<Resource> collected = new ArrayList<Resource>();,         FileNameMapper m =,             mapper != null ? mapper.getImplementation() : new IdentityMapper();,         for (Resource r : nested) {,             if (enableMultipleMappings) {,                 String[] n = m.mapFileName(r.getName());,                 if (n != null) {,                     for (int i = 0; i < n.length; i++) {,                         collected.add(new MappedResource(r,,                                                          new MergingMapper(n[i])),                                       );,                     },                 },             } else {,                 collected.add(new MappedResource(r, m));,             },         },         return collected;,     }, ,     /**,      * Format this resource collection as a String.,      * @return a descriptive <code>String</code>.,      */,     public String toString() {,         if (isReference()) {,             return getCheckedRef().toString();,         },         Iterator<Resource> i = iterator();,         if (!i.hasNext()) {,             return "";,         },         StringBuffer sb = new StringBuffer();,         while (i.hasNext()) {,             if (sb.length() > 0) {,                 sb.append(File.pathSeparatorChar);,             },             sb.append(i.next());,         },         return sb.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/types/resources/MultiRootFileSetTest.java,,41-56,[        return new MultiRootFileSet() {,             // overriding so set/getDir works as expected by the base test class,             private File dir;,             public void setDir(File dir) {,                 if (isReference()) {,                     throw tooManyAttributes();,                 },                 this.dir = dir;,             }, ,             public synchronized File getDir(Project p) {,                 if (isReference()) {,                     return getRef(p).getDir(p);,                 },                 dieOnCircularReference();,                 return dir;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/PropertyResource.java,<clinit>,39-39,[        = Resource.getMagicNumber("PropertyResource".getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/PropertyResource.java,getInputStream,159-159,[        return o == null ? UNSET : new ByteArrayInputStream(String.valueOf(o).getBytes());],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/tools/ant/types/resources/ResourceDecorator.java,hashCode,185-185,[        return (getClass().hashCode() << 4) | getResource().hashCode();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/ResourceList.java,read,190-190,[                input = new InputStreamReader(bis);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/types/resources/ResourceList.java,read,198-198,[            BufferedReader reader = new BufferedReader(crh.getAssembledReader());],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/Resources.java,,85-85,[                if (cache) {],,,139-139,[        cache = b;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/StringResource.java,<clinit>,40-40,[        = Resource.getMagicNumber("StringResource".getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/StringResource.java,getInputStream,190-190,[                ? content.getBytes() : content.getBytes(encoding));],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/tools/ant/types/Resource.java,equals,287-291,[        if (isReference()) {,             return getCheckedRef().equals(other);,         },         return other != null && other.getClass().equals(getClass()),             && compareTo((Resource) other) == 0;],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/tools/ant/types/resources/StringResource.java,setRefid,216-216,[        if (encoding != DEFAULT_ENCODING) {],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/tools/ant/types/resources/StringResource.java,hashCode,157-160,[        if (isReference()) {,             return getCheckedRef().hashCode();,         },         return super.hashCode() * STRING_MAGIC;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/StringResource.java,,216-216,[        if (encoding != DEFAULT_ENCODING) {],,,131-131,[        encoding = s;],,,139-139,[        return encoding;],,,189-189,[        return new ByteArrayInputStream(encoding == null],,,190-190,[                ? content.getBytes() : content.getBytes(encoding));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/StringResource.java,close,256-256,[                    ? baos.toString() : baos.toString(encoding);],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/types/resources/Tokens.java,dieOnCircularReference,130-130,[                pushAndInvokeCircularReferenceCheck((DataType) tokenizer, stk,],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/Tokens.java,getCollection,66-66,[                rdr = new InputStreamReader(cat);],,
PERFORMANCE,DMI_BLOCKING_METHODS_ON_URL,org/apache/tools/ant/types/resources/URLResource.java,equals,322-322,[            : getURL().equals(otheru.getURL());],,
PERFORMANCE,DMI_BLOCKING_METHODS_ON_URL,org/apache/tools/ant/types/resources/URLResource.java,hashCode,333-333,[        return MAGIC * ((getURL() == null) ? NULL_URL : getURL().hashCode());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/URLResource.java,<clinit>,43-43,[        = Resource.getMagicNumber("null URL".getBytes());],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/resources/ZipResource.java,getExtraFields,184-184,[        return extras;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/types/resources/ZipResource.java,,140-151,[        return new FilterInputStream(z.getInputStream(ze)) {,             public void close() throws IOException {,                 FileUtils.close(in);,                 z.close();,             },             protected void finalize() throws Throwable {,                 try {,                     close();,                 } finally {,                     super.finalize();,                 },             }],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Content.java,,30-66,[public class Content extends ResourceComparator {, ,     private boolean binary = true;, ,     /**,      * Set binary mode for this Content ResourceComparator. If this,      * attribute is set to false, Resource content will be compared,      * ignoring platform line-ending conventions.,      * Default is <code>true</code>.,      * @param b whether to compare content in binary mode.,      */,     public void setBinary(boolean b) {,         binary = b;,     }, ,     /**,      * Learn whether this Content ResourceComparator is operating in binary mode.,      * @return boolean binary flag.,      */,     public boolean isBinary() {,         return binary;,     }, ,     /**,      * Compare two Resources by content.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      * @throws BuildException if I/O errors occur.,      * @see org.apache.tools.ant.util.ResourceUtils#compareContent(Resource, Resource, boolean).,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         try {,             return ResourceUtils.compareContent(foo, bar, !binary);,         } catch (IOException e) {,             throw new BuildException(e);],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Date.java,,26-41,[public class Date extends ResourceComparator {,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         long diff = foo.getLastModified() - bar.getLastModified();,         if (diff > 0) {,             return +1;,         } else if (diff < 0) {,             return -1;,         } else {,             return 0;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/comparators/DelegatedResourceComparator.java,,71-71,[        List<ResourceComparator> ov = ((DelegatedResourceComparator) o).resourceComparators;],,,114-114,[            if (!(resourceComparators == null || resourceComparators.isEmpty())) {],,,115-115,[                for (ResourceComparator resourceComparator : resourceComparators) {],,,72-72,[        return resourceComparators == null ? ov == null : resourceComparators.equals(ov);],,,89-89,[        if (resourceComparators == null || resourceComparators.isEmpty()) {],,,93-93,[        for (Iterator<ResourceComparator> i = resourceComparators.iterator(); result == 0 && i.hasNext();) {],,,50-50,[        resourceComparators = (resourceComparators == null) ? new Vector<ResourceComparator>() : resourceComparators;],,,51-51,[        resourceComparators.add(c);],,,83-83,[        return resourceComparators == null ? 0 : resourceComparators.hashCode();],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/DelegatedResourceComparator.java,,35-124,[public class DelegatedResourceComparator extends ResourceComparator {, ,     private List<ResourceComparator> resourceComparators = null;, ,     /**,      * Add a delegate ResourceComparator.,      * @param c the next delegate ResourceComparator.,      */,     public synchronized void add(ResourceComparator c) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (c == null) {,             return;,         },         resourceComparators = (resourceComparators == null) ? new Vector<ResourceComparator>() : resourceComparators;,         resourceComparators.add(c);,         setChecked(false);,     }, ,     /**,      * Equality method based on the vector of resources,,      * or if a reference, the referredto object.,      * @param o the object to check against.,      * @return true if there is equality.,      */,     public synchronized boolean equals(Object o) {,         if (o == this) {,             return true;,         },         if (isReference()) {,             return getCheckedRef().equals(o);,         },         if (!(o instanceof DelegatedResourceComparator)) {,             return false;,         },         List<ResourceComparator> ov = ((DelegatedResourceComparator) o).resourceComparators;,         return resourceComparators == null ? ov == null : resourceComparators.equals(ov);,     }, ,     /**,      * Hashcode based on the rules for equality.,      * @return a hashcode.,      */,     public synchronized int hashCode() {,         if (isReference()) {,             return getCheckedRef().hashCode();,         },         return resourceComparators == null ? 0 : resourceComparators.hashCode();,     }, ,     /** {@inheritDoc} */,     protected synchronized int resourceCompare(Resource foo, Resource bar) {,         //if no nested, natural order:,         if (resourceComparators == null || resourceComparators.isEmpty()) {,             return foo.compareTo(bar);,         },         int result = 0;,         for (Iterator<ResourceComparator> i = resourceComparators.iterator(); result == 0 && i.hasNext();) {,             result = i.next().resourceCompare(foo, bar);,         },         return result;,     }, ,     /**,      * Overrides the version from DataType to recurse on nested ResourceSelector, s.,      * @param stk the Stack of references.,      * @param p   the Project to resolve against.,      * @throws BuildException on error.,      */,     protected void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (!(resourceComparators == null || resourceComparators.isEmpty())) {,                 for (ResourceComparator resourceComparator : resourceComparators) {,                     if (resourceComparator instanceof DataType) {,                         pushAndInvokeCircularReferenceCheck((DataType) resourceComparator, stk,,                                                             p);,                     },                 },             },             setChecked(true);,         },     }],,
CORRECTNESS,SIO_SUPERFLUOUS_INSTANCEOF,org/apache/tools/ant/types/resources/comparators/DelegatedResourceComparator.java,dieOnCircularReference,116-116,[                    if (resourceComparator instanceof DataType) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Exists.java,,26-40,[public class Exists extends ResourceComparator {, ,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         boolean f = foo.isExists();,         if (f == bar.isExists()) {,             return 0;,         },         return f ? 1 : -1;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/FileSystem.java,,30-57,[public class FileSystem extends ResourceComparator {,     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();, ,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      * @throws ClassCastException if either resource is not an instance of FileResource.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         FileProvider fooFP = foo.as(FileProvider.class);,         if (fooFP == null) {,             throw new ClassCastException(foo.getClass(),                                          + " doesn't provide files");,         },         File foofile = fooFP.getFile();,         FileProvider barFP = bar.as(FileProvider.class);,         if (barFP == null) {,             throw new ClassCastException(bar.getClass(),                                          + " doesn't provide files");,         },         File barfile = barFP.getFile();,         return foofile.equals(barfile) ? 0,             : FILE_UTILS.isLeadingPath(foofile, barfile) ? -1,             : FILE_UTILS.normalize(foofile.getAbsolutePath()).compareTo(,                 FILE_UTILS.normalize(barfile.getAbsolutePath()));],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Name.java,,26-35,[public class Name extends ResourceComparator {,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         return foo.getName().compareTo(bar.getName());],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/tools/ant/types/resources/comparators/Reverse.java,dieOnCircularReference,84-84,[            if (nested instanceof DataType) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Reverse.java,,41-90,[    public Reverse() {,     }, ,     /**,      * Construct a new Reverse, supplying the ResourceComparator to be reversed.,      * @param c the ResourceComparator to reverse.,      */,     public Reverse(ResourceComparator c) {,         add(c);,     }, ,     /**,      * Add the ResourceComparator to reverse.,      * @param c the ResourceComparator to add.,      */,     public void add(ResourceComparator c) {,         if (nested != null) {,             throw new BuildException(ONE_NESTED);,         },         nested = c;,         setChecked(false);,     }, ,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is greater than, equal to, or less than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         return -1 * (nested == null,             ? foo.compareTo(bar) : nested.compare(foo, bar));,     }, ,     protected void dieOnCircularReference(Stack<Object> stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (nested instanceof DataType) {,                 pushAndInvokeCircularReferenceCheck((DataType) nested, stk,,                                                     p);,             },             setChecked(true);,         },     }],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Size.java,,26-36,[public class Size extends ResourceComparator {,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         long diff = foo.getSize() - bar.getSize();,         return diff > 0 ? 1 : (diff == 0 ? 0 : -1);],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Type.java,,27-41,[public class Type extends ResourceComparator {, ,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         boolean f = foo.isDirectory();,         if (f == bar.isDirectory()) {,             return 0;,         },         return f ? 1 : -1;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/types/resources/selectors/Date.java,setMillis,54-54,[        millis = new Long(m);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/resources/selectors/Type.java,getValues,69-69,[            return VALUES;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/selectors/AbstractSelectorContainer.java,,36-350,[public abstract class AbstractSelectorContainer extends DataType,     implements Cloneable, SelectorContainer {, ,     private Vector<FileSelector> selectorsList = new Vector<FileSelector>();, ,     /**,      * Indicates whether there are any selectors here.,      * @return true if there are selectors,      */,     public boolean hasSelectors() {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef()).hasSelectors();,         },         dieOnCircularReference();,         return !(selectorsList.isEmpty());,     }, ,     /**,      * Gives the count of the number of selectors in this container,      * @return the number of selectors,      */,     public int selectorCount() {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef()).selectorCount();,         },         dieOnCircularReference();,         return selectorsList.size();,     }, ,     /**,      * Returns the set of selectors as an array.,      * @param p the current project,      * @return an array of selectors,      */,     public FileSelector[] getSelectors(Project p) {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef(p)),                 .getSelectors(p);,         },         dieOnCircularReference(p);,         FileSelector[] result = new FileSelector[selectorsList.size()];,         selectorsList.copyInto(result);,         return result;,     }, ,     /**,      * Returns an enumerator for accessing the set of selectors.,      * @return an enumerator for the selectors,      */,     public Enumeration<FileSelector> selectorElements() {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef()),                 .selectorElements();,         },         dieOnCircularReference();,         return selectorsList.elements();,     }, ,     /**,      * Convert the Selectors within this container to a string. This will,      * just be a helper class for the subclasses that put their own name,      * around the contents listed here.,      *,      * @return comma separated list of Selectors contained in this one,      */,     public String toString() {,         StringBuilder buf = new StringBuilder();,         Enumeration<FileSelector> e = selectorElements();,         if (e.hasMoreElements()) {,             while (e.hasMoreElements()) {,                 buf.append(e.nextElement().toString());,                 if (e.hasMoreElements()) {,                     buf.append(", ");,                 },             },         }, ,         return buf.toString();,     }, ,     /**,      * Add a new selector into this container.,      *,      * @param selector the new selector to add,      */,     public void appendSelector(FileSelector selector) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         selectorsList.addElement(selector);,         setChecked(false);,     }, ,     /**,      * <p>,      * This validates each contained selector,      * provided that the selector implements the validate interface.,      * </p>,      * <p>Ordinarily, this will validate all the elements of a selector,      * container even if the isSelected() method of some elements is,      * never called. This has two effects:</p>,      * <ul>,      * <li>Validation will often occur twice.,      * <li>Since it is not required that selectors derive from,      * BaseSelector, there could be selectors in the container whose,      * error conditions are not detected if their isSelected() call,      * is never made.,      * </ul>,      */,     public void validate() {,         if (isReference()) {,             ((AbstractSelectorContainer) getCheckedRef()).validate();,         },         dieOnCircularReference();,         Enumeration<FileSelector> e = selectorElements();,         while (e.hasMoreElements()) {,             Object o = e.nextElement();,             if (o instanceof BaseSelector) {,                 ((BaseSelector) o).validate();,             },         },     }, , ,     /* Methods below all add specific selectors */, ,     /**,      * add a "Select" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addSelector(SelectSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add an "And" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addAnd(AndSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add an "Or" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addOr(OrSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a "Not" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addNot(NotSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a "None" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addNone(NoneSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a majority selector entry on the selector list,      * @param selector the selector to add,      */,     public void addMajority(MajoritySelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a selector date entry on the selector list,      * @param selector the selector to add,      */,     public void addDate(DateSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a selector size entry on the selector list,      * @param selector the selector to add,      */,     public void addSize(SizeSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a selector filename entry on the selector list,      * @param selector the selector to add,      */,     public void addFilename(FilenameSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add an extended selector entry on the selector list,      * @param selector the selector to add,      */,     public void addCustom(ExtendSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a contains selector entry on the selector list,      * @param selector the selector to add,      */,     public void addContains(ContainsSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a present selector entry on the selector list,      * @param selector the selector to add,      */,     public void addPresent(PresentSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a depth selector entry on the selector list,      * @param selector the selector to add,      */,     public void addDepth(DepthSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a depends selector entry on the selector list,      * @param selector the selector to add,      */,     public void addDepend(DependSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * adds a different selector to the selector list,      * @param selector the selector to add,      */,     public void addDifferent(DifferentSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * adds a type selector to the selector list,      * @param selector the selector to add,      */,     public void addType(TypeSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a regular expression selector entry on the selector list,      * @param selector the selector to add,      */,     public void addContainsRegexp(ContainsRegexpSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add the modified selector,      * @param selector the selector to add,      * @since ant 1.6,      */,     public void addModified(ModifiedSelector selector) {,         appendSelector(selector);,     }, ,     public void addReadable(ReadableSelector r) {,         appendSelector(r);,     }, ,     public void addWritable(WritableSelector w) {,         appendSelector(w);,     }, ,     /**,      * add an arbitrary selector,      * @param selector the selector to add,      * @since Ant 1.6,      */,     public void add(FileSelector selector) {,         appendSelector(selector);,     }, ,     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p) {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             for (FileSelector fileSelector : selectorsList) {,                 if (fileSelector instanceof DataType) {,                     pushAndInvokeCircularReferenceCheck((DataType) fileSelector, stk, p);,                 },             },             setChecked(true);,         },     }, ,     public synchronized Object clone() {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef()).clone();,         },         try {,             AbstractSelectorContainer sc =,                 (AbstractSelectorContainer) super.clone();,             sc.selectorsList = new Vector<FileSelector>(selectorsList);,             return sc;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/tools/ant/types/selectors/AbstractSelectorContainer.java,toString,104-104,[        if (e.hasMoreElements()) {],,toString,105-105,[            while (e.hasMoreElements()) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/types/selectors/BaseExtendSelector.java,setParameters,57-57,[        this.parameters = parameters;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/selectors/BaseSelectorRule.java,getFilenames,82-82,[        return filenames;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/selectors/BaseSelectorRule.java,getFiles,78-78,[        return files;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/selectors/BaseSelectorRule.java,getMirrorFiles,74-74,[        return mirrorfiles;],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/types/selectors/BaseSelectorTest.java,,264-290,[        TaskdefForMakingBed(String name) {,             super(name);,         }, ,         public void setUp() {,             configureProject("src/etc/testcases/types/selectors.xml");,         }, ,         public void tearDown() {,             try {,                 super.tearDown();,             } catch (Exception exc) {,                 // ignore,             },         }, ,         public void makeTestbed() {,             executeTarget("setupfiles");,         }, ,         public void makeMirror() {,             executeTarget("mirrorfiles");,         }, ,         public void deleteMirror() {,             executeTarget("tearDown");,         }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/selectors/BaseSelectorTest.java,,264-290,[        TaskdefForMakingBed(String name) {,             super(name);,         }, ,         public void setUp() {,             configureProject("src/etc/testcases/types/selectors.xml");,         }, ,         public void tearDown() {,             try {,                 super.tearDown();,             } catch (Exception exc) {,                 // ignore,             },         }, ,         public void makeTestbed() {,             executeTarget("setupfiles");,         }, ,         public void makeMirror() {,             executeTarget("mirrorfiles");,         }, ,         public void deleteMirror() {,             executeTarget("tearDown");,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/selectors/ContainsRegexpSelector.java,isSelected,187-187,[            in = new BufferedReader(new InputStreamReader(r.getInputStream()));],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/types/selectors/ContainsRegexpTest.java,testContainsRegexp,46-46,[        int filecount = files.length;],,testContainsRegexp,45-45,[        File[] files = dir.listFiles();],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/types/selectors/ContainsSelector.java,isSelected,182-182,[            userstr = contains.toLowerCase();],,isSelected,202-202,[                    teststr = teststr.toLowerCase();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/selectors/ContainsSelector.java,isSelected,192-192,[                in = new BufferedReader(new InputStreamReader(r.getInputStream()));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/ContainsSelector.java,isSelected,194-194,[        } catch (Exception e) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/selectors/MockComparator.java,,23-30,[public class MockComparator implements Comparator {, ,     public int compare(Object o1, Object o2) {,         return 0;,     }, ,     public String toString() {,         return "MockComparator";],,
PERFORMANCE,DM_STRING_CTOR,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,doTest,631-631,[        Object o1 = new String("string1");],,doTest,632-632,[        Object o2 = new String("string2");],,doTest,633-633,[        Object o3 = new String("string2"); // really "2"],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,doScenarioTest,873-873,[            cachefile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,testCreatePropertiesCacheViaCustomSelector,396-396,[        cachefile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,testCreatePropertiesCacheViaModifiedSelector,364-364,[        cachefile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,testScenario2,822-822,[            (new java.io.File(cachefile)).delete();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,doDelayUpdateTest,263-266,[        switch (kind) {,             case 1 : project.fireTaskFinished();   break;,             case 2 : project.fireTargetFinished(); break;,             case 3 : project.fireBuildFinished();  break;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,writeProperties,938-938,[                    new java.io.FileWriter(file.getAbsolutePath(), true);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,writeProperties,938-938,[                    new java.io.FileWriter(file.getAbsolutePath(), true);],,writeProperties,939-939,[                out.write(line);],,writeProperties,943-943,[            } catch (Exception e) {],,writeProperties,944-944,[                e.printStackTrace();],,writeProperties,946-946,[        }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,writeProperties,937-937,[                java.io.FileWriter out =],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,deleteCachefile,956-956,[            cacheFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,deletePropertiesfile,950-950,[            new File(getProject().getBaseDir(), propfile).delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,,900-957,[    private class BFT extends BuildFileRule {,         String buildfile = "src/etc/testcases/types/selectors.xml";, ,         String propfile = "ModifiedSelectorTest.properties";, ,         boolean isConfigured = false;, , ,         public void setUp() {,             super.configureProject(buildfile);,             isConfigured = true;,         }, , ,         /**,          * This stub teardown is here because the outer class needs to call the,          * tearDown method, and in the superclass it is protected.,          */,         public void tearDown() {,             super.after();, ,         }, ,         public void doTarget(String target) {,             if (!isConfigured) setUp();,             executeTarget(target);,         }, ,         public String getProperty(String property) {,             return super.getProject().getProperty(property);,         }, ,         public void writeProperties(String line) {,             if (!isConfigured) setUp();,             File dir = getProject().getBaseDir();,             File file = new File(dir, propfile);,             try {,                 java.io.FileWriter out =,                     new java.io.FileWriter(file.getAbsolutePath(), true);,                 out.write(line);,                 out.write(System.getProperty("line.separator"));,                 out.flush();,                 out.close();,             } catch (Exception e) {,                 e.printStackTrace();,             },         }, ,         public void deletePropertiesfile() {,             if (!isConfigured) setUp();,             new File(getProject().getBaseDir(), propfile).delete();,         }, ,         public void deleteCachefile() {,             File basedir = new File(buildfile).getParentFile();,             File cacheFile = new File(basedir, "cache.properties");,             cacheFile.delete();,         }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,,970-1000,[        public MockProject() {,             task = new Task(){,                 public void execute() {,                 },             };,             task.setTaskName("testTask");,             target = new Target();,             target.setName("testTarget");,             target.setProject(this);,             target.addTask(task);,             task.setOwningTarget(target);,         }, ,         public void fireBuildFinished() {,             super.fireBuildFinished(null);,         },         public void fireSubBuildFinished() {,             super.fireSubBuildFinished(null);,         },         public void fireTargetStarted() {,             super.fireTargetStarted(target);,         },         public void fireTargetFinished() {,             super.fireTargetFinished(target, null);,         },         public void fireTaskStarted() {,             super.fireTaskStarted(task);,         },         public void fireTaskFinished() {,             super.fireTaskFinished(task, null);,         }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/modifiedselector/ChecksumAlgorithm.java,getValue,126-126,[                 BufferedInputStream in = new BufferedInputStream(check);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/ChecksumAlgorithm.java,getValue,133-133,[        } catch (Exception e) {],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/tools/ant/types/selectors/modifiedselector/DigestAlgorithm.java,getValue,174-174,[                fis = null;],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/modifiedselector/DigestAlgorithm.java,getValue,167-167,[                DigestInputStream dis = new DigestInputStream(fis,],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/DigestAlgorithm.java,getValue,186-186,[            } catch (Exception e) {],,getValue,189-189,[        } catch (Exception e) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/selectors/modifiedselector/EqualComparator.java,,33-56,[public class EqualComparator implements Comparator<Object> {, ,     /**,      * Implements Comparator.compare().,      * @param o1 the first object,      * @param o2 the second object,      * @return 0, if both are equal, otherwise 1,      */,     public int compare(Object o1, Object o2) {,         if (o1 == null) {,             if (o2 == null) {,                 return 1;,             },             return 0;,         },         return (o1.equals(o2)) ? 0 : 1;,     }, ,     /**,      * Override Object.toString().,      * @return information about this comparator,      */,     public String toString() {,         return "EqualComparator";],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/selectors/modifiedselector/HashvalueAlgorithm.java,getValue,61-61,[            r = new FileReader(file);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/HashvalueAlgorithm.java,getValue,64-64,[        } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java,isSelected,438-438,[            FileResource fileResource = (FileResource) resource;],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java,configure,306-306,[            if (parameter.getName().indexOf(".") > 0) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java,isSelected,454-454,[                tmpFile.delete();],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,load,135-135,[                BufferedInputStream bis = new BufferedInputStream(],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,save,161-161,[                BufferedOutputStream bos = new BufferedOutputStream(],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,load,139-139,[            } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,save,166-166,[            } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,delete,176-176,[        cachefile.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/Base64Converter.java,encode,62-62,[        return encode(s.getBytes());],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/util/Base64Converter.java,,52-52,[    public static final char[] alphabet = ALPHABET;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/Base64ConverterTest.java,testHelloWorld,39-39,[        byte[] mybytes = "Hello World".getBytes();],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/util/ClasspathUtilsTest.java,testOnlyOneInstance,62-62,[            list = list + " " + enumeration.nextElement();],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/util/ConcatFileInputStream.java,<init>,51-51,[        this.file = file;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/util/DateUtils.java,formatElapsedTime,140-140,[        Object[] args = {new Long(minutes), new Long(seconds % ONE_MINUTE)};],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/tools/ant/util/FileUtils.java,close,1536-1536,[                    jf = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/FileUtils.java,getDefaultEncoding,1710-1710,[        InputStreamReader is = new InputStreamReader(],,
PERFORMANCE,DM_GC,org/apache/tools/ant/util/FileUtils.java,tryHardToDelete,1579-1579,[                System.gc();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/FileUtils.java,createNewFile,1118-1118,[            parent.mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/FileUtils.java,delete,1553-1553,[            file.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/util/FileUtils.java,,1375-1377,[        FilenameFilter ff = new FilenameFilter () {,             public boolean accept(File dir, String name) {,                 return name.equalsIgnoreCase(localFileName) && (!name.equals(localFileName));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/util/FileUtils.java,,1711-1713,[            new InputStream() {,                 public int read() {,                     return -1;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,219-219,[            } catch (Exception e) {],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,217-217,[                 FILE_UTILS.normalize("/").getPath();],,testNormalize,212-212,[                         FILE_UTILS.normalize("/").getPath());],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,234-234,[                 FILE_UTILS.normalize(driveSpec).getPath();],,testNormalize,285-285,[                             FILE_UTILS.normalize(driveSpec).getPath());],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,462-462,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,445-445,[            assertEquals(FILE_UTILS.normalize("/bar").getAbsolutePath(),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,428-428,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("/foo"),],,testRemoveLeadingPath,445-445,[            assertEquals(FILE_UTILS.normalize("/bar").getAbsolutePath(),],,testRemoveLeadingPath,447-447,[            assertEquals(FILE_UTILS.normalize("/foobar").getAbsolutePath(),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,430-430,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("/foo/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,428-428,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("/foo"),],,testRemoveLeadingPath,430-430,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("/foo/"),],,testRemoveLeadingPath,451-451,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar"),],,testRemoveLeadingPath,453-453,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar"),],,testRemoveLeadingPath,457-457,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar/"),],,testRemoveLeadingPath,462-462,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,453-453,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar"),],,testRemoveLeadingPath,455-455,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar/"),],,testRemoveLeadingPath,457-457,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,447-447,[            assertEquals(FILE_UTILS.normalize("/foobar").getAbsolutePath(),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,464-464,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("c:/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,436-436,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:/foo"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,438-438,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:/foo/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,436-436,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:/foo"),],,testRemoveLeadingPath,438-438,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:/foo/"),],,testRemoveLeadingPath,464-464,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("c:/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,466-466,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("c:\\"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,440-440,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:\\foo"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,442-442,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:\\foo\\"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,440-440,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:\\foo"),],,testRemoveLeadingPath,442-442,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:\\foo\\"),],,testRemoveLeadingPath,466-466,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("c:\\"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,491-491,[            assertEquals("file:/foo", removeExtraneousAuthority(FILE_UTILS.toURI("/foo")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,494-494,[            assertEquals("file:/" + dosRoot + "foo%20bar", removeExtraneousAuthority(FILE_UTILS.toURI("/foo bar")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,495-495,[            assertEquals("file:/" + dosRoot + "foo%23bar", removeExtraneousAuthority(FILE_UTILS.toURI("/foo#bar")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,506-506,[        assertEquals("file:/" + dosRoot + "%C3%A4nt", removeExtraneousAuthority(FILE_UTILS.toURI("/\u00E4nt")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,485-485,[            assertEquals("file:/c:/foo", removeExtraneousAuthority(FILE_UTILS.toURI("c:\\foo")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testCreateTempFile,372-372,[        File parent = new File((new File("/tmp")).getAbsolutePath());],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/util/FileUtilsTest.java,setUp,51-51,[        root = new File(File.separator).getAbsolutePath().toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/util/FileUtilsTest.java,testHasErrorInCase,581-581,[        String s = wellcased.getName().toUpperCase();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/util/FileUtilsTest.java,testSetLastModified,77-77,[        FileOutputStream fos = new FileOutputStream(removeThis);],,testSetLastModified,78-78,[        fos.write(new byte[0]);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/util/FileUtilsTest.java,testSetLastModified,77-77,[        FileOutputStream fos = new FileOutputStream(removeThis);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,236-236,[            } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/FileUtilsTest.java,testCreateTempFile,356-356,[        tmp1.delete();],,testCreateTempFile,369-369,[        tmp2.delete();],,testCreateTempFile,370-370,[        dir2.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/FileUtilsTest.java,testCreateTempFile,359-359,[        dir2.mkdir();],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,217-217,[                 FILE_UTILS.normalize("/").getPath();],,testNormalize,222-222,[                 FILE_UTILS.normalize("\\").getPath();],,testNormalize,234-234,[                 FILE_UTILS.normalize(driveSpec).getPath();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/util/FirstMatchMapper.java,mapFileName,41-41,[        return null;],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/util/GlobPatternMapper.java,modifyName,194-194,[            name = name.toLowerCase();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/util/GlobPatternMapper.java,mapFileName,167-167,[            return null;],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/JAXPUtilsTest.java,testGetSystemId,37-37,[            file = new File("/user/local/bin");],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/JAXPUtilsTest.java,testGetSystemId,35-35,[            file = new File("d:\\jdk");],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/JavaEnvUtils.java,createVmsJavaOptionFile,553-553,[            out = new BufferedWriter(new FileWriter(script));],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/tools/ant/util/JavaEnvUtils.java,buildJrePackages,434-437,[                jrePackages.addElement("com.sun.org.apache");,                 //fall through.,             case VERSION_1_4:,                 if (javaVersionNumber == VERSION_1_4) {],,buildJrePackages,445-448,[                jrePackages.addElement("org.xml.sax");,                 // fall through,             case VERSION_1_3:,                 jrePackages.addElement("org.omg");],,buildJrePackages,456-459,[                jrePackages.addElement("sunw.util");,                 // fall through,             case VERSION_1_2:,                 jrePackages.addElement("com.sun.java");],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/tools/ant/util/JavaEnvUtils.java,getJrePackageTestCases,486-490,[                tests.addElement(,                     "com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl ");,                 // Fall through,             case VERSION_1_4:,                 tests.addElement("sun.audio.AudioPlayer");],,getJrePackageTestCases,500-503,[                tests.addElement("org.xml.sax.XMLReader");,                 // fall through,             case VERSION_1_3:,                 tests.addElement("org.omg.CORBA.Any");],,getJrePackageTestCases,510-513,[                tests.addElement("sunw.util.EventListener");,                 // fall through,             case VERSION_1_2:,                 tests.addElement("javax.accessibility.Accessible");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/tools/ant/util/JavaEnvUtils.java,buildJrePackages,427-460,[        switch(javaVersionNumber) {,         	case VERSION_1_9:,             case VERSION_1_8:,             case VERSION_1_7:,             case VERSION_1_6:,             case VERSION_1_5:,                 //In Java1.5, the apache stuff moved.,                 jrePackages.addElement("com.sun.org.apache");,                 //fall through.,             case VERSION_1_4:,                 if (javaVersionNumber == VERSION_1_4) {,                     jrePackages.addElement("org.apache.crimson");,                     jrePackages.addElement("org.apache.xalan");,                     jrePackages.addElement("org.apache.xml");,                     jrePackages.addElement("org.apache.xpath");,                 },                 jrePackages.addElement("org.ietf.jgss");,                 jrePackages.addElement("org.w3c.dom");,                 jrePackages.addElement("org.xml.sax");,                 // fall through,             case VERSION_1_3:,                 jrePackages.addElement("org.omg");,                 jrePackages.addElement("com.sun.corba");,                 jrePackages.addElement("com.sun.jndi");,                 jrePackages.addElement("com.sun.media");,                 jrePackages.addElement("com.sun.naming");,                 jrePackages.addElement("com.sun.org.omg");,                 jrePackages.addElement("com.sun.rmi");,                 jrePackages.addElement("sunw.io");,                 jrePackages.addElement("sunw.util");,                 // fall through,             case VERSION_1_2:,                 jrePackages.addElement("com.sun.java");,                 jrePackages.addElement("com.sun.image");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/tools/ant/util/JavaEnvUtils.java,getJrePackageTestCases,480-515,[        switch(javaVersionNumber) {,             case VERSION_1_9:,             case VERSION_1_8:,             case VERSION_1_7:,             case VERSION_1_6:,             case VERSION_1_5:,                 tests.addElement(,                     "com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl ");,                 // Fall through,             case VERSION_1_4:,                 tests.addElement("sun.audio.AudioPlayer");,                 if (javaVersionNumber == VERSION_1_4) {,                 	// only for 1.4, not for higher versions which fall through,                     tests.addElement("org.apache.crimson.parser.ContentModel");,                     tests.addElement("org.apache.xalan.processor.ProcessorImport");,                     tests.addElement("org.apache.xml.utils.URI");,                     tests.addElement("org.apache.xpath.XPathFactory");,                 },                 tests.addElement("org.ietf.jgss.Oid");,                 tests.addElement("org.w3c.dom.Attr");,                 tests.addElement("org.xml.sax.XMLReader");,                 // fall through,             case VERSION_1_3:,                 tests.addElement("org.omg.CORBA.Any");,                 tests.addElement("com.sun.corba.se.internal.corba.AnyImpl");,                 tests.addElement("com.sun.jndi.ldap.LdapURL");,                 tests.addElement("com.sun.media.sound.Printer");,                 tests.addElement("com.sun.naming.internal.VersionHelper");,                 tests.addElement("com.sun.org.omg.CORBA.Initializer");,                 tests.addElement("sunw.io.Serializable");,                 tests.addElement("sunw.util.EventListener");,                 // fall through,             case VERSION_1_2:,                 tests.addElement("javax.accessibility.Accessible");,                 tests.addElement("sun.misc.BASE64Encoder");,                 tests.addElement("com.sun.image.codec.jpeg.JPEGCodec");],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/KeepAliveOutputStream.java,wrap,81-81,[        return new PrintStream(new KeepAliveOutputStream(ps));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/util/LayoutPreservingProperties.java,innerSetProperty,185-185,[            keyedPairLines.put(key, new Integer(logicalLines.size()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/util/LayoutPreservingProperties.java,readLines,365-365,[                    keyedPairLines.put(key, new Integer(logicalLines.size()));],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/tools/ant/util/LayoutPreservingProperties.java,requiresContinuation,431-431,[        return tb % 2 == 1;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/util/LayoutPreservingProperties.java,saveAs,253-253,[        final FileOutputStream fos = new FileOutputStream(dest);],,saveAs,254-254,[        store(fos, null);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/util/LayoutPreservingProperties.java,saveAs,253-253,[        final FileOutputStream fos = new FileOutputStream(dest);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/tools/ant/util/LayoutPreservingProperties.java,,81-616,[    private String LS = StringUtils.LINE_SEP;, ,     /**,      * Logical lines have escaping and line continuation taken care,      * of. Comments and blank lines are logical lines; they are not,      * removed.,      */,     private ArrayList logicalLines = new ArrayList();, ,     /**,      * Position in the <code>logicalLines</code> list, keyed by property name.,      */,     private HashMap keyedPairLines = new HashMap();, ,     /**,      * Flag to indicate that, when we remove a property from the file, we,      * also want to remove the comments that precede it.,      */,     private boolean removeComments;, ,     /**,      * Create a new, empty, Properties collection, with no defaults.,      */,     public LayoutPreservingProperties() {,         super();,     }, ,     /**,      * Create a new, empty, Properties collection, with the specified defaults.,      * @param defaults the default property values,      */,     public LayoutPreservingProperties(final Properties defaults) {,         super(defaults);,     }, ,     /**,      * Returns <code>true</code> if comments are removed along with,      * properties, or <code>false</code> otherwise. If,      * <code>true</code>, then when a property is removed, the comment,      * preceding it in the original file is removed also.,      * @return <code>true</code> if leading comments are removed when,      * a property is removed; <code>false</code> otherwise,      */,     public boolean isRemoveComments() {,         return removeComments;,     }, ,     /**,      * Sets the behaviour for comments accompanying properties that,      * are being removed. If <code>true</code>, then when a property,      * is removed, the comment preceding it in the original file is,      * removed also.,      * @param val <code>true</code> if leading comments are to be,      * removed when a property is removed; <code>false</code>,      * otherwise,      */,     public void setRemoveComments(final boolean val) {,         removeComments = val;,     }, ,     @Override,     public void load(final InputStream inStream) throws IOException {,         final String s = readLines(inStream);,         final byte[] ba = s.getBytes(ResourceUtils.ISO_8859_1);,         final ByteArrayInputStream bais = new ByteArrayInputStream(ba);,         super.load(bais);,     }, ,     @Override,     public Object put(final Object key, final Object value) throws NullPointerException {,         final Object obj = super.put(key, value);,         // the above call will have failed if key or value are null,         innerSetProperty(key.toString(), value.toString());,         return obj;,     }, ,     @Override,     public Object setProperty(final String key, final String value),         throws NullPointerException {,         final Object obj = super.setProperty(key, value);,         // the above call will have failed if key or value are null,         innerSetProperty(key, value);,         return obj;,     }, ,     /**,      * Store a new key-value pair, or add a new one. The normal,      * functionality is taken care of by the superclass in the call to,      * {@link #setProperty}; this method takes care of this classes,      * extensions.,      * @param key the key of the property to be stored,      * @param value the value to be stored,      */,     private void innerSetProperty(String key, String value) {,         value = escapeValue(value);, ,         if (keyedPairLines.containsKey(key)) {,             final Integer i = (Integer) keyedPairLines.get(key);,             final Pair p = (Pair) logicalLines.get(i.intValue());,             p.setValue(value);,         } else {,             key = escapeName(key);,             final Pair p = new Pair(key, value);,             p.setNew(true);,             keyedPairLines.put(key, new Integer(logicalLines.size()));,             logicalLines.add(p);,         },     }, ,     @Override,     public void clear() {,         super.clear();,         keyedPairLines.clear();,         logicalLines.clear();,     }, ,     @Override,     public Object remove(final Object key) {,         final Object obj = super.remove(key);,         final Integer i = (Integer) keyedPairLines.remove(key);,         if (null != i) {,             if (removeComments) {,                 removeCommentsEndingAt(i.intValue());,             },             logicalLines.set(i.intValue(), null);,         },         return obj;,     }, ,     @Override,     public Object clone() {,         final LayoutPreservingProperties dolly =,             (LayoutPreservingProperties) super.clone();,         dolly.keyedPairLines = (HashMap) this.keyedPairLines.clone();,         dolly.logicalLines = (ArrayList) this.logicalLines.clone();,         final int size = dolly.logicalLines.size();,         for (int j = 0; j < size; j++) {,             final LogicalLine line = (LogicalLine) dolly.logicalLines.get(j);,             if (line instanceof Pair) {,                 final Pair p = (Pair) line;,                 dolly.logicalLines.set(j, p.clone());,             },             // no reason to clone other lines are they are immutable,         },         return dolly;,     }, ,     /**,      * Echo the lines of the properties (including blanks and comments) to the,      * stream.,      * @param out the stream to write to,      */,     public void listLines(final PrintStream out) {,         out.println("-- logical lines --");,         final Iterator i = logicalLines.iterator();,         while (i.hasNext()) {,             final LogicalLine line = (LogicalLine) i.next();,             if (line instanceof Blank) {,                 out.println("blank:   \"" + line + "\"");,             } else if (line instanceof Comment) {,                 out.println("comment: \"" + line + "\"");,             } else if (line instanceof Pair) {,                 out.println("pair:    \"" + line + "\"");,             },         },     }, ,     /**,      * Save the properties to a file.,      * @param dest the file to write to,      */,     public void saveAs(final File dest) throws IOException {,         final FileOutputStream fos = new FileOutputStream(dest);,         store(fos, null);,         fos.close();,     }, ,     @Override,     public void store(final OutputStream out, final String header) throws IOException {,         final OutputStreamWriter osw = new OutputStreamWriter(out, ResourceUtils.ISO_8859_1);, ,         int skipLines = 0;,         final int totalLines = logicalLines.size();, ,         if (header != null) {,             osw.write("#" + header + LS);,             if (totalLines > 0,                 && logicalLines.get(0) instanceof Comment,                 && header.equals(logicalLines.get(0).toString().substring(1))) {,                 skipLines = 1;,             },         }, ,         // we may be updatiung a file written by this class, replace,         // the date comment instead of adding a new one and preserving,         // the one written last time,         if (totalLines > skipLines,             && logicalLines.get(skipLines) instanceof Comment) {,             try {,                 DateUtils.parseDateFromHeader(logicalLines,                                               .get(skipLines),                                               .toString().substring(1));,                 skipLines++;,             } catch (final java.text.ParseException pe) {,                 // not an existing date comment,             },         },         osw.write("#" + DateUtils.getDateForHeader() + LS);, ,         boolean writtenSep = false;,         for (final Iterator i = logicalLines.subList(skipLines, totalLines).iterator();,              i.hasNext();) {,             final LogicalLine line = (LogicalLine) i.next();,             if (line instanceof Pair) {,                 if (((Pair)line).isNew()) {,                     if (!writtenSep) {,                         osw.write(LS);,                         writtenSep = true;,                     },                 },                 osw.write(line.toString() + LS);,             } else if (line != null) {,                 osw.write(line.toString() + LS);,             },         },         osw.close();,     }, ,     /**,      * Reads a properties file into an internally maintained,      * collection of logical lines (possibly spanning physcial lines),,      * which make up the comments, blank lines and properties of the,      * file.,      * @param is the stream from which to read the data,      */,     private String readLines(final InputStream is) throws IOException {,         final InputStreamReader isr = new InputStreamReader(is, ResourceUtils.ISO_8859_1);,         final PushbackReader pbr = new PushbackReader(isr, 1);, ,         if (logicalLines.size() > 0) {,             // we add a blank line for spacing,             logicalLines.add(new Blank());,         }, ,         String s = readFirstLine(pbr);,         final BufferedReader br = new BufferedReader(pbr);, ,         boolean continuation = false;,         boolean comment = false;,         final StringBuffer fileBuffer = new StringBuffer();,         final StringBuffer logicalLineBuffer = new StringBuffer();,         while (s != null) {,             fileBuffer.append(s).append(LS);, ,             if (continuation) {,                 // put in the line feed that was removed,                 s = "\n" + s;,             } else {,                 // could be a comment, if first non-whitespace is a # or !,                 comment = s.matches("^( |\t|\f)*(#|!).*");,             }, ,             // continuation if not a comment and the line ends is an,             // odd number of backslashes,             if (!comment) {,                 continuation = requiresContinuation(s);,             }, ,             logicalLineBuffer.append(s);, ,             if (!continuation) {,                 LogicalLine line = null;,                 if (comment) {,                     line = new Comment(logicalLineBuffer.toString());,                 } else if (logicalLineBuffer.toString().trim().length() == 0) {,                     line = new Blank();,                 } else {,                     line = new Pair(logicalLineBuffer.toString());,                     final String key = unescape(((Pair)line).getName());,                     if (keyedPairLines.containsKey(key)) {,                         // this key is already present, so we remove it and add,                         // the new one,                         remove(key);,                     },                     keyedPairLines.put(key, new Integer(logicalLines.size()));,                 },                 logicalLines.add(line);,                 logicalLineBuffer.setLength(0);,             },             s = br.readLine();,         },         return fileBuffer.toString();,     }, ,     /**,      * Reads the first line and determines the EOL-style of the file,      * (relies on the style to be consistent, of course).,      *,      * <p>Sets LS as a side-effect.</p>,      *,      * @return the first line without any line separator, leaves the,      * reader positioned after the first line separator,      *,      * @since Ant 1.8.2,      */,     private String readFirstLine(final PushbackReader r) throws IOException {,         final StringBuffer sb = new StringBuffer(80);,         int ch = r.read();,         boolean hasCR = false;,         // when reaching EOF before the first EOL, assume native line,         // feeds,         LS = StringUtils.LINE_SEP;, ,         while (ch >= 0) {,             if (hasCR && ch != '\n') {,                 // line feed is sole CR,                 r.unread(ch);,                 break;,             }, ,             if (ch == '\r') {,                 LS = "\r";,                 hasCR = true;,             } else if (ch == '\n') {,                 LS = hasCR ? "\r\n" : "\n";,                 break;,             } else {,                 sb.append((char) ch);,             },             ch = r.read();,         },         return sb.toString();,     }, ,     /**,      * Returns <code>true</code> if the line represented by,      * <code>s</code> is to be continued on the next line of the file,,      * or <code>false</code> otherwise.,      * @param s the contents of the line to examine,      * @return <code>true</code> if the line is to be continued,,      * <code>false</code> otherwise,      */,     private boolean requiresContinuation(final String s) {,         final char[] ca = s.toCharArray();,         int i = ca.length - 1;,         while (i > 0 && ca[i] == '\\') {,             i--;,         },         // trailing backslashes,         final int tb = ca.length - i - 1;,         return tb % 2 == 1;,     }, ,     /**,      * Unescape the string according to the rules for a Properites,      * file, as laid out in the docs for <a,      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.,      * @param s the string to unescape (coming from the source file),      * @return the unescaped string,      */,     private String unescape(final String s) {,         /*,          * The following combinations are converted:,          * \n  newline,          * \r  carraige return,          * \f  form feed,          * \t  tab,          * \\  backslash,          * \u0000  unicode character,          * Any other slash is ignored, so,          * \b  becomes 'b'.,          */, ,         final char[] ch = new char[s.length() + 1];,         s.getChars(0, s.length(), ch, 0);,         ch[s.length()] = '\n';,         final StringBuffer buffy = new StringBuffer(s.length());,         for (int i = 0; i < ch.length; i++) {,             char c = ch[i];,             if (c == '\n') {,                 // we have hit out end-of-string marker,                 break;,             } else if (c == '\\') {,                 // possibly an escape sequence,                 c = ch[++i];,                 if (c == 'n') {,                     buffy.append('\n');,                 } else if (c == 'r') {,                     buffy.append('\r');,                 } else if (c == 'f') {,                     buffy.append('\f');,                 } else if (c == 't') {,                     buffy.append('\t');,                 } else if (c == 'u') {,                     // handle unicode escapes,                     c = unescapeUnicode(ch, i+1);,                     i += 4;,                     buffy.append(c);,                 } else {,                     buffy.append(c);,                 },             } else {,                 buffy.append(c);,             },         },         return buffy.toString();,     }, ,     /**,      * Retrieve the unicode character whose code is listed at position,      * <code>i</code> in the character array <code>ch</code>.,      * @param ch the character array containing the unicode character code,      * @return the character extracted,      */,     private char unescapeUnicode(final char[] ch, final int i) {,         final String s = new String(ch, i, 4);,         return (char) Integer.parseInt(s, 16);,     }, ,     /**,      * Escape the string <code>s</code> according to the rules in the,      * docs for <a,      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.,      * @param s the string to escape,      * @return the escaped string,      */,     private String escapeValue(final String s) {,         return escape(s, false);,     }, ,     /**,      * Escape the string <code>s</code> according to the rules in the,      * docs for <a,      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.,      * This method escapes all the whitespace, not just the stuff at,      * the beginning.,      * @param s the string to escape,      * @return the escaped string,      */,     private String escapeName(final String s) {,         return escape(s, true);,     }, ,     /**,      * Escape the string <code>s</code> according to the rules in the,      * docs for <a,      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.,      * @param s the string to escape,      * @param escapeAllSpaces if <code>true</code> the method escapes,      * all the spaces, if <code>false</code>, it escapes only the,      * leading whitespace,      * @return the escaped string,      */,     private String escape(final String s, final boolean escapeAllSpaces) {,         if (s == null) {,             return null;,         }, ,         final char[] ch = new char[s.length()];,         s.getChars(0, s.length(), ch, 0);,         final String forEscaping = "\t\f\r\n\\:=#!";,         final String escaped = "tfrn\\:=#!";,         final StringBuffer buffy = new StringBuffer(s.length());,         boolean leadingSpace = true;,         for (int i = 0; i < ch.length; i++) {,             final char c = ch[i];,             if (c == ' ') {,                 if (escapeAllSpaces || leadingSpace) {,                     buffy.append("\\");,                 },             } else {,                 leadingSpace = false;,             },             final int p = forEscaping.indexOf(c);,             if (p != -1) {,                 buffy.append("\\").append(escaped.substring(p,p+1));,             } else if (c < 0x0020 || c > 0x007e) {,                 buffy.append(escapeUnicode(c));,             } else {,                 buffy.append(c);,             },         },         return buffy.toString();,     }, ,     /**,      * Return the unicode escape sequence for a character, in the form,      * \u005CuNNNN.,      * @param ch the character to encode,      * @return the unicode escape sequence,      */,     private String escapeUnicode(final char ch) {,         return "\\" + UnicodeUtil.EscapeUnicode(ch);,         }, ,     /**,      * Remove the comments in the leading up the {@link logicalLines},      * list leading up to line <code>pos</code>.,      * @param pos the line number to which the comments lead,      */,     private void removeCommentsEndingAt(int pos) {,         /* We want to remove comments preceding this position. Step,          * back counting blank lines (call this range B1) until we hit,          * something non-blank. If what we hit is not a comment, then,          * exit. If what we hit is a comment, then step back counting,          * comment lines (call this range C1). Nullify lines in C1 and,          * B1.,          */, ,         final int end = pos - 1;, ,         // step pos back until it hits something non-blank,         for (pos = end; pos > 0; pos--) {,             if (!(logicalLines.get(pos) instanceof Blank)) {,                 break;,             },         }, ,         // if the thing it hits is not a comment, then we have nothing,         // to remove,         if (!(logicalLines.get(pos) instanceof Comment)) {,             return;,         }, ,         // step back until we hit the start of the comment,         for (; pos >= 0; pos--) {,             if (!(logicalLines.get(pos) instanceof Comment)) {,                 break;,             },         }, ,         // now we want to delete from pos+1 to end,         for (pos++; pos <= end; pos++) {,             logicalLines.set(pos, null);,         },     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,readFile,310-310,[        InputStreamReader isr = new InputStreamReader(fis);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testClear,161-161,[        FileInputStream fis = new FileInputStream(simple);],,testClear,162-162,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testClear,163-163,[        lpf.load(fis);],,testClear,165-165,[        lpf.clear();],,testClear,167-167,[        File tmp = File.createTempFile("tmp", "props");],,testClear,168-168,[        tmp.deleteOnExit();],,testClear,169-169,[        lpf.saveAs(tmp);],,testClear,172-172,[        String s = readFile(tmp);],,testClear,174-174,[        assertTrue("should have had no properties ",],,testClear,175-175,[                   s.indexOf("prop.alpha") == -1);],,testClear,176-176,[        assertTrue("should have had no properties ",],,testClear,177-177,[                   s.indexOf("prop.beta") == -1);],,testClear,178-178,[        assertTrue("should have had no properties ",],,testClear,179-179,[                   s.indexOf("prop.gamma") == -1);],,testClear,181-181,[        assertTrue("should have had no comments",],,testClear,182-182,[                   s.indexOf("# a comment") == -1);],,testClear,183-183,[        assertTrue("should have had no comments",],,testClear,184-184,[                   s.indexOf("! more comment") == -1);],,testClear,185-185,[        assertTrue("should have had no comments",],,testClear,186-186,[                   s.indexOf("# now a line wrapping one") == -1);],,testClear,187-187,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testClone,241-241,[        FileInputStream fis = new FileInputStream(simple);],,testClone,242-242,[        LayoutPreservingProperties lpf1 = new LayoutPreservingProperties();],,testClone,243-243,[        lpf1.load(fis);],,testClone,245-245,[        LayoutPreservingProperties lpf2 =],,testClone,246-246,[            (LayoutPreservingProperties) lpf1.clone();],,testClone,248-248,[        lpf2.setProperty("prop.new", "a new property");],,testClone,249-249,[        lpf2.setProperty("prop.beta", "a new value for beta");],,testClone,251-251,[        assertEquals("size of original is wrong", 3, lpf1.size());],,testClone,252-252,[        assertEquals("size of clone is wrong", 4, lpf2.size());],,testClone,254-254,[        File tmp1 = File.createTempFile("tmp", "props");],,testClone,255-255,[        tmp1.deleteOnExit();],,testClone,256-256,[        lpf1.saveAs(tmp1);],,testClone,257-257,[        String s1 = readFile(tmp1);],,testClone,259-259,[        File tmp2 = File.createTempFile("tmp", "props");],,testClone,260-260,[        tmp2.deleteOnExit();],,testClone,261-261,[        lpf2.saveAs(tmp2);],,testClone,262-262,[        String s2 = readFile(tmp2);],,testClone,265-265,[        assertTrue("should have had 'simple'", s1.indexOf("simple") > -1);],,testClone,266-266,[        assertTrue("should not have had prop.new", s1.indexOf("prop.new") == -1);],,testClone,269-269,[        assertTrue("should have had 'a new value for beta'",],,testClone,270-270,[                   s2.indexOf("a new value for beta") > -1);],,testClone,271-271,[        assertTrue("should have had prop.new", s2.indexOf("prop.new") > -1);],,testClone,272-272,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testOverwrite,113-113,[        FileInputStream fis = new FileInputStream(unusual);],,testOverwrite,114-114,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testOverwrite,115-115,[        lpf.load(fis);],,testOverwrite,117-117,[        lpf.setProperty(" prop one ", "new one");],,testOverwrite,118-118,[        lpf.setProperty("prop\ttwo", "new two");],,testOverwrite,119-119,[        lpf.setProperty("prop\nthree", "new three");],,testOverwrite,121-121,[        File tmp = File.createTempFile("tmp", "props");],,testOverwrite,122-122,[        tmp.deleteOnExit();],,testOverwrite,123-123,[        lpf.saveAs(tmp);],,testOverwrite,126-126,[        String s = readFile(tmp);],,testOverwrite,128-128,[        assertTrue(s.indexOf("\\ prop\\ one\\ =\\ \\ leading and"],,testOverwrite,130-130,[        assertTrue(s.indexOf("\\ prop\\ one\\ =new one") > -1);],,testOverwrite,131-131,[        assertTrue(s.indexOf("prop\\ttwo=contains\\ttab") == -1);],,testOverwrite,132-132,[        assertTrue(s.indexOf("prop\\ttwo=new two") > -1);],,testOverwrite,133-133,[        assertTrue(s.indexOf("prop\\nthree=contains\\nnewline") == -1);],,testOverwrite,134-134,[        assertTrue(s.indexOf("prop\\nthree=new three") > -1);],,testOverwrite,135-135,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testPreserve,43-43,[        FileInputStream fis = new FileInputStream(simple);],,testPreserve,44-44,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testPreserve,45-45,[        lpf.load(fis);],,testPreserve,47-47,[        File tmp = File.createTempFile("tmp", "props");],,testPreserve,48-48,[        tmp.deleteOnExit();],,testPreserve,49-49,[        lpf.saveAs(tmp);],,testPreserve,52-52,[        Properties originalProps = new Properties();],,testPreserve,53-53,[        originalProps.load(new FileInputStream(simple));],,testPreserve,55-55,[        Properties tmpProps = new Properties();],,testPreserve,56-56,[        tmpProps.load(new FileInputStream(tmp));],,testPreserve,58-58,[        assertEquals("properties corrupted", originalProps, tmpProps);],,testPreserve,61-61,[        String s = readFile(tmp);],,testPreserve,62-62,[        assertTrue("missing comment", s.indexOf("# a comment") > -1);],,testPreserve,63-63,[        assertTrue("missing comment", s.indexOf("! more comment") > -1);],,testPreserve,64-64,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testPreserveEscapeName,279-279,[        FileInputStream fis = new FileInputStream(unusual);],,testPreserveEscapeName,280-280,[        lpf.load(fis);],,testPreserveEscapeName,282-282,[        lpf.setProperty("prop:seven", "new value for seven");],,testPreserveEscapeName,283-283,[        lpf.setProperty("prop=eight", "new value for eight");],,testPreserveEscapeName,284-284,[        lpf.setProperty("prop eleven", "new value for eleven");],,testPreserveEscapeName,286-286,[        lpf.setProperty("alpha", "new value for alpha");],,testPreserveEscapeName,287-287,[        lpf.setProperty("beta", "new value for beta");],,testPreserveEscapeName,289-289,[        File tmp = File.createTempFile("tmp", "props");],,testPreserveEscapeName,290-290,[        tmp.deleteOnExit();],,testPreserveEscapeName,291-291,[        lpf.saveAs(tmp);],,testPreserveEscapeName,294-294,[        String s = readFile(tmp);],,testPreserveEscapeName,296-296,[        assertTrue(s.indexOf("prop\\:seven=new value for seven") > -1);],,testPreserveEscapeName,297-297,[        assertTrue(s.indexOf("prop\\=eight=new value for eight") > -1);],,testPreserveEscapeName,298-298,[        assertTrue(s.indexOf("prop\\ eleven=new value for eleven") > -1);],,testPreserveEscapeName,299-299,[        assertTrue(s.indexOf("alpha=new value for alpha") > -1);],,testPreserveEscapeName,300-300,[        assertTrue(s.indexOf("beta=new value for beta") > -1);],,testPreserveEscapeName,302-302,[        assertTrue(s.indexOf("prop\\:seven=contains\\:colon") == -1);],,testPreserveEscapeName,303-303,[        assertTrue(s.indexOf("prop\\=eight=contains\\=equals") == -1);],,testPreserveEscapeName,304-304,[        assertTrue(s.indexOf("alpha:set with a colon") == -1);],,testPreserveEscapeName,305-305,[        assertTrue(s.indexOf("beta set with a space") == -1);],,testPreserveEscapeName,306-306,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testRemove,193-193,[        FileInputStream fis = new FileInputStream(simple);],,testRemove,194-194,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testRemove,195-195,[        lpf.load(fis);],,testRemove,197-197,[        lpf.remove("prop.beta");],,testRemove,199-199,[        File tmp = File.createTempFile("tmp", "props");],,testRemove,200-200,[        tmp.deleteOnExit();],,testRemove,201-201,[        lpf.saveAs(tmp);],,testRemove,204-204,[        String s = readFile(tmp);],,testRemove,206-206,[        assertTrue("should not have had prop.beta",],,testRemove,207-207,[                   s.indexOf("prop.beta") == -1);],,testRemove,208-208,[        assertTrue("should have had prop.beta's comment",],,testRemove,209-209,[                   s.indexOf("! more comment") > -1);],,testRemove,210-210,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testRemoveWithComment,216-216,[        FileInputStream fis = new FileInputStream(simple);],,testRemoveWithComment,217-217,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testRemoveWithComment,218-218,[        lpf.load(fis);],,testRemoveWithComment,220-220,[        lpf.setRemoveComments(true);],,testRemoveWithComment,222-222,[        lpf.remove("prop.beta");],,testRemoveWithComment,224-224,[        File tmp = File.createTempFile("tmp", "props");],,testRemoveWithComment,225-225,[        tmp.deleteOnExit();],,testRemoveWithComment,226-226,[        lpf.saveAs(tmp);],,testRemoveWithComment,229-229,[        String s = readFile(tmp);],,testRemoveWithComment,231-231,[        assertTrue("should not have had prop.beta",],,testRemoveWithComment,232-232,[                   s.indexOf("prop.beta") == -1);],,testRemoveWithComment,233-233,[        assertTrue("should not have had prop.beta's comment",],,testRemoveWithComment,234-234,[                   s.indexOf("! more comment") == -1);],,testRemoveWithComment,235-235,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testStoreWithHeader,141-141,[        FileInputStream fis = new FileInputStream(simple);],,testStoreWithHeader,142-142,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testStoreWithHeader,143-143,[        lpf.load(fis);],,testStoreWithHeader,145-145,[        File tmp = File.createTempFile("tmp", "props");],,testStoreWithHeader,146-146,[        tmp.deleteOnExit();],,testStoreWithHeader,147-147,[        FileOutputStream fos = new FileOutputStream(tmp);],,testStoreWithHeader,148-148,[        lpf.store(fos, "file-header");],,testStoreWithHeader,149-149,[        fos.close();],,testStoreWithHeader,152-152,[        String s = readFile(tmp);],,testStoreWithHeader,154-154,[        assertTrue("should have had header ", s.startsWith("#file-header"));],,testStoreWithHeader,155-155,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testPreserve,53-53,[        originalProps.load(new FileInputStream(simple));],,testPreserve,56-56,[        tmpProps.load(new FileInputStream(tmp));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,readFile,310-310,[        InputStreamReader isr = new InputStreamReader(fis);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testStoreWithHeader,147-147,[        FileOutputStream fos = new FileOutputStream(tmp);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/LazyFileOutputStreamTest.java,tearDown,45-45,[            f.delete();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/tools/ant/util/LazyHashtable.java,,33-115,[    protected boolean initAllDone = false;,     // CheckStyle:VisibilityModifier OFF - bc, ,     /** No arg constructor. */,     public LazyHashtable() {,         super();,     }, ,     /** Used to be part of init. It must be done once - but,      * we delay it until we do need _all_ tasks. Otherwise we,      * just get the tasks that we need, and avoid costly init.,      */,     protected void initAll() {,         if (initAllDone) {,             return;,         },         initAllDone = true;,     }, , ,     /**,      * Get a enumeration over the elements.,      * @return an enumeration.,      */,     public Enumeration elements() {,         initAll();,         return super.elements();,     }, ,     /**,      * Check if the table is empty.,      * @return true if it is.,      */,     public boolean isEmpty() {,         initAll();,         return super.isEmpty();,     }, ,     /**,      * Get the size of the table.,      * @return the size.,      */,     public int size() {,         initAll();,         return super.size();,     }, ,     /**,      * Check if the table contains a particular value.,      * @param value the value to look for.,      * @return true if the table contains the value.,      */,     public boolean contains(Object value) {,         initAll();,         return super.contains(value);,     }, ,     /**,      * Check if the table contains a particular key.,      * @param value the key to look for.,      * @return true if the table contains key.,      */,     public boolean containsKey(Object value) {,         initAll();,         return super.containsKey(value);,     }, ,     /**,      * Delegates to {@link #contains contains}.,      * @param value the value to look for.,      * @return true if the table contains the value.,      */,     public boolean containsValue(Object value) {,         return contains(value);,     }, ,     /**,      * Get an enumeration over the keys.,      * @return an enumeration.,      */,     public Enumeration keys() {,         initAll();,         return super.keys();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LineOrientedOutputStream.java,processLine,109-109,[        processLine(new String(line));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LineOrientedOutputStreamRedirector.java,<clinit>,40-40,[        System.getProperty("line.separator").getBytes();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LineOrientedOutputStreamRedirector.java,processLine,54-54,[        stream.write((line + System.getProperty("line.separator")).getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LineOrientedOutputStreamTest.java,writeByteArray,124-124,[        stream.write(LINE.getBytes(), 0, LINE.length());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LineOrientedOutputStreamTest.java,writeSingleBytes,128-128,[        byte[] b = LINE.getBytes();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/util/LineOrientedOutputStreamTest.java,,138-151,[    private class DummyStream extends LineOrientedOutputStream {,         private boolean invoked;,         protected void processLine(String line) {,             assertFalse("Only one line", invoked);,             assertEquals(LINE, line);,             invoked = true;,         }, ,         private void assertInvoked() {,             assertTrue("At least one line", invoked);,         },         private void assertNotInvoked() {,             assertTrue("No output", !invoked);,         }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/util/MergingMapper.java,mapFileName,64-64,[        return mergedFile;],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/tools/ant/util/OutputStreamFunneler.java,release,147-147,[                        wait(timeoutMillis);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/util/ProcessUtil.java,main,61-61,[        } catch (Exception exc) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/PropertyOutputStream.java,close,63-63,[            String s = new String(toByteArray());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ReaderInputStreamTest.java,testReadZero,76-76,[        assertEquals("abc".getBytes().length, readin);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/tools/ant/util/ReaderInputStreamTest.java,testReadZero,72-72,[        r.read(bytes, 0, 0);],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/tools/ant/util/ReaderInputStreamTest.java,testSimpleAbc16,63-63,[        new String(bytes, 0, bytes.length, "utf-16");],,
STYLE,UC_USELESS_OBJECT,org/apache/tools/ant/util/ReaderInputStreamTest.java,testSimpleAbc16,50-50,[        byte[] bytes = new byte[40];],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/tools/ant/util/ReflectUtil.java,getField,151-151,[            field.setAccessible(true);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/util/ReflectUtil.java,invoke,110-110,[        } catch (Exception t) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/util/ReflectUtil.java,invoke,134-134,[        } catch (Exception t) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/util/ReflectWrapper.java,<init>,43-43,[        } catch (Exception t) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/util/RegexpPatternMapper.java,mapFileName,124-124,[            return null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ResourceUtils.java,copyWithFilterChainsOrTranscoding,728-728,[                isr = new InputStreamReader(source.getInputStream());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ResourceUtils.java,copyWithFilterChainsOrTranscoding,737-737,[                osw = new OutputStreamWriter(os);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ResourceUtils.java,copyWithFilterSets,670-670,[                isr = new InputStreamReader(source.getInputStream());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ResourceUtils.java,copyWithFilterSets,679-679,[                osw = new OutputStreamWriter(os);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ResourceUtils.java,textCompare,615-615,[            in1 = new BufferedReader(new InputStreamReader(r1.getInputStream()));],,textCompare,616-616,[            in2 = new BufferedReader(new InputStreamReader(r2.getInputStream()));],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/util/ResourceUtils.java,selectSources,194-194,[            srName = srName == null],,
STYLE,RV_DONT_JUST_NULL_CHECK_READLINE,org/apache/tools/ant/util/ResourceUtils.java,textCompare,629-629,[            return in2.readLine() == null ? 0 : -1;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ScriptRunnerBase.java,loadResource,241-241,[        readSource(new InputStreamReader(in), name);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ScriptRunnerBase.java,setSrc,199-199,[            readSource(new FileReader(file), filename);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/ScriptRunnerBase.java,setSrc,199-199,[            readSource(new FileReader(file), filename);],,setSrc,203-203,[        }],,setSrc,204-204,[    }],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/util/ScriptRunnerBase.java,addBeans,73-73,[                Object val = dictionary.get(key);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/util/ScriptRunnerCreator.java,createRunner,113-113,[        if (!manager.equals(AUTO) && !manager.equals(checkManager)) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/util/ScriptRunnerHelper.java,,164-164,[        scriptLoader = loader;],,,168-168,[        if (scriptLoader != null) {],,,169-169,[            return scriptLoader;],,,175-175,[        scriptLoader = cpDelegate.getClassLoader();],,,176-176,[        return scriptLoader;],,,172-172,[            scriptLoader = getClass().getClassLoader();],,,173-173,[            return scriptLoader;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/util/ScriptRunnerHelper.java,getRunner,193-193,[        return new ScriptRunnerCreator(projectComponent.getProject()).createRunner(],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/util/SourceFileScanner.java,,96-98,[            v.addElement(new FileResource(srcDir, name) {,                 public String getName() {,                     return name;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/util/SplitClassLoader.java,<init>,40-40,[        this.splitClasses = splitClasses;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/util/SymbolicLinkUtils.java,,179-181,[            final String[] c = parent.list(new FilenameFilter() {,                     public boolean accept(final File d, final String n) {,                         return localName.equals(n);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/SymlinkUtilsTest.java,testRootIsNoSymlink,37-37,[        assertFalse(SYMLINK_UTILS.isSymbolicLink("/"));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/UUEncoder.java,encodeString,85-85,[        PrintStream writer = new PrintStream(out);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/util/UnicodeUtil.java,EscapeUnicode,36-44,[        StringBuffer unicodeBuf = new StringBuffer("u0000");,         String s = Integer.toHexString(ch);,         //replace the last 0s by the chars contained in s,         for (int i = 0; i < s.length(); i++) {,             unicodeBuf.setCharAt(unicodeBuf.length(),                                  - s.length() + i,,                                  s.charAt(i));,         },         return unicodeBuf;],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/tools/ant/util/WorkerAnt.java,waitUntilFinished,122-122,[                notify.wait(timeout);],,
MALICIOUS_CODE,MS_OOI_PKGPROTECT,org/apache/tools/bzip2/BZip2Constants.java,,55-55,[    int[] rNums = {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/mail/MailMessage.java,replyto,207-208,[      this.replyto.addElement(rto);,     }],,replyTo,678-679,[            replyToList.add(replyTo);,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessageTest.java,testAsciiCharset,459-459,[            baos1.toString(), baos2.toString() ); // order of headers cannot be guaranteed],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessageTest.java,testAsciiCharset,450-450,[        PrintStream bos1 = new PrintStream(baos1, true);],,testAsciiCharset,451-451,[        PrintStream bos2 = new PrintStream(baos2, true);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/mail/MailMessageTest.java,,585-703,[    private class ClientThread implements Runnable {, ,         private MailMessage msg;,         private boolean fail = false;,         private String failMessage = null;, ,         protected String from = null;,         protected String subject = null;,         protected String message = null;, ,         protected Vector replyToList = new Vector();,         protected Vector toList = new Vector();,         protected Vector ccList = new Vector();,         protected Vector bccList = new Vector();, , ,         public void run() {,             for (int i = 9; i > 0; i--) {,                 try {,                     msg = new MailMessage("localhost", TEST_PORT);,                 } catch (java.net.ConnectException ce) {,                     try {,                         Thread.sleep(10 * 1000);,                     } catch (InterruptedException ie) {,                         throw new AssumptionViolatedException("Thread interrupted", ie);,                     },                 } catch (IOException ioe) {,                     fail = true;,                     failMessage = "IOException: " + ioe;,                     return;,                 },                 if (msg != null) {,                     break;,                 },             }, ,             if (msg == null) {,                 fail = true;,                 failMessage = "java.net.ConnectException: Connection refused";,                 return;,             }, ,             try {,                 msg.from(from);, ,                 Enumeration e;, ,                 e = replyToList.elements();,                 while (e.hasMoreElements()) {,                     msg.replyto(e.nextElement().toString());,                 }, ,                 e = toList.elements();,                 while (e.hasMoreElements()) {,                     msg.to(e.nextElement().toString());,                 }, ,                 e = ccList.elements();,                 while (e.hasMoreElements()) {,                     msg.cc(e.nextElement().toString());,                 }, ,                 e = bccList.elements();,                 while (e.hasMoreElements()) {,                     msg.bcc(e.nextElement().toString());,                 }, ,                 if (subject != null) {,                     msg.setSubject(subject);,                 }, ,                 if (message != null ) {,                     PrintStream out = msg.getPrintStream();,                     out.println( message );,                 }, ,                 msg.sendAndClose();,             } catch (IOException ioe) {,                 fail = true;,                 failMessage = "IOException: " + ioe;,                 return;,             },         }, ,         public boolean isFailed() {,             return fail;,         }, ,         public String getFailMessage() {,             return failMessage;,         }, ,         public void replyTo(String replyTo) {,             replyToList.add(replyTo);,         }, ,         public void to(String to) {,             toList.add(to);,         }, ,         public void cc(String cc) {,             ccList.add(cc);,         }, ,         public void bcc(String bcc) {,             bccList.add(bcc);,         }, ,         public void setSubject(String subject) {,             this.subject = subject;,         }, ,         public void from(String from) {,             this.from = from;,         }, ,         public void setMessage(String message) {,             this.message = message;,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessageTest.java,run,485-485,[                    sock.getInputStream()) );],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessageTest.java,run,487-487,[                    sock.getOutputStream() ) );],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessage.java,<init>,491-491,[    super(out, true);  // deprecated, but email is byte-oriented],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/SmtpResponseReader.java,<init>,45-45,[        reader = new BufferedReader(new InputStreamReader(in));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/tar/TarBuffer.java,readRecord,221-221,[            return null;],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/tools/tar/TarEntry.java,getGroupName,480-480,[        return groupName.toString();],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/tools/tar/TarEntry.java,getLinkName,408-408,[        return linkName.toString();],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/tools/tar/TarEntry.java,getName,381-381,[        return name.toString();],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/tools/tar/TarEntry.java,getUserName,462-462,[        return userName.toString();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/tar/TarEntry.java,getDirectoryEntries,780-780,[        TarEntry[] result = new TarEntry[list.length];],,getDirectoryEntries,779-779,[        String[]   list = file.list();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/tar/TarEntry.java,normalizeFileName,987-987,[        if (osname != null) {],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/tar/TarEntryTest.java,testFileConstructor,33-33,[        new TarEntry(new java.io.File("/foo"));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/tar/TarInputStream.java,getLongNameData,361-361,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/tar/TarInputStream.java,getRecord,391-391,[            return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/tar/TarOutputStream.java,putNextEntry,281-281,[        boolean paxHeaderContainsLinkPath = linkName != null && linkName.length() > 0],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/tar/TarOutputStream.java,,154-154,[        this.debug = false;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/tar/TarUtils.java,exceptionMessage,243-243,[        String string = new String(buffer, offset, length);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/AsiExtraField.java,getLocalFileDataData,145-145,[        byte[] linkArray = getLinkedFile().getBytes(); // Uses default charset - see class Javadoc],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/AsiExtraField.java,getLocalFileDataLength,121-121,[                          + getLinkedFile().getBytes().length);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/AsiExtraField.java,parseFromLocalFileData,318-318,[            link = new String(linkArray); // Uses default charset - see class Javadoc],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/tools/zip/ExtraFieldUtils.java,parse,161-167,[                    v.add(field);,                     //$FALL-THROUGH$,                 case UnparseableExtraField.SKIP_KEY:,                     // since we cannot parse the data we must assume,                     // the extra field consumes the whole rest of the,                     // available data,                     break LOOP;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/FallbackZipEncoding.java,decode,89-89,[            return new String(data);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/FallbackZipEncoding.java,encode,77-77,[            return ByteBuffer.wrap(name.getBytes());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/zip/UTF8ZipFilesTest.java,testFileRoundtrip,117-117,[                file.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/zip/UTF8ZipFilesTest.java,testZipFileReadsUnicodeFields,102-102,[                file.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/zip/UnrecognizedExtraField.java,getLocalFileDataLength,77-77,[        return new ZipShort(localData.length);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/zip/ZipEntry.java,,56-716,[    private static final byte[] EMPTY = new byte[0];, ,     /**,      * The {@link java.util.zip.ZipEntry} base class only supports,      * the compression methods STORED and DEFLATED. We override the,      * field so that any compression methods can be used.,      * <p>,      * The default value -1 means that the method has not been specified.,      */,     private int method = -1;, ,     /**,      * The {@link java.util.zip.ZipEntry#setSize} method in the base,      * class throws an IllegalArgumentException if the size is bigger,      * than 2GB for Java versions < 7.  Need to keep our own size,      * information for Zip64 support.,      */,     private long size = -1;, ,     private int internalAttributes = 0;,     private int platform = PLATFORM_FAT;,     private long externalAttributes = 0;,     private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;,     private UnparseableExtraFieldData unparseableExtra = null;,     private String name = null;,     private byte[] rawName = null;,     private GeneralPurposeBit gpb = new GeneralPurposeBit();, ,     /**,      * Creates a new zip entry with the specified name.,      *,      * <p>Assumes the entry represents a directory if and only if the,      * name ends with a forward slash "/".</p>,      *,      * @param name the name of the entry,      * @since 1.1,      */,     public ZipEntry(final String name) {,         super(name);,         setName(name);,     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      *,      * <p>Assumes the entry represents a directory if and only if the,      * name ends with a forward slash "/".</p>,      *,      * @param entry the entry to get fields from,      * @since 1.1,      * @throws ZipException on error,      */,     public ZipEntry(final java.util.zip.ZipEntry entry) throws ZipException {,         super(entry);,         setName(entry.getName());,         final byte[] extra = entry.getExtra();,         if (extra != null) {,             setExtraFields(ExtraFieldUtils.parse(extra, true,,                                                  ExtraFieldUtils,                                                  .UnparseableExtraField.READ));,         } else {,             // initializes extra data to an empty byte array,             setExtra();,         },         setMethod(entry.getMethod());,         this.size = entry.getSize();,     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      *,      * <p>Assumes the entry represents a directory if and only if the,      * name ends with a forward slash "/".</p>,      *,      * @param entry the entry to get fields from,      * @throws ZipException on error,      * @since 1.1,      */,     public ZipEntry(final ZipEntry entry) throws ZipException {,         this((java.util.zip.ZipEntry) entry);,         setInternalAttributes(entry.getInternalAttributes());,         setExternalAttributes(entry.getExternalAttributes());,         setExtraFields(entry.getExtraFields(true));,         setPlatform(entry.platform);,         setGeneralPurposeBit(entry.gpb == null ? null :,                              (GeneralPurposeBit) entry.gpb.clone());,     }, ,     /**,      * @since 1.9,      */,     protected ZipEntry() {,         this("");,     }, ,     /**,      * Creates a new zip entry taking some information from the given,      * file and using the provided name.,      *,      * <p>The name will be adjusted to end with a forward slash "/" if,      * the file is a directory.  If the file is not a directory a,      * potential trailing forward slash will be stripped from the,      * entry name.</p>,      */,     public ZipEntry(final File inputFile, final String entryName) {,         this(inputFile.isDirectory() && !entryName.endsWith("/") ?,              entryName + "/" : entryName);,         if (inputFile.isFile()){,             setSize(inputFile.length());,         },         setTime(inputFile.lastModified());,         // TODO are there any other fields we can set here?,     }, ,     /**,      * Overwrite clone.,      * @return a cloned copy of this ZipEntry,      * @since 1.1,      */,     @Override,     public Object clone() {,         final ZipEntry e = (ZipEntry) super.clone();, ,         e.setInternalAttributes(getInternalAttributes());,         e.setExternalAttributes(getExternalAttributes());,         e.setExtraFields(getExtraFields(true));,         return e;,     }, ,     /**,      * Returns the compression method of this entry, or -1 if the,      * compression method has not been specified.,      *,      * @return compression method,      */,     @Override,     public int getMethod() {,         return method;,     }, ,     /**,      * Sets the compression method of this entry.,      *,      * @param method compression method,      */,     @Override,     public void setMethod(final int method) {,         if (method < 0) {,             throw new IllegalArgumentException(,                     "ZIP compression method can not be negative: " + method);,         },         this.method = method;,     }, ,     /**,      * Retrieves the internal file attributes.,      *,      * @return the internal file attributes,      * @since 1.1,      */,     public int getInternalAttributes() {,         return internalAttributes;,     }, ,     /**,      * Sets the internal file attributes.,      * @param value an <code>int</code> value,      * @since 1.1,      */,     public void setInternalAttributes(final int value) {,         internalAttributes = value;,     }, ,     /**,      * Retrieves the external file attributes.,      * @return the external file attributes,      * @since 1.1,      */,     public long getExternalAttributes() {,         return externalAttributes;,     }, ,     /**,      * Sets the external file attributes.,      * @param value an <code>long</code> value,      * @since 1.1,      */,     public void setExternalAttributes(final long value) {,         externalAttributes = value;,     }, ,     /**,      * Sets Unix permissions in a way that is understood by Info-Zip's,      * unzip command.,      * @param mode an <code>int</code> value,      * @since Ant 1.5.2,      */,     public void setUnixMode(final int mode) {,         // CheckStyle:MagicNumberCheck OFF - no point,         setExternalAttributes((mode << SHORT_SHIFT),                               // MS-DOS read-only attribute,                               | ((mode & 0200) == 0 ? 1 : 0),                               // MS-DOS directory flag,                               | (isDirectory() ? 0x10 : 0));,         // CheckStyle:MagicNumberCheck ON,         platform = PLATFORM_UNIX;,     }, ,     /**,      * Unix permission.,      * @return the unix permissions,      * @since Ant 1.6,      */,     public int getUnixMode() {,         return platform != PLATFORM_UNIX ? 0 :,             (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);,     }, ,     /**,      * Platform specification to put into the &quot;version made,      * by&quot; part of the central file header.,      *,      * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode},      * has been called, in which case PLATFORM_UNIX will be returned.,      *,      * @since Ant 1.5.2,      */,     public int getPlatform() {,         return platform;,     }, ,     /**,      * Set the platform (UNIX or FAT).,      * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX,      * @since 1.9,      */,     protected void setPlatform(final int platform) {,         this.platform = platform;,     }, ,     /**,      * Replaces all currently attached extra fields with the new array.,      * @param fields an array of extra fields,      * @since 1.1,      */,     public void setExtraFields(final ZipExtraField[] fields) {,         extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();,         for (final ZipExtraField field : fields) {,             if (field instanceof UnparseableExtraFieldData) {,                 unparseableExtra = (UnparseableExtraFieldData) field;,             } else {,                 extraFields.put(field.getHeaderId(), field);,             },         },         setExtra();,     }, ,     /**,      * Retrieves all extra fields that have been parsed successfully.,      * @return an array of the extra fields,      */,     public ZipExtraField[] getExtraFields() {,         return getExtraFields(false);,     }, ,     /**,      * Retrieves extra fields.,      * @param includeUnparseable whether to also return unparseable,      * extra fields as {@link UnparseableExtraFieldData} if such data,      * exists.,      * @return an array of the extra fields,      * @since 1.1,      */,     public ZipExtraField[] getExtraFields(final boolean includeUnparseable) {,         if (extraFields == null) {,             return !includeUnparseable || unparseableExtra == null,                 ? new ZipExtraField[0],                 : new ZipExtraField[] {unparseableExtra};,         },         final List<ZipExtraField> result =,             new ArrayList<ZipExtraField>(extraFields.values());,         if (includeUnparseable && unparseableExtra != null) {,             result.add(unparseableExtra);,         },         return result.toArray(new ZipExtraField[0]);,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>If no extra field of the same type exists, the field will be,      * added as last field.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addExtraField(final ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             if (extraFields == null) {,                 extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();,             },             extraFields.put(ze.getHeaderId(), ze);,         },         setExtra();,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>The new extra field will be the first one.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addAsFirstExtraField(final ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             final LinkedHashMap<ZipShort, ZipExtraField> copy = extraFields;,             extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();,             extraFields.put(ze.getHeaderId(), ze);,             if (copy != null) {,                 copy.remove(ze.getHeaderId());,                 extraFields.putAll(copy);,             },         },         setExtra();,     }, ,     /**,      * Remove an extra field.,      * @param type the type of extra field to remove,      * @since 1.1,      */,     public void removeExtraField(final ZipShort type) {,         if (extraFields == null) {,             throw new java.util.NoSuchElementException();,         },         if (extraFields.remove(type) == null) {,             throw new java.util.NoSuchElementException();,         },         setExtra();,     }, ,     /**,      * Removes unparseable extra field data.,      */,     public void removeUnparseableExtraFieldData() {,         if (unparseableExtra == null) {,             throw new java.util.NoSuchElementException();,         },         unparseableExtra = null;,         setExtra();,     }, ,     /**,      * Looks up an extra field by its header id.,      *,      * @return null if no such field exists.,      */,     public ZipExtraField getExtraField(final ZipShort type) {,         if (extraFields != null) {,             return extraFields.get(type);,         },         return null;,     }, ,     /**,      * Looks up extra field data that couldn't be parsed correctly.,      *,      * @return null if no such field exists.,      */,     public UnparseableExtraFieldData getUnparseableExtraFieldData() {,         return unparseableExtra;,     }, ,     /**,      * Parses the given bytes as extra field data and consumes any,      * unparseable data as an {@link UnparseableExtraFieldData},      * instance.,      * @param extra an array of bytes to be parsed into extra fields,      * @throws RuntimeException if the bytes cannot be parsed,      * @since 1.1,      * @throws RuntimeException on error,      */,     @Override,     public void setExtra(final byte[] extra) throws RuntimeException {,         try {,             final ZipExtraField[] local =,                 ExtraFieldUtils.parse(extra, true,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(local, true);,         } catch (final ZipException e) {,             // actually this is not be possible as of Ant 1.8.1,             throw new RuntimeException("Error parsing extra fields for entry: ",                                        + getName() + " - " + e.getMessage(), e);,         },     }, ,     /**,      * Unfortunately {@link java.util.zip.ZipOutputStream,      * java.util.zip.ZipOutputStream} seems to access the extra data,      * directly, so overriding getExtra doesn't help - we need to,      * modify super's data directly.,      *,      * @since 1.1,      */,     protected void setExtra() {,         super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));,     }, ,     /**,      * Sets the central directory part of extra fields.,      */,     public void setCentralDirectoryExtra(final byte[] b) {,         try {,             final ZipExtraField[] central =,                 ExtraFieldUtils.parse(b, false,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(central, false);,         } catch (final ZipException e) {,             throw new RuntimeException(e.getMessage(), e);,         },     }, ,     /**,      * Retrieves the extra data for the local file data.,      * @return the extra data for local file,      * @since 1.1,      */,     public byte[] getLocalFileDataExtra() {,         final byte[] extra = getExtra();,         return extra != null ? extra : EMPTY;,     }, ,     /**,      * Retrieves the extra data for the central directory.,      * @return the central directory extra data,      * @since 1.1,      */,     public byte[] getCentralDirectoryExtra() {,         return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));,     }, ,     /**,      * Make this class work in JDK 1.1 like a 1.2 class.,      *,      * <p>This either stores the size for later usage or invokes,      * setCompressedSize via reflection.</p>,      * @param size the size to use,      * @deprecated since 1.7.,      *             Use setCompressedSize directly.,      * @since 1.2,      */,     @Deprecated,     public void setComprSize(final long size) {,         setCompressedSize(size);,     }, ,     /**,      * Get the name of the entry.,      * @return the entry name,      * @since 1.9,      */,     @Override,     public String getName() {,         return name == null ? super.getName() : name;,     }, ,     /**,      * Is this entry a directory?,      * @return true if the entry is a directory,      * @since 1.10,      */,     @Override,     public boolean isDirectory() {,         return getName().endsWith("/");,     }, ,     /**,      * Set the name of the entry.,      * @param name the name to use,      */,     protected void setName(String name) {,         if (name != null && getPlatform() == PLATFORM_FAT,             && name.indexOf("/") == -1) {,             name = name.replace('\\', '/');,         },         this.name = name;,     }, ,     /**,      * Gets the uncompressed size of the entry data.,      * @return the entry size,      */,     @Override,     public long getSize() {,         return size;,     }, ,     /**,      * Sets the uncompressed size of the entry data.,      * @param size the uncompressed size in bytes,      * @exception IllegalArgumentException if the specified size is less,      *            than 0,      */,     @Override,     public void setSize(final long size) {,         if (size < 0) {,             throw new IllegalArgumentException("invalid entry size");,         },         this.size = size;,     }, ,     /**,      * Sets the name using the raw bytes and the string created from,      * it by guessing or using the configured encoding.,      * @param name the name to use created from the raw bytes using,      * the guessed or configured encoding,      * @param rawName the bytes originally read as name from the,      * archive,      */,     protected void setName(final String name, final byte[] rawName) {,         setName(name);,         this.rawName = rawName;,     }, ,     /**,      * Returns the raw bytes that made up the name before it has been,      * converted using the configured or guessed encoding.,      *,      * <p>This method will return null if this instance has not been,      * read from an archive.</p>,      */,     public byte[] getRawName() {,         if (rawName != null) {,             final byte[] b = new byte[rawName.length];,             System.arraycopy(rawName, 0, b, 0, rawName.length);,             return b;,         },         return null;,     }, ,     /**,      * Get the hashCode of the entry.,      * This uses the name as the hashcode.,      * @return a hashcode.,      * @since Ant 1.7,      */,     @Override,     public int hashCode() {,         // this method has severe consequences on performance. We cannot rely,         // on the super.hashCode() method since super.getName() always return,         // the empty string in the current implemention (there's no setter),         // so it is basically draining the performance of a hashmap lookup,         return getName().hashCode();,     }, ,     /**,      * The "general purpose bit" field.,      */,     public GeneralPurposeBit getGeneralPurposeBit() {,         return gpb;,     }, ,     /**,      * The "general purpose bit" field.,      */,     public void setGeneralPurposeBit(final GeneralPurposeBit b) {,         gpb = b;,     }, ,     /**,      * If there are no extra fields, use the given fields as new extra,      * data - otherwise merge the fields assuming the existing fields,      * and the new fields stem from different locations inside the,      * archive.,      * @param f the extra fields to merge,      * @param local whether the new fields originate from local data,      */,     private void mergeExtraFields(final ZipExtraField[] f, final boolean local),         throws ZipException {,         if (extraFields == null) {,             setExtraFields(f);,         } else {,             for (final ZipExtraField element : f) {,                 ZipExtraField existing;,                 if (element instanceof UnparseableExtraFieldData) {,                     existing = unparseableExtra;,                 } else {,                     existing = getExtraField(element.getHeaderId());,                 },                 if (existing == null) {,                     addExtraField(element);,                 } else {,                     if (local,                         || !(existing,                              instanceof CentralDirectoryParsingZipExtraField)) {,                         final byte[] b = element.getLocalFileDataData();,                         existing.parseFromLocalFileData(b, 0, b.length);,                     } else {,                         final byte[] b = element.getCentralDirectoryData();,                         ((CentralDirectoryParsingZipExtraField) existing),                             .parseFromCentralDirectoryData(b, 0, b.length);,                     },                 },             },             setExtra();,         },     }, ,     /** {@inheritDoc} */,     public Date getLastModifiedDate() {,         return new Date(getTime());,     }, ,     /* (non-Javadoc),      * @see java.lang.Object#equals(java.lang.Object),      */,     @Override,     public boolean equals(final Object obj) {,         if (this == obj) {,             return true;,         },         if (obj == null || getClass() != obj.getClass()) {,             return false;,         },         final ZipEntry other = (ZipEntry) obj;,         final String myName = getName();,         final String otherName = other.getName();,         if (myName == null) {,             if (otherName != null) {,                 return false;,             },         } else if (!myName.equals(otherName)) {,             return false;,         },         String myComment = getComment();,         String otherComment = other.getComment();,         if (myComment == null) {,             myComment = "";,         },         if (otherComment == null) {,             otherComment = "";,         },         return getTime() == other.getTime(),             && myComment.equals(otherComment),             && getInternalAttributes() == other.getInternalAttributes(),             && getPlatform() == other.getPlatform(),             && getExternalAttributes() == other.getExternalAttributes(),             && getMethod() == other.getMethod(),             && getSize() == other.getSize(),             && getCrc() == other.getCrc(),             && getCompressedSize() == other.getCompressedSize(),             && Arrays.equals(getCentralDirectoryExtra(),,                              other.getCentralDirectoryExtra()),             && Arrays.equals(getLocalFileDataExtra(),,                              other.getLocalFileDataExtra()),             && gpb.equals(other.gpb);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/zip/UnsupportedZipFeatureException.java,,68-86,[        public static final Feature ENCRYPTION = new Feature("encryption");,         /**,          * The entry used an unsupported compression method.,          */,         public static final Feature METHOD = new Feature("compression method");,         /**,          * The entry uses a data descriptor.,          */,         public static final Feature DATA_DESCRIPTOR = new Feature("data descriptor");, ,         private final String name;, ,         private Feature(String name) {,             this.name = name;,         }, ,         @Override,         public String toString() {,             return name;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/zip/Zip64ExtendedInformationExtraField.java,getCentralDirectoryData,143-143,[            off += WORD;],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/zip/Zip64ExtendedInformationExtraField.java,parseFromLocalFileData,174-174,[            remaining -= WORD;],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/tools/zip/ZipEntry.java,,56-716,[    private static final byte[] EMPTY = new byte[0];, ,     /**,      * The {@link java.util.zip.ZipEntry} base class only supports,      * the compression methods STORED and DEFLATED. We override the,      * field so that any compression methods can be used.,      * <p>,      * The default value -1 means that the method has not been specified.,      */,     private int method = -1;, ,     /**,      * The {@link java.util.zip.ZipEntry#setSize} method in the base,      * class throws an IllegalArgumentException if the size is bigger,      * than 2GB for Java versions < 7.  Need to keep our own size,      * information for Zip64 support.,      */,     private long size = -1;, ,     private int internalAttributes = 0;,     private int platform = PLATFORM_FAT;,     private long externalAttributes = 0;,     private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;,     private UnparseableExtraFieldData unparseableExtra = null;,     private String name = null;,     private byte[] rawName = null;,     private GeneralPurposeBit gpb = new GeneralPurposeBit();, ,     /**,      * Creates a new zip entry with the specified name.,      *,      * <p>Assumes the entry represents a directory if and only if the,      * name ends with a forward slash "/".</p>,      *,      * @param name the name of the entry,      * @since 1.1,      */,     public ZipEntry(final String name) {,         super(name);,         setName(name);,     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      *,      * <p>Assumes the entry represents a directory if and only if the,      * name ends with a forward slash "/".</p>,      *,      * @param entry the entry to get fields from,      * @since 1.1,      * @throws ZipException on error,      */,     public ZipEntry(final java.util.zip.ZipEntry entry) throws ZipException {,         super(entry);,         setName(entry.getName());,         final byte[] extra = entry.getExtra();,         if (extra != null) {,             setExtraFields(ExtraFieldUtils.parse(extra, true,,                                                  ExtraFieldUtils,                                                  .UnparseableExtraField.READ));,         } else {,             // initializes extra data to an empty byte array,             setExtra();,         },         setMethod(entry.getMethod());,         this.size = entry.getSize();,     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      *,      * <p>Assumes the entry represents a directory if and only if the,      * name ends with a forward slash "/".</p>,      *,      * @param entry the entry to get fields from,      * @throws ZipException on error,      * @since 1.1,      */,     public ZipEntry(final ZipEntry entry) throws ZipException {,         this((java.util.zip.ZipEntry) entry);,         setInternalAttributes(entry.getInternalAttributes());,         setExternalAttributes(entry.getExternalAttributes());,         setExtraFields(entry.getExtraFields(true));,         setPlatform(entry.platform);,         setGeneralPurposeBit(entry.gpb == null ? null :,                              (GeneralPurposeBit) entry.gpb.clone());,     }, ,     /**,      * @since 1.9,      */,     protected ZipEntry() {,         this("");,     }, ,     /**,      * Creates a new zip entry taking some information from the given,      * file and using the provided name.,      *,      * <p>The name will be adjusted to end with a forward slash "/" if,      * the file is a directory.  If the file is not a directory a,      * potential trailing forward slash will be stripped from the,      * entry name.</p>,      */,     public ZipEntry(final File inputFile, final String entryName) {,         this(inputFile.isDirectory() && !entryName.endsWith("/") ?,              entryName + "/" : entryName);,         if (inputFile.isFile()){,             setSize(inputFile.length());,         },         setTime(inputFile.lastModified());,         // TODO are there any other fields we can set here?,     }, ,     /**,      * Overwrite clone.,      * @return a cloned copy of this ZipEntry,      * @since 1.1,      */,     @Override,     public Object clone() {,         final ZipEntry e = (ZipEntry) super.clone();, ,         e.setInternalAttributes(getInternalAttributes());,         e.setExternalAttributes(getExternalAttributes());,         e.setExtraFields(getExtraFields(true));,         return e;,     }, ,     /**,      * Returns the compression method of this entry, or -1 if the,      * compression method has not been specified.,      *,      * @return compression method,      */,     @Override,     public int getMethod() {,         return method;,     }, ,     /**,      * Sets the compression method of this entry.,      *,      * @param method compression method,      */,     @Override,     public void setMethod(final int method) {,         if (method < 0) {,             throw new IllegalArgumentException(,                     "ZIP compression method can not be negative: " + method);,         },         this.method = method;,     }, ,     /**,      * Retrieves the internal file attributes.,      *,      * @return the internal file attributes,      * @since 1.1,      */,     public int getInternalAttributes() {,         return internalAttributes;,     }, ,     /**,      * Sets the internal file attributes.,      * @param value an <code>int</code> value,      * @since 1.1,      */,     public void setInternalAttributes(final int value) {,         internalAttributes = value;,     }, ,     /**,      * Retrieves the external file attributes.,      * @return the external file attributes,      * @since 1.1,      */,     public long getExternalAttributes() {,         return externalAttributes;,     }, ,     /**,      * Sets the external file attributes.,      * @param value an <code>long</code> value,      * @since 1.1,      */,     public void setExternalAttributes(final long value) {,         externalAttributes = value;,     }, ,     /**,      * Sets Unix permissions in a way that is understood by Info-Zip's,      * unzip command.,      * @param mode an <code>int</code> value,      * @since Ant 1.5.2,      */,     public void setUnixMode(final int mode) {,         // CheckStyle:MagicNumberCheck OFF - no point,         setExternalAttributes((mode << SHORT_SHIFT),                               // MS-DOS read-only attribute,                               | ((mode & 0200) == 0 ? 1 : 0),                               // MS-DOS directory flag,                               | (isDirectory() ? 0x10 : 0));,         // CheckStyle:MagicNumberCheck ON,         platform = PLATFORM_UNIX;,     }, ,     /**,      * Unix permission.,      * @return the unix permissions,      * @since Ant 1.6,      */,     public int getUnixMode() {,         return platform != PLATFORM_UNIX ? 0 :,             (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);,     }, ,     /**,      * Platform specification to put into the &quot;version made,      * by&quot; part of the central file header.,      *,      * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode},      * has been called, in which case PLATFORM_UNIX will be returned.,      *,      * @since Ant 1.5.2,      */,     public int getPlatform() {,         return platform;,     }, ,     /**,      * Set the platform (UNIX or FAT).,      * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX,      * @since 1.9,      */,     protected void setPlatform(final int platform) {,         this.platform = platform;,     }, ,     /**,      * Replaces all currently attached extra fields with the new array.,      * @param fields an array of extra fields,      * @since 1.1,      */,     public void setExtraFields(final ZipExtraField[] fields) {,         extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();,         for (final ZipExtraField field : fields) {,             if (field instanceof UnparseableExtraFieldData) {,                 unparseableExtra = (UnparseableExtraFieldData) field;,             } else {,                 extraFields.put(field.getHeaderId(), field);,             },         },         setExtra();,     }, ,     /**,      * Retrieves all extra fields that have been parsed successfully.,      * @return an array of the extra fields,      */,     public ZipExtraField[] getExtraFields() {,         return getExtraFields(false);,     }, ,     /**,      * Retrieves extra fields.,      * @param includeUnparseable whether to also return unparseable,      * extra fields as {@link UnparseableExtraFieldData} if such data,      * exists.,      * @return an array of the extra fields,      * @since 1.1,      */,     public ZipExtraField[] getExtraFields(final boolean includeUnparseable) {,         if (extraFields == null) {,             return !includeUnparseable || unparseableExtra == null,                 ? new ZipExtraField[0],                 : new ZipExtraField[] {unparseableExtra};,         },         final List<ZipExtraField> result =,             new ArrayList<ZipExtraField>(extraFields.values());,         if (includeUnparseable && unparseableExtra != null) {,             result.add(unparseableExtra);,         },         return result.toArray(new ZipExtraField[0]);,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>If no extra field of the same type exists, the field will be,      * added as last field.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addExtraField(final ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             if (extraFields == null) {,                 extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();,             },             extraFields.put(ze.getHeaderId(), ze);,         },         setExtra();,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>The new extra field will be the first one.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addAsFirstExtraField(final ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             final LinkedHashMap<ZipShort, ZipExtraField> copy = extraFields;,             extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();,             extraFields.put(ze.getHeaderId(), ze);,             if (copy != null) {,                 copy.remove(ze.getHeaderId());,                 extraFields.putAll(copy);,             },         },         setExtra();,     }, ,     /**,      * Remove an extra field.,      * @param type the type of extra field to remove,      * @since 1.1,      */,     public void removeExtraField(final ZipShort type) {,         if (extraFields == null) {,             throw new java.util.NoSuchElementException();,         },         if (extraFields.remove(type) == null) {,             throw new java.util.NoSuchElementException();,         },         setExtra();,     }, ,     /**,      * Removes unparseable extra field data.,      */,     public void removeUnparseableExtraFieldData() {,         if (unparseableExtra == null) {,             throw new java.util.NoSuchElementException();,         },         unparseableExtra = null;,         setExtra();,     }, ,     /**,      * Looks up an extra field by its header id.,      *,      * @return null if no such field exists.,      */,     public ZipExtraField getExtraField(final ZipShort type) {,         if (extraFields != null) {,             return extraFields.get(type);,         },         return null;,     }, ,     /**,      * Looks up extra field data that couldn't be parsed correctly.,      *,      * @return null if no such field exists.,      */,     public UnparseableExtraFieldData getUnparseableExtraFieldData() {,         return unparseableExtra;,     }, ,     /**,      * Parses the given bytes as extra field data and consumes any,      * unparseable data as an {@link UnparseableExtraFieldData},      * instance.,      * @param extra an array of bytes to be parsed into extra fields,      * @throws RuntimeException if the bytes cannot be parsed,      * @since 1.1,      * @throws RuntimeException on error,      */,     @Override,     public void setExtra(final byte[] extra) throws RuntimeException {,         try {,             final ZipExtraField[] local =,                 ExtraFieldUtils.parse(extra, true,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(local, true);,         } catch (final ZipException e) {,             // actually this is not be possible as of Ant 1.8.1,             throw new RuntimeException("Error parsing extra fields for entry: ",                                        + getName() + " - " + e.getMessage(), e);,         },     }, ,     /**,      * Unfortunately {@link java.util.zip.ZipOutputStream,      * java.util.zip.ZipOutputStream} seems to access the extra data,      * directly, so overriding getExtra doesn't help - we need to,      * modify super's data directly.,      *,      * @since 1.1,      */,     protected void setExtra() {,         super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));,     }, ,     /**,      * Sets the central directory part of extra fields.,      */,     public void setCentralDirectoryExtra(final byte[] b) {,         try {,             final ZipExtraField[] central =,                 ExtraFieldUtils.parse(b, false,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(central, false);,         } catch (final ZipException e) {,             throw new RuntimeException(e.getMessage(), e);,         },     }, ,     /**,      * Retrieves the extra data for the local file data.,      * @return the extra data for local file,      * @since 1.1,      */,     public byte[] getLocalFileDataExtra() {,         final byte[] extra = getExtra();,         return extra != null ? extra : EMPTY;,     }, ,     /**,      * Retrieves the extra data for the central directory.,      * @return the central directory extra data,      * @since 1.1,      */,     public byte[] getCentralDirectoryExtra() {,         return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));,     }, ,     /**,      * Make this class work in JDK 1.1 like a 1.2 class.,      *,      * <p>This either stores the size for later usage or invokes,      * setCompressedSize via reflection.</p>,      * @param size the size to use,      * @deprecated since 1.7.,      *             Use setCompressedSize directly.,      * @since 1.2,      */,     @Deprecated,     public void setComprSize(final long size) {,         setCompressedSize(size);,     }, ,     /**,      * Get the name of the entry.,      * @return the entry name,      * @since 1.9,      */,     @Override,     public String getName() {,         return name == null ? super.getName() : name;,     }, ,     /**,      * Is this entry a directory?,      * @return true if the entry is a directory,      * @since 1.10,      */,     @Override,     public boolean isDirectory() {,         return getName().endsWith("/");,     }, ,     /**,      * Set the name of the entry.,      * @param name the name to use,      */,     protected void setName(String name) {,         if (name != null && getPlatform() == PLATFORM_FAT,             && name.indexOf("/") == -1) {,             name = name.replace('\\', '/');,         },         this.name = name;,     }, ,     /**,      * Gets the uncompressed size of the entry data.,      * @return the entry size,      */,     @Override,     public long getSize() {,         return size;,     }, ,     /**,      * Sets the uncompressed size of the entry data.,      * @param size the uncompressed size in bytes,      * @exception IllegalArgumentException if the specified size is less,      *            than 0,      */,     @Override,     public void setSize(final long size) {,         if (size < 0) {,             throw new IllegalArgumentException("invalid entry size");,         },         this.size = size;,     }, ,     /**,      * Sets the name using the raw bytes and the string created from,      * it by guessing or using the configured encoding.,      * @param name the name to use created from the raw bytes using,      * the guessed or configured encoding,      * @param rawName the bytes originally read as name from the,      * archive,      */,     protected void setName(final String name, final byte[] rawName) {,         setName(name);,         this.rawName = rawName;,     }, ,     /**,      * Returns the raw bytes that made up the name before it has been,      * converted using the configured or guessed encoding.,      *,      * <p>This method will return null if this instance has not been,      * read from an archive.</p>,      */,     public byte[] getRawName() {,         if (rawName != null) {,             final byte[] b = new byte[rawName.length];,             System.arraycopy(rawName, 0, b, 0, rawName.length);,             return b;,         },         return null;,     }, ,     /**,      * Get the hashCode of the entry.,      * This uses the name as the hashcode.,      * @return a hashcode.,      * @since Ant 1.7,      */,     @Override,     public int hashCode() {,         // this method has severe consequences on performance. We cannot rely,         // on the super.hashCode() method since super.getName() always return,         // the empty string in the current implemention (there's no setter),         // so it is basically draining the performance of a hashmap lookup,         return getName().hashCode();,     }, ,     /**,      * The "general purpose bit" field.,      */,     public GeneralPurposeBit getGeneralPurposeBit() {,         return gpb;,     }, ,     /**,      * The "general purpose bit" field.,      */,     public void setGeneralPurposeBit(final GeneralPurposeBit b) {,         gpb = b;,     }, ,     /**,      * If there are no extra fields, use the given fields as new extra,      * data - otherwise merge the fields assuming the existing fields,      * and the new fields stem from different locations inside the,      * archive.,      * @param f the extra fields to merge,      * @param local whether the new fields originate from local data,      */,     private void mergeExtraFields(final ZipExtraField[] f, final boolean local),         throws ZipException {,         if (extraFields == null) {,             setExtraFields(f);,         } else {,             for (final ZipExtraField element : f) {,                 ZipExtraField existing;,                 if (element instanceof UnparseableExtraFieldData) {,                     existing = unparseableExtra;,                 } else {,                     existing = getExtraField(element.getHeaderId());,                 },                 if (existing == null) {,                     addExtraField(element);,                 } else {,                     if (local,                         || !(existing,                              instanceof CentralDirectoryParsingZipExtraField)) {,                         final byte[] b = element.getLocalFileDataData();,                         existing.parseFromLocalFileData(b, 0, b.length);,                     } else {,                         final byte[] b = element.getCentralDirectoryData();,                         ((CentralDirectoryParsingZipExtraField) existing),                             .parseFromCentralDirectoryData(b, 0, b.length);,                     },                 },             },             setExtra();,         },     }, ,     /** {@inheritDoc} */,     public Date getLastModifiedDate() {,         return new Date(getTime());,     }, ,     /* (non-Javadoc),      * @see java.lang.Object#equals(java.lang.Object),      */,     @Override,     public boolean equals(final Object obj) {,         if (this == obj) {,             return true;,         },         if (obj == null || getClass() != obj.getClass()) {,             return false;,         },         final ZipEntry other = (ZipEntry) obj;,         final String myName = getName();,         final String otherName = other.getName();,         if (myName == null) {,             if (otherName != null) {,                 return false;,             },         } else if (!myName.equals(otherName)) {,             return false;,         },         String myComment = getComment();,         String otherComment = other.getComment();,         if (myComment == null) {,             myComment = "";,         },         if (otherComment == null) {,             otherComment = "";,         },         return getTime() == other.getTime(),             && myComment.equals(otherComment),             && getInternalAttributes() == other.getInternalAttributes(),             && getPlatform() == other.getPlatform(),             && getExternalAttributes() == other.getExternalAttributes(),             && getMethod() == other.getMethod(),             && getSize() == other.getSize(),             && getCrc() == other.getCrc(),             && getCompressedSize() == other.getCompressedSize(),             && Arrays.equals(getCentralDirectoryExtra(),,                              other.getCentralDirectoryExtra()),             && Arrays.equals(getLocalFileDataExtra(),,                              other.getLocalFileDataExtra()),             && gpb.equals(other.gpb);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/zip/ZipEntry.java,getRawName,598-598,[        return null;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/zip/ZipEntry.java,,56-716,[    private static final byte[] EMPTY = new byte[0];, ,     /**,      * The {@link java.util.zip.ZipEntry} base class only supports,      * the compression methods STORED and DEFLATED. We override the,      * field so that any compression methods can be used.,      * <p>,      * The default value -1 means that the method has not been specified.,      */,     private int method = -1;, ,     /**,      * The {@link java.util.zip.ZipEntry#setSize} method in the base,      * class throws an IllegalArgumentException if the size is bigger,      * than 2GB for Java versions < 7.  Need to keep our own size,      * information for Zip64 support.,      */,     private long size = -1;, ,     private int internalAttributes = 0;,     private int platform = PLATFORM_FAT;,     private long externalAttributes = 0;,     private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;,     private UnparseableExtraFieldData unparseableExtra = null;,     private String name = null;,     private byte[] rawName = null;,     private GeneralPurposeBit gpb = new GeneralPurposeBit();, ,     /**,      * Creates a new zip entry with the specified name.,      *,      * <p>Assumes the entry represents a directory if and only if the,      * name ends with a forward slash "/".</p>,      *,      * @param name the name of the entry,      * @since 1.1,      */,     public ZipEntry(final String name) {,         super(name);,         setName(name);,     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      *,      * <p>Assumes the entry represents a directory if and only if the,      * name ends with a forward slash "/".</p>,      *,      * @param entry the entry to get fields from,      * @since 1.1,      * @throws ZipException on error,      */,     public ZipEntry(final java.util.zip.ZipEntry entry) throws ZipException {,         super(entry);,         setName(entry.getName());,         final byte[] extra = entry.getExtra();,         if (extra != null) {,             setExtraFields(ExtraFieldUtils.parse(extra, true,,                                                  ExtraFieldUtils,                                                  .UnparseableExtraField.READ));,         } else {,             // initializes extra data to an empty byte array,             setExtra();,         },         setMethod(entry.getMethod());,         this.size = entry.getSize();,     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      *,      * <p>Assumes the entry represents a directory if and only if the,      * name ends with a forward slash "/".</p>,      *,      * @param entry the entry to get fields from,      * @throws ZipException on error,      * @since 1.1,      */,     public ZipEntry(final ZipEntry entry) throws ZipException {,         this((java.util.zip.ZipEntry) entry);,         setInternalAttributes(entry.getInternalAttributes());,         setExternalAttributes(entry.getExternalAttributes());,         setExtraFields(entry.getExtraFields(true));,         setPlatform(entry.platform);,         setGeneralPurposeBit(entry.gpb == null ? null :,                              (GeneralPurposeBit) entry.gpb.clone());,     }, ,     /**,      * @since 1.9,      */,     protected ZipEntry() {,         this("");,     }, ,     /**,      * Creates a new zip entry taking some information from the given,      * file and using the provided name.,      *,      * <p>The name will be adjusted to end with a forward slash "/" if,      * the file is a directory.  If the file is not a directory a,      * potential trailing forward slash will be stripped from the,      * entry name.</p>,      */,     public ZipEntry(final File inputFile, final String entryName) {,         this(inputFile.isDirectory() && !entryName.endsWith("/") ?,              entryName + "/" : entryName);,         if (inputFile.isFile()){,             setSize(inputFile.length());,         },         setTime(inputFile.lastModified());,         // TODO are there any other fields we can set here?,     }, ,     /**,      * Overwrite clone.,      * @return a cloned copy of this ZipEntry,      * @since 1.1,      */,     @Override,     public Object clone() {,         final ZipEntry e = (ZipEntry) super.clone();, ,         e.setInternalAttributes(getInternalAttributes());,         e.setExternalAttributes(getExternalAttributes());,         e.setExtraFields(getExtraFields(true));,         return e;,     }, ,     /**,      * Returns the compression method of this entry, or -1 if the,      * compression method has not been specified.,      *,      * @return compression method,      */,     @Override,     public int getMethod() {,         return method;,     }, ,     /**,      * Sets the compression method of this entry.,      *,      * @param method compression method,      */,     @Override,     public void setMethod(final int method) {,         if (method < 0) {,             throw new IllegalArgumentException(,                     "ZIP compression method can not be negative: " + method);,         },         this.method = method;,     }, ,     /**,      * Retrieves the internal file attributes.,      *,      * @return the internal file attributes,      * @since 1.1,      */,     public int getInternalAttributes() {,         return internalAttributes;,     }, ,     /**,      * Sets the internal file attributes.,      * @param value an <code>int</code> value,      * @since 1.1,      */,     public void setInternalAttributes(final int value) {,         internalAttributes = value;,     }, ,     /**,      * Retrieves the external file attributes.,      * @return the external file attributes,      * @since 1.1,      */,     public long getExternalAttributes() {,         return externalAttributes;,     }, ,     /**,      * Sets the external file attributes.,      * @param value an <code>long</code> value,      * @since 1.1,      */,     public void setExternalAttributes(final long value) {,         externalAttributes = value;,     }, ,     /**,      * Sets Unix permissions in a way that is understood by Info-Zip's,      * unzip command.,      * @param mode an <code>int</code> value,      * @since Ant 1.5.2,      */,     public void setUnixMode(final int mode) {,         // CheckStyle:MagicNumberCheck OFF - no point,         setExternalAttributes((mode << SHORT_SHIFT),                               // MS-DOS read-only attribute,                               | ((mode & 0200) == 0 ? 1 : 0),                               // MS-DOS directory flag,                               | (isDirectory() ? 0x10 : 0));,         // CheckStyle:MagicNumberCheck ON,         platform = PLATFORM_UNIX;,     }, ,     /**,      * Unix permission.,      * @return the unix permissions,      * @since Ant 1.6,      */,     public int getUnixMode() {,         return platform != PLATFORM_UNIX ? 0 :,             (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);,     }, ,     /**,      * Platform specification to put into the &quot;version made,      * by&quot; part of the central file header.,      *,      * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode},      * has been called, in which case PLATFORM_UNIX will be returned.,      *,      * @since Ant 1.5.2,      */,     public int getPlatform() {,         return platform;,     }, ,     /**,      * Set the platform (UNIX or FAT).,      * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX,      * @since 1.9,      */,     protected void setPlatform(final int platform) {,         this.platform = platform;,     }, ,     /**,      * Replaces all currently attached extra fields with the new array.,      * @param fields an array of extra fields,      * @since 1.1,      */,     public void setExtraFields(final ZipExtraField[] fields) {,         extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();,         for (final ZipExtraField field : fields) {,             if (field instanceof UnparseableExtraFieldData) {,                 unparseableExtra = (UnparseableExtraFieldData) field;,             } else {,                 extraFields.put(field.getHeaderId(), field);,             },         },         setExtra();,     }, ,     /**,      * Retrieves all extra fields that have been parsed successfully.,      * @return an array of the extra fields,      */,     public ZipExtraField[] getExtraFields() {,         return getExtraFields(false);,     }, ,     /**,      * Retrieves extra fields.,      * @param includeUnparseable whether to also return unparseable,      * extra fields as {@link UnparseableExtraFieldData} if such data,      * exists.,      * @return an array of the extra fields,      * @since 1.1,      */,     public ZipExtraField[] getExtraFields(final boolean includeUnparseable) {,         if (extraFields == null) {,             return !includeUnparseable || unparseableExtra == null,                 ? new ZipExtraField[0],                 : new ZipExtraField[] {unparseableExtra};,         },         final List<ZipExtraField> result =,             new ArrayList<ZipExtraField>(extraFields.values());,         if (includeUnparseable && unparseableExtra != null) {,             result.add(unparseableExtra);,         },         return result.toArray(new ZipExtraField[0]);,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>If no extra field of the same type exists, the field will be,      * added as last field.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addExtraField(final ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             if (extraFields == null) {,                 extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();,             },             extraFields.put(ze.getHeaderId(), ze);,         },         setExtra();,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>The new extra field will be the first one.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addAsFirstExtraField(final ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             final LinkedHashMap<ZipShort, ZipExtraField> copy = extraFields;,             extraFields = new LinkedHashMap<ZipShort, ZipExtraField>();,             extraFields.put(ze.getHeaderId(), ze);,             if (copy != null) {,                 copy.remove(ze.getHeaderId());,                 extraFields.putAll(copy);,             },         },         setExtra();,     }, ,     /**,      * Remove an extra field.,      * @param type the type of extra field to remove,      * @since 1.1,      */,     public void removeExtraField(final ZipShort type) {,         if (extraFields == null) {,             throw new java.util.NoSuchElementException();,         },         if (extraFields.remove(type) == null) {,             throw new java.util.NoSuchElementException();,         },         setExtra();,     }, ,     /**,      * Removes unparseable extra field data.,      */,     public void removeUnparseableExtraFieldData() {,         if (unparseableExtra == null) {,             throw new java.util.NoSuchElementException();,         },         unparseableExtra = null;,         setExtra();,     }, ,     /**,      * Looks up an extra field by its header id.,      *,      * @return null if no such field exists.,      */,     public ZipExtraField getExtraField(final ZipShort type) {,         if (extraFields != null) {,             return extraFields.get(type);,         },         return null;,     }, ,     /**,      * Looks up extra field data that couldn't be parsed correctly.,      *,      * @return null if no such field exists.,      */,     public UnparseableExtraFieldData getUnparseableExtraFieldData() {,         return unparseableExtra;,     }, ,     /**,      * Parses the given bytes as extra field data and consumes any,      * unparseable data as an {@link UnparseableExtraFieldData},      * instance.,      * @param extra an array of bytes to be parsed into extra fields,      * @throws RuntimeException if the bytes cannot be parsed,      * @since 1.1,      * @throws RuntimeException on error,      */,     @Override,     public void setExtra(final byte[] extra) throws RuntimeException {,         try {,             final ZipExtraField[] local =,                 ExtraFieldUtils.parse(extra, true,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(local, true);,         } catch (final ZipException e) {,             // actually this is not be possible as of Ant 1.8.1,             throw new RuntimeException("Error parsing extra fields for entry: ",                                        + getName() + " - " + e.getMessage(), e);,         },     }, ,     /**,      * Unfortunately {@link java.util.zip.ZipOutputStream,      * java.util.zip.ZipOutputStream} seems to access the extra data,      * directly, so overriding getExtra doesn't help - we need to,      * modify super's data directly.,      *,      * @since 1.1,      */,     protected void setExtra() {,         super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));,     }, ,     /**,      * Sets the central directory part of extra fields.,      */,     public void setCentralDirectoryExtra(final byte[] b) {,         try {,             final ZipExtraField[] central =,                 ExtraFieldUtils.parse(b, false,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(central, false);,         } catch (final ZipException e) {,             throw new RuntimeException(e.getMessage(), e);,         },     }, ,     /**,      * Retrieves the extra data for the local file data.,      * @return the extra data for local file,      * @since 1.1,      */,     public byte[] getLocalFileDataExtra() {,         final byte[] extra = getExtra();,         return extra != null ? extra : EMPTY;,     }, ,     /**,      * Retrieves the extra data for the central directory.,      * @return the central directory extra data,      * @since 1.1,      */,     public byte[] getCentralDirectoryExtra() {,         return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));,     }, ,     /**,      * Make this class work in JDK 1.1 like a 1.2 class.,      *,      * <p>This either stores the size for later usage or invokes,      * setCompressedSize via reflection.</p>,      * @param size the size to use,      * @deprecated since 1.7.,      *             Use setCompressedSize directly.,      * @since 1.2,      */,     @Deprecated,     public void setComprSize(final long size) {,         setCompressedSize(size);,     }, ,     /**,      * Get the name of the entry.,      * @return the entry name,      * @since 1.9,      */,     @Override,     public String getName() {,         return name == null ? super.getName() : name;,     }, ,     /**,      * Is this entry a directory?,      * @return true if the entry is a directory,      * @since 1.10,      */,     @Override,     public boolean isDirectory() {,         return getName().endsWith("/");,     }, ,     /**,      * Set the name of the entry.,      * @param name the name to use,      */,     protected void setName(String name) {,         if (name != null && getPlatform() == PLATFORM_FAT,             && name.indexOf("/") == -1) {,             name = name.replace('\\', '/');,         },         this.name = name;,     }, ,     /**,      * Gets the uncompressed size of the entry data.,      * @return the entry size,      */,     @Override,     public long getSize() {,         return size;,     }, ,     /**,      * Sets the uncompressed size of the entry data.,      * @param size the uncompressed size in bytes,      * @exception IllegalArgumentException if the specified size is less,      *            than 0,      */,     @Override,     public void setSize(final long size) {,         if (size < 0) {,             throw new IllegalArgumentException("invalid entry size");,         },         this.size = size;,     }, ,     /**,      * Sets the name using the raw bytes and the string created from,      * it by guessing or using the configured encoding.,      * @param name the name to use created from the raw bytes using,      * the guessed or configured encoding,      * @param rawName the bytes originally read as name from the,      * archive,      */,     protected void setName(final String name, final byte[] rawName) {,         setName(name);,         this.rawName = rawName;,     }, ,     /**,      * Returns the raw bytes that made up the name before it has been,      * converted using the configured or guessed encoding.,      *,      * <p>This method will return null if this instance has not been,      * read from an archive.</p>,      */,     public byte[] getRawName() {,         if (rawName != null) {,             final byte[] b = new byte[rawName.length];,             System.arraycopy(rawName, 0, b, 0, rawName.length);,             return b;,         },         return null;,     }, ,     /**,      * Get the hashCode of the entry.,      * This uses the name as the hashcode.,      * @return a hashcode.,      * @since Ant 1.7,      */,     @Override,     public int hashCode() {,         // this method has severe consequences on performance. We cannot rely,         // on the super.hashCode() method since super.getName() always return,         // the empty string in the current implemention (there's no setter),         // so it is basically draining the performance of a hashmap lookup,         return getName().hashCode();,     }, ,     /**,      * The "general purpose bit" field.,      */,     public GeneralPurposeBit getGeneralPurposeBit() {,         return gpb;,     }, ,     /**,      * The "general purpose bit" field.,      */,     public void setGeneralPurposeBit(final GeneralPurposeBit b) {,         gpb = b;,     }, ,     /**,      * If there are no extra fields, use the given fields as new extra,      * data - otherwise merge the fields assuming the existing fields,      * and the new fields stem from different locations inside the,      * archive.,      * @param f the extra fields to merge,      * @param local whether the new fields originate from local data,      */,     private void mergeExtraFields(final ZipExtraField[] f, final boolean local),         throws ZipException {,         if (extraFields == null) {,             setExtraFields(f);,         } else {,             for (final ZipExtraField element : f) {,                 ZipExtraField existing;,                 if (element instanceof UnparseableExtraFieldData) {,                     existing = unparseableExtra;,                 } else {,                     existing = getExtraField(element.getHeaderId());,                 },                 if (existing == null) {,                     addExtraField(element);,                 } else {,                     if (local,                         || !(existing,                              instanceof CentralDirectoryParsingZipExtraField)) {,                         final byte[] b = element.getLocalFileDataData();,                         existing.parseFromLocalFileData(b, 0, b.length);,                     } else {,                         final byte[] b = element.getCentralDirectoryData();,                         ((CentralDirectoryParsingZipExtraField) existing),                             .parseFromCentralDirectoryData(b, 0, b.length);,                     },                 },             },             setExtra();,         },     }, ,     /** {@inheritDoc} */,     public Date getLastModifiedDate() {,         return new Date(getTime());,     }, ,     /* (non-Javadoc),      * @see java.lang.Object#equals(java.lang.Object),      */,     @Override,     public boolean equals(final Object obj) {,         if (this == obj) {,             return true;,         },         if (obj == null || getClass() != obj.getClass()) {,             return false;,         },         final ZipEntry other = (ZipEntry) obj;,         final String myName = getName();,         final String otherName = other.getName();,         if (myName == null) {,             if (otherName != null) {,                 return false;,             },         } else if (!myName.equals(otherName)) {,             return false;,         },         String myComment = getComment();,         String otherComment = other.getComment();,         if (myComment == null) {,             myComment = "";,         },         if (otherComment == null) {,             otherComment = "";,         },         return getTime() == other.getTime(),             && myComment.equals(otherComment),             && getInternalAttributes() == other.getInternalAttributes(),             && getPlatform() == other.getPlatform(),             && getExternalAttributes() == other.getExternalAttributes(),             && getMethod() == other.getMethod(),             && getSize() == other.getSize(),             && getCrc() == other.getCrc(),             && getCompressedSize() == other.getCompressedSize(),             && Arrays.equals(getCentralDirectoryExtra(),,                              other.getCentralDirectoryExtra()),             && Arrays.equals(getLocalFileDataExtra(),,                              other.getLocalFileDataExtra()),             && gpb.equals(other.gpb);],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/zip/ZipFile.java,resolveLocalFileHeaderData,858-858,[            final Entry ze = (Entry) it.next();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/zip/ZipFile.java,<init>,223-223,[                } catch (final IOException e2) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/zip/ZipFile.java,,380-385,[                return new InflaterInputStream(bis, inflater) {,                     @Override,                     public void close() throws IOException {,                         super.close();,                         inflater.end();,                     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/zip/ZipFile.java,,994-1010,[        new Comparator<ZipEntry>() {,         public int compare(final ZipEntry e1, final ZipEntry e2) {,             if (e1 == e2) {,                 return 0;,             }, ,             final Entry ent1 = e1 instanceof Entry ? (Entry) e1 : null;,             final Entry ent2 = e2 instanceof Entry ? (Entry) e2 : null;,             if (ent1 == null) {,                 return 1;,             },             if (ent2 == null) {,                 return -1;,             },             final long val = (ent1.getOffsetEntry().headerOffset,                         - ent2.getOffsetEntry().headerOffset);,             return val == 0 ? 0 : val < 0 ? -1 : +1;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/zip/ZipLongTest.java,testEquals,74-74,[        assertTrue("non ZipLong handling", !zl.equals(new Integer(0x1234)));],,
CORRECTNESS,EC_UNRELATED_TYPES,org/apache/tools/zip/ZipLongTest.java,testEquals,74-74,[        assertTrue("non ZipLong handling", !zl.equals(new Integer(0x1234)));],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/zip/ZipFile.java,,433-433,[    private static final long CFH_SIG =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/zip/ZipOutputStream.java,,878-878,[    protected static final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/zip/ZipOutputStream.java,,890-890,[    protected static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/zip/ZipOutputStream.java,,872-872,[    protected static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/zip/ZipOutputStreamTest.java,testZipLong,60-60,[        assertEquals(test.getValue(), zl.getValue());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/zip/ZipShortTest.java,testEquals,72-72,[        assertTrue("non ZipShort handling", !zs.equals(new Integer(0x1234)));],,
CORRECTNESS,EC_UNRELATED_TYPES,org/apache/tools/zip/ZipShortTest.java,testEquals,72-72,[        assertTrue("non ZipShort handling", !zs.equals(new Integer(0x1234)));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/zip/ZipUtil.java,copy,184-184,[        return null;],,
CORRECTNESS,IJU_NO_TESTS,org/example/junit/JUnit3NonTestMissed.java,,22-26,[public class JUnit3NonTestMissed extends TestCase {, ,     public void notATest() {,         //this isn't a test but shouldn't case an error,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/example/junit/ThreadedOutput.java,,35-38,[        Thread t = new Thread(new Runnable() {,                 public void run() {,                     System.out.println("foo");,                 }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/example/tasks/TaskdefTestSimpleTask.java,,26-29,[    public class Echo {,         Echo() {},         private String message = null;,         public void setMessage(String s) {message = s;}],,

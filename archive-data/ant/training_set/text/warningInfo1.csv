BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/AntClassLoader.java,initializeClass,586-586,[                } catch (Exception e) {],,
MALICIOUS_CODE,DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED,org/apache/tools/ant/AntClassLoader.java,newAntClassLoader,1559-1559,[        return new AntClassLoader(parent, project, path, parentFirst);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/AntClassLoader.java,cleanup,1391-1404,[        for (Enumeration e = jarFiles.elements(); e.hasMoreElements();) {,             JarFile jarFile = (JarFile) e.nextElement();,             try {,                 jarFile.close();,             } catch (IOException ioe) {,                 // ignore,             },         },         jarFiles = new Hashtable();,         if (project != null) {,             project.removeBuildListener(this);,         },         project = null;,     }],,cleanUp,151-153,[        descriptorAdded = false;,         super.cleanUp();,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/AntClassLoader.java,setClassPath,349-362,[        pathComponents.removeAllElements();,         if (classpath != null) {,             Path actualClasspath = classpath.concatSystemClasspath("ignore");,             String[] pathElements = actualClasspath.list();,             for (int i = 0; i < pathElements.length; ++i) {,                 try {,                     addPathElement(pathElements[i]);,                 } catch (BuildException e) {,                     // ignore path elements which are invalid,                     // relative to the project,                 },             },         },     }],,setClasspath,77-78,[        createClasspath().append(classpath);,     }],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/AntClassLoader.java,getCertificates,1194-1194,[            return null;],,getCertificates,1198-1198,[            return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/AntClassLoader.java,initializeClass,579-579,[        if (cons != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/AntClassLoader.java,initializeClass,586-586,[                } catch (Exception e) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/AntClassLoaderTest.java,testInvalidZipException,166-166,[            PrintStream err =],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/AntClassLoaderTest.java,tearDown,50-50,[    }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/AntClassLoaderTest.java,testCleanup,74-74,[        loader = p.createClassLoader(path);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/AntTypeDefinition.java,getClassName,103-103,[        return className;],,getClassname,518-518,[        return classname;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/AntTypeDefinition.java,setClassName,95-96,[        this.className = className;,     }],,setClassname,161-164,[        if (!"".equals(classname)) {,             this.classname = classname;,         },     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/AntTypeDefinition.java,createAndSet,230-230,[        if (adapterObject == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/AntTypeDefinition.java,createAndSet,220-220,[        if (o == null || adapterClass == null) {],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/ant/Project.java,,129-2474,[    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();, ,     /** Name of this project. */,     private String name;,     /** Description for this project (if any). */,     private String description;, , ,     /** Map of references within the project (paths etc) (String to Object). */,     private Hashtable references = new AntRefTable();, ,     /** Map of id references - used for indicating broken build files */,     private HashMap idReferences = new HashMap();, ,     /** the parent project for old id resolution (if inheritreferences is set) */,     private Project parentIdProject = null;, ,     /** Name of the project's default target. */,     private String defaultTarget;, ,     /** Map from target names to targets (String to Target). */,     private Hashtable targets = new Hashtable();,     /** Set of global filters. */,     private FilterSet globalFilterSet = new FilterSet();,     {,         // Initialize the globalFileSet's project,         globalFilterSet.setProject(this);,     }, ,     /**,      * Wrapper around globalFilterSet. This collection only ever,      * contains one FilterSet, but the wrapper is needed in order to,      * make it easier to use the FileUtils interface.,      */,     private FilterSetCollection globalFilters,         = new FilterSetCollection(globalFilterSet);, ,     /** Project base directory. */,     private File baseDir;, ,     /** lock object used when adding/removing listeners */,     private final Object listenersLock = new Object();, ,     /** List of listeners to notify of build events. */,     private volatile BuildListener[] listeners = new BuildListener[0];, ,     /** for each thread, record whether it is currently executing,         messageLogged */,     private final ThreadLocal isLoggingMessage = new ThreadLocal() {,             protected Object initialValue() {,                 return Boolean.FALSE;,             },         };, ,     /**,      * The Ant core classloader--may be <code>null</code> if using,      * parent classloader.,      */,     private ClassLoader coreLoader = null;, ,     /** Records the latest task to be executed on a thread. */,     private final Map/*<Thread,Task>*/ threadTasks =,         Collections.synchronizedMap(new WeakHashMap());, ,     /** Records the latest task to be executed on a thread group. */,     private final Map/*<ThreadGroup,Task>*/ threadGroupTasks,         = Collections.synchronizedMap(new WeakHashMap());, ,     /**,      * Called to handle any input requests.,      */,     private InputHandler inputHandler = null;, ,     /**,      * The default input stream used to read any input.,      */,     private InputStream defaultInputStream = null;, ,     /**,      * Keep going flag.,      */,     private boolean keepGoingMode = false;, ,     /**,      * Set the input handler.,      *,      * @param handler the InputHandler instance to use for gathering input.,      */,     public void setInputHandler(InputHandler handler) {,         inputHandler = handler;,     }, ,     /**,      * Set the default System input stream. Normally this stream is set to,      * System.in. This inputStream is used when no task input redirection is,      * being performed.,      *,      * @param defaultInputStream the default input stream to use when input,      *        is requested.,      * @since Ant 1.6,      */,     public void setDefaultInputStream(InputStream defaultInputStream) {,         this.defaultInputStream = defaultInputStream;,     }, ,     /**,      * Get this project's input stream.,      *,      * @return the InputStream instance in use by this Project instance to,      * read input.,      */,     public InputStream getDefaultInputStream() {,         return defaultInputStream;,     }, ,     /**,      * Retrieve the current input handler.,      *,      * @return the InputHandler instance currently in place for the project,      *         instance.,      */,     public InputHandler getInputHandler() {,         return inputHandler;,     }, ,     /**,      * Create a new Ant project.,      */,     public Project() {,         inputHandler = new DefaultInputHandler();,     }, ,     /**,      * Create and initialize a subproject. By default the subproject will be of,      * the same type as its parent. If a no-arg constructor is unavailable, the,      * <code>Project</code> class will be used.,      * @return a Project instance configured as a subproject of this Project.,      * @since Ant 1.7,      */,     public Project createSubProject() {,         Project subProject = null;,         try {,             subProject = (Project) (getClass().newInstance());,         } catch (Exception e) {,             subProject = new Project();,         },         initSubProject(subProject);,         return subProject;,     }, ,     /**,      * Initialize a subproject.,      * @param subProject the subproject to initialize.,      */,     public void initSubProject(Project subProject) {,         ComponentHelper.getComponentHelper(subProject),             .initSubProject(ComponentHelper.getComponentHelper(this));,         subProject.setDefaultInputStream(getDefaultInputStream());,         subProject.setKeepGoingMode(this.isKeepGoingMode());,         subProject.setExecutor(getExecutor().getSubProjectExecutor());,     }, ,     /**,      * Initialise the project.,      *,      * This involves setting the default task definitions and loading the,      * system properties.,      *,      * @exception BuildException if the default task list cannot be loaded.,      */,     public void init() throws BuildException {,         initProperties();, ,         ComponentHelper.getComponentHelper(this).initDefaultDefinitions();,     }, ,     /**,      * Initializes the properties.,      * @exception BuildException if an vital property could not be set.,      * @since Ant 1.7,      */,     public void initProperties() throws BuildException {,         setJavaVersionProperty();,         setSystemProperties();,         setPropertyInternal(MagicNames.ANT_VERSION, Main.getAntVersion());,         setAntLib();,     }, ,     /**,      * Set a property to the location of ant.jar.,      * Use the locator to find the location of the Project.class, and,      * if this is not null, set the property {@link MagicNames#ANT_LIB},      * to the result,      */,     private void setAntLib() {,         File antlib = org.apache.tools.ant.launch.Locator.getClassSource(,             Project.class);,         if (antlib != null) {,             setPropertyInternal(MagicNames.ANT_LIB, antlib.getAbsolutePath());,         },     },     /**,      * Factory method to create a class loader for loading classes from,      * a given path.,      *,      * @param path the path from which classes are to be loaded.,      *,      * @return an appropriate classloader.,      */,     public AntClassLoader createClassLoader(Path path) {,         return AntClassLoader,             .newAntClassLoader(getClass().getClassLoader(), this, path, true);,     }, ,     /**,      * Factory method to create a class loader for loading classes from,      * a given path.,      *,      * @param parent the parent classloader for the new loader.,      * @param path the path from which classes are to be loaded.,      *,      * @return an appropriate classloader.,      */,     public AntClassLoader createClassLoader(,         ClassLoader parent, Path path) {,         return AntClassLoader.newAntClassLoader(parent, this, path, true);,     }, ,     /**,      * Set the core classloader for the project. If a <code>null</code>,      * classloader is specified, the parent classloader should be used.,      *,      * @param coreLoader The classloader to use for the project.,      *                   May be <code>null</code>.,      */,     public void setCoreLoader(ClassLoader coreLoader) {,         this.coreLoader = coreLoader;,     }, ,     /**,      * Return the core classloader to use for this project.,      * This may be <code>null</code>, indicating that,      * the parent classloader should be used.,      *,      * @return the core classloader to use for this project.,      *,      */,     public ClassLoader getCoreLoader() {,         return coreLoader;,     }, ,     /**,      * Add a build listener to the list. This listener will,      * be notified of build events for this project.,      *,      * @param listener The listener to add to the list.,      *                 Must not be <code>null</code>.,      */,     public void addBuildListener(BuildListener listener) {,         synchronized (listenersLock) {,             // If the listeners already has this listener, do nothing,             for (int i = 0; i < listeners.length; i++) {,                 if (listeners[i] == listener) {,                     return;,                 },             },             // copy on write semantics,             BuildListener[] newListeners =,                 new BuildListener[listeners.length + 1];,             System.arraycopy(listeners, 0, newListeners, 0, listeners.length);,             newListeners[listeners.length] = listener;,             listeners = newListeners;,         },     }, ,     /**,      * Remove a build listener from the list. This listener,      * will no longer be notified of build events for this project.,      *,      * @param listener The listener to remove from the list.,      *                 Should not be <code>null</code>.,      */,     public void removeBuildListener(BuildListener listener) {,         synchronized (listenersLock) {,             // copy on write semantics,             for (int i = 0; i < listeners.length; i++) {,                 if (listeners[i] == listener) {,                     BuildListener[] newListeners =,                         new BuildListener[listeners.length - 1];,                     System.arraycopy(listeners, 0, newListeners, 0, i);,                     System.arraycopy(listeners, i + 1, newListeners, i,,                                      listeners.length - i - 1);,                     listeners = newListeners;,                     break;,                 },             },         },     }, ,     /**,      * Return a copy of the list of build listeners for the project.,      * ,      * @return a list of build listeners for the project,      */,     public Vector getBuildListeners() {,         synchronized (listenersLock) {,             Vector r = new Vector(listeners.length);,             for (int i = 0; i < listeners.length; i++) {,                 r.add(listeners[i]);,             },             return r;,         },     }, ,     /**,      * Write a message to the log with the default log level,      * of MSG_INFO .,      * @param message The text to log. Should not be <code>null</code>.,      */, ,     public void log(String message) {,         log(message, MSG_INFO);,     }, ,     /**,      * Write a project level message to the log with the given log level.,      * @param message The text to log. Should not be <code>null</code>.,      * @param msgLevel The log priority level to use.,      */,     public void log(String message, int msgLevel) {,         log(message, null, msgLevel);,     }, ,     /**,      * Write a project level message to the log with the given log level.,      * @param message The text to log. Should not be <code>null</code>.,      * @param throwable The exception causing this log, may be <code>null</code>.,      * @param msgLevel The log priority level to use.,      * @since 1.7,      */,     public void log(String message, Throwable throwable, int msgLevel) {,         fireMessageLogged(this, message, throwable, msgLevel);,     }, ,     /**,      * Write a task level message to the log with the given log level.,      * @param task The task to use in the log. Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param msgLevel The log priority level to use.,      */,     public void log(Task task, String message, int msgLevel) {,         fireMessageLogged(task, message, null, msgLevel);,     }, ,     /**,      * Write a task level message to the log with the given log level.,      * @param task The task to use in the log. Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param throwable The exception causing this log, may be <code>null</code>.,      * @param msgLevel The log priority level to use.,      * @since 1.7,      */,     public void log(Task task, String message, Throwable throwable, int msgLevel) {,         fireMessageLogged(task, message, throwable, msgLevel);,     }, ,     /**,      * Write a target level message to the log with the given log level.,      * @param target The target to use in the log.,      *               Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param msgLevel The log priority level to use.,      */,     public void log(Target target, String message, int msgLevel) {,         log(target, message, null, msgLevel);,     }, ,     /**,      * Write a target level message to the log with the given log level.,      * @param target The target to use in the log.,      *               Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param throwable The exception causing this log, may be <code>null</code>.,      * @param msgLevel The log priority level to use.,      * @since 1.7,      */,     public void log(Target target, String message, Throwable throwable,,             int msgLevel) {,         fireMessageLogged(target, message, throwable, msgLevel);,     }, ,     /**,      * Return the set of global filters.,      *,      * @return the set of global filters.,      */,     public FilterSet getGlobalFilterSet() {,         return globalFilterSet;,     }, ,     /**,      * Set a property. Any existing property of the same name,      * is overwritten, unless it is a user property.,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      */,     public void setProperty(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setProperty(name, value, true);,     }, ,     /**,      * Set a property if no value currently exists. If the property,      * exists already, a message is logged and the method returns with,      * no other effect.,      *,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      * @since 1.5,      */,     public void setNewProperty(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setNewProperty(name, value);,     }, ,     /**,      * Set a user property, which cannot be overwritten by,      * set/unset property calls. Any previous value is overwritten.,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      * @see #setProperty(String,String),      */,     public void setUserProperty(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setUserProperty(name, value);,     }, ,     /**,      * Set a user property, which cannot be overwritten by set/unset,      * property calls. Any previous value is overwritten. Also marks,      * these properties as properties that have not come from the,      * command line.,      *,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      * @see #setProperty(String,String),      */,     public void setInheritedProperty(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setInheritedProperty(name, value);,     }, ,     /**,      * Set a property unless it is already defined as a user property,      * (in which case the method returns silently).,      *,      * @param name The name of the property.,      *             Must not be <code>null</code>.,      * @param value The property value. Must not be <code>null</code>.,      */,     private void setPropertyInternal(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setProperty(name, value, false);,     }, ,     /**,      * Return the value of a property, if it is set.,      *,      * @param propertyName The name of the property.,      *             May be <code>null</code>, in which case,      *             the return value is also <code>null</code>.,      * @return the property value, or <code>null</code> for no match,      *         or if a <code>null</code> name is provided.,      */,     public String getProperty(String propertyName) {,         Object value = PropertyHelper.getPropertyHelper(this).getProperty(propertyName);,         return value == null ? null : String.valueOf(value);,     }, ,     /**,      * Replace ${} style constructions in the given value with the,      * string value of the corresponding data types.,      *,      * @param value The string to be scanned for property references.,      *              May be <code>null</code>.,      *,      * @return the given string with embedded property names replaced,      *         by values, or <code>null</code> if the given string is,      *         <code>null</code>.,      *,      * @exception BuildException if the given value has an unclosed,      *                           property name, e.g. <code>${xxx</code>.,      */,     public String replaceProperties(String value) throws BuildException {,         return PropertyHelper.getPropertyHelper(this).replaceProperties(null, value, null);,     }, ,     /**,      * Return the value of a user property, if it is set.,      *,      * @param propertyName The name of the property.,      *             May be <code>null</code>, in which case,      *             the return value is also <code>null</code>.,      * @return the property value, or <code>null</code> for no match,      *         or if a <code>null</code> name is provided.,      */,      public String getUserProperty(String propertyName) {,         return (String) PropertyHelper.getPropertyHelper(this).getUserProperty(propertyName);,     }, ,     /**,      * Return a copy of the properties table.,      * @return a hashtable containing all properties,      *         (including user properties).,      */,     public Hashtable getProperties() {,         return PropertyHelper.getPropertyHelper(this).getProperties();,     }, ,     /**,      * Return a copy of the user property hashtable.,      * @return a hashtable containing just the user properties.,      */,     public Hashtable getUserProperties() {,         return PropertyHelper.getPropertyHelper(this).getUserProperties();,     }, ,     /**,      * Return a copy of the inherited property hashtable.,      * @return a hashtable containing just the inherited properties.,      * @since Ant 1.8.0,      */,     public Hashtable getInheritedProperties() {,         return PropertyHelper.getPropertyHelper(this).getInheritedProperties();,     }, ,     /**,      * Copy all user properties that have been set on the command,      * line or a GUI tool from this instance to the Project instance,      * given as the argument.,      *,      * <p>To copy all &quot;user&quot; properties, you will also have to call,      * {@link #copyInheritedProperties copyInheritedProperties}.</p>,      *,      * @param other the project to copy the properties to.  Must not be null.,      *,      * @since Ant 1.5,      */,     public void copyUserProperties(Project other) {,         PropertyHelper.getPropertyHelper(this).copyUserProperties(other);,     }, ,     /**,      * Copy all user properties that have not been set on the,      * command line or a GUI tool from this instance to the Project,      * instance given as the argument.,      *,      * <p>To copy all &quot;user&quot; properties, you will also have to call,      * {@link #copyUserProperties copyUserProperties}.</p>,      *,      * @param other the project to copy the properties to.  Must not be null.,      *,      * @since Ant 1.5,      */,     public void copyInheritedProperties(Project other) {,         PropertyHelper.getPropertyHelper(this).copyInheritedProperties(other);,     }, ,     /**,      * Set the default target of the project.,      *,      * @param defaultTarget The name of the default target for this project.,      *                      May be <code>null</code>, indicating that there is,      *                      no default target.,      *,      * @deprecated since 1.5.x.,      *             Use setDefault.,      * @see #setDefault(String),      */,     public void setDefaultTarget(String defaultTarget) {,         setDefault(defaultTarget);,     }, ,     /**,      * Return the name of the default target of the project.,      * @return name of the default target or,      *         <code>null</code> if no default has been set.,      */,     public String getDefaultTarget() {,         return defaultTarget;,     }, ,     /**,      * Set the default target of the project.,      *,      * @param defaultTarget The name of the default target for this project.,      *                      May be <code>null</code>, indicating that there is,      *                      no default target.,      */,     public void setDefault(String defaultTarget) {,         if (defaultTarget != null) {,             setUserProperty(MagicNames.PROJECT_DEFAULT_TARGET, defaultTarget);,         },         this.defaultTarget = defaultTarget;,     }, ,     /**,      * Set the name of the project, also setting the user,      * property <code>ant.project.name</code>.,      *,      * @param name The name of the project.,      *             Must not be <code>null</code>.,      */,     public void setName(String name) {,         setUserProperty(MagicNames.PROJECT_NAME,  name);,         this.name = name;,     }, ,     /**,      * Return the project name, if one has been set.,      *,      * @return the project name, or <code>null</code> if it hasn't been set.,      */,     public String getName() {,         return name;,     }, ,     /**,      * Set the project description.,      *,      * @param description The description of the project.,      *                    May be <code>null</code>.,      */,     public void setDescription(String description) {,         this.description = description;,     }, ,     /**,      * Return the project description, if one has been set.,      *,      * @return the project description, or <code>null</code> if it hasn't,      *         been set.,      */,     public String getDescription() {,         if (description == null) {,             description = Description.getDescription(this);,         },         return description;,     }, ,     /**,      * Add a filter to the set of global filters.,      *,      * @param token The token to filter.,      *              Must not be <code>null</code>.,      * @param value The replacement value.,      *              Must not be <code>null</code>.,      * @deprecated since 1.4.x.,      *             Use getGlobalFilterSet().addFilter(token,value),      *,      * @see #getGlobalFilterSet(),      * @see FilterSet#addFilter(String,String),      */,     public void addFilter(String token, String value) {,         if (token == null) {,             return;,         },         globalFilterSet.addFilter(new FilterSet.Filter(token, value));,     }, ,     /**,      * Return a hashtable of global filters, mapping tokens to values.,      *,      * @return a hashtable of global filters, mapping tokens to values,      *         (String to String).,      *,      * @deprecated since 1.4.x,      *             Use getGlobalFilterSet().getFilterHash().,      *,      * @see #getGlobalFilterSet(),      * @see FilterSet#getFilterHash(),      */,     public Hashtable getFilters() {,         // we need to build the hashtable dynamically,         return globalFilterSet.getFilterHash();,     }, ,     /**,      * Set the base directory for the project, checking that,      * the given filename exists and is a directory.,      *,      * @param baseD The project base directory.,      *              Must not be <code>null</code>.,      *,      * @exception BuildException if the directory if invalid.,      */,     public void setBasedir(String baseD) throws BuildException {,         setBaseDir(new File(baseD));,     }, ,     /**,      * Set the base directory for the project, checking that,      * the given file exists and is a directory.,      *,      * @param baseDir The project base directory.,      *                Must not be <code>null</code>.,      * @exception BuildException if the specified file doesn't exist or,      *                           isn't a directory.,      */,     public void setBaseDir(File baseDir) throws BuildException {,         baseDir = FILE_UTILS.normalize(baseDir.getAbsolutePath());,         if (!baseDir.exists()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " does not exist");,         },         if (!baseDir.isDirectory()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " is not a directory");,         },         this.baseDir = baseDir;,         setPropertyInternal(MagicNames.PROJECT_BASEDIR, this.baseDir.getPath());,         String msg = "Project base dir set to: " + this.baseDir;,         log(msg, MSG_VERBOSE);,     }, ,     /**,      * Return the base directory of the project as a file object.,      *,      * @return the project base directory, or <code>null</code> if the,      *         base directory has not been successfully set to a valid value.,      */,     public File getBaseDir() {,         if (baseDir == null) {,             try {,                 setBasedir(".");,             } catch (BuildException ex) {,                 ex.printStackTrace();,             },         },         return baseDir;,     }, ,     /**,      * Set &quot;keep-going&quot; mode. In this mode Ant will try to execute,      * as many targets as possible. All targets that do not depend,      * on failed target(s) will be executed.  If the keepGoing settor/getter,      * methods are used in conjunction with the <code>ant.executor.class</code>,      * property, they will have no effect.,      * @param keepGoingMode &quot;keep-going&quot; mode,      * @since Ant 1.6,      */,     public void setKeepGoingMode(boolean keepGoingMode) {,         this.keepGoingMode = keepGoingMode;,     }, ,     /**,      * Return the keep-going mode.  If the keepGoing settor/getter,      * methods are used in conjunction with the <code>ant.executor.class</code>,      * property, they will have no effect.,      * @return &quot;keep-going&quot; mode,      * @since Ant 1.6,      */,     public boolean isKeepGoingMode() {,         return this.keepGoingMode;,     }, ,     /**,      * Return the version of Java this class is running under.,      * @return the version of Java as a String, e.g. "1.1" .,      * @see org.apache.tools.ant.util.JavaEnvUtils#getJavaVersion,      * @deprecated since 1.5.x.,      *             Use org.apache.tools.ant.util.JavaEnvUtils instead.,      */,     public static String getJavaVersion() {,         return JavaEnvUtils.getJavaVersion();,     }, ,     /**,      * Set the <code>ant.java.version</code> property and tests for,      * unsupported JVM versions. If the version is supported,,      * verbose log messages are generated to record the Java version,      * and operating system name.,      *,      * @exception BuildException if this Java version is not supported.,      *,      * @see org.apache.tools.ant.util.JavaEnvUtils#getJavaVersion,      */,     public void setJavaVersionProperty() throws BuildException {,         String javaVersion = JavaEnvUtils.getJavaVersion();,         setPropertyInternal(MagicNames.ANT_JAVA_VERSION, javaVersion);, ,         // sanity check,         if (!JavaEnvUtils.isAtLeastJavaVersion(JavaEnvUtils.JAVA_1_4))  {,             throw new BuildException("Ant cannot work on Java prior to 1.4");,         },         log("Detected Java version: " + javaVersion + " in: ",             + System.getProperty("java.home"), MSG_VERBOSE);, ,         log("Detected OS: " + System.getProperty("os.name"), MSG_VERBOSE);,     }, ,     /**,      * Add all system properties which aren't already defined as,      * user properties to the project properties.,      */,     public void setSystemProperties() {,         Properties systemP = System.getProperties();,         Enumeration e = systemP.propertyNames();,         while (e.hasMoreElements()) {,             String propertyName = (String) e.nextElement();,             String value = systemP.getProperty(propertyName);,             if (value != null) {,                 this.setPropertyInternal(propertyName, value);,             },         },     }, ,     /**,      * Add a new task definition to the project.,      * Attempting to override an existing definition with an,      * equivalent one (i.e. with the same classname) results in,      * a verbose log message. Attempting to override an existing definition,      * with a different one results in a warning log message and,      * invalidates any tasks which have already been created with the,      * old definition.,      *,      * @param taskName The name of the task to add.,      *                 Must not be <code>null</code>.,      * @param taskClass The full name of the class implementing the task.,      *                  Must not be <code>null</code>.,      *,      * @exception BuildException if the class is unsuitable for being an Ant,      *                           task. An error level message is logged before,      *                           this exception is thrown.,      *,      * @see #checkTaskClass(Class),      */,     public void addTaskDefinition(String taskName, Class taskClass),          throws BuildException {,         ComponentHelper.getComponentHelper(this).addTaskDefinition(taskName,,                 taskClass);,     }, ,     /**,      * Check whether or not a class is suitable for serving as Ant task.,      * Ant task implementation classes must be public, concrete, and have,      * a no-arg constructor.,      *,      * @param taskClass The class to be checked.,      *                  Must not be <code>null</code>.,      *,      * @exception BuildException if the class is unsuitable for being an Ant,      *                           task. An error level message is logged before,      *                           this exception is thrown.,      */,     public void checkTaskClass(final Class taskClass) throws BuildException {,         ComponentHelper.getComponentHelper(this).checkTaskClass(taskClass);, ,         if (!Modifier.isPublic(taskClass.getModifiers())) {,             final String message = taskClass + " is not public";,             log(message, Project.MSG_ERR);,             throw new BuildException(message);,         },         if (Modifier.isAbstract(taskClass.getModifiers())) {,             final String message = taskClass + " is abstract";,             log(message, Project.MSG_ERR);,             throw new BuildException(message);,         },         try {,             taskClass.getConstructor((Class[]) null);,             // don't have to check for public, since,             // getConstructor finds public constructors only.,         } catch (NoSuchMethodException e) {,             final String message = "No public no-arg constructor in ",                 + taskClass;,             log(message, Project.MSG_ERR);,             throw new BuildException(message);,         } catch (LinkageError e) {,             String message = "Could not load " + taskClass + ": " + e;,             log(message, Project.MSG_ERR);,             throw new BuildException(message, e);,         },         if (!Task.class.isAssignableFrom(taskClass)) {,             TaskAdapter.checkTaskClass(taskClass, this);,         },     }, ,     /**,      * Return the current task definition hashtable. The returned hashtable is,      * &quot;live&quot; and so should not be modified.,      *,      * @return a map of from task name to implementing class,      *         (String to Class).,      */,     public Hashtable getTaskDefinitions() {,         return ComponentHelper.getComponentHelper(this).getTaskDefinitions();,     }, ,     /**,      * Return the current task definition map. The returned map is a,      * copy of the &quot;live&quot; definitions.,      *,      * @return a map of from task name to implementing class,      *         (String to Class).,      *,      * @since Ant 1.8.1,      */,     public Map getCopyOfTaskDefinitions() {,         return new HashMap(getTaskDefinitions());,     }, ,     /**,      * Add a new datatype definition.,      * Attempting to override an existing definition with an,      * equivalent one (i.e. with the same classname) results in,      * a verbose log message. Attempting to override an existing definition,      * with a different one results in a warning log message, but the,      * definition is changed.,      *,      * @param typeName The name of the datatype.,      *                 Must not be <code>null</code>.,      * @param typeClass The full name of the class implementing the datatype.,      *                  Must not be <code>null</code>.,      */,     public void addDataTypeDefinition(String typeName, Class typeClass) {,         ComponentHelper.getComponentHelper(this).addDataTypeDefinition(typeName,,                 typeClass);,     }, ,     /**,      * Return the current datatype definition hashtable. The returned,      * hashtable is &quot;live&quot; and so should not be modified.,      *,      * @return a map of from datatype name to implementing class,      *         (String to Class).,      */,     public Hashtable getDataTypeDefinitions() {,         return ComponentHelper.getComponentHelper(this).getDataTypeDefinitions();,     }, ,     /**,      * Return the current datatype definition map. The returned,      * map is a copy pf the &quot;live&quot; definitions.,      *,      * @return a map of from datatype name to implementing class,      *         (String to Class).,      *,      * @since Ant 1.8.1,      */,     public Map getCopyOfDataTypeDefinitions() {,         return new HashMap(getDataTypeDefinitions());,     }, ,     /**,      * Add a <em>new</em> target to the project.,      *,      * @param target The target to be added to the project.,      *               Must not be <code>null</code>.,      *,      * @exception BuildException if the target already exists in the project,      *,      * @see Project#addOrReplaceTarget(Target),      */,     public void addTarget(Target target) throws BuildException {,         addTarget(target.getName(), target);,     }, ,     /**,      * Add a <em>new</em> target to the project.,      *,      * @param targetName The name to use for the target.,      *             Must not be <code>null</code>.,      * @param target The target to be added to the project.,      *               Must not be <code>null</code>.,      *,      * @exception BuildException if the target already exists in the project.,      *,      * @see Project#addOrReplaceTarget(String, Target),      */,      public void addTarget(String targetName, Target target),          throws BuildException {,          if (targets.get(targetName) != null) {,              throw new BuildException("Duplicate target: `" + targetName + "'");,          },          addOrReplaceTarget(targetName, target);,      }, ,     /**,      * Add a target to the project, or replaces one with the same,      * name.,      *,      * @param target The target to be added or replaced in the project.,      *               Must not be <code>null</code>.,      */,     public void addOrReplaceTarget(Target target) {,         addOrReplaceTarget(target.getName(), target);,     }, ,     /**,      * Add a target to the project, or replaces one with the same,      * name.,      *,      * @param targetName The name to use for the target.,      *                   Must not be <code>null</code>.,      * @param target The target to be added or replaced in the project.,      *               Must not be <code>null</code>.,      */,     public void addOrReplaceTarget(String targetName, Target target) {,         String msg = " +Target: " + targetName;,         log(msg, MSG_DEBUG);,         target.setProject(this);,         targets.put(targetName, target);,     }, ,     /**,      * Return the hashtable of targets. The returned hashtable,      * is &quot;live&quot; and so should not be modified.,      * @return a map from name to target (String to Target).,      */,     public Hashtable getTargets() {,         return targets;,     }, ,     /**,      * Return the map of targets. The returned map,      * is a copy of the &quot;live&quot; targets.,      * @return a map from name to target (String to Target).,      * @since Ant 1.8.1,      */,     public Map getCopyOfTargets() {,         return new HashMap(targets);,     }, ,     /**,      * Create a new instance of a task, adding it to a list of,      * created tasks for later invalidation. This causes all tasks,      * to be remembered until the containing project is removed,      * @param taskType The name of the task to create an instance of.,      *                 Must not be <code>null</code>.,      *,      * @return an instance of the specified task, or <code>null</code> if,      *         the task name is not recognised.,      *,      * @exception BuildException if the task name is recognised but task,      *                           creation fails.,      */,     public Task createTask(String taskType) throws BuildException {,         return ComponentHelper.getComponentHelper(this).createTask(taskType);,     }, ,     /**,      * Create a new instance of a data type.,      *,      * @param typeName The name of the data type to create an instance of.,      *                 Must not be <code>null</code>.,      *,      * @return an instance of the specified data type, or <code>null</code> if,      *         the data type name is not recognised.,      *,      * @exception BuildException if the data type name is recognised but,      *                           instance creation fails.,      */,     public Object createDataType(String typeName) throws BuildException {,         return ComponentHelper.getComponentHelper(this).createDataType(typeName);,     }, ,     /**,      * Set the Executor instance for this Project.,      * @param e the Executor to use.,      */,     public void setExecutor(Executor e) {,         addReference(MagicNames.ANT_EXECUTOR_REFERENCE, e);,     }, ,     /**,      * Get this Project's Executor (setting it if necessary).,      * @return an Executor instance.,      */,     public Executor getExecutor() {,         Object o = getReference(MagicNames.ANT_EXECUTOR_REFERENCE);,         if (o == null) {,             String classname = getProperty(MagicNames.ANT_EXECUTOR_CLASSNAME);,             if (classname == null) {,                 classname = DefaultExecutor.class.getName();,             },             log("Attempting to create object of type " + classname, MSG_DEBUG);,             try {,                 o = Class.forName(classname, true, coreLoader).newInstance();,             } catch (ClassNotFoundException seaEnEfEx) {,                 //try the current classloader,                 try {,                     o = Class.forName(classname).newInstance();,                 } catch (Exception ex) {,                     log(ex.toString(), MSG_ERR);,                 },             } catch (Exception ex) {,                 log(ex.toString(), MSG_ERR);,             },             if (o == null) {,                 throw new BuildException(,                     "Unable to obtain a Target Executor instance.");,             },             setExecutor((Executor) o);,         },         return (Executor) o;,     }, ,     /**,      * Execute the specified sequence of targets, and the targets,      * they depend on.,      *,      * @param names A vector of target name strings to execute.,      *              Must not be <code>null</code>.,      *,      * @exception BuildException if the build failed.,      */,     public void executeTargets(Vector names) throws BuildException {,         setUserProperty(MagicNames.PROJECT_INVOKED_TARGETS,,                         CollectionUtils.flattenToString(names));,         getExecutor().executeTargets(this,,             (String[]) (names.toArray(new String[names.size()])));,     }, ,     /**,      * Demultiplex output so that each task receives the appropriate,      * messages. If the current thread is not currently executing a task,,      * the message is logged directly.,      *,      * @param output Message to handle. Should not be <code>null</code>.,      * @param isWarning Whether the text represents an warning (<code>true</code>),      *        or information (<code>false</code>).,      */,     public void demuxOutput(String output, boolean isWarning) {,         Task task = getThreadTask(Thread.currentThread());,         if (task == null) {,             log(output, isWarning ? MSG_WARN : MSG_INFO);,         } else {,             if (isWarning) {,                 task.handleErrorOutput(output);,             } else {,                 task.handleOutput(output);,             },         },     }, ,     /**,      * Read data from the default input stream. If no default has been,      * specified, System.in is used.,      *,      * @param buffer the buffer into which data is to be read.,      * @param offset the offset into the buffer at which data is stored.,      * @param length the amount of data to read.,      *,      * @return the number of bytes read.,      *,      * @exception IOException if the data cannot be read.,      * @since Ant 1.6,      */,     public int defaultInput(byte[] buffer, int offset, int length),         throws IOException {,         if (defaultInputStream != null) {,             System.out.flush();,             return defaultInputStream.read(buffer, offset, length);,         } else {,             throw new EOFException("No input provided for project");,         },     }, ,     /**,      * Demux an input request to the correct task.,      *,      * @param buffer the buffer into which data is to be read.,      * @param offset the offset into the buffer at which data is stored.,      * @param length the amount of data to read.,      *,      * @return the number of bytes read.,      *,      * @exception IOException if the data cannot be read.,      * @since Ant 1.6,      */,     public int demuxInput(byte[] buffer, int offset, int length),         throws IOException {,         Task task = getThreadTask(Thread.currentThread());,         if (task == null) {,             return defaultInput(buffer, offset, length);,         } else {,             return task.handleInput(buffer, offset, length);,         },     }, ,     /**,      * Demultiplex flush operations so that each task receives the appropriate,      * messages. If the current thread is not currently executing a task,,      * the message is logged directly.,      *,      * @since Ant 1.5.2,      *,      * @param output Message to handle. Should not be <code>null</code>.,      * @param isError Whether the text represents an error (<code>true</code>),      *        or information (<code>false</code>).,      */,     public void demuxFlush(String output, boolean isError) {,         Task task = getThreadTask(Thread.currentThread());,         if (task == null) {,             fireMessageLogged(this, output, isError ? MSG_ERR : MSG_INFO);,         } else {,             if (isError) {,                 task.handleErrorFlush(output);,             } else {,                 task.handleFlush(output);,             },         },     }, ,     /**,      * Execute the specified target and any targets it depends on.,      *,      * @param targetName The name of the target to execute.,      *                   Must not be <code>null</code>.,      *,      * @exception BuildException if the build failed.,      */,     public void executeTarget(String targetName) throws BuildException {, ,         // sanity check ourselves, if we've been asked to build nothing,         // then we should complain, ,         if (targetName == null) {,             String msg = "No target specified";,             throw new BuildException(msg);,         }, ,         // Sort and run the dependency tree.,         // Sorting checks if all the targets (and dependencies),         // exist, and if there is any cycle in the dependency,         // graph.,         executeSortedTargets(topoSort(targetName, targets, false));,     }, ,     /**,      * Execute a <code>Vector</code> of sorted targets.,      * @param sortedTargets   the aforementioned <code>Vector</code>.,      * @throws BuildException on error.,      */,     public void executeSortedTargets(Vector sortedTargets),         throws BuildException {,         Set succeededTargets = new HashSet();,         BuildException buildException = null; // first build exception,         for (Enumeration iter = sortedTargets.elements();,              iter.hasMoreElements();) {,             Target curtarget = (Target) iter.nextElement();,             boolean canExecute = true;,             for (Enumeration depIter = curtarget.getDependencies();,                  depIter.hasMoreElements();) {,                 String dependencyName = ((String) depIter.nextElement());,                 if (!succeededTargets.contains(dependencyName)) {,                     canExecute = false;,                     log(curtarget,,                         "Cannot execute '" + curtarget.getName() + "' - '",                         + dependencyName + "' failed or was not executed.",,                         MSG_ERR);,                     break;,                 },             },             if (canExecute) {,                 Throwable thrownException = null;,                 try {,                     curtarget.performTasks();,                     succeededTargets.add(curtarget.getName());,                 } catch (RuntimeException ex) {,                     if (!(keepGoingMode)) {,                         throw ex; // throw further,                     },                     thrownException = ex;,                 } catch (Throwable ex) {,                     if (!(keepGoingMode)) {,                         throw new BuildException(ex);,                     },                     thrownException = ex;,                 },                 if (thrownException != null) {,                     if (thrownException instanceof BuildException) {,                         log(curtarget,,                             "Target '" + curtarget.getName(),                             + "' failed with message '",                             + thrownException.getMessage() + "'.", MSG_ERR);,                         // only the first build exception is reported,                         if (buildException == null) {,                             buildException = (BuildException) thrownException;,                         },                     } else {,                         log(curtarget,,                             "Target '" + curtarget.getName(),                             + "' failed with message '",                             + thrownException.getMessage() + "'.", MSG_ERR);,                         thrownException.printStackTrace(System.err);,                         if (buildException == null) {,                             buildException =,                                 new BuildException(thrownException);,                         },                     },                 },             },         },         if (buildException != null) {,             throw buildException;,         },     }, ,     /**,      * Return the canonical form of a filename.,      * <p>,      * If the specified file name is relative it is resolved,      * with respect to the given root directory.,      *,      * @param fileName The name of the file to resolve.,      *                 Must not be <code>null</code>.,      *,      * @param rootDir  The directory respective to which relative file names,      *                 are resolved. May be <code>null</code>, in which case,      *                 the current directory is used.,      *,      * @return the resolved File.,      *,      * @deprecated since 1.4.x,      */,     public File resolveFile(String fileName, File rootDir) {,         return FILE_UTILS.resolveFile(rootDir, fileName);,     }, ,     /**,      * Return the canonical form of a filename.,      * <p>,      * If the specified file name is relative it is resolved,      * with respect to the project's base directory.,      *,      * @param fileName The name of the file to resolve.,      *                 Must not be <code>null</code>.,      *,      * @return the resolved File.,      *,      */,     public File resolveFile(String fileName) {,         return FILE_UTILS.resolveFile(baseDir, fileName);,     }, ,     /**,      * Translate a path into its native (platform specific) format.,      * <p>,      * This method uses PathTokenizer to separate the input path,      * into its components. This handles DOS style paths in a relatively,      * sensible way. The file separators are then converted to their platform,      * specific versions.,      *,      * @param toProcess The path to be translated.,      *                  May be <code>null</code>.,      *,      * @return the native version of the specified path or,      *         an empty string if the path is <code>null</code> or empty.,      *,      * @deprecated since 1.7,      *             Use FileUtils.translatePath instead.,      *,      * @see PathTokenizer,      */,     public static String translatePath(String toProcess) {,         return FileUtils.translatePath(toProcess);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination.,      * No filtering is performed.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(String sourceFile, String destFile),           throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination,      * specifying if token filtering should be used.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(String sourceFile, String destFile, boolean filtering),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used and if,      * source files may overwrite newer destination files.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(String sourceFile, String destFile, boolean filtering,,                          boolean overwrite) throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used, if,      * source files may overwrite newer destination files, and if the,      * last modified time of the resulting file should be set to,      * that of the source file.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      * @param preserveLastModified Whether or not the last modified time of,      *                             the resulting file should be set to that,      *                             of the source file.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(String sourceFile, String destFile, boolean filtering,,                          boolean overwrite, boolean preserveLastModified),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite, preserveLastModified);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination.,      * No filtering is performed.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(File sourceFile, File destFile) throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination,      * specifying if token filtering should be used.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(File sourceFile, File destFile, boolean filtering),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used and if,      * source files may overwrite newer destination files.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      *,      * @exception IOException if the file cannot be copied.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(File sourceFile, File destFile, boolean filtering,,                          boolean overwrite) throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used, if,      * source files may overwrite newer destination files, and if the,      * last modified time of the resulting file should be set to,      * that of the source file.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      * @param preserveLastModified Whether or not the last modified time of,      *                             the resulting file should be set to that,      *                             of the source file.,      *,      * @exception IOException if the file cannot be copied.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(File sourceFile, File destFile, boolean filtering,,                          boolean overwrite, boolean preserveLastModified),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite, preserveLastModified);,     }, ,     /**,      * Call File.setLastModified(long time) on Java above 1.1, and logs,      * a warning on Java 1.1.,      *,      * @param file The file to set the last modified time on.,      *             Must not be <code>null</code>.,      *,      * @param time the required modification time.,      *,      * @deprecated since 1.4.x,      *,      * @exception BuildException if the last modified time cannot be set,      *                           despite running on a platform with a version,      *                           above 1.1.,      */,     public void setFileLastModified(File file, long time),          throws BuildException {,         FILE_UTILS.setFileLastModified(file, time);,         log("Setting modification time for " + file, MSG_VERBOSE);,     }, ,     /**,      * Return the boolean equivalent of a string, which is considered,      * <code>true</code> if either <code>"on"</code>, <code>"true"</code>,,      * or <code>"yes"</code> is found, ignoring case.,      *,      * @param s The string to convert to a boolean value.,      *,      * @return <code>true</code> if the given string is <code>"on"</code>,,      *         <code>"true"</code> or <code>"yes"</code>, or,      *         <code>false</code> otherwise.,      */,     public static boolean toBoolean(String s) {,         return ("on".equalsIgnoreCase(s),                 || "true".equalsIgnoreCase(s),                 || "yes".equalsIgnoreCase(s));,     }, ,     /**,      * Get the Project instance associated with the specified object.,      * @param o the object to query.,      * @return Project instance, if any.,      * @since Ant 1.7.1,      */,     public static Project getProject(Object o) {,         if (o instanceof ProjectComponent) {,             return ((ProjectComponent) o).getProject();,         },         try {,             Method m = o.getClass().getMethod("getProject", (Class[]) null);,             if (Project.class == m.getReturnType()) {,                 return (Project) m.invoke(o, (Object[]) null);,             },         } catch (Exception e) {,             //too bad,         },         return null;,     }, ,     /**,      * Topologically sort a set of targets.  Equivalent to calling,      * <code>topoSort(new String[] {root}, targets, true)</code>.,      *,      * @param root The name of the root target. The sort is created in such,      *             a way that the sequence of Targets up to the root,      *             target is the minimum possible such sequence.,      *             Must not be <code>null</code>.,      * @param targetTable A Hashtable mapping names to Targets.,      *                Must not be <code>null</code>.,      * @return a Vector of ALL Target objects in sorted order.,      * @exception BuildException if there is a cyclic dependency among the,      *                           targets, or if a named target does not exist.,      */,     public final Vector topoSort(String root, Hashtable targetTable),         throws BuildException {,         return topoSort(new String[] {root}, targetTable, true);,     }, ,     /**,      * Topologically sort a set of targets.  Equivalent to calling,      * <code>topoSort(new String[] {root}, targets, returnAll)</code>.,      *,      * @param root The name of the root target. The sort is created in such,      *             a way that the sequence of Targets up to the root,      *             target is the minimum possible such sequence.,      *             Must not be <code>null</code>.,      * @param targetTable A Hashtable mapping names to Targets.,      *                Must not be <code>null</code>.,      * @param returnAll <code>boolean</code> indicating whether to return all,      *                  targets, or the execution sequence only.,      * @return a Vector of Target objects in sorted order.,      * @exception BuildException if there is a cyclic dependency among the,      *                           targets, or if a named target does not exist.,      * @since Ant 1.6.3,      */,     public final Vector topoSort(String root, Hashtable targetTable,,                                  boolean returnAll) throws BuildException {,         return topoSort(new String[] {root}, targetTable, returnAll);,     }, ,     /**,      * Topologically sort a set of targets.,      *,      * @param root <code>String[]</code> containing the names of the root targets.,      *             The sort is created in such a way that the ordered sequence of,      *             Targets is the minimum possible such sequence to the specified,      *             root targets.,      *             Must not be <code>null</code>.,      * @param targetTable A map of names to targets (String to Target).,      *                Must not be <code>null</code>.,      * @param returnAll <code>boolean</code> indicating whether to return all,      *                  targets, or the execution sequence only.,      * @return a Vector of Target objects in sorted order.,      * @exception BuildException if there is a cyclic dependency among the,      *                           targets, or if a named target does not exist.,      * @since Ant 1.6.3,      */,     public final Vector topoSort(String[] root, Hashtable targetTable,,                                  boolean returnAll) throws BuildException {,         Vector ret = new VectorSet();,         Hashtable state = new Hashtable();,         Stack visiting = new Stack();, ,         // We first run a DFS based sort using each root as a starting node.,         // This creates the minimum sequence of Targets to the root node(s).,         // We then do a sort on any remaining unVISITED targets.,         // This is unnecessary for doing our build, but it catches,         // circular dependencies or missing Targets on the entire,         // dependency tree, not just on the Targets that depend on the,         // build Target., ,         for (int i = 0; i < root.length; i++) {,             String st = (String) (state.get(root[i]));,             if (st == null) {,                 tsort(root[i], targetTable, state, visiting, ret);,             } else if (st == VISITING) {,                 throw new RuntimeException("Unexpected node in visiting state: ",                     + root[i]);,             },         },         StringBuffer buf = new StringBuffer("Build sequence for target(s)");, ,         for (int j = 0; j < root.length; j++) {,             buf.append((j == 0) ? " `" : ", `").append(root[j]).append('\'');,         },         buf.append(" is " + ret);,         log(buf.toString(), MSG_VERBOSE);, ,         Vector complete = (returnAll) ? ret : new Vector(ret);,         for (Enumeration en = targetTable.keys(); en.hasMoreElements();) {,             String curTarget = (String) en.nextElement();,             String st = (String) state.get(curTarget);,             if (st == null) {,                 tsort(curTarget, targetTable, state, visiting, complete);,             } else if (st == VISITING) {,                 throw new RuntimeException("Unexpected node in visiting state: ",                     + curTarget);,             },         },         log("Complete build sequence is " + complete, MSG_VERBOSE);,         return ret;,     }, ,     /**,      * Perform a single step in a recursive depth-first-search traversal of,      * the target dependency tree.,      * <p>,      * The current target is first set to the &quot;visiting&quot; state, and,      * pushed onto the &quot;visiting&quot; stack.,      * <p>,      * An exception is then thrown if any child of the current node is in the,      * visiting state, as that implies a circular dependency. The exception,      * contains details of the cycle, using elements of the &quot;visiting&quot;,      * stack.,      * <p>,      * If any child has not already been &quot;visited&quot;, this method is,      * called recursively on it.,      * <p>,      * The current target is then added to the ordered list of targets. Note,      * that this is performed after the children have been visited in order,      * to get the correct order. The current target is set to the,      * &quot;visited&quot; state.,      * <p>,      * By the time this method returns, the ordered list contains the sequence,      * of targets up to and including the current target.,      *,      * @param root The current target to inspect.,      *             Must not be <code>null</code>.,      * @param targetTable A mapping from names to targets (String to Target).,      *                Must not be <code>null</code>.,      * @param state   A mapping from target names to states (String to String).,      *                The states in question are &quot;VISITING&quot; and,      *                &quot;VISITED&quot;. Must not be <code>null</code>.,      * @param visiting A stack of targets which are currently being visited.,      *                 Must not be <code>null</code>.,      * @param ret     The list to add target names to. This will end up,      *                containing the complete list of dependencies in,      *                dependency order.,      *                Must not be <code>null</code>.,      *,      * @exception BuildException if a non-existent target is specified or if,      *                           a circular dependency is detected.,      */,     private void tsort(String root, Hashtable targetTable,,                              Hashtable state, Stack visiting,,                              Vector ret),         throws BuildException {,         state.put(root, VISITING);,         visiting.push(root);, ,         Target target = (Target) targetTable.get(root);, ,         // Make sure we exist,         if (target == null) {,             StringBuffer sb = new StringBuffer("Target \"");,             sb.append(root);,             sb.append("\" does not exist in the project \"");,             sb.append(name);,             sb.append("\". ");,             visiting.pop();,             if (!visiting.empty()) {,                 String parent = (String) visiting.peek();,                 sb.append("It is used from target \"");,                 sb.append(parent);,                 sb.append("\".");,             },             throw new BuildException(new String(sb));,         },         for (Enumeration en = target.getDependencies(); en.hasMoreElements();) {,             String cur = (String) en.nextElement();,             String m = (String) state.get(cur);,             if (m == null) {,                 // Not been visited,                 tsort(cur, targetTable, state, visiting, ret);,             } else if (m == VISITING) {,                 // Currently visiting this node, so have a cycle,                 throw makeCircularException(cur, visiting);,             },         },         String p = (String) visiting.pop();,         if (root != p) {,             throw new RuntimeException("Unexpected internal error: expected to ",                 + "pop " + root + " but got " + p);,         },         state.put(root, VISITED);,         ret.addElement(target);,     }, ,     /**,      * Build an appropriate exception detailing a specified circular,      * dependency.,      *,      * @param end The dependency to stop at. Must not be <code>null</code>.,      * @param stk A stack of dependencies. Must not be <code>null</code>.,      *,      * @return a BuildException detailing the specified circular dependency.,      */,     private static BuildException makeCircularException(String end, Stack stk) {,         StringBuffer sb = new StringBuffer("Circular dependency: ");,         sb.append(end);,         String c;,         do {,             c = (String) stk.pop();,             sb.append(" <- ");,             sb.append(c);,         } while (!c.equals(end));,         return new BuildException(new String(sb));,     }, ,     /**,      * Inherit the id references.,      * @param parent the parent project of this project.,      */,     public void inheritIDReferences(Project parent) {,         parentIdProject = parent;,     }, ,     /**,      * Add an id reference.,      * Used for broken build files.,      * @param id the id to set.,      * @param value the value to set it to (Unknown element in this case.,      */,     public void addIdReference(String id, Object value) {,         idReferences.put(id, value);,     }, ,     /**,      * Add a reference to the project.,      *,      * @param referenceName The name of the reference. Must not be <code>null</code>.,      * @param value The value of the reference.,      */,     public void addReference(String referenceName, Object value) {,         Object old = ((AntRefTable) references).getReal(referenceName);,         if (old == value) {,             // no warning, this is not changing anything,             return;,         },         if (old != null && !(old instanceof UnknownElement)) {,             log("Overriding previous definition of reference to " + referenceName,,                 MSG_VERBOSE);,         },         log("Adding reference: " + referenceName, MSG_DEBUG);,         references.put(referenceName, value);,     }, ,     /**,      * Return a map of the references in the project (String to Object).,      * The returned hashtable is &quot;live&quot; and so must not be modified.,      *,      * @return a map of the references in the project (String to Object).,      */,     public Hashtable getReferences() {,         return references;,     }, ,     /**,      * Does the project know this reference?,      *,      * @since Ant 1.8.0,      */,     public boolean hasReference(String key) {,         return references.containsKey(key);,     }, ,     /**,      * Return a map of the references in the project (String to,      * Object).  The returned hashtable is a copy of the,      * &quot;live&quot; references.,      *,      * @return a map of the references in the project (String to Object).,      *,      * @since Ant 1.8.1,      */,     public Map getCopyOfReferences() {,         return new HashMap(references);,     }, ,     /**,      * Look up a reference by its key (ID).,      *,      * @param key The key for the desired reference.,      *            Must not be <code>null</code>.,      *,      * @return the reference with the specified ID, or <code>null</code> if,      *         there is no such reference in the project.,      */,     public Object getReference(String key) {,         Object ret = references.get(key);,         if (ret != null) {,             return ret;,         },         if (!key.equals(MagicNames.REFID_PROPERTY_HELPER)) {,             try {,                 if (PropertyHelper.getPropertyHelper(this).containsProperties(key)) {,                     log("Unresolvable reference " + key,                             + " might be a misuse of property expansion syntax.", MSG_WARN);,                 },             } catch (Exception e) {,                 //ignore,             },         },         return ret;,     }, ,     /**,      * Return a description of the type of the given element, with,      * special handling for instances of tasks and data types.,      * <p>,      * This is useful for logging purposes.,      *,      * @param element The element to describe.,      *                Must not be <code>null</code>.,      *,      * @return a description of the element type.,      *,      * @since 1.95, Ant 1.5,      */,     public String getElementName(Object element) {,         return ComponentHelper.getComponentHelper(this).getElementName(element);,     }, ,     /**,      * Send a &quot;build started&quot; event,      * to the build listeners for this project.,      */,     public void fireBuildStarted() {,         BuildEvent event = new BuildEvent(this);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].buildStarted(event);,         },     }, ,     /**,      * Send a &quot;build finished&quot; event to the build listeners,      * for this project.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      */,     public void fireBuildFinished(Throwable exception) {,         BuildEvent event = new BuildEvent(this);,         event.setException(exception);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].buildFinished(event);,         },         // Inform IH to clear the cache,         IntrospectionHelper.clearCache();,     }, ,     /**,      * Send a &quot;subbuild started&quot; event to the build listeners for,      * this project.,      *,      * @since Ant 1.6.2,      */,     public void fireSubBuildStarted() {,         BuildEvent event = new BuildEvent(this);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             if (currListeners[i] instanceof SubBuildListener) {,                 ((SubBuildListener) currListeners[i]).subBuildStarted(event);,             },         },     }, ,     /**,      * Send a &quot;subbuild finished&quot; event to the build listeners for,      * this project.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      *,      * @since Ant 1.6.2,      */,     public void fireSubBuildFinished(Throwable exception) {,         BuildEvent event = new BuildEvent(this);,         event.setException(exception);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             if (currListeners[i] instanceof SubBuildListener) {,                 ((SubBuildListener) currListeners[i]).subBuildFinished(event);,             },         },     }, ,     /**,      * Send a &quot;target started&quot; event to the build listeners,      * for this project.,      *,      * @param target The target which is starting to build.,      *               Must not be <code>null</code>.,      */,     protected void fireTargetStarted(Target target) {,         BuildEvent event = new BuildEvent(target);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].targetStarted(event);,         }, ,     }, ,     /**,      * Send a &quot;target finished&quot; event to the build listeners,      * for this project.,      *,      * @param target    The target which has finished building.,      *                  Must not be <code>null</code>.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      */,     protected void fireTargetFinished(Target target, Throwable exception) {,         BuildEvent event = new BuildEvent(target);,         event.setException(exception);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].targetFinished(event);,         }, ,     }, ,     /**,      * Send a &quot;task started&quot; event to the build listeners,      * for this project.,      *,      * @param task The target which is starting to execute.,      *               Must not be <code>null</code>.,      */,     protected void fireTaskStarted(Task task) {,         // register this as the current task on the current thread.,         registerThreadTask(Thread.currentThread(), task);,         BuildEvent event = new BuildEvent(task);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].taskStarted(event);,         },     }, ,     /**,      * Send a &quot;task finished&quot; event to the build listeners for this,      * project.,      *,      * @param task      The task which has finished executing.,      *                  Must not be <code>null</code>.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      */,     protected void fireTaskFinished(Task task, Throwable exception) {,         registerThreadTask(Thread.currentThread(), null);,         System.out.flush();,         System.err.flush();,         BuildEvent event = new BuildEvent(task);,         event.setException(exception);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].taskFinished(event);,         }, ,     }, ,     /**,      * Send a &quot;message logged&quot; event to the build listeners,      * for this project.,      *,      * @param event    The event to send. This should be built up with the,      *                 appropriate task/target/project by the caller, so that,      *                 this method can set the message and priority, then send,      *                 the event. Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     private void fireMessageLoggedEvent(BuildEvent event, String message,,                                         int priority) {, ,         if (message == null) {,             message = String.valueOf(message);,         },         if (message.endsWith(StringUtils.LINE_SEP)) {,             int endIndex = message.length() - StringUtils.LINE_SEP.length();,             event.setMessage(message.substring(0, endIndex), priority);,         } else {,             event.setMessage(message, priority);,         },         if (isLoggingMessage.get() != Boolean.FALSE) {,             /*,              * One of the Listeners has attempted to access,              * System.err or System.out.,              *,              * We used to throw an exception in this case, but,              * sometimes Listeners can't prevent it(like our own,              * Log4jListener which invokes getLogger() which in,              * turn wants to write to the console).,              *,              * @see http://marc.theaimsgroup.com/?t=110538624200006&r=1&w=2,              *,              * We now (Ant 1.6.3 and later) simply swallow the message.,              */,             return;,         },         try {,             isLoggingMessage.set(Boolean.TRUE);,             BuildListener[] currListeners = listeners;,             for (int i = 0; i < currListeners.length; i++) {,                 currListeners[i].messageLogged(event);,             },         } finally {,             isLoggingMessage.set(Boolean.FALSE);,         },     }, ,     /**,      * Send a &quot;message logged&quot; project level event,      * to the build listeners for this project.,      *,      * @param project  The project generating the event.,      *                 Should not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     protected void fireMessageLogged(Project project, String message,,                                      int priority) {,         fireMessageLogged(project, message, null, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; project level event,      * to the build listeners for this project.,      *,      * @param project  The project generating the event.,      *                 Should not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param throwable The exception that caused this message. May be <code>null</code>.,      * @param priority The priority of the message.,      * @since 1.7,      */,     protected void fireMessageLogged(Project project, String message,,             Throwable throwable, int priority) {,         BuildEvent event = new BuildEvent(project);,         event.setException(throwable);,         fireMessageLoggedEvent(event, message, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; target level event,      * to the build listeners for this project.,      *,      * @param target   The target generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     protected void fireMessageLogged(Target target, String message,,                                      int priority) {,         fireMessageLogged(target, message, null, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; target level event,      * to the build listeners for this project.,      *,      * @param target   The target generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param throwable The exception that caused this message. May be <code>null</code>.,      * @param priority The priority of the message.,      * @since 1.7,      */,     protected void fireMessageLogged(Target target, String message,,             Throwable throwable, int priority) {,         BuildEvent event = new BuildEvent(target);,         event.setException(throwable);,         fireMessageLoggedEvent(event, message, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; task level event,      * to the build listeners for this project.,      *,      * @param task     The task generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     protected void fireMessageLogged(Task task, String message, int priority) {,         fireMessageLogged(task, message, null, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; task level event,      * to the build listeners for this project.,      *,      * @param task     The task generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param throwable The exception that caused this message. May be <code>null</code>.,      * @param priority The priority of the message.,      * @since 1.7,      */,     protected void fireMessageLogged(Task task, String message,,             Throwable throwable, int priority) {,         BuildEvent event = new BuildEvent(task);,         event.setException(throwable);,         fireMessageLoggedEvent(event, message, priority);,     }, ,     /**,      * Register a task as the current task for a thread.,      * If the task is null, the thread's entry is removed.,      *,      * @param thread the thread on which the task is registered.,      * @param task the task to be registered.,      * @since Ant 1.5,      */,     public void registerThreadTask(Thread thread, Task task) {,         synchronized(threadTasks) {,             if (task != null) {,                 threadTasks.put(thread, task);,                 threadGroupTasks.put(thread.getThreadGroup(), task);,             } else {,                 threadTasks.remove(thread);,                 threadGroupTasks.remove(thread.getThreadGroup());,             },         },     }, ,     /**,      * Get the current task associated with a thread, if any.,      *,      * @param thread the thread for which the task is required.,      * @return the task which is currently registered for the given thread or,      *         null if no task is registered.,      */,     public Task getThreadTask(Thread thread) {,         synchronized(threadTasks) {,             Task task = (Task) threadTasks.get(thread);,             if (task == null) {,                 ThreadGroup group = thread.getThreadGroup();,                 while (task == null && group != null) {,                     task = (Task) threadGroupTasks.get(group);,                     group = group.getParent();,                 },             },             return task;,         },     }, , ,     // Should move to a separate public class - and have API to add,     // listeners, etc.,     private static class AntRefTable extends Hashtable {, ,         AntRefTable() {,             super();,         }, ,         /** Returns the unmodified original object.,          * This method should be called internally to,          * get the &quot;real&quot; object.,          * The normal get method will do the replacement,          * of UnknownElement (this is similar with the JDNI,          * refs behavior).,          */,         private Object getReal(Object key) {,             return super.get(key);,         }, ,         /** Get method for the reference table.,          *  It can be used to hook dynamic references and to modify,          * some references on the fly--for example for delayed,          * evaluation.,          *,          * It is important to make sure that the processing that is,          * done inside is not calling get indirectly.,          *,          * @param key lookup key.,          * @return mapped value.,          */,         public Object get(Object key) {,             //System.out.println("AntRefTable.get " + key);,             Object o = getReal(key);,             if (o instanceof UnknownElement) {,                 // Make sure that,                 UnknownElement ue = (UnknownElement) o;,                 ue.maybeConfigure();,                 o = ue.getRealThing();,             },             return o;,         },     }, ,     /**,      * Set a reference to this Project on the parameterized object.,      * Need to set the project before other set/add elements,      * are called.,      * @param obj the object to invoke setProject(this) on.,      */,     public final void setProjectReference(final Object obj) {,         if (obj instanceof ProjectComponent) {,             ((ProjectComponent) obj).setProject(this);,             return;,         },         try {,             Method method =,                 obj.getClass().getMethod(,                     "setProject", new Class[] {Project.class});,             if (method != null) {,                 method.invoke(obj, new Object[] {this});,             },         } catch (Throwable e) {,             // ignore this if the object does not have,             // a set project method or the method,             // is private/protected.,         },     }, ,     /**,      * Resolve the file relative to the project's basedir and return it as a,      * FileResource.,      * @param name the name of the file to resolve.,      * @return the file resource.,      * @since Ant 1.7,      */,     public Resource getResource(String name) {,         return new FileResource(getBaseDir(), name);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/ant/Target.java,,43-477,[    private String ifCondition = "";, ,     /** The "unless" condition to test on execution. */,     private String unlessCondition = "";, ,     /** List of targets this target is dependent on. */,     private List/*<String>*/ dependencies = null;, ,     /** Children of this target (tasks and data types). */,     private List children = new ArrayList();, ,     /** Since Ant 1.6.2 */,     private Location location = Location.UNKNOWN_LOCATION;, ,     /** Project this target belongs to. */,     private Project project;, ,     /** Description of this target, if any. */,     private String description = null;, ,     /** Default constructor. */,     public Target() {,         //empty,     }, ,     /**,      * Cloning constructor.,      * @param other the Target to clone.,      */,     public Target(Target other) {,         this.name = other.name;,         this.ifCondition = other.ifCondition;,         this.unlessCondition = other.unlessCondition;,         this.dependencies = other.dependencies;,         this.location = other.location;,         this.project = other.project;,         this.description = other.description;,         // The children are added to after this cloning,         this.children = other.children;,     }, ,     /**,      * Sets the project this target belongs to.,      *,      * @param project The project this target belongs to.,      *                Must not be <code>null</code>.,      */,     public void setProject(Project project) {,         this.project = project;,     }, ,     /**,      * Returns the project this target belongs to.,      *,      * @return The project this target belongs to, or <code>null</code> if,      *         the project has not been set yet.,      */,     public Project getProject() {,         return project;,     }, ,     /**,      * Sets the location of this target's definition.,      *,      * @param location   <code>Location</code>,      * @since 1.6.2,      */,     public void setLocation(Location location) {,         this.location = location;,     }, ,     /**,      * Get the location of this target's definition.,      *,      * @return <code>Location</code>,      * @since 1.6.2,      */,     public Location getLocation() {,         return location;,     }, ,     /**,      * Sets the list of targets this target is dependent on.,      * The targets themselves are not resolved at this time.,      *,      * @param depS A comma-separated list of targets this target,      *             depends on. Must not be <code>null</code>.,      */,     public void setDepends(String depS) {,         for (Iterator iter = parseDepends(depS, getName(), "depends").iterator();,              iter.hasNext(); ) {,             addDependency((String) iter.next());,         },     }, ,     public static List/*<String>*/ parseDepends(String depends,,                                                 String targetName,,                                                 String attributeName) {,         ArrayList list = new ArrayList();,         if (depends.length() > 0) {,             StringTokenizer tok =,                 new StringTokenizer(depends, ",", true);,             while (tok.hasMoreTokens()) {,                 String token = tok.nextToken().trim();, ,                 // Make sure the dependency is not empty string,                 if ("".equals(token) || ",".equals(token)) {,                     throw new BuildException("Syntax Error: ",                                              + attributeName,                                              + " attribute of target \"",                                              + targetName,                                              + "\" contains an empty string.");,                 }, ,                 list.add(token);, ,                 // Make sure that depends attribute does not,                 // end in a ,,                 if (tok.hasMoreTokens()) {,                     token = tok.nextToken();,                     if (!tok.hasMoreTokens() || !",".equals(token)) {,                         throw new BuildException("Syntax Error: ",                                                  + attributeName,                                                  + " attribute for target \"",                                                  + targetName,                                                  + "\" ends with a \",\" ",                                                  + "character");,                     },                 },             },         },         return list;,     }, ,     /**,      * Sets the name of this target.,      *,      * @param name The name of this target. Should not be <code>null</code>.,      */,     public void setName(String name) {,         this.name = name;,     }, ,     /**,      * Returns the name of this target.,      *,      * @return the name of this target, or <code>null</code> if the,      *         name has not been set yet.,      */,     public String getName() {,         return name;,     }, ,     /**,      * Adds a task to this target.,      *,      * @param task The task to be added. Must not be <code>null</code>.,      */,     public void addTask(Task task) {,         children.add(task);,     }, ,     /**,      * Adds the wrapper for a data type element to this target.,      *,      * @param r The wrapper for the data type element to be added.,      *          Must not be <code>null</code>.,      */,     public void addDataType(RuntimeConfigurable r) {,         children.add(r);,     }, ,     /**,      * Returns the current set of tasks to be executed by this target.,      *,      * @return an array of the tasks currently within this target,      */,     public Task[] getTasks() {,         List tasks = new ArrayList(children.size());,         Iterator it = children.iterator();,         while (it.hasNext()) {,             Object o = it.next();,             if (o instanceof Task) {,                 tasks.add(o);,             },         },         return (Task[]) tasks.toArray(new Task[tasks.size()]);,     }, ,     /**,      * Adds a dependency to this target.,      *,      * @param dependency The name of a target this target is dependent on.,      *                   Must not be <code>null</code>.,      */,     public void addDependency(String dependency) {,         if (dependencies == null) {,             dependencies = new ArrayList(2);,         },         dependencies.add(dependency);,     }, ,     /**,      * Returns an enumeration of the dependencies of this target.,      *,      * @return an enumeration of the dependencies of this target (enumeration of String),      */,     public Enumeration getDependencies() {,         return Collections,                 .enumeration(dependencies == null ? Collections.EMPTY_LIST : dependencies);,     }, ,     /**,      * Does this target depend on the named target?,      * @param other the other named target.,      * @return true if the target does depend on the named target,      * @since Ant 1.6,      */,     public boolean dependsOn(String other) {,         Project p = getProject();,         Hashtable t = p == null ? null : p.getTargets();,         return p != null && p.topoSort(getName(), t, false).contains(t.get(other));,     }, ,     /**,      * Sets the "if" condition to test on execution. This is the,      * name of a property to test for existence - if the property,      * is not set, the task will not execute. The property goes,      * through property substitution once before testing, so if,      * property <code>foo</code> has value <code>bar</code>, setting,      * the "if" condition to <code>${foo}_x</code> will mean that the,      * task will only execute if property <code>bar_x</code> is set.,      *,      * @param property The property condition to test on execution.,      *                 May be <code>null</code>, in which case,      *                 no "if" test is performed.,      */,     public void setIf(String property) {,         ifCondition = property == null ? "" : property;,     }, ,     /**,      * Returns the "if" property condition of this target.,      *,      * @return the "if" property condition or <code>null</code> if no,      *         "if" condition had been defined.,      * @since 1.6.2,      */,     public String getIf() {,         return "".equals(ifCondition) ? null : ifCondition;,     }, ,     /**,      * Sets the "unless" condition to test on execution. This is the,      * name of a property to test for existence - if the property,      * is set, the task will not execute. The property goes,      * through property substitution once before testing, so if,      * property <code>foo</code> has value <code>bar</code>, setting,      * the "unless" condition to <code>${foo}_x</code> will mean that the,      * task will only execute if property <code>bar_x</code> isn't set.,      *,      * @param property The property condition to test on execution.,      *                 May be <code>null</code>, in which case,      *                 no "unless" test is performed.,      */,     public void setUnless(String property) {,         unlessCondition = property == null ? "" : property;,     }, ,     /**,      * Returns the "unless" property condition of this target.,      *,      * @return the "unless" property condition or <code>null</code>,      *         if no "unless" condition had been defined.,      * @since 1.6.2,      */,     public String getUnless() {,         return "".equals(unlessCondition) ? null : unlessCondition;,     }, ,     /**,      * Sets the description of this target.,      *,      * @param description The description for this target.,      *                    May be <code>null</code>, indicating that no,      *                    description is available.,      */,     public void setDescription(String description) {,         this.description = description;,     }, ,     /**,      * Returns the description of this target.,      *,      * @return the description of this target, or <code>null</code> if no,      *         description is available.,      */,     public String getDescription() {,         return description;,     }, ,     /**,      * Returns the name of this target.,      *,      * @return the name of this target, or <code>null</code> if the,      *         name has not been set yet.,      */,     public String toString() {,         return name;,     }, ,     /**,      * Executes the target if the "if" and "unless" conditions are,      * satisfied. Dependency checking should be done before calling this,      * method, as it does no checking of its own. If either the "if",      * or "unless" test prevents this target from being executed, a verbose,      * message is logged giving the reason. It is recommended that clients,      * of this class call performTasks rather than this method so that,      * appropriate build events are fired.,      *,      * @exception BuildException if any of the tasks fail or if a data type,      *                           configuration fails.,      *,      * @see #performTasks(),      * @see #setIf(String),      * @see #setUnless(String),      */,     public void execute() throws BuildException {,         if (!testIfAllows()) {,             project.log(this, "Skipped because property '" + project.replaceProperties(ifCondition),                     + "' not set.", Project.MSG_VERBOSE);,             return;,         },         if (!testUnlessAllows()) {,             project.log(this, "Skipped because property '",                     + project.replaceProperties(unlessCondition) + "' set.", Project.MSG_VERBOSE);,             return;,         },         LocalProperties localProperties = LocalProperties.get(getProject());,         localProperties.enterScope();,         try {,             // use index-based approach to avoid ConcurrentModificationExceptions;,             // also account for growing target children,             for (int i = 0; i < children.size(); i++) {,                 Object o = children.get(i);,                 if (o instanceof Task) {,                     Task task = (Task) o;,                     task.perform();,                 } else {,                     ((RuntimeConfigurable) o).maybeConfigure(project);,                 },             },         } finally {,             localProperties.exitScope();,         },     }, ,     /**,      * Performs the tasks within this target (if the conditions are met),,      * firing target started/target finished messages around a call to,      * execute.,      *,      * @see #execute(),      */,     public final void performTasks() {,         RuntimeException thrown = null;,         project.fireTargetStarted(this);,         try {,             execute();,         } catch (RuntimeException exc) {,             thrown = exc;,             throw exc;,         } finally {,             project.fireTargetFinished(this, thrown);,         },     }, ,     /**,      * Replaces all occurrences of the given task in the list,      * of children with the replacement data type wrapper.,      *,      * @param el The task to replace.,      *           Must not be <code>null</code>.,      * @param o  The data type wrapper to replace <code>el</code> with.,      */,     void replaceChild(Task el, RuntimeConfigurable o) {,         int index;,         while ((index = children.indexOf(el)) >= 0) {,             children.set(index, o);,         },     }, ,     /**,      * Replaces all occurrences of the given task in the list,      * of children with the replacement task.,      *,      * @param el The task to replace.,      *           Must not be <code>null</code>.,      * @param o  The task to replace <code>el</code> with.,      */,     void replaceChild(Task el, Task o) {,         int index;,         while ((index = children.indexOf(el)) >= 0) {,             children.set(index, o);,         },     }, ,     /**,      * Tests whether or not the "if" condition allows the execution of this target.,      *,      * @return whether or not the "if" condition is satisfied. If no,      *         condition (or an empty condition) has been set,,      *         <code>true</code> is returned.,      *,      * @see #setIf(String),      */,     private boolean testIfAllows() {,         PropertyHelper propertyHelper = PropertyHelper.getPropertyHelper(getProject());,         Object o = propertyHelper.parseProperties(ifCondition);,         return propertyHelper.testIfCondition(o);,     }, ,     /**,      * Tests whether or not the "unless" condition allows the execution of this target.,      *,      * @return whether or not the "unless" condition is satisfied. If no,      *         condition (or an empty condition) has been set,,      *         <code>true</code> is returned.,      *,      * @see #setUnless(String),      */,     private boolean testUnlessAllows() {,         PropertyHelper propertyHelper = PropertyHelper.getPropertyHelper(getProject());,         Object o = propertyHelper.parseProperties(unlessCondition);,         return propertyHelper.testUnlessCondition(o);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/ant/Task.java,,85-481,[    public Task() {,     }, ,     /**,      * Sets the target container of this task.,      *,      * @param target Target in whose scope this task belongs.,      *               May be <code>null</code>, indicating a top-level task.,      */,     public void setOwningTarget(Target target) {,         this.target = target;,     }, ,     /**,      * Returns the container target of this task.,      *,      * @return The target containing this task, or <code>null</code> if,      *         this task is a top-level task.,      */,     public Target getOwningTarget() {,         return target;,     }, ,     /**,      * Sets the name to use in logging messages.,      *,      * @param name The name to use in logging messages.,      *             Should not be <code>null</code>.,      */,     public void setTaskName(String name) {,         this.taskName = name;,     }, ,     /**,      * Returns the name to use in logging messages.,      *,      * @return the name to use in logging messages.,      */,     public String getTaskName() {,         return taskName;,     }, ,     /**,      * Sets the name with which the task has been invoked.,      *,      * @param type The name the task has been invoked as.,      *             Should not be <code>null</code>.,      */,     public void setTaskType(String type) {,         this.taskType = type;,     }, ,     /**,      * Called by the project to let the task initialize properly.,      * The default implementation is a no-op.,      *,      * @exception BuildException if something goes wrong with the build,      */,     public void init() throws BuildException {,     }, ,     /**,      * Called by the project to let the task do its work. This method may be,      * called more than once, if the task is invoked more than once.,      * For example,,      * if target1 and target2 both depend on target3, then running,      * "ant target1 target2" will run all tasks in target3 twice.,      *,      * @exception BuildException if something goes wrong with the build.,      */,     public void execute() throws BuildException {,     }, ,     /**,      * Returns the wrapper used for runtime configuration.,      *,      * @return the wrapper used for runtime configuration. This,      *         method will generate a new wrapper (and cache it),      *         if one isn't set already.,      */,     public RuntimeConfigurable getRuntimeConfigurableWrapper() {,         if (wrapper == null) {,             wrapper = new RuntimeConfigurable(this, getTaskName());,         },         return wrapper;,     }, ,     /**,      * Sets the wrapper to be used for runtime configuration.,      *,      * This method should be used only by the ProjectHelper and Ant internals.,      * It is public to allow helper plugins to operate on tasks, normal tasks,      * should never use it.,      *,      * @param wrapper The wrapper to be used for runtime configuration.,      *                May be <code>null</code>, in which case the next call,      *                to getRuntimeConfigurableWrapper will generate a new,      *                wrapper.,      */,     public void setRuntimeConfigurableWrapper(RuntimeConfigurable wrapper) {,         this.wrapper = wrapper;,     }, ,     // XXX: (Jon Skeet) The comment "if it hasn't been done already" may,     // not be strictly true. wrapper.maybeConfigure() won't configure the same,     // attributes/text more than once, but it may well add the children again,,     // unless I've missed something.,     /**,      * Configures this task - if it hasn't been done already.,      * If the task has been invalidated, it is replaced with an,      * UnknownElement task which uses the new definition in the project.,      *,      * @exception BuildException if the task cannot be configured.,      */,     public void maybeConfigure() throws BuildException {,         if (!invalid) {,             if (wrapper != null) {,                 wrapper.maybeConfigure(getProject());,             },         } else {,             getReplacement();,         },     }, ,     /**,      * Force the task to be reconfigured from its RuntimeConfigurable.,      */,     public void reconfigure() {,         if (wrapper != null) {,             wrapper.reconfigure(getProject());,         },     }, ,     /**,      * Handles output by logging it with the INFO priority.,      *,      * @param output The output to log. Should not be <code>null</code>.,      */,     protected void handleOutput(String output) {,         log(output, Project.MSG_INFO);,     }, ,     /**,      * Handles output by logging it with the INFO priority.,      *,      * @param output The output to log. Should not be <code>null</code>.,      *,      * @since Ant 1.5.2,      */,     protected void handleFlush(String output) {,         handleOutput(output);,     }, ,     /**,      * Handle an input request by this task.,      *,      * @param buffer the buffer into which data is to be read.,      * @param offset the offset into the buffer at which data is stored.,      * @param length the amount of data to read.,      *,      * @return the number of bytes read.,      *,      * @exception IOException if the data cannot be read.,      * @since Ant 1.6,      */,     protected int handleInput(byte[] buffer, int offset, int length),         throws IOException {,         return getProject().defaultInput(buffer, offset, length);,     }, ,     /**,      * Handles an error output by logging it with the WARN priority.,      *,      * @param output The error output to log. Should not be <code>null</code>.,      */,     protected void handleErrorOutput(String output) {,         log(output, Project.MSG_WARN);,     }, ,     /**,      * Handles an error line by logging it with the WARN priority.,      *,      * @param output The error output to log. Should not be <code>null</code>.,      *,      * @since Ant 1.5.2,      */,     protected void handleErrorFlush(String output) {,         handleErrorOutput(output);,     }, ,     /**,      * Logs a message with the default (INFO) priority.,      *,      * @param msg The message to be logged. Should not be <code>null</code>.,      */,     public void log(String msg) {,         log(msg, Project.MSG_INFO);,     }, ,     /**,      * Logs a message with the given priority. This delegates,      * the actual logging to the project.,      *,      * @param msg The message to be logged. Should not be <code>null</code>.,      * @param msgLevel The message priority at which this message is to,      *                 be logged.,      */,     public void log(String msg, int msgLevel) {,         if (getProject() != null) {,             getProject().log(this, msg, msgLevel);,         } else {,             super.log(msg, msgLevel);,         },     }, ,     /**,      * Logs a message with the given priority. This delegates,      * the actual logging to the project.,      *,      * @param t The exception to be logged. Should not be <code>null</code>.,      * @param msgLevel The message priority at which this message is to,      *                 be logged.,      * @since 1.7,      */,     public void log(Throwable t, int msgLevel) {,         if (t != null) {,             log(t.getMessage(), t, msgLevel);,         },     }, ,     /**,      * Logs a message with the given priority. This delegates,      * the actual logging to the project.,      *,      * @param msg The message to be logged. Should not be <code>null</code>.,      * @param t The exception to be logged. May be <code>null</code>.,      * @param msgLevel The message priority at which this message is to,      *                 be logged.,      * @since 1.7,      */,     public void log(String msg, Throwable t, int msgLevel) {,         if (getProject() != null) {,             getProject().log(this, msg, t, msgLevel);,         } else {,             super.log(msg, msgLevel);,         },     }, ,     /**,      * Performs this task if it's still valid, or gets a replacement,      * version and performs that otherwise.,      *,      * Performing a task consists of firing a task started event,,      * configuring the task, executing it, and then firing task finished,      * event. If a runtime exception is thrown, the task finished event,      * is still fired, but with the exception as the cause.,      */,     public final void perform() {,         if (!invalid) {,             getProject().fireTaskStarted(this);,             Throwable reason = null;,             try {,                 maybeConfigure();,                 DispatchUtils.execute(this);,             } catch (BuildException ex) {,                 if (ex.getLocation() == Location.UNKNOWN_LOCATION) {,                     ex.setLocation(getLocation());,                 },                 reason = ex;,                 throw ex;,             } catch (Exception ex) {,                 reason = ex;,                 BuildException be = new BuildException(ex);,                 be.setLocation(getLocation());,                 throw be;,             } catch (Error ex) {,                 reason = ex;,                 throw ex;,             } finally {,                 getProject().fireTaskFinished(this, reason);,             },         } else {,             UnknownElement ue = getReplacement();,             Task task = ue.getTask();,             task.perform();,         },     }, ,     /**,      * Marks this task as invalid. Any further use of this task,      * will go through a replacement with the updated definition.,      */,     final void markInvalid() {,         invalid = true;,     }, ,     /**,      * Has this task been marked invalid?,      *,      * @return true if this task is no longer valid. A new task should be,      * configured in this case.,      *,      * @since Ant 1.5,      */,     protected final boolean isInvalid() {,         return invalid;,     }, ,     /**,      * Replacement element used if this task is invalidated.,      */,     private UnknownElement replacement;, ,     /**,      * Creates an UnknownElement that can be used to replace this task.,      * Once this has been created once, it is cached and returned by,      * future calls.,      *,      * @return the UnknownElement instance for the new definition of this task.,      */,     private UnknownElement getReplacement() {,         if (replacement == null) {,             replacement = new UnknownElement(taskType);,             replacement.setProject(getProject());,             replacement.setTaskType(taskType);,             replacement.setTaskName(taskName);,             replacement.setLocation(getLocation());,             replacement.setOwningTarget(target);,             replacement.setRuntimeConfigurableWrapper(wrapper);,             wrapper.setProxy(replacement);,             replaceChildren(wrapper, replacement);,             target.replaceChild(this, replacement);,             replacement.maybeConfigure();,         },         return replacement;,     }, ,     /**,      * Recursively adds an UnknownElement instance for each child,      * element of replacement.,      *,      * @since Ant 1.5.1,      */,     private void replaceChildren(RuntimeConfigurable wrapper,,                                  UnknownElement parentElement) {,         Enumeration e = wrapper.getChildren();,         while (e.hasMoreElements()) {,             RuntimeConfigurable childWrapper =,                 (RuntimeConfigurable) e.nextElement();,             UnknownElement childElement =,                 new UnknownElement(childWrapper.getElementTag());,             parentElement.addChild(childElement);,             childElement.setProject(getProject());,             childElement.setRuntimeConfigurableWrapper(childWrapper);,             childWrapper.setProxy(childElement);,             replaceChildren(childWrapper, childElement);,         },     }, ,     /**,      * Return the type of task.,      *,      * @return the type of task.,      */,     public String getTaskType() {,         return taskType;,     }, ,     /**,      * Return the runtime configurable structure for this task.,      *,      * @return the runtime structure for this task.,      */,     protected RuntimeConfigurable getWrapper() {,         return wrapper;,     }, ,     /**,      * Bind a task to another; use this when configuring a newly created,      * task to do work on behalf of another.,      * Project, OwningTarget, TaskName, Location and Description are all copied,      *,      * Important: this method does not call {@link Task#init()}.,      * If you are creating a task to delegate work to, call {@link Task#init()},      * to initialize it.,      *,      * @param owner owning target,      * @since Ant1.7,      */,     public final void bindToOwner(Task owner) {,         setProject(owner.getProject());,         setOwningTarget(owner.getOwningTarget());,         setTaskName(owner.getTaskName());,         setDescription(owner.getDescription());,         setLocation(owner.getLocation());,         setTaskType(owner.getTaskType());,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/BuildFileTest.java,executeTarget,316-316,[            PrintStream out = new PrintStream(new AntOutputStream(outBuffer));],,executeTarget,319-319,[            PrintStream err = new PrintStream(new AntOutputStream(errBuffer));],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/BuildFileTest.java,getResource,468-468,[        URL url = getClass().getResource(resource);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/ComponentHelper.java,getDataTypeDefinitions,445-445,[        return typeClassDefinitions;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/ComponentHelper.java,getTaskDefinitions,416-416,[        return taskClassDefinitions;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/ant/Project.java,,129-2474,[    private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();, ,     /** Name of this project. */,     private String name;,     /** Description for this project (if any). */,     private String description;, , ,     /** Map of references within the project (paths etc) (String to Object). */,     private Hashtable references = new AntRefTable();, ,     /** Map of id references - used for indicating broken build files */,     private HashMap idReferences = new HashMap();, ,     /** the parent project for old id resolution (if inheritreferences is set) */,     private Project parentIdProject = null;, ,     /** Name of the project's default target. */,     private String defaultTarget;, ,     /** Map from target names to targets (String to Target). */,     private Hashtable targets = new Hashtable();,     /** Set of global filters. */,     private FilterSet globalFilterSet = new FilterSet();,     {,         // Initialize the globalFileSet's project,         globalFilterSet.setProject(this);,     }, ,     /**,      * Wrapper around globalFilterSet. This collection only ever,      * contains one FilterSet, but the wrapper is needed in order to,      * make it easier to use the FileUtils interface.,      */,     private FilterSetCollection globalFilters,         = new FilterSetCollection(globalFilterSet);, ,     /** Project base directory. */,     private File baseDir;, ,     /** lock object used when adding/removing listeners */,     private final Object listenersLock = new Object();, ,     /** List of listeners to notify of build events. */,     private volatile BuildListener[] listeners = new BuildListener[0];, ,     /** for each thread, record whether it is currently executing,         messageLogged */,     private final ThreadLocal isLoggingMessage = new ThreadLocal() {,             protected Object initialValue() {,                 return Boolean.FALSE;,             },         };, ,     /**,      * The Ant core classloader--may be <code>null</code> if using,      * parent classloader.,      */,     private ClassLoader coreLoader = null;, ,     /** Records the latest task to be executed on a thread. */,     private final Map/*<Thread,Task>*/ threadTasks =,         Collections.synchronizedMap(new WeakHashMap());, ,     /** Records the latest task to be executed on a thread group. */,     private final Map/*<ThreadGroup,Task>*/ threadGroupTasks,         = Collections.synchronizedMap(new WeakHashMap());, ,     /**,      * Called to handle any input requests.,      */,     private InputHandler inputHandler = null;, ,     /**,      * The default input stream used to read any input.,      */,     private InputStream defaultInputStream = null;, ,     /**,      * Keep going flag.,      */,     private boolean keepGoingMode = false;, ,     /**,      * Set the input handler.,      *,      * @param handler the InputHandler instance to use for gathering input.,      */,     public void setInputHandler(InputHandler handler) {,         inputHandler = handler;,     }, ,     /**,      * Set the default System input stream. Normally this stream is set to,      * System.in. This inputStream is used when no task input redirection is,      * being performed.,      *,      * @param defaultInputStream the default input stream to use when input,      *        is requested.,      * @since Ant 1.6,      */,     public void setDefaultInputStream(InputStream defaultInputStream) {,         this.defaultInputStream = defaultInputStream;,     }, ,     /**,      * Get this project's input stream.,      *,      * @return the InputStream instance in use by this Project instance to,      * read input.,      */,     public InputStream getDefaultInputStream() {,         return defaultInputStream;,     }, ,     /**,      * Retrieve the current input handler.,      *,      * @return the InputHandler instance currently in place for the project,      *         instance.,      */,     public InputHandler getInputHandler() {,         return inputHandler;,     }, ,     /**,      * Create a new Ant project.,      */,     public Project() {,         inputHandler = new DefaultInputHandler();,     }, ,     /**,      * Create and initialize a subproject. By default the subproject will be of,      * the same type as its parent. If a no-arg constructor is unavailable, the,      * <code>Project</code> class will be used.,      * @return a Project instance configured as a subproject of this Project.,      * @since Ant 1.7,      */,     public Project createSubProject() {,         Project subProject = null;,         try {,             subProject = (Project) (getClass().newInstance());,         } catch (Exception e) {,             subProject = new Project();,         },         initSubProject(subProject);,         return subProject;,     }, ,     /**,      * Initialize a subproject.,      * @param subProject the subproject to initialize.,      */,     public void initSubProject(Project subProject) {,         ComponentHelper.getComponentHelper(subProject),             .initSubProject(ComponentHelper.getComponentHelper(this));,         subProject.setDefaultInputStream(getDefaultInputStream());,         subProject.setKeepGoingMode(this.isKeepGoingMode());,         subProject.setExecutor(getExecutor().getSubProjectExecutor());,     }, ,     /**,      * Initialise the project.,      *,      * This involves setting the default task definitions and loading the,      * system properties.,      *,      * @exception BuildException if the default task list cannot be loaded.,      */,     public void init() throws BuildException {,         initProperties();, ,         ComponentHelper.getComponentHelper(this).initDefaultDefinitions();,     }, ,     /**,      * Initializes the properties.,      * @exception BuildException if an vital property could not be set.,      * @since Ant 1.7,      */,     public void initProperties() throws BuildException {,         setJavaVersionProperty();,         setSystemProperties();,         setPropertyInternal(MagicNames.ANT_VERSION, Main.getAntVersion());,         setAntLib();,     }, ,     /**,      * Set a property to the location of ant.jar.,      * Use the locator to find the location of the Project.class, and,      * if this is not null, set the property {@link MagicNames#ANT_LIB},      * to the result,      */,     private void setAntLib() {,         File antlib = org.apache.tools.ant.launch.Locator.getClassSource(,             Project.class);,         if (antlib != null) {,             setPropertyInternal(MagicNames.ANT_LIB, antlib.getAbsolutePath());,         },     },     /**,      * Factory method to create a class loader for loading classes from,      * a given path.,      *,      * @param path the path from which classes are to be loaded.,      *,      * @return an appropriate classloader.,      */,     public AntClassLoader createClassLoader(Path path) {,         return AntClassLoader,             .newAntClassLoader(getClass().getClassLoader(), this, path, true);,     }, ,     /**,      * Factory method to create a class loader for loading classes from,      * a given path.,      *,      * @param parent the parent classloader for the new loader.,      * @param path the path from which classes are to be loaded.,      *,      * @return an appropriate classloader.,      */,     public AntClassLoader createClassLoader(,         ClassLoader parent, Path path) {,         return AntClassLoader.newAntClassLoader(parent, this, path, true);,     }, ,     /**,      * Set the core classloader for the project. If a <code>null</code>,      * classloader is specified, the parent classloader should be used.,      *,      * @param coreLoader The classloader to use for the project.,      *                   May be <code>null</code>.,      */,     public void setCoreLoader(ClassLoader coreLoader) {,         this.coreLoader = coreLoader;,     }, ,     /**,      * Return the core classloader to use for this project.,      * This may be <code>null</code>, indicating that,      * the parent classloader should be used.,      *,      * @return the core classloader to use for this project.,      *,      */,     public ClassLoader getCoreLoader() {,         return coreLoader;,     }, ,     /**,      * Add a build listener to the list. This listener will,      * be notified of build events for this project.,      *,      * @param listener The listener to add to the list.,      *                 Must not be <code>null</code>.,      */,     public void addBuildListener(BuildListener listener) {,         synchronized (listenersLock) {,             // If the listeners already has this listener, do nothing,             for (int i = 0; i < listeners.length; i++) {,                 if (listeners[i] == listener) {,                     return;,                 },             },             // copy on write semantics,             BuildListener[] newListeners =,                 new BuildListener[listeners.length + 1];,             System.arraycopy(listeners, 0, newListeners, 0, listeners.length);,             newListeners[listeners.length] = listener;,             listeners = newListeners;,         },     }, ,     /**,      * Remove a build listener from the list. This listener,      * will no longer be notified of build events for this project.,      *,      * @param listener The listener to remove from the list.,      *                 Should not be <code>null</code>.,      */,     public void removeBuildListener(BuildListener listener) {,         synchronized (listenersLock) {,             // copy on write semantics,             for (int i = 0; i < listeners.length; i++) {,                 if (listeners[i] == listener) {,                     BuildListener[] newListeners =,                         new BuildListener[listeners.length - 1];,                     System.arraycopy(listeners, 0, newListeners, 0, i);,                     System.arraycopy(listeners, i + 1, newListeners, i,,                                      listeners.length - i - 1);,                     listeners = newListeners;,                     break;,                 },             },         },     }, ,     /**,      * Return a copy of the list of build listeners for the project.,      * ,      * @return a list of build listeners for the project,      */,     public Vector getBuildListeners() {,         synchronized (listenersLock) {,             Vector r = new Vector(listeners.length);,             for (int i = 0; i < listeners.length; i++) {,                 r.add(listeners[i]);,             },             return r;,         },     }, ,     /**,      * Write a message to the log with the default log level,      * of MSG_INFO .,      * @param message The text to log. Should not be <code>null</code>.,      */, ,     public void log(String message) {,         log(message, MSG_INFO);,     }, ,     /**,      * Write a project level message to the log with the given log level.,      * @param message The text to log. Should not be <code>null</code>.,      * @param msgLevel The log priority level to use.,      */,     public void log(String message, int msgLevel) {,         log(message, null, msgLevel);,     }, ,     /**,      * Write a project level message to the log with the given log level.,      * @param message The text to log. Should not be <code>null</code>.,      * @param throwable The exception causing this log, may be <code>null</code>.,      * @param msgLevel The log priority level to use.,      * @since 1.7,      */,     public void log(String message, Throwable throwable, int msgLevel) {,         fireMessageLogged(this, message, throwable, msgLevel);,     }, ,     /**,      * Write a task level message to the log with the given log level.,      * @param task The task to use in the log. Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param msgLevel The log priority level to use.,      */,     public void log(Task task, String message, int msgLevel) {,         fireMessageLogged(task, message, null, msgLevel);,     }, ,     /**,      * Write a task level message to the log with the given log level.,      * @param task The task to use in the log. Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param throwable The exception causing this log, may be <code>null</code>.,      * @param msgLevel The log priority level to use.,      * @since 1.7,      */,     public void log(Task task, String message, Throwable throwable, int msgLevel) {,         fireMessageLogged(task, message, throwable, msgLevel);,     }, ,     /**,      * Write a target level message to the log with the given log level.,      * @param target The target to use in the log.,      *               Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param msgLevel The log priority level to use.,      */,     public void log(Target target, String message, int msgLevel) {,         log(target, message, null, msgLevel);,     }, ,     /**,      * Write a target level message to the log with the given log level.,      * @param target The target to use in the log.,      *               Must not be <code>null</code>.,      * @param message The text to log. Should not be <code>null</code>.,      * @param throwable The exception causing this log, may be <code>null</code>.,      * @param msgLevel The log priority level to use.,      * @since 1.7,      */,     public void log(Target target, String message, Throwable throwable,,             int msgLevel) {,         fireMessageLogged(target, message, throwable, msgLevel);,     }, ,     /**,      * Return the set of global filters.,      *,      * @return the set of global filters.,      */,     public FilterSet getGlobalFilterSet() {,         return globalFilterSet;,     }, ,     /**,      * Set a property. Any existing property of the same name,      * is overwritten, unless it is a user property.,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      */,     public void setProperty(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setProperty(name, value, true);,     }, ,     /**,      * Set a property if no value currently exists. If the property,      * exists already, a message is logged and the method returns with,      * no other effect.,      *,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      * @since 1.5,      */,     public void setNewProperty(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setNewProperty(name, value);,     }, ,     /**,      * Set a user property, which cannot be overwritten by,      * set/unset property calls. Any previous value is overwritten.,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      * @see #setProperty(String,String),      */,     public void setUserProperty(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setUserProperty(name, value);,     }, ,     /**,      * Set a user property, which cannot be overwritten by set/unset,      * property calls. Any previous value is overwritten. Also marks,      * these properties as properties that have not come from the,      * command line.,      *,      * @param name The name of property to set.,      *             Must not be <code>null</code>.,      * @param value The new value of the property.,      *              Must not be <code>null</code>.,      * @see #setProperty(String,String),      */,     public void setInheritedProperty(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setInheritedProperty(name, value);,     }, ,     /**,      * Set a property unless it is already defined as a user property,      * (in which case the method returns silently).,      *,      * @param name The name of the property.,      *             Must not be <code>null</code>.,      * @param value The property value. Must not be <code>null</code>.,      */,     private void setPropertyInternal(String name, String value) {,         PropertyHelper.getPropertyHelper(this).setProperty(name, value, false);,     }, ,     /**,      * Return the value of a property, if it is set.,      *,      * @param propertyName The name of the property.,      *             May be <code>null</code>, in which case,      *             the return value is also <code>null</code>.,      * @return the property value, or <code>null</code> for no match,      *         or if a <code>null</code> name is provided.,      */,     public String getProperty(String propertyName) {,         Object value = PropertyHelper.getPropertyHelper(this).getProperty(propertyName);,         return value == null ? null : String.valueOf(value);,     }, ,     /**,      * Replace ${} style constructions in the given value with the,      * string value of the corresponding data types.,      *,      * @param value The string to be scanned for property references.,      *              May be <code>null</code>.,      *,      * @return the given string with embedded property names replaced,      *         by values, or <code>null</code> if the given string is,      *         <code>null</code>.,      *,      * @exception BuildException if the given value has an unclosed,      *                           property name, e.g. <code>${xxx</code>.,      */,     public String replaceProperties(String value) throws BuildException {,         return PropertyHelper.getPropertyHelper(this).replaceProperties(null, value, null);,     }, ,     /**,      * Return the value of a user property, if it is set.,      *,      * @param propertyName The name of the property.,      *             May be <code>null</code>, in which case,      *             the return value is also <code>null</code>.,      * @return the property value, or <code>null</code> for no match,      *         or if a <code>null</code> name is provided.,      */,      public String getUserProperty(String propertyName) {,         return (String) PropertyHelper.getPropertyHelper(this).getUserProperty(propertyName);,     }, ,     /**,      * Return a copy of the properties table.,      * @return a hashtable containing all properties,      *         (including user properties).,      */,     public Hashtable getProperties() {,         return PropertyHelper.getPropertyHelper(this).getProperties();,     }, ,     /**,      * Return a copy of the user property hashtable.,      * @return a hashtable containing just the user properties.,      */,     public Hashtable getUserProperties() {,         return PropertyHelper.getPropertyHelper(this).getUserProperties();,     }, ,     /**,      * Return a copy of the inherited property hashtable.,      * @return a hashtable containing just the inherited properties.,      * @since Ant 1.8.0,      */,     public Hashtable getInheritedProperties() {,         return PropertyHelper.getPropertyHelper(this).getInheritedProperties();,     }, ,     /**,      * Copy all user properties that have been set on the command,      * line or a GUI tool from this instance to the Project instance,      * given as the argument.,      *,      * <p>To copy all &quot;user&quot; properties, you will also have to call,      * {@link #copyInheritedProperties copyInheritedProperties}.</p>,      *,      * @param other the project to copy the properties to.  Must not be null.,      *,      * @since Ant 1.5,      */,     public void copyUserProperties(Project other) {,         PropertyHelper.getPropertyHelper(this).copyUserProperties(other);,     }, ,     /**,      * Copy all user properties that have not been set on the,      * command line or a GUI tool from this instance to the Project,      * instance given as the argument.,      *,      * <p>To copy all &quot;user&quot; properties, you will also have to call,      * {@link #copyUserProperties copyUserProperties}.</p>,      *,      * @param other the project to copy the properties to.  Must not be null.,      *,      * @since Ant 1.5,      */,     public void copyInheritedProperties(Project other) {,         PropertyHelper.getPropertyHelper(this).copyInheritedProperties(other);,     }, ,     /**,      * Set the default target of the project.,      *,      * @param defaultTarget The name of the default target for this project.,      *                      May be <code>null</code>, indicating that there is,      *                      no default target.,      *,      * @deprecated since 1.5.x.,      *             Use setDefault.,      * @see #setDefault(String),      */,     public void setDefaultTarget(String defaultTarget) {,         setDefault(defaultTarget);,     }, ,     /**,      * Return the name of the default target of the project.,      * @return name of the default target or,      *         <code>null</code> if no default has been set.,      */,     public String getDefaultTarget() {,         return defaultTarget;,     }, ,     /**,      * Set the default target of the project.,      *,      * @param defaultTarget The name of the default target for this project.,      *                      May be <code>null</code>, indicating that there is,      *                      no default target.,      */,     public void setDefault(String defaultTarget) {,         if (defaultTarget != null) {,             setUserProperty(MagicNames.PROJECT_DEFAULT_TARGET, defaultTarget);,         },         this.defaultTarget = defaultTarget;,     }, ,     /**,      * Set the name of the project, also setting the user,      * property <code>ant.project.name</code>.,      *,      * @param name The name of the project.,      *             Must not be <code>null</code>.,      */,     public void setName(String name) {,         setUserProperty(MagicNames.PROJECT_NAME,  name);,         this.name = name;,     }, ,     /**,      * Return the project name, if one has been set.,      *,      * @return the project name, or <code>null</code> if it hasn't been set.,      */,     public String getName() {,         return name;,     }, ,     /**,      * Set the project description.,      *,      * @param description The description of the project.,      *                    May be <code>null</code>.,      */,     public void setDescription(String description) {,         this.description = description;,     }, ,     /**,      * Return the project description, if one has been set.,      *,      * @return the project description, or <code>null</code> if it hasn't,      *         been set.,      */,     public String getDescription() {,         if (description == null) {,             description = Description.getDescription(this);,         },         return description;,     }, ,     /**,      * Add a filter to the set of global filters.,      *,      * @param token The token to filter.,      *              Must not be <code>null</code>.,      * @param value The replacement value.,      *              Must not be <code>null</code>.,      * @deprecated since 1.4.x.,      *             Use getGlobalFilterSet().addFilter(token,value),      *,      * @see #getGlobalFilterSet(),      * @see FilterSet#addFilter(String,String),      */,     public void addFilter(String token, String value) {,         if (token == null) {,             return;,         },         globalFilterSet.addFilter(new FilterSet.Filter(token, value));,     }, ,     /**,      * Return a hashtable of global filters, mapping tokens to values.,      *,      * @return a hashtable of global filters, mapping tokens to values,      *         (String to String).,      *,      * @deprecated since 1.4.x,      *             Use getGlobalFilterSet().getFilterHash().,      *,      * @see #getGlobalFilterSet(),      * @see FilterSet#getFilterHash(),      */,     public Hashtable getFilters() {,         // we need to build the hashtable dynamically,         return globalFilterSet.getFilterHash();,     }, ,     /**,      * Set the base directory for the project, checking that,      * the given filename exists and is a directory.,      *,      * @param baseD The project base directory.,      *              Must not be <code>null</code>.,      *,      * @exception BuildException if the directory if invalid.,      */,     public void setBasedir(String baseD) throws BuildException {,         setBaseDir(new File(baseD));,     }, ,     /**,      * Set the base directory for the project, checking that,      * the given file exists and is a directory.,      *,      * @param baseDir The project base directory.,      *                Must not be <code>null</code>.,      * @exception BuildException if the specified file doesn't exist or,      *                           isn't a directory.,      */,     public void setBaseDir(File baseDir) throws BuildException {,         baseDir = FILE_UTILS.normalize(baseDir.getAbsolutePath());,         if (!baseDir.exists()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " does not exist");,         },         if (!baseDir.isDirectory()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " is not a directory");,         },         this.baseDir = baseDir;,         setPropertyInternal(MagicNames.PROJECT_BASEDIR, this.baseDir.getPath());,         String msg = "Project base dir set to: " + this.baseDir;,         log(msg, MSG_VERBOSE);,     }, ,     /**,      * Return the base directory of the project as a file object.,      *,      * @return the project base directory, or <code>null</code> if the,      *         base directory has not been successfully set to a valid value.,      */,     public File getBaseDir() {,         if (baseDir == null) {,             try {,                 setBasedir(".");,             } catch (BuildException ex) {,                 ex.printStackTrace();,             },         },         return baseDir;,     }, ,     /**,      * Set &quot;keep-going&quot; mode. In this mode Ant will try to execute,      * as many targets as possible. All targets that do not depend,      * on failed target(s) will be executed.  If the keepGoing settor/getter,      * methods are used in conjunction with the <code>ant.executor.class</code>,      * property, they will have no effect.,      * @param keepGoingMode &quot;keep-going&quot; mode,      * @since Ant 1.6,      */,     public void setKeepGoingMode(boolean keepGoingMode) {,         this.keepGoingMode = keepGoingMode;,     }, ,     /**,      * Return the keep-going mode.  If the keepGoing settor/getter,      * methods are used in conjunction with the <code>ant.executor.class</code>,      * property, they will have no effect.,      * @return &quot;keep-going&quot; mode,      * @since Ant 1.6,      */,     public boolean isKeepGoingMode() {,         return this.keepGoingMode;,     }, ,     /**,      * Return the version of Java this class is running under.,      * @return the version of Java as a String, e.g. "1.1" .,      * @see org.apache.tools.ant.util.JavaEnvUtils#getJavaVersion,      * @deprecated since 1.5.x.,      *             Use org.apache.tools.ant.util.JavaEnvUtils instead.,      */,     public static String getJavaVersion() {,         return JavaEnvUtils.getJavaVersion();,     }, ,     /**,      * Set the <code>ant.java.version</code> property and tests for,      * unsupported JVM versions. If the version is supported,,      * verbose log messages are generated to record the Java version,      * and operating system name.,      *,      * @exception BuildException if this Java version is not supported.,      *,      * @see org.apache.tools.ant.util.JavaEnvUtils#getJavaVersion,      */,     public void setJavaVersionProperty() throws BuildException {,         String javaVersion = JavaEnvUtils.getJavaVersion();,         setPropertyInternal(MagicNames.ANT_JAVA_VERSION, javaVersion);, ,         // sanity check,         if (!JavaEnvUtils.isAtLeastJavaVersion(JavaEnvUtils.JAVA_1_4))  {,             throw new BuildException("Ant cannot work on Java prior to 1.4");,         },         log("Detected Java version: " + javaVersion + " in: ",             + System.getProperty("java.home"), MSG_VERBOSE);, ,         log("Detected OS: " + System.getProperty("os.name"), MSG_VERBOSE);,     }, ,     /**,      * Add all system properties which aren't already defined as,      * user properties to the project properties.,      */,     public void setSystemProperties() {,         Properties systemP = System.getProperties();,         Enumeration e = systemP.propertyNames();,         while (e.hasMoreElements()) {,             String propertyName = (String) e.nextElement();,             String value = systemP.getProperty(propertyName);,             if (value != null) {,                 this.setPropertyInternal(propertyName, value);,             },         },     }, ,     /**,      * Add a new task definition to the project.,      * Attempting to override an existing definition with an,      * equivalent one (i.e. with the same classname) results in,      * a verbose log message. Attempting to override an existing definition,      * with a different one results in a warning log message and,      * invalidates any tasks which have already been created with the,      * old definition.,      *,      * @param taskName The name of the task to add.,      *                 Must not be <code>null</code>.,      * @param taskClass The full name of the class implementing the task.,      *                  Must not be <code>null</code>.,      *,      * @exception BuildException if the class is unsuitable for being an Ant,      *                           task. An error level message is logged before,      *                           this exception is thrown.,      *,      * @see #checkTaskClass(Class),      */,     public void addTaskDefinition(String taskName, Class taskClass),          throws BuildException {,         ComponentHelper.getComponentHelper(this).addTaskDefinition(taskName,,                 taskClass);,     }, ,     /**,      * Check whether or not a class is suitable for serving as Ant task.,      * Ant task implementation classes must be public, concrete, and have,      * a no-arg constructor.,      *,      * @param taskClass The class to be checked.,      *                  Must not be <code>null</code>.,      *,      * @exception BuildException if the class is unsuitable for being an Ant,      *                           task. An error level message is logged before,      *                           this exception is thrown.,      */,     public void checkTaskClass(final Class taskClass) throws BuildException {,         ComponentHelper.getComponentHelper(this).checkTaskClass(taskClass);, ,         if (!Modifier.isPublic(taskClass.getModifiers())) {,             final String message = taskClass + " is not public";,             log(message, Project.MSG_ERR);,             throw new BuildException(message);,         },         if (Modifier.isAbstract(taskClass.getModifiers())) {,             final String message = taskClass + " is abstract";,             log(message, Project.MSG_ERR);,             throw new BuildException(message);,         },         try {,             taskClass.getConstructor((Class[]) null);,             // don't have to check for public, since,             // getConstructor finds public constructors only.,         } catch (NoSuchMethodException e) {,             final String message = "No public no-arg constructor in ",                 + taskClass;,             log(message, Project.MSG_ERR);,             throw new BuildException(message);,         } catch (LinkageError e) {,             String message = "Could not load " + taskClass + ": " + e;,             log(message, Project.MSG_ERR);,             throw new BuildException(message, e);,         },         if (!Task.class.isAssignableFrom(taskClass)) {,             TaskAdapter.checkTaskClass(taskClass, this);,         },     }, ,     /**,      * Return the current task definition hashtable. The returned hashtable is,      * &quot;live&quot; and so should not be modified.,      *,      * @return a map of from task name to implementing class,      *         (String to Class).,      */,     public Hashtable getTaskDefinitions() {,         return ComponentHelper.getComponentHelper(this).getTaskDefinitions();,     }, ,     /**,      * Return the current task definition map. The returned map is a,      * copy of the &quot;live&quot; definitions.,      *,      * @return a map of from task name to implementing class,      *         (String to Class).,      *,      * @since Ant 1.8.1,      */,     public Map getCopyOfTaskDefinitions() {,         return new HashMap(getTaskDefinitions());,     }, ,     /**,      * Add a new datatype definition.,      * Attempting to override an existing definition with an,      * equivalent one (i.e. with the same classname) results in,      * a verbose log message. Attempting to override an existing definition,      * with a different one results in a warning log message, but the,      * definition is changed.,      *,      * @param typeName The name of the datatype.,      *                 Must not be <code>null</code>.,      * @param typeClass The full name of the class implementing the datatype.,      *                  Must not be <code>null</code>.,      */,     public void addDataTypeDefinition(String typeName, Class typeClass) {,         ComponentHelper.getComponentHelper(this).addDataTypeDefinition(typeName,,                 typeClass);,     }, ,     /**,      * Return the current datatype definition hashtable. The returned,      * hashtable is &quot;live&quot; and so should not be modified.,      *,      * @return a map of from datatype name to implementing class,      *         (String to Class).,      */,     public Hashtable getDataTypeDefinitions() {,         return ComponentHelper.getComponentHelper(this).getDataTypeDefinitions();,     }, ,     /**,      * Return the current datatype definition map. The returned,      * map is a copy pf the &quot;live&quot; definitions.,      *,      * @return a map of from datatype name to implementing class,      *         (String to Class).,      *,      * @since Ant 1.8.1,      */,     public Map getCopyOfDataTypeDefinitions() {,         return new HashMap(getDataTypeDefinitions());,     }, ,     /**,      * Add a <em>new</em> target to the project.,      *,      * @param target The target to be added to the project.,      *               Must not be <code>null</code>.,      *,      * @exception BuildException if the target already exists in the project,      *,      * @see Project#addOrReplaceTarget(Target),      */,     public void addTarget(Target target) throws BuildException {,         addTarget(target.getName(), target);,     }, ,     /**,      * Add a <em>new</em> target to the project.,      *,      * @param targetName The name to use for the target.,      *             Must not be <code>null</code>.,      * @param target The target to be added to the project.,      *               Must not be <code>null</code>.,      *,      * @exception BuildException if the target already exists in the project.,      *,      * @see Project#addOrReplaceTarget(String, Target),      */,      public void addTarget(String targetName, Target target),          throws BuildException {,          if (targets.get(targetName) != null) {,              throw new BuildException("Duplicate target: `" + targetName + "'");,          },          addOrReplaceTarget(targetName, target);,      }, ,     /**,      * Add a target to the project, or replaces one with the same,      * name.,      *,      * @param target The target to be added or replaced in the project.,      *               Must not be <code>null</code>.,      */,     public void addOrReplaceTarget(Target target) {,         addOrReplaceTarget(target.getName(), target);,     }, ,     /**,      * Add a target to the project, or replaces one with the same,      * name.,      *,      * @param targetName The name to use for the target.,      *                   Must not be <code>null</code>.,      * @param target The target to be added or replaced in the project.,      *               Must not be <code>null</code>.,      */,     public void addOrReplaceTarget(String targetName, Target target) {,         String msg = " +Target: " + targetName;,         log(msg, MSG_DEBUG);,         target.setProject(this);,         targets.put(targetName, target);,     }, ,     /**,      * Return the hashtable of targets. The returned hashtable,      * is &quot;live&quot; and so should not be modified.,      * @return a map from name to target (String to Target).,      */,     public Hashtable getTargets() {,         return targets;,     }, ,     /**,      * Return the map of targets. The returned map,      * is a copy of the &quot;live&quot; targets.,      * @return a map from name to target (String to Target).,      * @since Ant 1.8.1,      */,     public Map getCopyOfTargets() {,         return new HashMap(targets);,     }, ,     /**,      * Create a new instance of a task, adding it to a list of,      * created tasks for later invalidation. This causes all tasks,      * to be remembered until the containing project is removed,      * @param taskType The name of the task to create an instance of.,      *                 Must not be <code>null</code>.,      *,      * @return an instance of the specified task, or <code>null</code> if,      *         the task name is not recognised.,      *,      * @exception BuildException if the task name is recognised but task,      *                           creation fails.,      */,     public Task createTask(String taskType) throws BuildException {,         return ComponentHelper.getComponentHelper(this).createTask(taskType);,     }, ,     /**,      * Create a new instance of a data type.,      *,      * @param typeName The name of the data type to create an instance of.,      *                 Must not be <code>null</code>.,      *,      * @return an instance of the specified data type, or <code>null</code> if,      *         the data type name is not recognised.,      *,      * @exception BuildException if the data type name is recognised but,      *                           instance creation fails.,      */,     public Object createDataType(String typeName) throws BuildException {,         return ComponentHelper.getComponentHelper(this).createDataType(typeName);,     }, ,     /**,      * Set the Executor instance for this Project.,      * @param e the Executor to use.,      */,     public void setExecutor(Executor e) {,         addReference(MagicNames.ANT_EXECUTOR_REFERENCE, e);,     }, ,     /**,      * Get this Project's Executor (setting it if necessary).,      * @return an Executor instance.,      */,     public Executor getExecutor() {,         Object o = getReference(MagicNames.ANT_EXECUTOR_REFERENCE);,         if (o == null) {,             String classname = getProperty(MagicNames.ANT_EXECUTOR_CLASSNAME);,             if (classname == null) {,                 classname = DefaultExecutor.class.getName();,             },             log("Attempting to create object of type " + classname, MSG_DEBUG);,             try {,                 o = Class.forName(classname, true, coreLoader).newInstance();,             } catch (ClassNotFoundException seaEnEfEx) {,                 //try the current classloader,                 try {,                     o = Class.forName(classname).newInstance();,                 } catch (Exception ex) {,                     log(ex.toString(), MSG_ERR);,                 },             } catch (Exception ex) {,                 log(ex.toString(), MSG_ERR);,             },             if (o == null) {,                 throw new BuildException(,                     "Unable to obtain a Target Executor instance.");,             },             setExecutor((Executor) o);,         },         return (Executor) o;,     }, ,     /**,      * Execute the specified sequence of targets, and the targets,      * they depend on.,      *,      * @param names A vector of target name strings to execute.,      *              Must not be <code>null</code>.,      *,      * @exception BuildException if the build failed.,      */,     public void executeTargets(Vector names) throws BuildException {,         setUserProperty(MagicNames.PROJECT_INVOKED_TARGETS,,                         CollectionUtils.flattenToString(names));,         getExecutor().executeTargets(this,,             (String[]) (names.toArray(new String[names.size()])));,     }, ,     /**,      * Demultiplex output so that each task receives the appropriate,      * messages. If the current thread is not currently executing a task,,      * the message is logged directly.,      *,      * @param output Message to handle. Should not be <code>null</code>.,      * @param isWarning Whether the text represents an warning (<code>true</code>),      *        or information (<code>false</code>).,      */,     public void demuxOutput(String output, boolean isWarning) {,         Task task = getThreadTask(Thread.currentThread());,         if (task == null) {,             log(output, isWarning ? MSG_WARN : MSG_INFO);,         } else {,             if (isWarning) {,                 task.handleErrorOutput(output);,             } else {,                 task.handleOutput(output);,             },         },     }, ,     /**,      * Read data from the default input stream. If no default has been,      * specified, System.in is used.,      *,      * @param buffer the buffer into which data is to be read.,      * @param offset the offset into the buffer at which data is stored.,      * @param length the amount of data to read.,      *,      * @return the number of bytes read.,      *,      * @exception IOException if the data cannot be read.,      * @since Ant 1.6,      */,     public int defaultInput(byte[] buffer, int offset, int length),         throws IOException {,         if (defaultInputStream != null) {,             System.out.flush();,             return defaultInputStream.read(buffer, offset, length);,         } else {,             throw new EOFException("No input provided for project");,         },     }, ,     /**,      * Demux an input request to the correct task.,      *,      * @param buffer the buffer into which data is to be read.,      * @param offset the offset into the buffer at which data is stored.,      * @param length the amount of data to read.,      *,      * @return the number of bytes read.,      *,      * @exception IOException if the data cannot be read.,      * @since Ant 1.6,      */,     public int demuxInput(byte[] buffer, int offset, int length),         throws IOException {,         Task task = getThreadTask(Thread.currentThread());,         if (task == null) {,             return defaultInput(buffer, offset, length);,         } else {,             return task.handleInput(buffer, offset, length);,         },     }, ,     /**,      * Demultiplex flush operations so that each task receives the appropriate,      * messages. If the current thread is not currently executing a task,,      * the message is logged directly.,      *,      * @since Ant 1.5.2,      *,      * @param output Message to handle. Should not be <code>null</code>.,      * @param isError Whether the text represents an error (<code>true</code>),      *        or information (<code>false</code>).,      */,     public void demuxFlush(String output, boolean isError) {,         Task task = getThreadTask(Thread.currentThread());,         if (task == null) {,             fireMessageLogged(this, output, isError ? MSG_ERR : MSG_INFO);,         } else {,             if (isError) {,                 task.handleErrorFlush(output);,             } else {,                 task.handleFlush(output);,             },         },     }, ,     /**,      * Execute the specified target and any targets it depends on.,      *,      * @param targetName The name of the target to execute.,      *                   Must not be <code>null</code>.,      *,      * @exception BuildException if the build failed.,      */,     public void executeTarget(String targetName) throws BuildException {, ,         // sanity check ourselves, if we've been asked to build nothing,         // then we should complain, ,         if (targetName == null) {,             String msg = "No target specified";,             throw new BuildException(msg);,         }, ,         // Sort and run the dependency tree.,         // Sorting checks if all the targets (and dependencies),         // exist, and if there is any cycle in the dependency,         // graph.,         executeSortedTargets(topoSort(targetName, targets, false));,     }, ,     /**,      * Execute a <code>Vector</code> of sorted targets.,      * @param sortedTargets   the aforementioned <code>Vector</code>.,      * @throws BuildException on error.,      */,     public void executeSortedTargets(Vector sortedTargets),         throws BuildException {,         Set succeededTargets = new HashSet();,         BuildException buildException = null; // first build exception,         for (Enumeration iter = sortedTargets.elements();,              iter.hasMoreElements();) {,             Target curtarget = (Target) iter.nextElement();,             boolean canExecute = true;,             for (Enumeration depIter = curtarget.getDependencies();,                  depIter.hasMoreElements();) {,                 String dependencyName = ((String) depIter.nextElement());,                 if (!succeededTargets.contains(dependencyName)) {,                     canExecute = false;,                     log(curtarget,,                         "Cannot execute '" + curtarget.getName() + "' - '",                         + dependencyName + "' failed or was not executed.",,                         MSG_ERR);,                     break;,                 },             },             if (canExecute) {,                 Throwable thrownException = null;,                 try {,                     curtarget.performTasks();,                     succeededTargets.add(curtarget.getName());,                 } catch (RuntimeException ex) {,                     if (!(keepGoingMode)) {,                         throw ex; // throw further,                     },                     thrownException = ex;,                 } catch (Throwable ex) {,                     if (!(keepGoingMode)) {,                         throw new BuildException(ex);,                     },                     thrownException = ex;,                 },                 if (thrownException != null) {,                     if (thrownException instanceof BuildException) {,                         log(curtarget,,                             "Target '" + curtarget.getName(),                             + "' failed with message '",                             + thrownException.getMessage() + "'.", MSG_ERR);,                         // only the first build exception is reported,                         if (buildException == null) {,                             buildException = (BuildException) thrownException;,                         },                     } else {,                         log(curtarget,,                             "Target '" + curtarget.getName(),                             + "' failed with message '",                             + thrownException.getMessage() + "'.", MSG_ERR);,                         thrownException.printStackTrace(System.err);,                         if (buildException == null) {,                             buildException =,                                 new BuildException(thrownException);,                         },                     },                 },             },         },         if (buildException != null) {,             throw buildException;,         },     }, ,     /**,      * Return the canonical form of a filename.,      * <p>,      * If the specified file name is relative it is resolved,      * with respect to the given root directory.,      *,      * @param fileName The name of the file to resolve.,      *                 Must not be <code>null</code>.,      *,      * @param rootDir  The directory respective to which relative file names,      *                 are resolved. May be <code>null</code>, in which case,      *                 the current directory is used.,      *,      * @return the resolved File.,      *,      * @deprecated since 1.4.x,      */,     public File resolveFile(String fileName, File rootDir) {,         return FILE_UTILS.resolveFile(rootDir, fileName);,     }, ,     /**,      * Return the canonical form of a filename.,      * <p>,      * If the specified file name is relative it is resolved,      * with respect to the project's base directory.,      *,      * @param fileName The name of the file to resolve.,      *                 Must not be <code>null</code>.,      *,      * @return the resolved File.,      *,      */,     public File resolveFile(String fileName) {,         return FILE_UTILS.resolveFile(baseDir, fileName);,     }, ,     /**,      * Translate a path into its native (platform specific) format.,      * <p>,      * This method uses PathTokenizer to separate the input path,      * into its components. This handles DOS style paths in a relatively,      * sensible way. The file separators are then converted to their platform,      * specific versions.,      *,      * @param toProcess The path to be translated.,      *                  May be <code>null</code>.,      *,      * @return the native version of the specified path or,      *         an empty string if the path is <code>null</code> or empty.,      *,      * @deprecated since 1.7,      *             Use FileUtils.translatePath instead.,      *,      * @see PathTokenizer,      */,     public static String translatePath(String toProcess) {,         return FileUtils.translatePath(toProcess);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination.,      * No filtering is performed.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(String sourceFile, String destFile),           throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination,      * specifying if token filtering should be used.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(String sourceFile, String destFile, boolean filtering),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used and if,      * source files may overwrite newer destination files.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(String sourceFile, String destFile, boolean filtering,,                          boolean overwrite) throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used, if,      * source files may overwrite newer destination files, and if the,      * last modified time of the resulting file should be set to,      * that of the source file.,      *,      * @param sourceFile Name of file to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile Name of file to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      * @param preserveLastModified Whether or not the last modified time of,      *                             the resulting file should be set to that,      *                             of the source file.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(String sourceFile, String destFile, boolean filtering,,                          boolean overwrite, boolean preserveLastModified),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite, preserveLastModified);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination.,      * No filtering is performed.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(File sourceFile, File destFile) throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile);,     }, ,     /**,      * Convenience method to copy a file from a source to a destination,      * specifying if token filtering should be used.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      *,      * @exception IOException if the copying fails.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(File sourceFile, File destFile, boolean filtering),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used and if,      * source files may overwrite newer destination files.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      *,      * @exception IOException if the file cannot be copied.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(File sourceFile, File destFile, boolean filtering,,                          boolean overwrite) throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite);,     }, ,     /**,      * Convenience method to copy a file from a source to a,      * destination specifying if token filtering should be used, if,      * source files may overwrite newer destination files, and if the,      * last modified time of the resulting file should be set to,      * that of the source file.,      *,      * @param sourceFile File to copy from.,      *                   Must not be <code>null</code>.,      * @param destFile File to copy to.,      *                 Must not be <code>null</code>.,      * @param filtering Whether or not token filtering should be used during,      *                  the copy.,      * @param overwrite Whether or not the destination file should be,      *                  overwritten if it already exists.,      * @param preserveLastModified Whether or not the last modified time of,      *                             the resulting file should be set to that,      *                             of the source file.,      *,      * @exception IOException if the file cannot be copied.,      *,      * @deprecated since 1.4.x,      */,     public void copyFile(File sourceFile, File destFile, boolean filtering,,                          boolean overwrite, boolean preserveLastModified),         throws IOException {,         FILE_UTILS.copyFile(sourceFile, destFile,,             filtering ? globalFilters : null, overwrite, preserveLastModified);,     }, ,     /**,      * Call File.setLastModified(long time) on Java above 1.1, and logs,      * a warning on Java 1.1.,      *,      * @param file The file to set the last modified time on.,      *             Must not be <code>null</code>.,      *,      * @param time the required modification time.,      *,      * @deprecated since 1.4.x,      *,      * @exception BuildException if the last modified time cannot be set,      *                           despite running on a platform with a version,      *                           above 1.1.,      */,     public void setFileLastModified(File file, long time),          throws BuildException {,         FILE_UTILS.setFileLastModified(file, time);,         log("Setting modification time for " + file, MSG_VERBOSE);,     }, ,     /**,      * Return the boolean equivalent of a string, which is considered,      * <code>true</code> if either <code>"on"</code>, <code>"true"</code>,,      * or <code>"yes"</code> is found, ignoring case.,      *,      * @param s The string to convert to a boolean value.,      *,      * @return <code>true</code> if the given string is <code>"on"</code>,,      *         <code>"true"</code> or <code>"yes"</code>, or,      *         <code>false</code> otherwise.,      */,     public static boolean toBoolean(String s) {,         return ("on".equalsIgnoreCase(s),                 || "true".equalsIgnoreCase(s),                 || "yes".equalsIgnoreCase(s));,     }, ,     /**,      * Get the Project instance associated with the specified object.,      * @param o the object to query.,      * @return Project instance, if any.,      * @since Ant 1.7.1,      */,     public static Project getProject(Object o) {,         if (o instanceof ProjectComponent) {,             return ((ProjectComponent) o).getProject();,         },         try {,             Method m = o.getClass().getMethod("getProject", (Class[]) null);,             if (Project.class == m.getReturnType()) {,                 return (Project) m.invoke(o, (Object[]) null);,             },         } catch (Exception e) {,             //too bad,         },         return null;,     }, ,     /**,      * Topologically sort a set of targets.  Equivalent to calling,      * <code>topoSort(new String[] {root}, targets, true)</code>.,      *,      * @param root The name of the root target. The sort is created in such,      *             a way that the sequence of Targets up to the root,      *             target is the minimum possible such sequence.,      *             Must not be <code>null</code>.,      * @param targetTable A Hashtable mapping names to Targets.,      *                Must not be <code>null</code>.,      * @return a Vector of ALL Target objects in sorted order.,      * @exception BuildException if there is a cyclic dependency among the,      *                           targets, or if a named target does not exist.,      */,     public final Vector topoSort(String root, Hashtable targetTable),         throws BuildException {,         return topoSort(new String[] {root}, targetTable, true);,     }, ,     /**,      * Topologically sort a set of targets.  Equivalent to calling,      * <code>topoSort(new String[] {root}, targets, returnAll)</code>.,      *,      * @param root The name of the root target. The sort is created in such,      *             a way that the sequence of Targets up to the root,      *             target is the minimum possible such sequence.,      *             Must not be <code>null</code>.,      * @param targetTable A Hashtable mapping names to Targets.,      *                Must not be <code>null</code>.,      * @param returnAll <code>boolean</code> indicating whether to return all,      *                  targets, or the execution sequence only.,      * @return a Vector of Target objects in sorted order.,      * @exception BuildException if there is a cyclic dependency among the,      *                           targets, or if a named target does not exist.,      * @since Ant 1.6.3,      */,     public final Vector topoSort(String root, Hashtable targetTable,,                                  boolean returnAll) throws BuildException {,         return topoSort(new String[] {root}, targetTable, returnAll);,     }, ,     /**,      * Topologically sort a set of targets.,      *,      * @param root <code>String[]</code> containing the names of the root targets.,      *             The sort is created in such a way that the ordered sequence of,      *             Targets is the minimum possible such sequence to the specified,      *             root targets.,      *             Must not be <code>null</code>.,      * @param targetTable A map of names to targets (String to Target).,      *                Must not be <code>null</code>.,      * @param returnAll <code>boolean</code> indicating whether to return all,      *                  targets, or the execution sequence only.,      * @return a Vector of Target objects in sorted order.,      * @exception BuildException if there is a cyclic dependency among the,      *                           targets, or if a named target does not exist.,      * @since Ant 1.6.3,      */,     public final Vector topoSort(String[] root, Hashtable targetTable,,                                  boolean returnAll) throws BuildException {,         Vector ret = new VectorSet();,         Hashtable state = new Hashtable();,         Stack visiting = new Stack();, ,         // We first run a DFS based sort using each root as a starting node.,         // This creates the minimum sequence of Targets to the root node(s).,         // We then do a sort on any remaining unVISITED targets.,         // This is unnecessary for doing our build, but it catches,         // circular dependencies or missing Targets on the entire,         // dependency tree, not just on the Targets that depend on the,         // build Target., ,         for (int i = 0; i < root.length; i++) {,             String st = (String) (state.get(root[i]));,             if (st == null) {,                 tsort(root[i], targetTable, state, visiting, ret);,             } else if (st == VISITING) {,                 throw new RuntimeException("Unexpected node in visiting state: ",                     + root[i]);,             },         },         StringBuffer buf = new StringBuffer("Build sequence for target(s)");, ,         for (int j = 0; j < root.length; j++) {,             buf.append((j == 0) ? " `" : ", `").append(root[j]).append('\'');,         },         buf.append(" is " + ret);,         log(buf.toString(), MSG_VERBOSE);, ,         Vector complete = (returnAll) ? ret : new Vector(ret);,         for (Enumeration en = targetTable.keys(); en.hasMoreElements();) {,             String curTarget = (String) en.nextElement();,             String st = (String) state.get(curTarget);,             if (st == null) {,                 tsort(curTarget, targetTable, state, visiting, complete);,             } else if (st == VISITING) {,                 throw new RuntimeException("Unexpected node in visiting state: ",                     + curTarget);,             },         },         log("Complete build sequence is " + complete, MSG_VERBOSE);,         return ret;,     }, ,     /**,      * Perform a single step in a recursive depth-first-search traversal of,      * the target dependency tree.,      * <p>,      * The current target is first set to the &quot;visiting&quot; state, and,      * pushed onto the &quot;visiting&quot; stack.,      * <p>,      * An exception is then thrown if any child of the current node is in the,      * visiting state, as that implies a circular dependency. The exception,      * contains details of the cycle, using elements of the &quot;visiting&quot;,      * stack.,      * <p>,      * If any child has not already been &quot;visited&quot;, this method is,      * called recursively on it.,      * <p>,      * The current target is then added to the ordered list of targets. Note,      * that this is performed after the children have been visited in order,      * to get the correct order. The current target is set to the,      * &quot;visited&quot; state.,      * <p>,      * By the time this method returns, the ordered list contains the sequence,      * of targets up to and including the current target.,      *,      * @param root The current target to inspect.,      *             Must not be <code>null</code>.,      * @param targetTable A mapping from names to targets (String to Target).,      *                Must not be <code>null</code>.,      * @param state   A mapping from target names to states (String to String).,      *                The states in question are &quot;VISITING&quot; and,      *                &quot;VISITED&quot;. Must not be <code>null</code>.,      * @param visiting A stack of targets which are currently being visited.,      *                 Must not be <code>null</code>.,      * @param ret     The list to add target names to. This will end up,      *                containing the complete list of dependencies in,      *                dependency order.,      *                Must not be <code>null</code>.,      *,      * @exception BuildException if a non-existent target is specified or if,      *                           a circular dependency is detected.,      */,     private void tsort(String root, Hashtable targetTable,,                              Hashtable state, Stack visiting,,                              Vector ret),         throws BuildException {,         state.put(root, VISITING);,         visiting.push(root);, ,         Target target = (Target) targetTable.get(root);, ,         // Make sure we exist,         if (target == null) {,             StringBuffer sb = new StringBuffer("Target \"");,             sb.append(root);,             sb.append("\" does not exist in the project \"");,             sb.append(name);,             sb.append("\". ");,             visiting.pop();,             if (!visiting.empty()) {,                 String parent = (String) visiting.peek();,                 sb.append("It is used from target \"");,                 sb.append(parent);,                 sb.append("\".");,             },             throw new BuildException(new String(sb));,         },         for (Enumeration en = target.getDependencies(); en.hasMoreElements();) {,             String cur = (String) en.nextElement();,             String m = (String) state.get(cur);,             if (m == null) {,                 // Not been visited,                 tsort(cur, targetTable, state, visiting, ret);,             } else if (m == VISITING) {,                 // Currently visiting this node, so have a cycle,                 throw makeCircularException(cur, visiting);,             },         },         String p = (String) visiting.pop();,         if (root != p) {,             throw new RuntimeException("Unexpected internal error: expected to ",                 + "pop " + root + " but got " + p);,         },         state.put(root, VISITED);,         ret.addElement(target);,     }, ,     /**,      * Build an appropriate exception detailing a specified circular,      * dependency.,      *,      * @param end The dependency to stop at. Must not be <code>null</code>.,      * @param stk A stack of dependencies. Must not be <code>null</code>.,      *,      * @return a BuildException detailing the specified circular dependency.,      */,     private static BuildException makeCircularException(String end, Stack stk) {,         StringBuffer sb = new StringBuffer("Circular dependency: ");,         sb.append(end);,         String c;,         do {,             c = (String) stk.pop();,             sb.append(" <- ");,             sb.append(c);,         } while (!c.equals(end));,         return new BuildException(new String(sb));,     }, ,     /**,      * Inherit the id references.,      * @param parent the parent project of this project.,      */,     public void inheritIDReferences(Project parent) {,         parentIdProject = parent;,     }, ,     /**,      * Add an id reference.,      * Used for broken build files.,      * @param id the id to set.,      * @param value the value to set it to (Unknown element in this case.,      */,     public void addIdReference(String id, Object value) {,         idReferences.put(id, value);,     }, ,     /**,      * Add a reference to the project.,      *,      * @param referenceName The name of the reference. Must not be <code>null</code>.,      * @param value The value of the reference.,      */,     public void addReference(String referenceName, Object value) {,         Object old = ((AntRefTable) references).getReal(referenceName);,         if (old == value) {,             // no warning, this is not changing anything,             return;,         },         if (old != null && !(old instanceof UnknownElement)) {,             log("Overriding previous definition of reference to " + referenceName,,                 MSG_VERBOSE);,         },         log("Adding reference: " + referenceName, MSG_DEBUG);,         references.put(referenceName, value);,     }, ,     /**,      * Return a map of the references in the project (String to Object).,      * The returned hashtable is &quot;live&quot; and so must not be modified.,      *,      * @return a map of the references in the project (String to Object).,      */,     public Hashtable getReferences() {,         return references;,     }, ,     /**,      * Does the project know this reference?,      *,      * @since Ant 1.8.0,      */,     public boolean hasReference(String key) {,         return references.containsKey(key);,     }, ,     /**,      * Return a map of the references in the project (String to,      * Object).  The returned hashtable is a copy of the,      * &quot;live&quot; references.,      *,      * @return a map of the references in the project (String to Object).,      *,      * @since Ant 1.8.1,      */,     public Map getCopyOfReferences() {,         return new HashMap(references);,     }, ,     /**,      * Look up a reference by its key (ID).,      *,      * @param key The key for the desired reference.,      *            Must not be <code>null</code>.,      *,      * @return the reference with the specified ID, or <code>null</code> if,      *         there is no such reference in the project.,      */,     public Object getReference(String key) {,         Object ret = references.get(key);,         if (ret != null) {,             return ret;,         },         if (!key.equals(MagicNames.REFID_PROPERTY_HELPER)) {,             try {,                 if (PropertyHelper.getPropertyHelper(this).containsProperties(key)) {,                     log("Unresolvable reference " + key,                             + " might be a misuse of property expansion syntax.", MSG_WARN);,                 },             } catch (Exception e) {,                 //ignore,             },         },         return ret;,     }, ,     /**,      * Return a description of the type of the given element, with,      * special handling for instances of tasks and data types.,      * <p>,      * This is useful for logging purposes.,      *,      * @param element The element to describe.,      *                Must not be <code>null</code>.,      *,      * @return a description of the element type.,      *,      * @since 1.95, Ant 1.5,      */,     public String getElementName(Object element) {,         return ComponentHelper.getComponentHelper(this).getElementName(element);,     }, ,     /**,      * Send a &quot;build started&quot; event,      * to the build listeners for this project.,      */,     public void fireBuildStarted() {,         BuildEvent event = new BuildEvent(this);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].buildStarted(event);,         },     }, ,     /**,      * Send a &quot;build finished&quot; event to the build listeners,      * for this project.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      */,     public void fireBuildFinished(Throwable exception) {,         BuildEvent event = new BuildEvent(this);,         event.setException(exception);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].buildFinished(event);,         },         // Inform IH to clear the cache,         IntrospectionHelper.clearCache();,     }, ,     /**,      * Send a &quot;subbuild started&quot; event to the build listeners for,      * this project.,      *,      * @since Ant 1.6.2,      */,     public void fireSubBuildStarted() {,         BuildEvent event = new BuildEvent(this);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             if (currListeners[i] instanceof SubBuildListener) {,                 ((SubBuildListener) currListeners[i]).subBuildStarted(event);,             },         },     }, ,     /**,      * Send a &quot;subbuild finished&quot; event to the build listeners for,      * this project.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      *,      * @since Ant 1.6.2,      */,     public void fireSubBuildFinished(Throwable exception) {,         BuildEvent event = new BuildEvent(this);,         event.setException(exception);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             if (currListeners[i] instanceof SubBuildListener) {,                 ((SubBuildListener) currListeners[i]).subBuildFinished(event);,             },         },     }, ,     /**,      * Send a &quot;target started&quot; event to the build listeners,      * for this project.,      *,      * @param target The target which is starting to build.,      *               Must not be <code>null</code>.,      */,     protected void fireTargetStarted(Target target) {,         BuildEvent event = new BuildEvent(target);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].targetStarted(event);,         }, ,     }, ,     /**,      * Send a &quot;target finished&quot; event to the build listeners,      * for this project.,      *,      * @param target    The target which has finished building.,      *                  Must not be <code>null</code>.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      */,     protected void fireTargetFinished(Target target, Throwable exception) {,         BuildEvent event = new BuildEvent(target);,         event.setException(exception);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].targetFinished(event);,         }, ,     }, ,     /**,      * Send a &quot;task started&quot; event to the build listeners,      * for this project.,      *,      * @param task The target which is starting to execute.,      *               Must not be <code>null</code>.,      */,     protected void fireTaskStarted(Task task) {,         // register this as the current task on the current thread.,         registerThreadTask(Thread.currentThread(), task);,         BuildEvent event = new BuildEvent(task);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].taskStarted(event);,         },     }, ,     /**,      * Send a &quot;task finished&quot; event to the build listeners for this,      * project.,      *,      * @param task      The task which has finished executing.,      *                  Must not be <code>null</code>.,      * @param exception an exception indicating a reason for a build,      *                  failure. May be <code>null</code>, indicating,      *                  a successful build.,      */,     protected void fireTaskFinished(Task task, Throwable exception) {,         registerThreadTask(Thread.currentThread(), null);,         System.out.flush();,         System.err.flush();,         BuildEvent event = new BuildEvent(task);,         event.setException(exception);,         BuildListener[] currListeners = listeners;,         for (int i = 0; i < currListeners.length; i++) {,             currListeners[i].taskFinished(event);,         }, ,     }, ,     /**,      * Send a &quot;message logged&quot; event to the build listeners,      * for this project.,      *,      * @param event    The event to send. This should be built up with the,      *                 appropriate task/target/project by the caller, so that,      *                 this method can set the message and priority, then send,      *                 the event. Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     private void fireMessageLoggedEvent(BuildEvent event, String message,,                                         int priority) {, ,         if (message == null) {,             message = String.valueOf(message);,         },         if (message.endsWith(StringUtils.LINE_SEP)) {,             int endIndex = message.length() - StringUtils.LINE_SEP.length();,             event.setMessage(message.substring(0, endIndex), priority);,         } else {,             event.setMessage(message, priority);,         },         if (isLoggingMessage.get() != Boolean.FALSE) {,             /*,              * One of the Listeners has attempted to access,              * System.err or System.out.,              *,              * We used to throw an exception in this case, but,              * sometimes Listeners can't prevent it(like our own,              * Log4jListener which invokes getLogger() which in,              * turn wants to write to the console).,              *,              * @see http://marc.theaimsgroup.com/?t=110538624200006&r=1&w=2,              *,              * We now (Ant 1.6.3 and later) simply swallow the message.,              */,             return;,         },         try {,             isLoggingMessage.set(Boolean.TRUE);,             BuildListener[] currListeners = listeners;,             for (int i = 0; i < currListeners.length; i++) {,                 currListeners[i].messageLogged(event);,             },         } finally {,             isLoggingMessage.set(Boolean.FALSE);,         },     }, ,     /**,      * Send a &quot;message logged&quot; project level event,      * to the build listeners for this project.,      *,      * @param project  The project generating the event.,      *                 Should not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     protected void fireMessageLogged(Project project, String message,,                                      int priority) {,         fireMessageLogged(project, message, null, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; project level event,      * to the build listeners for this project.,      *,      * @param project  The project generating the event.,      *                 Should not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param throwable The exception that caused this message. May be <code>null</code>.,      * @param priority The priority of the message.,      * @since 1.7,      */,     protected void fireMessageLogged(Project project, String message,,             Throwable throwable, int priority) {,         BuildEvent event = new BuildEvent(project);,         event.setException(throwable);,         fireMessageLoggedEvent(event, message, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; target level event,      * to the build listeners for this project.,      *,      * @param target   The target generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     protected void fireMessageLogged(Target target, String message,,                                      int priority) {,         fireMessageLogged(target, message, null, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; target level event,      * to the build listeners for this project.,      *,      * @param target   The target generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param throwable The exception that caused this message. May be <code>null</code>.,      * @param priority The priority of the message.,      * @since 1.7,      */,     protected void fireMessageLogged(Target target, String message,,             Throwable throwable, int priority) {,         BuildEvent event = new BuildEvent(target);,         event.setException(throwable);,         fireMessageLoggedEvent(event, message, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; task level event,      * to the build listeners for this project.,      *,      * @param task     The task generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param priority The priority of the message.,      */,     protected void fireMessageLogged(Task task, String message, int priority) {,         fireMessageLogged(task, message, null, priority);,     }, ,     /**,      * Send a &quot;message logged&quot; task level event,      * to the build listeners for this project.,      *,      * @param task     The task generating the event.,      *                 Must not be <code>null</code>.,      * @param message  The message to send. Should not be <code>null</code>.,      * @param throwable The exception that caused this message. May be <code>null</code>.,      * @param priority The priority of the message.,      * @since 1.7,      */,     protected void fireMessageLogged(Task task, String message,,             Throwable throwable, int priority) {,         BuildEvent event = new BuildEvent(task);,         event.setException(throwable);,         fireMessageLoggedEvent(event, message, priority);,     }, ,     /**,      * Register a task as the current task for a thread.,      * If the task is null, the thread's entry is removed.,      *,      * @param thread the thread on which the task is registered.,      * @param task the task to be registered.,      * @since Ant 1.5,      */,     public void registerThreadTask(Thread thread, Task task) {,         synchronized(threadTasks) {,             if (task != null) {,                 threadTasks.put(thread, task);,                 threadGroupTasks.put(thread.getThreadGroup(), task);,             } else {,                 threadTasks.remove(thread);,                 threadGroupTasks.remove(thread.getThreadGroup());,             },         },     }, ,     /**,      * Get the current task associated with a thread, if any.,      *,      * @param thread the thread for which the task is required.,      * @return the task which is currently registered for the given thread or,      *         null if no task is registered.,      */,     public Task getThreadTask(Thread thread) {,         synchronized(threadTasks) {,             Task task = (Task) threadTasks.get(thread);,             if (task == null) {,                 ThreadGroup group = thread.getThreadGroup();,                 while (task == null && group != null) {,                     task = (Task) threadGroupTasks.get(group);,                     group = group.getParent();,                 },             },             return task;,         },     }, , ,     // Should move to a separate public class - and have API to add,     // listeners, etc.,     private static class AntRefTable extends Hashtable {, ,         AntRefTable() {,             super();,         }, ,         /** Returns the unmodified original object.,          * This method should be called internally to,          * get the &quot;real&quot; object.,          * The normal get method will do the replacement,          * of UnknownElement (this is similar with the JDNI,          * refs behavior).,          */,         private Object getReal(Object key) {,             return super.get(key);,         }, ,         /** Get method for the reference table.,          *  It can be used to hook dynamic references and to modify,          * some references on the fly--for example for delayed,          * evaluation.,          *,          * It is important to make sure that the processing that is,          * done inside is not calling get indirectly.,          *,          * @param key lookup key.,          * @return mapped value.,          */,         public Object get(Object key) {,             //System.out.println("AntRefTable.get " + key);,             Object o = getReal(key);,             if (o instanceof UnknownElement) {,                 // Make sure that,                 UnknownElement ue = (UnknownElement) o;,                 ue.maybeConfigure();,                 o = ue.getRealThing();,             },             return o;,         },     }, ,     /**,      * Set a reference to this Project on the parameterized object.,      * Need to set the project before other set/add elements,      * are called.,      * @param obj the object to invoke setProject(this) on.,      */,     public final void setProjectReference(final Object obj) {,         if (obj instanceof ProjectComponent) {,             ((ProjectComponent) obj).setProject(this);,             return;,         },         try {,             Method method =,                 obj.getClass().getMethod(,                     "setProject", new Class[] {Project.class});,             if (method != null) {,                 method.invoke(obj, new Object[] {this});,             },         } catch (Throwable e) {,             // ignore this if the object does not have,             // a set project method or the method,             // is private/protected.,         },     }, ,     /**,      * Resolve the file relative to the project's basedir and return it as a,      * FileResource.,      * @param name the name of the file to resolve.,      * @return the file resource.,      * @since Ant 1.7,      */,     public Resource getResource(String name) {,         return new FileResource(getBaseDir(), name);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/DefaultLogger.java,setErrorPrintStream,111-111,[        this.err = new PrintStream(err, true);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/DefaultLogger.java,setOutputPrintStream,101-101,[        this.out = new PrintStream(output, true);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/DefaultLoggerTest.java,,53-57,[        Exception x = new Exception("problem") {,             public void printStackTrace(PrintWriter w) {,                 w.println("problem");,                 w.println("  at p.C.m");,             }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/DemuxOutputStream.java,processBuffer,171-171,[        String output = buffer.toString();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/DemuxOutputStream.java,processFlush,185-185,[        String output = buffer.toString();],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/tools/ant/Diagnostics.java,doReportSystemProperties,366-366,[        for (Enumeration keys = sysprops.propertyNames();],,doReportSystemProperties,359-359,[        Properties sysprops = null;],,doReportSystemProperties,362-362,[        } catch (SecurityException  e) {],,doReportSystemProperties,363-363,[            ignoreThrowable(e);],,doReportSystemProperties,364-364,[            out.println("Access to System.getProperties() blocked " + "by a security manager");],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/Diagnostics.java,doReportTasksAvailability,485-485,[        InputStream is = Main.class.getResourceAsStream(],,doReportTasksAvailability,487-487,[        if (is == null) {],,doReportTasksAvailability,490-490,[            Properties props = new Properties();],,doReportTasksAvailability,492-492,[                props.load(is);],,doReportTasksAvailability,493-493,[                for (Enumeration keys = props.keys(); keys.hasMoreElements();) {],,doReportTasksAvailability,509-509,[                if (props.size() == 0) {],,doReportTasksAvailability,512-512,[                    out.println("A task being missing/unavailable should only "],,doReportTasksAvailability,517-517,[            }],,doReportTasksAvailability,519-519,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/Diagnostics.java,doReportTasksAvailability,485-485,[        InputStream is = Main.class.getResourceAsStream(],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/Diagnostics.java,listLibraries,112-112,[            return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/Diagnostics.java,getSAXParser,198-198,[        if (saxParserFactory == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/Diagnostics.java,getXSLTProcessor,217-217,[        if (transformerFactory == null) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/Diagnostics.java,doReportTempDir,602-602,[            tempFile.delete();],,doReportTempDir,628-628,[                tempFile.delete();],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/DirectoryScanner.java,fillNonPatternSet,1827-1827,[                    ? patterns[i] : patterns[i].toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/DirectoryScanner.java,isExcluded,1517-1517,[            : excludeNonPatterns.containsKey(name.toString().toUpperCase())) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/DirectoryScanner.java,isIncluded,1374-1374,[            : includeNonPatterns.containsKey(path.toString().toUpperCase())) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/DirectoryScanner.java,setSelectors,803-803,[        this.selectors = selectors;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/DirectoryScanner.java,,668-668,[        this.errorOnMissingDir = errorOnMissingDir;],,,870-870,[                        if (errorOnMissingDir) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/DirectoryScanner.java,,837-837,[                if (illegal != null) {],,,838-838,[                    throw illegal;],,,847-847,[                illegal = null;],,,884-884,[                    if (illegal != null) {],,,885-885,[                        throw illegal;],,,871-871,[                            illegal = new IllegalStateException("basedir "],,,879-879,[                        illegal = new IllegalStateException("basedir "],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/DirectoryScanner.java,,148-148,[    protected static final String[] DEFAULTEXCLUDES = {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/DirectoryScanner.java,getBasedir,636-636,[        return basedir;],,getBaseDir,864-871,[        if (baseDir == null) {,             try {,                 setBasedir(".");,             } catch (BuildException ex) {,                 ex.printStackTrace();,             },         },         return baseDir;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/DirectoryScanner.java,setBasedir,626-627,[        this.basedir = basedir;,     }],,setBaseDir,842-855,[        baseDir = FILE_UTILS.normalize(baseDir.getAbsolutePath());,         if (!baseDir.exists()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " does not exist");,         },         if (!baseDir.isDirectory()) {,             throw new BuildException("Basedir " + baseDir.getAbsolutePath(),                 + " is not a directory");,         },         this.baseDir = baseDir;,         setPropertyInternal(MagicNames.PROJECT_BASEDIR, this.baseDir.getPath());,         String msg = "Project base dir set to: " + this.baseDir;,         log(msg, MSG_VERBOSE);,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/DirectoryScanner.java,setCaseSensitive,657-658,[        this.isCaseSensitive = isCaseSensitive;,     }],,setCasesensitive,58-59,[        caseSensitive = b;,     }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/DirectoryScannerTest.java,testAbsolute5,491-491,[        String pattern = new File(File.separator).getAbsolutePath().toUpperCase() + "*";],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/DirectoryScannerTest.java,tearDown,51-51,[    }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/DirectoryScannerTest.java,testIsExcludedDirectoryScanned,412-412,[        if (shareclassloader == null],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/tools/ant/DirectoryScannerTest.java,testIsExcludedDirectoryScanned,412-412,[        if (shareclassloader == null],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/tools/ant/IntrospectionHelper.java,setAttribute,405-405,[            as.setObject(p, element, value);],,setAttribute,382-382,[        if (as == null && value != null) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/IntrospectionHelper.java,,1644-1650,[    private class MethodAndObject {,         private Method method;,         private Object object;,         public MethodAndObject(Method method, Object object) {,             this.method = method;,             this.object = object;,         }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAddTextMethod,87-87,[            m = ih.getAddTextMethod();],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,508-508,[        assertAttrMethod("nineteen", "setNineteen", Double.TYPE,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,504-504,[        assertAttrMethod("seventeen", "setSeventeen", Byte.TYPE,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,500-500,[        assertAttrMethod("fifteen", "setFifteen", Character.TYPE,],,testGetAttributeMethod,502-502,[        assertAttrMethod("sixteen", "setSixteen", Character.class,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,486-486,[        assertAttrMethod("eight", "setEight", Integer.TYPE,],,testGetAttributeMethod,488-488,[        assertAttrMethod("nine", "setNine", Integer.class,],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/IntrospectionHelperTest.java,testGetAttributeMethod,506-506,[        assertAttrMethod("eightteen", "setEightteen", Short.TYPE,],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/IntrospectionHelperTest.java,createFour,252-252,[        return null;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/LoaderRefTest.java,tearDown,37-37,[    }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/Location.java,getFileName,103-103,[        return fileName;],,getFilename,75-75,[        return filename;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/tools/ant/Location.java,,41-175,[    public static final Location UNKNOWN_LOCATION = new Location();, ,     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();, ,     /**,      * Creates an "unknown" location.,      */,     private Location() {,         this(null, 0, 0);,     }, ,     /**,      * Creates a location consisting of a file name but no line number or,      * column number.,      *,      * @param fileName The name of the file. May be <code>null</code>,,      *                 in which case the location is equivalent to,      *                 {@link #UNKNOWN_LOCATION UNKNOWN_LOCATION}.,      */,     public Location(String fileName) {,         this(fileName, 0, 0);,     }, ,     /**,      * Creates a location from the SAX locator using the system ID as,      * the filename.,      *,      * @param loc Must not be <code>null</code>.,      *,      * @since Ant 1.6,      */,     public Location(Locator loc) {,         this(loc.getSystemId(), loc.getLineNumber(), loc.getColumnNumber());,     }, ,     /**,      * Creates a location consisting of a file name, line number and,      * column number.,      *,      * @param fileName The name of the file. May be <code>null</code>,,      *                 in which case the location is equivalent to,      *                 {@link #UNKNOWN_LOCATION UNKNOWN_LOCATION}.,      *,      * @param lineNumber Line number within the file. Use 0 for unknown,      *                   positions within a file.,      * @param columnNumber Column number within the line.,      */,     public Location(String fileName, int lineNumber, int columnNumber) {,         if (fileName != null && fileName.startsWith("file:")) {,             this.fileName = FILE_UTILS.fromURI(fileName);,         } else {,             this.fileName = fileName;,         },         this.lineNumber = lineNumber;,         this.columnNumber = columnNumber;,     }, ,     /**,      * @return the filename portion of the location,      * @since Ant 1.6,      */,     public String getFileName() {,         return fileName;,     }, ,     /**,      * @return the line number,      * @since Ant 1.6,      */,     public int getLineNumber() {,         return lineNumber;,     }, ,     /**,      * @return the column number,      * @since Ant 1.7,      */,     public int getColumnNumber() {,         return columnNumber;,     }, ,     /**,      * Returns the file name, line number, a colon and a trailing space.,      * An error message can be appended easily. For unknown locations, an,      * empty string is returned.,      *,      * @return a String of the form <code>"fileName:lineNumber: "</code>,      *         if both file name and line number are known,,      *         <code>"fileName: "</code> if only the file name is known,,      *         and the empty string for unknown locations.,      */,     public String toString() {,         StringBuffer buf = new StringBuffer();, ,         if (fileName != null) {,             buf.append(fileName);, ,             if (lineNumber != 0) {,                 buf.append(":");,                 buf.append(lineNumber);,             }, ,             buf.append(": ");,         }, ,         return buf.toString();,     }, ,     /**,      * Equality operation.,      * @param other the object to compare to.,      * @return true if the other object contains the same information,      *              as this object.,      * @since Ant 1.6.3,      */,     public boolean equals(Object other) {,         if (this == other) {,             return true;,         },         if (other == null) {,             return false;,         },         if (!(other.getClass() == getClass())) {,             return false;,         },         return toString().equals(other.toString());,     }, ,     /**,      * Hash operation.,      * @return a hash code value for this location.,      * @since Ant 1.6.3,      */,     public int hashCode() {,         return toString().hashCode();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/Main.java,processArgs,334-334,[                    logTo = new PrintStream(new FileOutputStream(logFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/Main.java,runBuild,741-741,[                System.setOut(new PrintStream(new DemuxOutputStream(project, false)));],,runBuild,742-742,[                System.setErr(new PrintStream(new DemuxOutputStream(project, true)));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/Main.java,getAntVersion,1007-1007,[                    Main.class.getResourceAsStream("/org/apache/tools/ant/version.txt");],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/Main.java,printTargets,1196-1196,[            spaces += spaces;],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/Main.java,processArgs,335-335,[                    isLogFileUsed = true;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/Project.java,addReference,1980-1980,[        Object old = ((AntRefTable) references).getReal(referenceName);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/Project.java,getReferences,2000-2000,[        return references;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/Project.java,getTargets,1152-1152,[        return targets;],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/tools/ant/Project.java,tsort,1926-1926,[        if (root != p) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/tools/ant/Project.java,topoSort,1821-1821,[            } else if (st == VISITING) {],,topoSort,1840-1840,[            } else if (st == VISITING) {],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/tools/ant/Project.java,tsort,1920-1920,[            } else if (m == VISITING) {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/Project.java,fireMessageLoggedEvent,2226-2226,[            message = String.valueOf(message);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/Project.java,setProjectReference,2456-2456,[            if (method != null) {],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/tools/ant/Project.java,fireMessageLoggedEvent,2234-2234,[        if (isLoggingMessage.get() != Boolean.FALSE) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/Project.java,getProject,1739-1739,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/Project.java,createSubProject,272-272,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/Project.java,getReference,2045-2045,[            } catch (Exception e) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/Project.java,,177-179,[    private final ThreadLocal isLoggingMessage = new ThreadLocal() {,             protected Object initialValue() {,                 return Boolean.FALSE;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/tools/ant/Project.java,,2400-2437,[    private static class AntRefTable extends Hashtable {, ,         AntRefTable() {,             super();,         }, ,         /** Returns the unmodified original object.,          * This method should be called internally to,          * get the &quot;real&quot; object.,          * The normal get method will do the replacement,          * of UnknownElement (this is similar with the JDNI,          * refs behavior).,          */,         private Object getReal(Object key) {,             return super.get(key);,         }, ,         /** Get method for the reference table.,          *  It can be used to hook dynamic references and to modify,          * some references on the fly--for example for delayed,          * evaluation.,          *,          * It is important to make sure that the processing that is,          * done inside is not calling get indirectly.,          *,          * @param key lookup key.,          * @return mapped value.,          */,         public Object get(Object key) {,             //System.out.println("AntRefTable.get " + key);,             Object o = getReal(key);,             if (o instanceof UnknownElement) {,                 // Make sure that,                 UnknownElement ue = (UnknownElement) o;,                 ue.maybeConfigure();,                 o = ue.getRealThing();,             },             return o;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/ProjectComponentTest.java,,35-35,[        ProjectComponent pc = new ProjectComponent() {],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/tools/ant/ProjectHelper.java,isInIncludeMode,249-249,[        return inIncludeMode.get() == Boolean.TRUE;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/ProjectHelperRepository.java,getProjectHelperByService,193-193,[                isr = new InputStreamReader(is);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/ProjectHelperRepository.java,<clinit>,66-66,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/ProjectHelperRepository.java,getHelperConstructor,243-243,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/ProjectHelperRepository.java,getProjectHelperByService,203-203,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/ProjectHelperRepository.java,next,330-330,[            } catch (Exception e) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/ProjectTest.java,testDuplicateTargets,232-232,[            BFT bft = new BFT("", "core/duplicate-target.xml");],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/ProjectTest.java,setUp,48-48,[        root = new File(File.separator).getAbsolutePath().toUpperCase();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/ProjectTest.java,,283-283,[        p.log(new Task() {}, null, new Throwable(), Project.MSG_ERR);],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/ProjectTest.java,,298-326,[        BFT(String name, String buildfile) {,             super(name);,             this.buildfile = buildfile;,             setUp();,         }, ,         // avoid multiple configurations,         boolean isConfigured = false;, ,         // the buildfile to use,         String buildfile = "";, ,         public void setUp() {,             if (!isConfigured) {,                 configureProject("src/etc/testcases/"+buildfile);,                 isConfigured = true;,             },         }, ,         public void tearDown() { }, ,         // call a target,         public void doTarget(String target) {,             if (!isConfigured) setUp();,             executeTarget(target);,         }, ,         public org.apache.tools.ant.Project getProject() {,             return super.getProject();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/ProjectTest.java,tearDown,317-317,[        public void tearDown() { }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/ProjectTest.java,,298-326,[        BFT(String name, String buildfile) {,             super(name);,             this.buildfile = buildfile;,             setUp();,         }, ,         // avoid multiple configurations,         boolean isConfigured = false;, ,         // the buildfile to use,         String buildfile = "";, ,         public void setUp() {,             if (!isConfigured) {,                 configureProject("src/etc/testcases/"+buildfile);,                 isConfigured = true;,             },         }, ,         public void tearDown() { }, ,         // call a target,         public void doTarget(String target) {,             if (!isConfigured) setUp();,             executeTarget(target);,         }, ,         public org.apache.tools.ant.Project getProject() {,             return super.getProject();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/PropertyFileCLITest.java,testPropertyResolution,53-53,[            String l = FileUtils.safeReadFully(fr = new FileReader(log));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/PropertyFileCLITest.java,testPropertyResolution,40-40,[            fw = new FileWriter(props);],,testPropertyResolution,43-43,[            fw = new FileWriter(build);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/PropertyHelper.java,,344-344,[        return project;],,,483-483,[        if (project != null && name.startsWith("toString:")) {],,,485-485,[            Object v = project.getReference(name);],,,747-747,[        if (project != null) {],,,748-748,[            project.log("Setting ro project property: "],,,791-791,[        if (project != null) {],,,792-792,[            project.log("Setting ro project property: " + name + " -> "],,,336-336,[        this.project = p;],,,702-702,[            if (project != null && properties.containsKey(name)) {],,,707-707,[            if (project != null) {],,,708-708,[                project.log("Setting project property: " + name],,,703-703,[                project.log("Override ignored for property \"" + name],,,647-647,[            if (project != null && verbose) {],,,641-641,[                if (project != null && verbose) {],,,642-642,[                    project.log("Override ignored for user property \""],,,652-652,[                project.log("Setting project property: " + name + " -> "],,,649-649,[                    project.log("Overriding previous definition of property \""],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/tools/ant/PropertyHelper.java,toBoolean,1170-1170,[        return null;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/tools/ant/PropertyHelper.java,setProperty,640-640,[            if (userProperties.containsKey(name)) {],,setProperty,655-655,[            if (name != null && value != null) {],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/tools/ant/PropertyHelper.java,,175-175,[        private final String PREFIX = "toString:";],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/tools/ant/PropertyHelper.java,,239-239,[        private final String PREFIX = "ant.refid:";],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/RuntimeConfigurable.java,,440-440,[        if (r.attributeMap != null) {],,,441-441,[            for (Iterator i = r.attributeMap.keySet().iterator(); i.hasNext();) {],,,443-443,[                if (attributeMap == null || attributeMap.get(name) == null) {],,,444-444,[                    setAttribute(name, (String) r.attributeMap.get(name));],,,379-379,[        if (attributeMap != null) {],,,380-380,[            for (Iterator iter = attributeMap.entrySet().iterator(); iter.hasNext();) {],,,207-207,[        attributeMap.remove(name);],,,217-217,[        return (attributeMap == null)],,,185-185,[            if (attributeMap == null) {],,,186-186,[                attributeMap = new LinkedHashMap();],,,194-194,[                attributeMap.put(name, value);],,,188-188,[            if (name.equalsIgnoreCase("refid") && !attributeMap.isEmpty()) {],,,191-191,[                newAttributeMap.putAll(attributeMap);],,,192-192,[                attributeMap = newAttributeMap;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/RuntimeConfigurable.java,,463-463,[        if (r.characters != null) {],,,464-464,[            if (characters == null],,,466-466,[                characters = new StringBuffer(r.characters.toString());],,,305-305,[        return (characters == null) ? new StringBuffer(0) : characters;],,,275-275,[        characters = (characters == null)],,,276-276,[            ? new StringBuffer(data) : characters.append(data);],,,412-412,[        if (characters != null) {],,,413-413,[            ProjectHelper.addText(p, wrappedObject, characters.substring(0));],,,292-292,[        characters = ((characters == null)],,,293-293,[            ? new StringBuffer(count) : characters).append(buf, start, count);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/RuntimeConfigurable.java,,453-453,[        if (r.children != null) {],,,455-455,[            newChildren.addAll(r.children);],,,456-456,[            if (children != null) {],,,459-459,[            children = newChildren;],,,457-457,[                newChildren.addAll(children);],,,261-261,[        return (children == null) ? new CollectionUtils.EmptyEnumeration()],,,239-239,[        children = (children == null) ? new ArrayList() : children;],,,240-240,[        children.add(child);],,,252-252,[        return (RuntimeConfigurable) children.get(index);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/RuntimeConfigurable.java,,428-428,[        proxyConfigured = false;],,,114-114,[        proxyConfigured = false;],,,368-368,[        if (proxyConfigured) {],,,419-419,[        proxyConfigured = true;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/TaskAdapter.java,execute,126-126,[            if (setLocationM != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/TaskAdapter.java,execute,141-141,[            if (setProjectM != null) {],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/TaskContainerTest.java,tearDown,33-33,[    }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/UnknownElement.java,similar,608-608,[        if (!qname.equals(other.qname)) {],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/UnknownElementTest.java,XtestTaskFinishedEvent,40-62,[        getProject().addBuildListener(new BuildListener() {,                 public void buildStarted(BuildEvent event) {},                 public void buildFinished(BuildEvent event) {},                 public void targetStarted(BuildEvent event) {},                 public void targetFinished(BuildEvent event) {},                 public void taskStarted(BuildEvent event) {,                     assertTaskProperties(event.getTask());,                 },                 public void taskFinished(BuildEvent event) {,                     assertTaskProperties(event.getTask());,                 },                 public void messageLogged(BuildEvent event) {},                 private void assertTaskProperties(Task ue) {,                     assertNotNull(ue);,                     assertTrue(ue instanceof UnknownElement);,                     Task t = ((UnknownElement) ue).getTask();,                     assertNotNull(t);,                     assertEquals("org.apache.tools.ant.taskdefs.Echo",,                                  t.getClass().getName());,                 },             });,         executeTarget("echo");,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/UnknownElementTest.java,,40-59,[        getProject().addBuildListener(new BuildListener() {,                 public void buildStarted(BuildEvent event) {},                 public void buildFinished(BuildEvent event) {},                 public void targetStarted(BuildEvent event) {},                 public void targetFinished(BuildEvent event) {},                 public void taskStarted(BuildEvent event) {,                     assertTaskProperties(event.getTask());,                 },                 public void taskFinished(BuildEvent event) {,                     assertTaskProperties(event.getTask());,                 },                 public void messageLogged(BuildEvent event) {},                 private void assertTaskProperties(Task ue) {,                     assertNotNull(ue);,                     assertTrue(ue instanceof UnknownElement);,                     Task t = ((UnknownElement) ue).getTask();,                     assertNotNull(t);,                     assertEquals("org.apache.tools.ant.taskdefs.Echo",,                                  t.getClass().getName());,                 }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/UnknownElementTest.java,execute,70-70,[            parent.fromChild();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/XmlLogger.java,setOutputPrintStream,442-442,[        this.outStream = new PrintStream(output, true);],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/dispatch/DispatchUtils.java,execute,57-57,[                        mName = "get" + name.trim().substring(0, 1).toUpperCase();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/dispatch/DispatchUtils.java,execute,102-102,[                if (executeM == null) {],,execute,72-72,[                                    if (executeM == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/dispatch/DispatchUtils.java,execute,63-63,[                        if (actionM != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/dispatch/DispatchUtils.java,execute,67-67,[                                if (s != null && s.trim().length() > 0) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/filters/BaseParamFilterReader.java,setParameters,61-61,[        this.parameters = parameters;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/filters/ConcatFilter.java,initialize,206-206,[            prependReader = new BufferedReader(new FileReader(prepend));],,initialize,212-212,[            appendReader = new BufferedReader(new FileReader(append));],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/tools/ant/filters/ConcatFilterTest.java,read,147-147,[            rdr = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/filters/ConcatFilterTest.java,read,144-144,[            java.io.FileReader rdr = new java.io.FileReader(file);],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/filters/ConcatFilterTest.java,tearDown,79-79,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/filters/ConcatFilterTest.java,read,144-144,[            java.io.FileReader rdr = new java.io.FileReader(file);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/filters/ConcatFilterTest.java,read,148-148,[        } catch (Exception e) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/filters/DynamicFilterTest.java,getFileString,60-60,[            r = new FileReader(FILE_UTILS.resolveFile(getProject().getBaseDir(), filename));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/filters/DynamicFilterTest.java,tearDown,45-45,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/filters/EscapeUnicodeTest.java,tearDown,43-43,[    }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/filters/ExpandProperties.java,,103-106,[     *            Must not be <code>null</code>.,      *,      * @return a new filter based on this configuration, but filtering,      *         the specified reader],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/filters/FixCrLfFilter.java,,282-282,[        initialized = true;],,,296-296,[        if (!initialized) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/tools/ant/filters/FixCrLfFilter.java,read,642-683,[                switch (thisChar) {,                 case CTRLZ:,                     int c = super.read();,                     if (c == -1) {,                         atEnd = true;,                         if (fixLast && !previousWasEOL) {,                             numEOL = 1;,                             push(thisChar);,                         },                     } else {,                         push(c);,                     },                     break;,                 case -1:,                     atEnd = true;,                     if (fixLast && !previousWasEOL) {,                         numEOL = 1;,                     },                     break;,                 case '\n':,                     // EOL was "\n",                     numEOL = 1;,                     break;,                 case '\r':,                     numEOL = 1;,                     int c1 = super.read();,                     int c2 = super.read();, ,                     if (c1 == '\r' && c2 == '\n') {,                         // EOL was "\r\r\n",                     } else if (c1 == '\r') {,                         // EOL was "\r\r" - handle as two consecutive "\r" and,                         // "\r",                         numEOL = 2;,                         push(c2);,                     } else if (c1 == '\n') {,                         // EOL was "\r\n",                         push(c2);,                     } else {,                         // EOL was "\r",                         push(c2);,                         push(c1);],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/filters/HeadTailTest.java,tearDown,46-46,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/filters/LineContainsTest.java,tearDown,43-43,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/filters/NoNewLineTest.java,tearDown,41-41,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/filters/ReplaceTokensTest.java,tearDown,43-43,[    }],,
BAD_PRACTICE,RV_NEGATING_RESULT_OF_COMPARETO,org/apache/tools/ant/filters/SortFilter.java,compare,365-365,[                            return (-s1.compareTo(s2));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/filters/SortFilter.java,,361-365,[                Collections.sort(lines, new Comparator() {,                         public int compare(Object o1, Object o2) {,                             String s1 = (String) o1;,                             String s2 = (String) o2;,                             return (-s1.compareTo(s2));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/filters/StripJavaCommentsTest.java,tearDown,43-43,[    }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/filters/TokenFilterTest.java,getFileString,252-252,[            r = new FileReader(FILE_UTILS.resolveFile(getProject().getBaseDir(),filename));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/filters/TokenFilterTest.java,tearDown,45-45,[    }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/filters/TokenFilterTest.java,filter,291-291,[            return token.substring(0, 1).toUpperCase() +],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/helper/ProjectHelper2.java,parse,294-294,[            if (uri != null) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/helper/ProjectHelperImpl.java,configureId,1022-1022,[            project.addReference(id, target);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/helper/ProjectHelperImpl.java,handleElement,603-603,[        } else if (helperImpl.project.getDataTypeDefinitions().get(elementName) != null) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/input/DefaultInputHandler.java,handleInput,51-51,[            r = new BufferedReader(new InputStreamReader(getInputStream()));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/input/GreedyInputHandler.java,handleInput,66-66,[            request.setInput(new String(baos.toByteArray()));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/input/InputRequest.java,setDefaultValue,90-91,[        defaultValue = d;,     }],,setDefaultvalue,187-188,[        this.defaultvalue = defaultvalue;,     }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/input/PropertyFileInputHandler.java,,56-56,[        Object o = props.get(request.getPrompt());],,,72-72,[        if (props == null) {],,,81-81,[            props = new Properties();],,,84-84,[                props.load(new FileInputStream(propsFile));],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/input/PropertyFileInputHandler.java,readProps,84-84,[                props.load(new FileInputStream(propsFile));],,readProps,87-87,[            }],,readProps,89-89,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/input/PropertyFileInputHandler.java,readProps,84-84,[                props.load(new FileInputStream(propsFile));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/input/SecureInputHandler.java,handleInput,55-55,[        } catch (Exception e) {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/launch/Launcher.java,,65-65,[    public static boolean launchDiag = false;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/launch/Locator.java,getToolsJar,427-427,[            } catch (Exception e2) {],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/launch/Locator.java,getLocationURLs,521-521,[        urls = new URL[matches.length];],,getLocationURLs,509-509,[        File[] matches = location.listFiles(],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/launch/LocatorTest.java,NotestTripleForwardSlashNetworkURI,113-116,[        resolveTo("file:///PC03/jclasses/lib/ant-1.7.0.jar",,                 "///PC03/jclasses/lib/ant-1.7.0.jar",,                 "\\\\PC03\\jclasses\\lib\\ant-1.7.0.jar");,     }],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/listener/AnsiColorLogger.java,setColors,161-161,[                in = getClass().getResourceAsStream(systemColorFile);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/property/ResolvePropertyMap.java,getProperty,94-94,[            return parseProperties.parseProperties((String) map.get(name));],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,removeCvsPassword,458-458,[            int stop = cmdLine.indexOf("@", start);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,getErrorStream,244-244,[                                           new FileOutputStream(error.getPath(),],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,getOutputStream,205-205,[                                                                 .getPath(),],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,setCvsRoot,481-488,[        if (root != null) {,             if (root.trim().equals("")) {,                 root = null;,             },         }, ,         this.cvsRoot = root;,     }],,setCvsroot,150-151,[        this.cvsRoot = cvsRoot;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,setFailOnError,741-742,[        this.failOnError = failOnError;,     }],,setFailonerror,214-215,[        failOnError = fail;,     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/AbstractCvsTask.java,runCommand,340-340,[            dest.mkdirs();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/AbstractCvsTaskTest.java,tearDown,42-42,[    }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/AbstractJarSignerTask.java,addFileset,195-196,[        filesets.addElement(set);,     }],,addFileSet,109-110,[        filesets.add(fileset);,     }],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/Ant.java,copyReference,595-595,[        } catch (Exception e) {],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/Ant.java,execute,464-464,[                } catch (final Exception ex) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Ant.java,initializeProject,208-208,[                out = new PrintStream(new FileOutputStream(outfile));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Ant.java,setInheritAll,151-152,[        inheritAll = value;,     }],,setInheritall,420-421,[        this.inheritAll = b;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Ant.java,setInheritRefs,160-161,[        inheritRefs = value;,     }],,setInheritrefs,430-431,[        this.inheritRefs = b;,     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/Ant.java,copyReference,591-591,[            if (cloneM != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/Ant.java,copyReference,606-606,[                if (setProjectM != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/Ant.java,copyReference,595-595,[        } catch (Exception e) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/AntStructure.java,execute,95-95,[                out = new PrintWriter(new FileWriter(output));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/AntStructure.java,printElementDecl,410-410,[                    } catch (Exception x) {],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/AntStructureTest.java,tearDown,41-41,[    }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/AntStructureTest.java,printTail,94-94,[            p.log(TAIL_CALLED);],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/AntTest.java,tearDown,46-46,[    }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/AntTest.java,testRefId,225-238,[        Path testPath = new Path(project);,         testPath.createPath().setPath(System.getProperty("java.class.path"));,         PropertyChecker pc =,             new PropertyChecker("testprop",,                                 new String[] {null,,                                               testPath.toString()});,         project.addBuildListener(pc);,         executeTarget("testRefid");,         AssertionFailedError ae = pc.getError();,         if (ae != null) {,             throw ae;,         },         project.removeBuildListener(pc);,     }],,testRefid,61-62,[        executeTarget("testRefid");,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/AntTest.java,,322-351,[        private int calls = 0;,         private AssertionFailedError error;, ,         BasedirChecker(String[] dirs) {,             expectedBasedirs = dirs;,         }, ,         public void buildStarted(BuildEvent event) {},         public void buildFinished(BuildEvent event) {},         public void targetFinished(BuildEvent event){},         public void taskStarted(BuildEvent event) {},         public void taskFinished(BuildEvent event) {},         public void messageLogged(BuildEvent event) {}, ,         public void targetStarted(BuildEvent event) {,             if (event.getTarget().getName().equals("")) {,                 return;,             },             if (error == null) {,                 try {,                     assertEquals(expectedBasedirs[calls++],,                                  event.getProject().getBaseDir().getAbsolutePath());,                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/AntTest.java,,429-468,[        InputHandlerChecker(InputHandler value) {,             ih = value;,         }, ,         public void buildStarted(BuildEvent event) {,             check(event);,         },         public void buildFinished(BuildEvent event) {,             check(event);,         },         public void targetFinished(BuildEvent event) {,             check(event);,         },         public void taskStarted(BuildEvent event) {,             check(event);,         },         public void taskFinished(BuildEvent event) {,             check(event);,         },         public void messageLogged(BuildEvent event) {,             check(event);,         }, ,         public void targetStarted(BuildEvent event) {,             check(event);,         }, ,         private void check(BuildEvent event) {,             if (error == null) {,                 try {,                     assertNotNull(event.getProject().getInputHandler());,                     assertSame(ih, event.getProject().getInputHandler());,                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/AntTest.java,,476-512,[        private int calls = 0;,         private AssertionFailedError error;, ,         PropertyChecker(String key, String[] values) {,             this.key = key;,             this.expectedValues = values;,         }, ,         public void buildStarted(BuildEvent event) {},         public void buildFinished(BuildEvent event) {},         public void targetFinished(BuildEvent event){},         public void taskStarted(BuildEvent event) {},         public void taskFinished(BuildEvent event) {},         public void messageLogged(BuildEvent event) {}, ,         public void targetStarted(BuildEvent event) {,             if (event.getTarget().getName().equals("")) {,                 return;,             },             if (calls >= expectedValues.length) {,                 error = new AssertionFailedError("Unexpected invocation of",                                                  + " target ",                                                  + event.getTarget().getName());,             }, ,             if (error == null) {,                 try {,                     assertEquals(expectedValues[calls++],,                                  event.getProject().getProperty(key));,                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/AntTest.java,,360-420,[        private int calls = 0;,         private AssertionFailedError error;, ,         ReferenceChecker(String[] keys, boolean[] expectSame, Object value) {,             this.keys = keys;,             this.expectSame = expectSame;,             this.value = value;,         }, ,         public void buildStarted(BuildEvent event) {},         public void buildFinished(BuildEvent event) {},         public void targetFinished(BuildEvent event){},         public void taskStarted(BuildEvent event) {},         public void taskFinished(BuildEvent event) {},         public void messageLogged(BuildEvent event) {}, ,         public void targetStarted(BuildEvent event) {,             if (event.getTarget().getName().equals("")) {,                 return;,             },             if (error == null) {,                 try {,                     String msg =,                         "Call " + calls + " refid=\'" + keys[calls] + "\'";,                     if (value == null) {,                         Object o = event.getProject().getReference(keys[calls]);,                         if (expectSame[calls++]) {,                             assertNull(msg, o);,                         } else {,                             assertNotNull(msg, o);,                         },                     } else {,                         // a rather convoluted equals() test,                         Path expect = (Path) value;,                         Path received = (Path) event.getProject().getReference(keys[calls]);,                         boolean shouldBeEqual = expectSame[calls++];,                         if (received == null) {,                             assertTrue(msg, !shouldBeEqual);,                         } else {,                             String[] l1 = expect.list();,                             String[] l2 = received.list();,                             if (l1.length == l2.length) {,                                 for (int i=0; i<l1.length; i++) {,                                     if (!l1[i].equals(l2[i])) {,                                         assertTrue(msg, !shouldBeEqual);,                                     },                                 },                                 assertTrue(msg, shouldBeEqual);,                             } else {,                                 assertTrue(msg, !shouldBeEqual);,                             },                         },                     },                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/AptTest.java,tearDown,40-40,[    }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Available.java,setClasspathRef,99-100,[        createClasspath().setRefid(r);,     }],,setClasspathref,146-150,[        if (isReference()) {,             throw tooManyAttributes();,         },         createClasspath().setRefid(r);,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Available.java,setIgnoresystemclasses,220-221,[        this.ignoreSystemclasses = ignore;,     }],,setIgnoreSystemClasses,101-102,[        this.ignoreSystemClasses = ignoreSystemClasses;,     }],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/tools/ant/taskdefs/Available.java,checkClass,443-443,[                loader.setParentFirst(false);],,checkClass,445-445,[                if (loader != null) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Available.java,checkFile,344-344,[                    && (filename.equals(paths[i])],,checkFile,364-364,[                    && filename.equals(parent.getAbsolutePath())) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Available.java,getValues,495-495,[            return VALUES;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/BUnzip2Test.java,tearDown,43-43,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/BZip2Test.java,tearDown,45-45,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/BZip2Test.java,testRealTest,73-73,[        originalIn = new CBZip2InputStream(originalIn);],,testRealTest,74-74,[        actualIn   = new CBZip2InputStream(actualIn);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/CVSPass.java,execute,102-102,[                reader = new BufferedReader(new FileReader(passFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/CVSPass.java,execute,118-118,[            writer = new BufferedWriter(new FileWriter(passFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/CVSPassTest.java,readFile,108-108,[            reader = new BufferedReader(new FileReader(f));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/CVSPassTest.java,tearDown,67-67,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/CallTargetTest.java,tearDown,71-71,[    }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Checksum.java,generateChecksums,544-544,[                                                }).getBytes());],,generateChecksums,545-545,[                        fos.write(StringUtils.LINE_SEP.getBytes());],,generateChecksums,579-579,[                    messageDigest.update(fileName.getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Checksum.java,readChecksum,644-644,[            diskChecksumReader = new BufferedReader(new FileReader(f));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Checksum.java,setForceOverwrite,243-244,[        this.forceOverwrite = forceOverwrite;,     }],,setForceoverwrite,89-90,[        forceOverwrite = force;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Checksum.java,setTodir,178-179,[        this.todir = todir;,     }],,setToDir,208-209,[        this.toDir = toDir;,     }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/Checksum.java,generateChecksums,490-490,[                DigestInputStream dis = new DigestInputStream(fis,],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Checksum.java,getChecksumFile,464-464,[            directory.mkdirs();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/ChecksumTest.java,tearDown,39-39,[    }],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/tools/ant/taskdefs/Classloader.java,execute,205-205,[                if (name == null) {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/CommandLauncherTask.java,setVmLauncher,36-37,[],,setVMLauncher,584-585,[        this.vmLauncher = vmLauncher;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Concat.java,setDestfile,541-542,[        setDest(new FileResource(destinationFile));,     }],,setDestFile,155-156,[        this.tarFile = destFile;,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Concat.java,getReader,493-493,[            return new BufferedReader(encoding == null],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Concat.java,,499-501,[    private ReaderFactory identityReaderFactory = new ReaderFactory() {,         public Reader getReader(Object o) {,             return (Reader) o;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/tools/ant/types/Resource.java,equals,291-294,[        if (isReference()) {,             return getCheckedRef().equals(other);,         },         return other.getClass().equals(getClass()) && compareTo(other) == 0;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Concat.java,setFile,139-139,[                    reader = new BufferedReader(new FileReader(file));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/ConcatTest.java,getFileString,253-253,[            r = new FileReader(getProject().resolveFile(filename));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/ConcatTest.java,tearDown,71-71,[    }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/ConcatTest.java,test3,94-94,[            file.delete();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/ConditionTest.java,tearDown,50-50,[    }],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/Copy.java,<clinit>,73-73,[    static final File NULL_FILE_PLACEHOLDER = new File("/NULL_FILE");],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/Copy.java,,81-81,[    protected Vector filesets = rcs;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/Copy.java,doResourceOperations,941-941,[                String[] toFiles = (String[]) map.get(fromResource);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/CopyPath.java,setDestDir,75-76,[        this.destDir = destDir;,     }],,setDestdir,135-136,[        this.destDir = destDir;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/CopyPath.java,setPathRef,107-108,[        createPath().setRefid(r);,     }],,setPathref,149-152,[            Path p = new Path(getProject());,             p.setRefid(value);,             parts = new String[] {p.toString()};,         }],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/CopyPath.java,,66-66,[    private long granularity = FILE_UTILS.getFileTimestampGranularity();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/CopyPath.java,execute,184-184,[            String[] toFiles = (String[]) mapper.mapFileName(sourceFileName);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/CopyPath.java,execute,174-174,[        String[] sourceFiles = path.list();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/CopyTest.java,testFileResourceWithFilter,184-184,[            String file1Content = FileUtils.readFully(new FileReader(file1));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/CopyTest.java,tearDown,54-54,[    }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/CopyTest.java,testDirset,212-213,[        executeTarget("testDirset");,     }],,testDirSet,541-550,[        Path p = new Path(project);,         DirSet d = new DirSet();,         d.setProject(project);,         d.setDir(project.resolveFile("."));,         d.setIncludes("build");,         p.addDirset(d);,         String[] l = p.list();,         assertEquals(1, l.length);,         assertEquals(project.resolveFile("build").getAbsolutePath(), l[0]);,     }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/CopydirTest.java,tearDown,37-37,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/CopyfileTest.java,tearDown,41-41,[    }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/CopyfileTest.java,test5,63-63,[            f.delete();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/DefaultExcludesTest.java,tearDown,38-38,[    }],,
PERFORMANCE,DMI_COLLECTION_OF_URLS,org/apache/tools/ant/taskdefs/Definer.java,execute,282-282,[                    if (resourceStack.getStack().get(url) != null) {],,execute,287-287,[                            + resourceStack.getStack().get(url),],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Definer.java,fileToURL,337-337,[        if (!(file.exists())) {],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Delete.java,execute,679-679,[                    if (!(f.isDirectory()) || f.list().length == 0) {],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/DeleteTest.java,tearDown,37-37,[    }],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Deltree.java,removeDir,93-93,[        for (int i = 0; i < list.length; i++) {],,removeDir,92-92,[        String[] list = dir.list();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/EchoTest.java,<init>,63-63,[            this.setOutputPrintStream(new PrintStream(new ByteArrayOutputStream(256)));],,<init>,64-64,[            this.setErrorPrintStream(new PrintStream(new ByteArrayOutputStream(256)));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/EchoTest.java,,60-72,[        public EchoTestLogger() {,             super();,             this.setMessageOutputLevel(Project.MSG_DEBUG);,             this.setOutputPrintStream(new PrintStream(new ByteArrayOutputStream(256)));,             this.setErrorPrintStream(new PrintStream(new ByteArrayOutputStream(256)));,         }, ,         /**,          * {@inheritDoc},          */,         protected void log(String message) {,             this.lastLoggedMessage = message;,         }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/EchoXMLTest.java,tearDown,35-35,[    }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Exec.java,run,135-135,[                fos = new PrintWriter(new FileWriter(out));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Exec.java,<init>,249-249,[            this.din = new BufferedReader(new InputStreamReader(is));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ExecTask.java,setOutputproperty,247-249,[        redirector.setOutputProperty(outputProp);,         incompatibleWithSpawn = true;,     }],,setOutputProperty,412-419,[        if (outputProperty == null,                 || !(outputProperty.equals(this.outputProperty))) {,             synchronized (outMutex) {,                 this.outputProperty = outputProperty;,                 baos = null;,             },         },     }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/ExecTaskTest.java,tearDown,60-60,[    }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ExecTaskTest.java,testspawn,63-105,[        project.executeTarget("init");,         if (project.getProperty("test.can.run") == null) {,             return;,         },         myBuild = new MonitoredBuild(new File(System.getProperty("root"), BUILD_FILE), "spawn");,         logFile = FILE_UTILS.createTempFile("spawn", "log", project.getBaseDir(), false, false);,         // this is guaranteed by FileUtils#createTempFile,         assertTrue("log file not existing", !logFile.exists());,         // make the spawned process run 4 seconds,         myBuild.setTimeToWait(TIME_TO_WAIT);,         myBuild.setLogFile(logFile.getAbsolutePath());,         myBuild.addBuildListener(new MonitoredBuildListener());,         myBuild.start();,         GregorianCalendar startwait = new GregorianCalendar();,         // this loop runs parallel to the build,         while (!buildFinished) {,             try {,                 Thread.sleep(10);,             } catch (InterruptedException e) {,                 System.out.println("my sleep was interrupted");,             },             GregorianCalendar now = new GregorianCalendar();,             // security,             if (now.getTime().getTime() - startwait.getTime().getTime() > MAX_BUILD_TIME) {,                 System.out.println("aborting wait, too long ",                         + (now.getTime().getTime() - startwait.getTime().getTime()),                         + "milliseconds");,                 break;,             },         },         // now wait until the spawned process is finished,         try {,             Thread.sleep((TIME_TO_WAIT) * 1000 + SECURITY_MARGIN);,         } catch (InterruptedException e) {,             System.out.println("my sleep was interrupted");,         },         // time of the build in milli seconds,         long elapsed = myBuild.getTimeElapsed();,         assertTrue("we waited more than the process lasted",,                 TIME_TO_WAIT * 1000 + SECURITY_MARGIN > elapsed);,         logFile = new File(logFile.getAbsolutePath());,         assertTrue("log file found after spawn", logFile.exists());,     }],,testSpawn,181-198,[        File logFile = FILE_UTILS.createTempFile("spawn","log", project.getBaseDir(), false, false);,         // this is guaranteed by FileUtils#createTempFile,         assertTrue("log file not existing", !logFile.exists());,         project.setProperty("logFile", logFile.getAbsolutePath());,         project.setProperty("timeToWait", Long.toString(TIME_TO_WAIT));,         project.executeTarget("testSpawn");,         try {,             Thread.sleep(TIME_TO_WAIT * 1000 + SECURITY_MARGIN);,         } catch (Exception ex) {,             System.out.println("my sleep was interrupted");,         },         // let's be nice with the next generation of developers,         if (!logFile.exists()) {,             System.out.println("suggestion: increase the constant",             + " SECURITY_MARGIN to give more time for java to start.");,         },         assertTrue("log file exists", logFile.exists());,     }],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/ExecTaskTest.java,,118-118,[            this.logFile = logFile;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/ExecTaskTest.java,,123-123,[            this.timeToWait = timeToWait;],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/Execute.java,getProcEnvCommand,266-266,[            if (new File("/bin/env").canRead()) {],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/Execute.java,getProcEnvCommand,268-268,[            } else if (new File("/usr/bin/env").canRead()) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/Execute.java,patchEnvironment,678-678,[                    if (osEnvItem.toLowerCase().equals(key.toLowerCase())) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Execute.java,toString,312-312,[        return bos.toString();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Execute.java,getCommandline,367-367,[        return cmdl;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/Execute.java,setCommandline,376-376,[        cmdl = commandline;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/Execute.java,setEnvironment,405-405,[        this.env = env;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/taskdefs/Execute.java,getProcEnvCommand,283-283,[            return null;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/Execute.java,getEnvironmentVariables,169-169,[            } catch (Exception x) {],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/Execute.java,getEnvironmentVariables,201-201,[                        var += lineSep + line;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/Execute.java,getVMSLogicals,759-759,[                    logValue += "," + line.substring(4, line.length() - 1);],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/tools/ant/taskdefs/Execute.java,getEnvironmentVariables,182-182,[            if (retval != 0) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Execute.java,,563-566,[        OutputStream dummyOut = new OutputStream() {,             public void write(int b) throws IOException {,                 // Method intended to swallow whatever comes at it,             }],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/Execute.java,exec,931-931,[                    return exec(project, cmd, env);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/Execute.java,exec,1121-1121,[                    return exec(project, cmd, env);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/Execute.java,exec,1062-1062,[                    return exec(project, cmd, env);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Execute.java,createCommandFile,1217-1217,[                out = new BufferedWriter(new FileWriter(script));],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/Execute.java,exec,982-982,[                    return exec(project, cmd, env);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/ExecuteJava.java,,154-154,[                thread = new Thread(this, "ExecuteJava");],,,158-158,[                project.registerThreadTask(thread, currentThreadTask);],,,163-163,[                thread.setDaemon(true);],,,167-167,[                    thread.start();],,,178-178,[                        thread = null;],,,241-241,[        if (thread != null) {],,,243-243,[            thread.interrupt();],,
MT_CORRECTNESS,NN_NAKED_NOTIFY,org/apache/tools/ant/taskdefs/ExecuteJava.java,run,230-230,[                notifyAll();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/ExecuteJava.java,execute,143-143,[            if (main == null) {],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/tools/ant/taskdefs/ExecuteJava.java,execute,170-170,[                        wait();],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/tools/ant/taskdefs/ExecuteJava.java,execute,170-170,[                        wait();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/ExecuteJavaTest.java,setUp,50-50,[        ej.setTimeout(new Long(TIME_OUT));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ExecuteJavaTest.java,testNoTimeOut,66-70,[        Commandline cmd = getCommandline(TIME_OUT/2);,         ej.setJavaCommand(cmd);,         ej.execute(project);,         assertTrue("process should not have been killed", !ej.killedProcess());,     }],,testNoTimeout,65-66,[       expectPropertyUnset("notimeout", "timeout");,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ExecuteJavaTest.java,testTimeOut,74-87,[        Commandline cmd = getCommandline(TIME_OUT*2);,         ej.setJavaCommand(cmd);,         long now = System.currentTimeMillis();,         ej.execute(project);,         long elapsed = System.currentTimeMillis() - now;,         assertTrue("process should have been killed", ej.killedProcess());, ,         assertTrue("elapse time of "+elapsed,                    +" ms is less than timeout value of "+TIME_OUT_TEST+" ms",,                    elapsed >= TIME_OUT_TEST);,         assertTrue("elapse time of "+elapsed,                    +" ms is greater than run value of "+(TIME_OUT*2)+" ms",,                    elapsed < TIME_OUT*2);,     }],,testTimeout,61-62,[       expectPropertySet("timeout", "timeout");,     }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/ExecuteWatchdogTest.java,testTimeOut,106-106,[        int retCode = process.waitFor();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/ExecuteWatchdogTest.java,getErrorOutput,72-72,[        BufferedReader err = new BufferedReader( new InputStreamReader(p.getErrorStream()) );],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/ExecuteWatchdogTest.java,getErrorOutput,72-72,[        BufferedReader err = new BufferedReader( new InputStreamReader(p.getErrorStream()) );],,
CORRECTNESS,IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD,org/apache/tools/ant/taskdefs/ExecuteWatchdogTest.java,run,134-134,[                        fail("process interrupted in thread");],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/ExecuteWatchdogTest.java,,128-136,[        Thread thread = new Thread(){,                 public void run(){,                     try {,                         process.waitFor();,                     } catch(InterruptedException e){,                         // not very nice but will do the job,                         fail("process interrupted in thread");,                     },                 }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Exit.java,setStatus,119-119,[        status = new Integer(i);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Exit.java,testNestedCondition,224-224,[        return result && nestedCondition.eval();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Expand.java,extractFile,330-330,[                dirF.mkdirs();],,extractFile,334-334,[                f.mkdirs();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/FilterTest.java,getFilteredFile,100-100,[                in = new BufferedReader(new FileReader(f));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/FilterTest.java,tearDown,42-42,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/FilterTest.java,getFilteredFile,100-100,[                in = new BufferedReader(new FileReader(f));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/FilterTest.java,getFilteredFile,111-111,[        f.delete();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/FixCRLF.java,setSrcdir,126-127,[        this.srcDir = srcDir;,     }],,setSrcDir,97-98,[        this.srcDir = srcDir;,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/FixCRLF.java,<init>,421-421,[                    ((encoding == null) ? new FileReader(srcFile)],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/FixCrLfTest.java,tearDown,45-45,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/FixCrLfTest.java,assertEqualContent,200-200,[            inExpect = new BufferedInputStream(new FileInputStream(expect));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/GUnzipTest.java,tearDown,40-40,[    }],,
STYLE,RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE,org/apache/tools/ant/taskdefs/GenerateKey.java,execute,364-364,[        if (null != storepass) {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Get.java,setUsername,357-358,[        this.uname = u;,     }],,setUserName,159-160,[        this.userName = userName;,     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Get.java,checkAttributes,280-280,[            destination.mkdirs();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Get.java,execute,93-93,[            if (destination.isDirectory()) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Get.java,openConnection,647-647,[                encoding = encoder.encode(up.getBytes());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Get.java,closeStreams,803-803,[                dest.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Get.java,downloadFile,758-758,[                    dest.delete();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/GetTest.java,tearDown,37-37,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/GzipTest.java,tearDown,74-74,[    }],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/ImportTest.java,testSymlinkedImports,135-135,[        if (!new File(ln).exists()) {],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/ImportTest.java,tearDown,41-41,[    }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/ImportTest.java,testSymlinkedImports,159-159,[            symlinkFile.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/InitializeClassTest.java,testAll,52-52,[        PrintStream newps = new PrintStream(new FileOutputStream(f2));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/InitializeClassTest.java,tearDown,63-63,[    }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/InitializeClassTest.java,tearDown,61-61,[        f1.delete();],,tearDown,62-62,[        f2.delete();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Input.java,getRefid,67-67,[            return refid;],,getRefId,78-78,[        return refid;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Input.java,setRefid,60-61,[            this.refid = refid;,         }],,setRefId,70-71,[        refid = id;,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Input.java,,48-113,[    public class Handler extends DefBase {, ,         private String refid = null;,         private HandlerType type = null;,         private String classname = null;, ,         /**,          * Specify that the handler is a reference on the project;,          * this allows the use of a custom inputhandler.,          * @param refid the String refid.,          */,         public void setRefid(String refid) {,             this.refid = refid;,         },         /**,          * Get the refid of this Handler.,          * @return String refid.,          */,         public String getRefid() {,             return refid;,         },         /**,          * Set the InputHandler classname.,          * @param classname the String classname.,          */,         public void setClassname(String classname) {,             this.classname = classname;,         },         /**,          * Get the classname of the InputHandler.,          * @return String classname.,          */,         public String getClassname() {,             return classname;,         },         /**,          * Set the handler type.,          * @param type a HandlerType.,          */,         public void setType(HandlerType type) {,             this.type = type;,         },         /**,          * Get the handler type.,          * @return a HandlerType object.,          */,         public HandlerType getType() {,             return type;,         },         private InputHandler getInputHandler() {,             if (type != null) {,                return type.getInputHandler();,             },             if (refid != null) {,                try {,                    return (InputHandler) (getProject().getReference(refid));,                } catch (ClassCastException e) {,                    throw new BuildException(,                        refid + " does not denote an InputHandler", e);,                },             },             if (classname != null) {,                return (InputHandler) (ClasspathUtils.newInstance(classname,,                    createLoader(), InputHandler.class));,             },             throw new BuildException(],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Input.java,getValues,133-133,[            return VALUES;],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/JDBCTask.java,isValidRdbms,273-273,[                String theVendor = dmd.getDatabaseProductName().toLowerCase();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/JDBCTask.java,getUserId,494-494,[        return userId;],,getUserID,59-59,[        return userID;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/JDBCTask.java,setUserid,502-503,[        this.userId = userId;,     }],,setUserId,652-653,[        userId = u;,     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/JDBCTask.java,isValidRdbms,276-276,[                if (theVendor == null || theVendor.indexOf(rdbms) < 0) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/JDBCTask.java,isValidRdbms,286-286,[                if (theVersion == null],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/Jar.java,grabManifests,1170-1170,[            Resource[][] resources = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Jar.java,filesetManifest,722-722,[                        isr = new InputStreamReader(is);],,filesetManifest,745-745,[                        isr = new InputStreamReader(is);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Jar.java,getManifest,312-312,[                isr = new InputStreamReader(fis);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Jar.java,setJarfile,230-231,[        setDestFile(jarFile);,     }],,setJarFile,147-152,[        File parent = jarfile.getParentFile();,         if (!parent.isDirectory()) {,             throw new BuildException("Jar's directory not found: " + parent);,         },         this.dir = parent;,     }],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/tools/ant/taskdefs/Jar.java,setFilesetmanifest,417-417,[        mergeManifestsMain = "merge".equals(config.getValue());],,setFilesetmanifest,419-419,[        if (filesetManifestConfig != null],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JarTest.java,testManifestStaysIntact,148-148,[                            .resolveFile(tempDir + "manifest"));],,testManifestStaysIntact,150-150,[                            .resolveFile(tempDir + "META-INF/MANIFEST.MF"));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/JarTest.java,tearDown,68-68,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/JarTest.java,testRootFilesInIndex,234-234,[            BufferedReader r = new BufferedReader(new InputStreamReader(is,],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Java.java,getCommandLine,951-951,[        return cmdl;],,getCommandline,1757-1761,[        if (commandline == null) {,             commandline = new CommandlineJava();,             commandline.setClassname("org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner");,         },         return commandline;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JavaTest.java,testReleasedInput,253-253,[        out.write("foo\n".getBytes());],,testReleasedInput,255-255,[        out.write("bar\n".getBytes());],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/JavaTest.java,tearDown,73-73,[    }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/JavaTest.java,,272-274,[     * argv[0] = exit code (optional),      * argv[1] = string to print to System.out (optional),      * argv[1] = string to print to System.err (optional)],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JavaTest.java,run,291-291,[            if(exitCode!=0) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/JavaTest.java,,282-295,[                    exitCode=-1;,                 },             },             if(argv.length>1) {,                 System.out.println(argv[1]);,             },             if(argv.length>2) {,                 System.err.println(argv[2]);,             },             if(exitCode!=0) {,                 System.exit(exitCode);,             },         },     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JavaTest.java,main,335-335,[                out = new OutputStreamWriter(fos);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/tools/ant/taskdefs/JavaTest.java,main,327-327,[                Thread.sleep(sleepTime * 1000);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/JavaTest.java,main,337-337,[            } catch (Exception ex) {}],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Javac.java,getFileList,990-990,[        return compileList;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,createCompilerClasspath,872-872,[        return facade.getImplementationClasspath(getProject());],,createCompilerclasspath,339-342,[        if (compilerClasspath == null) {,             compilerClasspath = new Path(getProject());,         },         return compilerClasspath.createPath();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,getBootclasspath,365-365,[        return bootclasspath;],,getBootClassPath,648-652,[        Path bp = new Path(project);,         if (bootclasspath != null) {,             bp.append(bootclasspath);,         },         return bp.concatSystemBootClasspath("ignore");],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,getDestdir,263-263,[        return destDir;],,getDestDir,152-152,[        return destDir;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,getNowarn,723-723,[        return nowarn;],,getNoWarn,217-217,[        return mNwarn;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,getSrcdir,245-245,[        return src;],,getSrcDir,136-136,[        return src;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,setNowarn,715-716,[        this.nowarn = flag;,     }],,setNoWarn,208-209,[        mNwarn = nwarn;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Javac.java,setSrcdir,233-238,[        if (src == null) {,             src = srcDir;,         } else {,             src.append(srcDir);,         },     }],,setSrcDir,124-129,[        if (src == null) {,             src = srcDir;,         } else {,             src.append(srcDir);,         },     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Javac.java,generateMissingPackageInfoClasses,1203-1203,[            pkgBinDir.mkdirs();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javac.java,,1163-1171,[    public class ImplementationSpecificArgument extends,         org.apache.tools.ant.util.facade.ImplementationSpecificArgument {, ,         /**,          * @param impl the name of the compiler,          */,         public void setCompiler(String impl) {,             super.setImplementation(impl);,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Javadoc.java,doJava14,2103-2103,[                            BufferedReader in],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Javadoc.java,execute,1722-1722,[                    new FileWriter(tmpList.getAbsolutePath(),],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Javadoc.java,writeExternalArgs,1909-1909,[                new FileWriter(optionsTmpFile.getAbsolutePath(), true));],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Javadoc.java,parsePackages,2395-2395,[                if (files.length > 0) {],,parsePackages,2387-2387,[                String[] files = pd.list(new FilenameFilter () {],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/Javadoc.java,doJava14,2103-2103,[                            BufferedReader in],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/Javadoc.java,getPackages,2068-2068,[                if (title == null || packages == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/Javadoc.java,writeExternalArgs,1926-1926,[            if (optionsTmpFile != null) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Javadoc.java,execute,1730-1730,[            tmpList.delete();],,execute,1767-1767,[                tmpList.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Javadoc.java,writeExternalArgs,1927-1927,[                optionsTmpFile.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,87-130,[    public class DocletParam {,         /** The parameter name */,         private String name;, ,         /** The parameter value */,         private String value;, ,         /**,          * Set the name of the parameter.,          *,          * @param name the name of the doclet parameter,          */,         public void setName(String name) {,             this.name = name;,         }, ,         /**,          * Get the parameter name.,          *,          * @return the parameter's name.,          */,         public String getName() {,             return name;,         }, ,         /**,          * Set the parameter value.,          *,          * Note that only string values are supported. No resolution of file,          * paths is performed.,          *,          * @param value the parameter value.,          */,         public void setValue(String value) {,             this.value = value;,         }, ,         /**,          * Get the parameter value.,          *,          * @return the parameter value.,          */,         public String getValue() {,             return value;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,1453-1518,[        private Vector packages = new Vector();, ,         /** Constructor for GroupArgument */,         public GroupArgument() {,             //empty,         }, ,         /**,          * Set the title attribute using a string.,          * @param src a <code>String</code> value,          */,         public void setTitle(String src) {,             Html h = new Html();,             h.addText(src);,             addTitle(h);,         },         /**,          * Set the title attribute using a nested Html value.,          * @param text a <code>Html</code> value,          */,         public void addTitle(Html text) {,             title = text;,         }, ,         /**,          * Get the title.,          * @return the title,          */,         public String getTitle() {,             return title != null ? title.getText() : null;,         }, ,         /**,          * Set the packages to Javadoc on.,          * @param src a comma separated list of packages,          */,         public void setPackages(String src) {,             StringTokenizer tok = new StringTokenizer(src, ",");,             while (tok.hasMoreTokens()) {,                 String p = tok.nextToken();,                 PackageName pn = new PackageName();,                 pn.setName(p);,                 addPackage(pn);,             },         },         /**,          * Add a package nested element.,          * @param pn a nested element specifing the package.,          */,         public void addPackage(PackageName pn) {,             packages.addElement(pn);,         }, ,         /**,          * Get the packages as a collon separated list.,          * @return the packages as a string,          */,         public String getPackages() {,             StringBuffer p = new StringBuffer();,             for (int i = 0; i < packages.size(); i++) {,                 if (i > 0) {,                     p.append(":");,                 },                 p.append(packages.elementAt(i).toString());,             },             return p.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/tools/ant/taskdefs/Javadoc.java,,2425-2461,[        JavadocOutputStream(int level) {,             super(Javadoc.this, level);,         }, ,         //,         // Override the logging of output in order to filter out Generating,         // messages.  Generating messages are set to a priority of VERBOSE,         // unless they appear after what could be an informational message.,         //,         private String queuedLine = null;,         protected void processLine(String line, int messageLevel) {,             if (messageLevel == Project.MSG_INFO,                 && line.startsWith("Generating ")) {,                 if (queuedLine != null) {,                     super.processLine(queuedLine, Project.MSG_VERBOSE);,                 },                 queuedLine = line;,             } else {,                 if (queuedLine != null) {,                     if (line.startsWith("Building ")) {,                         super.processLine(queuedLine, Project.MSG_VERBOSE);,                     } else {,                         super.processLine(queuedLine, Project.MSG_INFO);,                     },                     queuedLine = null;,                 },                 super.processLine(line, messageLevel);,             },         }, , ,         protected void logFlush() {,             if (queuedLine != null) {,                 super.processLine(queuedLine, Project.MSG_VERBOSE);,                 queuedLine = null;,             },         }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,1182-1271,[        private boolean offline = false;,         private File packagelistLoc;,         private URL packagelistURL;,         private boolean resolveLink = false;, ,         /** Constructor for LinkArguement */,         public LinkArgument() {,             //empty,         }, ,         /**,          * Set the href attribute.,          * @param hr a <code>String</code> value,          */,         public void setHref(String hr) {,             href = hr;,         }, ,         /**,          * Get the href attribute.,          * @return the href attribute.,          */,         public String getHref() {,             return href;,         }, ,         /**,          * Set the packetlist location attribute.,          * @param src a <code>File</code> value,          */,         public void setPackagelistLoc(File src) {,             packagelistLoc = src;,         }, ,         /**,          * Get the packetList location attribute.,          * @return the packetList location attribute.,          */,         public File getPackagelistLoc() {,             return packagelistLoc;,         }, ,         /**,          * Set the packetlist location attribute.,          * @param src an <code>URL</code> value,          */,         public void setPackagelistURL(URL src) {,             packagelistURL = src;,         }, ,         /**,          * Get the packetList location attribute.,          * @return the packetList location attribute.,          */,         public URL getPackagelistURL() {,             return packagelistURL;,         }, ,         /**,          * Set the offline attribute.,          * @param offline a <code>boolean</code> value,          */,         public void setOffline(boolean offline) {,             this.offline = offline;,         }, ,         /**,          * Get the linkOffline attribute.,          * @return the linkOffline attribute.,          */,         public boolean isLinkOffline() {,             return offline;,         }, ,         /**,          * Sets whether Ant should resolve the link attribute relative,          * to the current basedir.,          * @param resolve a <code>boolean</code> value,          */,         public void setResolveLink(boolean resolve) {,             this.resolveLink = resolve;,         }, ,         /**,          * should Ant resolve the link attribute relative to the,          * current basedir?,          * @return the resolveLink attribute.,          */,         public boolean shouldResolveLink() {,             return resolveLink;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,368-383,[    public class ResourceCollectionContainer {,         private ArrayList rcs = new ArrayList();,         /**,          * Add a resource collection to the container.,          * @param rc the collection to add.,          */,         public void add(ResourceCollection rc) {,             rcs.add(rc);,         }, ,         /**,          * Get an iterator on the collection.,          * @return an iterator.,          */,         private Iterator iterator() {,             return rcs.iterator();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Javadoc.java,,1304-1431,[        private String name = null;,         /** Whether or not the tag is enabled. */,         private boolean enabled = true;,         /**,          * Scope string of the tag. This will form the middle,          * argument of the -tag parameter when the tag is enabled,          * (with an X prepended for and is parsed from human-readable form.,          */,         private String scope = "a";, ,         /** Sole constructor. */,         public TagArgument () {,             //empty,         }, ,         /**,          * Sets the name of the tag.,          *,          * @param name The name of the tag.,          *             Must not be <code>null</code> or empty.,          */,         public void setName (String name) {,             this.name = name;,         }, ,         /**,          * Sets the scope of the tag. This is in comma-separated,          * form, with each element being one of "all" (the default),,          * "overview", "packages", "types", "constructors", "methods",,          * "fields". The elements are treated in a case-insensitive,          * manner.,          *,          * @param verboseScope The scope of the tag.,          *                     Must not be <code>null</code>,,          *                     should not be empty.,          *,          * @exception BuildException if all is specified along with,          * other elements, if any elements are repeated, if no,          * elements are specified, or if any unrecognised elements are,          * specified.,          */,         public void setScope (String verboseScope) throws BuildException {,             verboseScope = verboseScope.toLowerCase(Locale.ENGLISH);, ,             boolean[] elements = new boolean[SCOPE_ELEMENTS.length];, ,             boolean gotAll = false;,             boolean gotNotAll = false;, ,             // Go through the tokens one at a time, updating the,             // elements array and issuing warnings where appropriate.,             StringTokenizer tok = new StringTokenizer (verboseScope, ",");,             while (tok.hasMoreTokens()) {,                 String next = tok.nextToken().trim();,                 if (next.equals("all")) {,                     if (gotAll) {,                         getProject().log ("Repeated tag scope element: all",,                                           Project.MSG_VERBOSE);,                     },                     gotAll = true;,                 } else {,                     int i;,                     for (i = 0; i < SCOPE_ELEMENTS.length; i++) {,                         if (next.equals (SCOPE_ELEMENTS[i])) {,                             break;,                         },                     },                     if (i == SCOPE_ELEMENTS.length) {,                         throw new BuildException ("Unrecognised scope element: ",                                                   + next);,                     } else {,                         if (elements[i]) {,                             getProject().log ("Repeated tag scope element: ",                                               + next, Project.MSG_VERBOSE);,                         },                         elements[i] = true;,                         gotNotAll = true;,                     },                 },             }, ,             if (gotNotAll && gotAll) {,                 throw new BuildException ("Mixture of \"all\" and other scope ",                                           + "elements in tag parameter.");,             },             if (!gotNotAll && !gotAll) {,                 throw new BuildException ("No scope elements specified in tag ",                                           + "parameter.");,             },             if (gotAll) {,                 this.scope = "a";,             } else {,                 StringBuffer buff = new StringBuffer (elements.length);,                 for (int i = 0; i < elements.length; i++) {,                     if (elements[i]) {,                         buff.append (SCOPE_ELEMENTS[i].charAt(0));,                     },                 },                 this.scope = buff.toString();,             },         }, ,         /**,          * Sets whether or not the tag is enabled.,          *,          * @param enabled Whether or not this tag is enabled.,          */,         public void setEnabled (boolean enabled) {,             this.enabled = enabled;,         }, ,         /**,          * Returns the -tag parameter this argument represented.,          * @return the -tag parameter as a string,          * @exception BuildException if either the name or description,          *                           is <code>null</code> or empty.,          */,         public String getParameter() throws BuildException {,             if (name == null || name.equals("")) {,                 throw new BuildException ("No name specified for custom tag.");,             },             if (getDescription() != null) {,                 return name + ":" + (enabled ? "" : "X"),                     + scope + ":" + getDescription();,             } else if (!enabled || !"a".equals(scope)) {,                 return name + ":" + (enabled ? "" : "X") + scope;,             } else {,                 return name;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Jikes.java,compile,91-91,[                    out = new BufferedWriter(new FileWriter(tmpFile));],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/JikesOutputParser.java,parseStandardOutput,133-133,[            lower = line.toLowerCase();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/JikesOutputParser.java,setProcessOutputStream,72-72,[        br = new BufferedReader(new InputStreamReader(is));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/KeySubst.java,execute,63-63,[            br = new BufferedReader(new FileReader(source));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/KeySubst.java,execute,65-65,[            bw = new BufferedWriter(new FileWriter(dest));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/KeySubst.java,execute,64-64,[            dest.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Length.java,execute,173-173,[            ? (OutputStream) new PropertyOutputStream(getProject(), property)],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Length.java,,233-233,[        for (Iterator i = resources.iterator(); i.hasNext();) {],,,217-217,[        } else if (resources != null) {],,,209-209,[            if (resources != null) {],,,103-103,[        resources = (resources == null) ? new Resources() : resources;],,,104-104,[        resources.add(c);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Length.java,,204-204,[        return when.evaluate(ell.compareTo(length));],,,131-131,[        when = c;],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/tools/ant/taskdefs/Length.java,getTrim,164-164,[        return trim != null && trim.booleanValue();],,setTrim,156-157,[        this.trim = trim ? Boolean.TRUE : Boolean.FALSE;,     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Length.java,handleResources,233-233,[        for (Iterator i = resources.iterator(); i.hasNext();) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Length.java,,315-315,[            return accum;],,,322-322,[                accum += size;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Length.java,getValues,259-259,[            return MODES;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/LoadFile.java,setSrcFile,38-39,[        addConfigured(new FileResource(srcFile));,     }],,setSrcfile,104-105,[        this.sourceFile = file;,     }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/LoadFileTest.java,tearDown,53-53,[    }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/LoadProperties.java,execute,180-180,[                instream = new InputStreamReader(bis);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/LoadProperties.java,,162-162,[        if (src == null) {],,,165-165,[        if (!src.isExists()) {],,,178-178,[            bis = new BufferedInputStream(src.getInputStream());],,,166-166,[            if (src instanceof JavaResource) {],,,171-171,[            throw new BuildException("Source resource does not exist: " + src);],,,168-168,[                log("Unable to find resource " + src, Project.MSG_WARN);],,,239-239,[        if (src == null) {],,,242-242,[        } else if (!(src instanceof JavaResource)) {],,,245-245,[        return (JavaResource) src;],,,240-240,[            src = new JavaResource();],,,241-241,[            src.setProject(getProject());],,,228-228,[        if (src != null) {],,,235-235,[        src = (Resource) a.iterator().next();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/LoadResource.java,execute,164-164,[                instream = new InputStreamReader(bis);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/MacroDef.java,getNestedTask,188-188,[        for (int i = 0; i < nestedSequential.getNested().size(); ++i) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/MacroDef.java,sameOrSimilar,726-726,[        if (!nestedSequential.similar(other.nestedSequential)) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/MacroDef.java,sameDefinition,801-801,[            MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/MacroDef.java,similarDefinition,817-817,[            MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/MacroInstance.java,copy,304-304,[                    (UnknownElement) presentElements.get(tag);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/MacroInstance.java,processTasks,134-134,[            if (presentElements.get(name) != null) {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/MakeUrlTest.java,testFileset,86-89,[        executeTarget("testFileset");,         assertPropertyContains("testFileset", ".xml ");,         assertPropertyEndsWith("testFileset", ".xml");,     }],,testFileSet,529-538,[        Path p = new Path(project);,         FileSet f = new FileSet();,         f.setProject(project);,         f.setDir(project.resolveFile("."));,         f.setIncludes("build.xml");,         p.addFileset(f);,         String[] l = p.list();,         assertEquals(1, l.length);,         assertEquals(project.resolveFile("build.xml").getAbsolutePath(), l[0]);,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Manifest.java,getDefaultManifest,824-824,[                insr = new InputStreamReader(in);],,
BAD_PRACTICE,NP_TOSTRING_COULD_RETURN_NULL,org/apache/tools/ant/taskdefs/Manifest.java,toString,1065-1065,[            return null;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/Manifest.java,getValue,281-281,[                fullValue += value + " ";],,
BAD_PRACTICE,CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE,org/apache/tools/ant/taskdefs/Manifest.java,clone,722-731,[            Section cloned = new Section();,             cloned.setName(name);,             Enumeration e = getAttributeKeys();,             while (e.hasMoreElements()) {,                 String key = (String) e.nextElement();,                 Attribute attribute = getAttribute(key);,                 cloned.storeAttribute(new Attribute(attribute.getName(),,                                                     attribute.getValue()));,             },             return cloned;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/ManifestClassPath.java,addClassPath,174-175,[        this.path = path;,     }],,addClasspath,632-636,[        if (classpath != null) {,             throw new BuildException("<classpath> can be set only once.");,         },         classpath = path;,     }],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/ManifestClassPathTest.java,testDifferentWindowsDrive,171-171,[                new java.io.File("D:/foo.txt").getCanonicalPath();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/ManifestTest.java,getManifest,359-359,[        FileReader r = new FileReader(new File(System.getProperty("root"), filename));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/ManifestTest.java,testLongLine,227-227,[        BufferedReader in = new BufferedReader(new FileReader(EXPANDED_MANIFEST));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/ManifestTest.java,tearDown,66-66,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/ManifestTest.java,testLongLine,227-227,[        BufferedReader in = new BufferedReader(new FileReader(EXPANDED_MANIFEST));],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/MatchingTask.java,XsetIgnore,161-170,[        log("The ignore attribute is deprecated.",             + "Please use the excludes attribute.", Project.MSG_WARN);,         if (ignoreString != null && ignoreString.length() > 0) {,             StringTokenizer tok = new StringTokenizer(ignoreString, ", ",,                                                       false);,             while (tok.hasMoreTokens()) {,                 createExclude().setName("**/" + tok.nextToken().trim() + "/**");,             },         },     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/MatchingTask.java,XsetItems,128-142,[        log("The items attribute is deprecated. ",             + "Please use the includes attribute.", Project.MSG_WARN);,         if (itemString == null || itemString.equals("*"),             || itemString.equals(".")) {,             createInclude().setName("**");,         } else {,             StringTokenizer tok = new StringTokenizer(itemString, ", ");,             while (tok.hasMoreTokens()) {,                 String pattern = tok.nextToken().trim();,                 if (pattern.length() > 0) {,                     createInclude().setName(pattern + "/**");,                 },             },         },     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/MkdirTest.java,test3,48-48,[            f.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Move.java,renameFile,348-348,[            parent.mkdirs();],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/Move.java,doFileOperations,94-94,[                File toDir = (File) completeDirMap.get(fromDir);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/Move.java,doFileOperations,155-155,[                String[] toDirNames = (String[]) dirCopyMap.get(fromDirName);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/Move.java,doFileOperations,126-126,[                    String[] toFiles = (String[]) fileCopyMap.get(fromFile);],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/MoveTest.java,tearDown,45-45,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/MultiMapTest.java,tearDown,39-39,[    }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Nice.java,setNewPriority,96-96,[        this.newPriority = new Integer(newPriority);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/Pack.java,,80-80,[            source = fp.getFile();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Pack.java,execute,135-135,[        } else if (zipFile.lastModified() < s.getLastModified()) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/Parallel.java,spinThreads,375-375,[                throw (BuildException) firstException;],,
MT_CORRECTNESS,ESync_EMPTY_SYNC,org/apache/tools/ant/taskdefs/Parallel.java,spinThreads,276-276,[        }],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/tools/ant/taskdefs/Parallel.java,run,302-302,[                            wait(timeout);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Parallel.java,interrupt,466-466,[            thread.interrupt();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/ParallelTest.java,testDemux,142-142,[        System.setOut(new PrintStream(new DemuxOutputStream(p, false)));],,testDemux,143-143,[        System.setErr(new PrintStream(new DemuxOutputStream(p, true)));],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/tools/ant/taskdefs/PathConvert.java,mapElement,431-431,[                if (newElem != elem) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/PathConvert.java,apply,149-149,[                onWindows ? elem.toLowerCase().replace('\\', '/') : elem;],,apply,151-151,[                onWindows ? from.toLowerCase().replace('\\', '/') : from;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/PathConvert.java,,110-157,[    public class MapEntry {, ,         // Members,         private String from = null;,         private String to = null;, ,         /**,          * Set the &quot;from&quot; attribute of the map entry.,          * @param from the prefix string to search for; required.,          * Note that this value is case-insensitive when the build is,          * running on a Windows platform and case-sensitive when running on,          * a Unix platform.,          */,         public void setFrom(String from) {,             this.from = from;,         }, ,         /**,          * Set the replacement text to use when from is matched; required.,          * @param to new prefix.,          */,         public void setTo(String to) {,             this.to = to;,         }, ,         /**,          * Apply this map entry to a given path element.,          *,          * @param elem Path element to process.,          * @return String Updated path element after mapping.,          */,         public String apply(String elem) {,             if (from == null || to == null) {,                 throw new BuildException("Both 'from' and 'to' must be set ",                      + "in a map entry");,             },             // If we're on windows, then do the comparison ignoring case,             // and treat the two directory characters the same,             String cmpElem =,                 onWindows ? elem.toLowerCase().replace('\\', '/') : elem;,             String cmpFrom =,                 onWindows ? from.toLowerCase().replace('\\', '/') : from;, ,             // If the element starts with the configured prefix, then,             // convert the prefix to the configured 'to' value., ,             return cmpElem.startsWith(cmpFrom),                 ? to + elem.substring(from.length()) : elem;],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/PreSetDef.java,sameDefinition,255-255,[            return (other != null && other.getClass() == getClass() && parent != null],,sameDefinition,256-256,[                && parent.sameDefinition(((PreSetDefinition) other).parent, project)],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/taskdefs/PreSetDef.java,similarDefinition,269-269,[            return (other != null && other.getClass().getName().equals(],,similarDefinition,271-271,[                && parent.similarDefinition(((PreSetDefinition) other).parent, project)],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Property.java,getUrl,271-271,[        return url;],,getURL,82-93,[        if (isReference()) {,             return ((JavaResource) getCheckedRef()).getURL();,         },         AbstractClasspathResource.ClassLoaderWithFlag classLoader =,             getClassLoader();,         if (classLoader.getLoader() == null) {,             return ClassLoader.getSystemResource(getName());,         } else {,             try {,                 return classLoader.getLoader().getResource(getName());,             } finally {,                 classLoader.cleanup();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Property.java,setUrl,263-264,[        this.url = url;,     }],,setURL,93-95,[        checkAttributesAllowed();,         url = u;,     }],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/Property.java,addProperties,690-690,[                addProperty(propertyName, m.get(k));],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/PropertyHelperTask.java,,111-111,[        if (propertyHelper == null && delegates == null) {],,,122-122,[            if (delegates != null) {],,,123-123,[                for (Iterator iter = delegates.iterator(); iter.hasNext();) {],,,140-140,[        if (delegates == null) {],,,143-143,[        return delegates;],,,141-141,[            delegates = new ArrayList();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/ProtectedJarMethodsTest.java,tearDown,42-42,[    }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Recorder.java,getValues,185-185,[            return VALUES;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/RecorderEntry.java,openFileImpl,358-358,[                out = new PrintStream(new FileOutputStream(filename, append));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/RecorderTest.java,tearDown,47-47,[    }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,createStreams,666-666,[                inputStream = new ByteArrayInputStream(inputString.getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,handleErrorFlush,843-843,[                errorPrintStream = new PrintStream(errorStream);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,handleErrorOutput,828-828,[                errorPrintStream = new PrintStream(errorStream);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,handleFlush,812-812,[                outPrintStream = new PrintStream(outputStream);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Redirector.java,handleOutput,770-770,[                outPrintStream = new PrintStream(outputStream);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Replace.java,<init>,369-369,[                reader = new BufferedReader(new FileReader(source));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/tools/ant/taskdefs/Replace.java,,365-413,[        FileInput(File source) throws IOException {,             outputBuffer = new StringBuffer();,             buffer = new char[BUFF_SIZE];,             if (encoding == null) {,                 reader = new BufferedReader(new FileReader(source));,             } else {,                 reader = new BufferedReader(new InputStreamReader(,                         new FileInputStream(source), encoding));,             },         }, ,         /**,          * Retrieves the output buffer of this filter. The component guarantees,          * that data is only appended to the end of this StringBuffer.,          * @return The StringBuffer containing the output of this filter.,          */,         StringBuffer getOutputBuffer() {,             return outputBuffer;,         }, ,         /**,          * Reads some data from the file.,          * @return true when the end of the file has not been reached.,          * @throws IOException When the file cannot be read from.,          */,         boolean readChunk() throws IOException {,             int bufferLength = 0;,             bufferLength = reader.read(buffer);,             if (bufferLength < 0) {,                 return false;,             },             outputBuffer.append(new String(buffer, 0, bufferLength));,             return true;,         }, ,         /**,          * Closes the file.,          * @throws IOException When the file cannot be closed.,          */,         void close() throws IOException {,             reader.close();,         }, ,         /**,          * Closes file but doesn't throw exception,          */,         void closeQuietly() {,             FileUtils.close(reader);,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/Replace.java,<init>,433-433,[                    writer = new BufferedWriter(new FileWriter(out));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/tools/ant/taskdefs/Replace.java,,431-487,[        FileOutput(File out) throws IOException {,                 if (encoding == null) {,                     writer = new BufferedWriter(new FileWriter(out));,                 } else {,                     writer = new BufferedWriter(new OutputStreamWriter,                             (new FileOutputStream(out), encoding));,                 },         }, ,         /**,          * Sets the input buffer for this component.,          * The filter expects from the component providing the input that data,          * is only added by that component to the end of this StringBuffer.,          * This StringBuffer will be modified by this filter, and expects that,          * another component will only append to this StringBuffer.,          * @param input The input for this filter.,          */,         void setInputBuffer(StringBuffer input) {,             inputBuffer = input;,         }, ,         /**,          * Writes the buffer as far as possible.,          * @return false to be inline with the Replacefilter.,          * (Yes defining an interface crossed my mind, but would publish the,          * internal behavior.),          * @throws IOException when the output cannot be written.,          */,         boolean process() throws IOException {,             writer.write(inputBuffer.toString());,             inputBuffer.delete(0, inputBuffer.length());,             return false;,         }, ,         /**,          * Processes the buffer to the end.,          * @throws IOException when the output cannot be flushed.,          */,         void flush() throws IOException {,             process();,             writer.flush();,         }, ,         /**,          * Closes the file.,          * @throws IOException When the file cannot be closed.,          */,         void close() throws IOException {,             writer.close();,         }, ,         /**,          * Closes file but doesn't throw exception,          */,         void closeQuietly() {,             FileUtils.close(writer);,         }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Replace.java,process,460-460,[            writer.write(inputBuffer.toString());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Replace.java,replace,338-338,[            final int replaceValueLength = replaceValue.length();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Replace.java,getToken,214-214,[            return token.getText();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Replace.java,getValue,231-231,[            return value.getText();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/ReplaceTest.java,tearDown,98-98,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/ReplaceTest.java,assertEqualContent,108-108,[            inExpect = new BufferedInputStream(new FileInputStream(expect));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/ResourceCount.java,eval,96-96,[        return when.evaluate(new Integer(rc.size()).compareTo(count));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/ResourceCount.java,setCount,104-104,[        count = new Integer(c);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Retry.java,,71-71,[                nestedTask.perform();],,,77-77,[                    exceptionMessage.append("Task [").append(nestedTask.getTaskName());],,,47-47,[        if (nestedTask != null) {],,,52-52,[        nestedTask = t;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Retry.java,execute,71-71,[                nestedTask.perform();],,execute,77-77,[                    exceptionMessage.append("Task [").append(nestedTask.getTaskName());],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Rmic.java,,308-308,[        return compileClasspath;],,,288-288,[        if (compileClasspath == null) {],,,291-291,[        return compileClasspath.createPath();],,,289-289,[            compileClasspath = new Path(getProject());],,,276-276,[        if (compileClasspath == null) {],,,279-279,[            compileClasspath.append(classpath);],,,277-277,[            compileClasspath = classpath;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Rmic.java,,475-475,[        return extDirs;],,,451-451,[        if (this.extDirs == null) {],,,454-454,[            this.extDirs.append(extDirs);],,,452-452,[            this.extDirs = extDirs;],,,463-463,[        if (extDirs == null) {],,,466-466,[        return extDirs.createPath();],,,464-464,[            extDirs = new Path(getProject());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Rmic.java,moveGeneratedFile,726-726,[                oldFile.delete();],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/tools/ant/taskdefs/Rmic.java,getClasspath,308-308,[        return compileClasspath;],,setClasspath,276-281,[        if (compileClasspath == null) {,             compileClasspath = classpath;,         } else {,             compileClasspath.append(classpath);,         },     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/tools/ant/taskdefs/Rmic.java,getExtdirs,475-475,[        return extDirs;],,setExtdirs,451-456,[        if (this.extDirs == null) {,             this.extDirs = extDirs;,         } else {,             this.extDirs.append(extDirs);,         },     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/Rmic.java,,832-844,[    public class ImplementationSpecificArgument extends,                                                     org.apache.tools.ant.util.facade.ImplementationSpecificArgument {,         /**,          * Only pass the specified argument if the,          * chosen compiler implementation matches the,          * value of this attribute. Legal values are,          * the same as those in the above list of,          * valid compilers.),          * @param impl the compiler to be used.,          */,         public void setCompiler(String impl) {,             super.setImplementation(impl);,         }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/RmicAdvancedTest.java,tearDown,52-52,[    }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/RmicAdvancedTest.java,NotestFailingAdapter,242-245,[        expectBuildExceptionContaining("testFailingAdapter",,                 "expected failures to propagate",,                 Rmic.ERROR_RMIC_FAILED);,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/RmicAdvancedTest.java,NotestForking,145-146,[        executeTarget("testForking");,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/RmicAdvancedTest.java,XtestWlrmic,131-132,[        executeTarget("testWlrmic");,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/RmicAdvancedTest.java,XtestWlrmicJArg,138-139,[        executeTarget("testWlrmicJArg");,     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/RmicTest.java,testCompilerArg,69-69,[        project.setProperty("build.rmic", "sun");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/RmicTest.java,testCompilerAttribute,90-90,[        project.setNewProperty("build.rmic", "weblogic");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/RmicTest.java,testCompilerArg,50-50,[        String[] args = rmic.getCurrentCompilerArgs();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/RmicTest.java,testCompilerAttribute,86-86,[        String compiler = rmic.getCompiler();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/SQLExec.java,execute,646-646,[                        out = new PrintStream(new BufferedOutputStream(os));],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/SQLExec.java,getStatement,676-676,[                    if (getStatement() != null) {],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/tools/ant/taskdefs/SQLExec.java,execSQL,775-775,[            ret = getStatement().execute(sql);],,
SECURITY,SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE,org/apache/tools/ant/taskdefs/SQLExec.java,runStatements,751-751,[            execSQL(sql.toString(), out);],,runStatements,745-745,[                execSQL(sql.substring(0, lastDelimPos), out);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/SQLExec.java,runTransaction,1053-1053,[                    reader = (encoding == null) ? new InputStreamReader(is)],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/SignJarTest.java,tearDown,45-45,[    }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/StreamPumper.java,,121-121,[        final byte[] buf = new byte[bufferSize];],,,195-195,[        return bufferSize;],,,187-187,[        this.bufferSize = bufferSize;],,
MT_CORRECTNESS,NN_NAKED_NOTIFY,org/apache/tools/ant/taskdefs/StreamPumper.java,run,154-154,[                notifyAll();],,
MT_CORRECTNESS,UW_UNCOND_WAIT,org/apache/tools/ant/taskdefs/StreamPumper.java,waitForInput,229-229,[                    this.wait(POLL_INTERVAL);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/StyleTest.java,getFileString,188-188,[            r = new FileReader(getProject().resolveFile(filename));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/StyleTest.java,tearDown,50-50,[    }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/SubAntTest.java,,109-138,[        private int calls = 0;,         private AssertionFailedError error;, ,         BasedirChecker(String[] dirs) {,             expectedBasedirs = dirs;,         }, ,         public void buildStarted(BuildEvent event) {},         public void buildFinished(BuildEvent event) {},         public void targetFinished(BuildEvent event){},         public void taskStarted(BuildEvent event) {},         public void taskFinished(BuildEvent event) {},         public void messageLogged(BuildEvent event) {}, ,         public void targetStarted(BuildEvent event) {,             if (event.getTarget().getName().equals("")) {,                 return;,             },             if (error == null) {,                 try {,                     assertEquals(expectedBasedirs[calls++],,                             event.getProject().getBaseDir().getAbsolutePath());,                 } catch (AssertionFailedError e) {,                     error = e;,                 },             },         }, ,         AssertionFailedError getError() {,             return error;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Sync.java,execute,110-110,[        boolean noRemovalNecessary = !toDir.exists() || toDir.list().length < 1;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Sync.java,removeEmptyDirectories,301-301,[            if (children.length < 1 && removeIfEmpty],,removeEmptyDirectories,299-299,[                children = dir.listFiles();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/Sync.java,removeEmptyDirectories,287-287,[            for (int i = 0; i < children.length; ++i) {],,removeEmptyDirectories,286-286,[            File[] children = dir.listFiles();],,
BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,org/apache/tools/ant/taskdefs/Sync.java,execute,136-136,[            || getExplicitPreserveEmptyDirs() == Boolean.FALSE) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Sync.java,removeEmptyDirectories,304-304,[                dir.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Sync.java,removeEmptyDirectories,332-332,[                f.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/Sync.java,removeOrphanFiles,231-231,[            f.delete();],,removeOrphanFiles,245-245,[                f.delete();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/SyncTest.java,tearDown,35-35,[    }],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_INT_VALUE,org/apache/tools/ant/taskdefs/Tar.java,tarResource,443-443,[            if (r.size() > TarConstants.MAXSIZE) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/Tar.java,,108-108,[    Vector fileSetFiles = new Vector();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Tar.java,archiveIsUpToDate,516-516,[        mm.setTo(tarFile.getAbsolutePath());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Tar.java,check,627-627,[            if (tarFile.equals(new File(basedir, files[i]))) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Tar.java,getFiles,803-803,[            return files;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Tar.java,getValues,867-867,[            return validModes;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/TarTest.java,tearDown,157-157,[    }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/TestProcess.java,,33-33,[        if (!done)],,,40-40,[                while (!done)],,,61-61,[            done = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,128-128,[        if (this.dateTime != null) {],,,131-131,[        this.dateTime = dateTime;],,,234-234,[        if (dateTime != null && !dateTimeConfigured) {],,,236-236,[            if ("now".equalsIgnoreCase(dateTime)) {],,,242-242,[                    workmillis = df.parse(dateTime).getTime();],,,249-249,[                            workmillis = df.parse(dateTime).getTime();],,,259-259,[                    throw new BuildException("Date of " + dateTime],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,132-132,[        dateTimeConfigured = false;],,,234-234,[        if (dateTime != null && !dateTimeConfigured) {],,,269-269,[            dateTimeConfigured = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,161-161,[        dfFactory = new DateFormatFactory() {],,,239-239,[                DateFormat df = dfFactory.getPrimaryFormat();],,,244-244,[                    df = dfFactory.getFallbackFormat();],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,108-108,[        this.file = file;],,,291-291,[        if (file != null) {],,,292-292,[            touch(new FileResource(file.getParentFile(), file.getName()),],,,227-227,[        if (file == null && resources == null) {],,,231-231,[        if (file != null && file.exists() && file.isDirectory()) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Touch.java,,295-295,[        if (resources == null) {],,,299-299,[        Iterator iter = resources.iterator();],,,227-227,[        if (file == null && resources == null) {],,,217-217,[        resources = resources == null ? new Union() : resources;],,,218-218,[        resources.add(rc);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Touch.java,setDatetime,128-133,[        if (this.dateTime != null) {,             log("Resetting datetime attribute to " + dateTime, Project.MSG_VERBOSE);,         },         this.dateTime = dateTime;,         dateTimeConfigured = false;,     }],,setDateTime,70-72,[        dateTime = s;,         millis = null;,     }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/TouchTest.java,testNoSeconds,61-61,[        long time = getTargetTime();],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/TouchTest.java,testSeconds,70-70,[        long time=getTargetTime();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/TouchTest.java,tearDown,44-44,[    }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/TouchTest.java,testFilelist,99-100,[        touchFile("testFilelist", 662256000000L);,     }],,testFileList,517-526,[        Path p = new Path(project);,         FileList f = new FileList();,         f.setProject(project);,         f.setDir(project.resolveFile("."));,         f.setFiles("build.xml");,         p.addFilelist(f);,         String[] l = p.list();,         assertEquals(1, l.length);,         assertEquals(project.resolveFile("build.xml").getAbsolutePath(), l[0]);,     }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/Truncate.java,,126-126,[        if (path == null) {],,,129-129,[        for (Iterator it = path.iterator(); it.hasNext();) {],,,201-201,[        if (path == null) {],,,204-204,[        return path;],,,202-202,[            path = new Path(getProject());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/Truncate.java,process,164-164,[                ? len + adjust.longValue() : length.longValue();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/Tstamp.java,<init>,311-311,[            calendarFields.put(MILLISECOND,],,<init>,313-313,[            calendarFields.put(SECOND, new Integer(Calendar.SECOND));],,<init>,314-314,[            calendarFields.put(MINUTE, new Integer(Calendar.MINUTE));],,<init>,315-315,[            calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY));],,<init>,316-316,[            calendarFields.put(DAY, new Integer(Calendar.DATE));],,<init>,317-317,[            calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR));],,<init>,318-318,[            calendarFields.put(MONTH, new Integer(Calendar.MONTH));],,<init>,319-319,[            calendarFields.put(YEAR, new Integer(Calendar.YEAR));],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Tstamp.java,getValues,337-337,[            return UNITS;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/TypeAdapterTest.java,execute,81-81,[            project.log("MyExec called");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/TypeAdapterTest.java,run,92-92,[            project.log("MyRunnable called");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/TypeAdapterTest.java,execute,138-138,[            Method executeMethod = getExecuteMethod(proxy.getClass());],,execute,142-142,[                log("Error in " + proxy.getClass(), Project.MSG_ERR);],,execute,150-150,[                log("Error in " + proxy.getClass(), Project.MSG_ERR);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/BUnzip2.java,extract,68-68,[                fis = srcResource.getInputStream();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/GUnzip.java,extract,63-63,[                fis = srcResource.getInputStream();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/UntarTest.java,tearDown,40-40,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/UnzipTest.java,tearDown,42-42,[    }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/UnzipTest.java,XtestSelfExtractingArchive,132-133,[        executeTarget("selfExtractingArchive");,     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/UpToDate.java,execute,240-240,[                log("File \"" + targetFile.getAbsolutePath()],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/UpToDate.java,getMapper,269-269,[            mm.setTo(targetFile.getAbsolutePath());],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/UpToDateTest.java,tearDown,35-35,[    }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/WaitFor.java,getValues,273-273,[            return UNITS;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/WarTest.java,tearDown,43-43,[    }],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/XSLTProcess.java,execute,413-413,[                        for (int i = 0; i < list.length; ++i) {],,execute,412-412,[                        list = new File(baseDir, dirs[j]).list();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/XSLTProcess.java,process,806-806,[            } else if (outFileName == null || outFileName.length > 1) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/XSLTProcess.java,process,860-860,[                outFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/XSLTProcess.java,process,825-825,[                outF.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/XmlProperty.java,execute,247-247,[              FileProvider fp = (FileProvider) src.as(FileProvider.class);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/XmlProperty.java,getFile,673-673,[        FileProvider fp = (FileProvider) src.as(FileProvider.class);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/XmlProperty.java,getResource,684-684,[        FileProvider fp = (FileProvider) src.as(FileProvider.class);],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,getGoldfile,291-291,[        String baseName = input.getName().toLowerCase();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,getFiles,350-350,[        for (int i=0;i<files.length;i++) {],,getFiles,349-349,[        File[] files = startingDir.listFiles(filter);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,doTest,173-173,[                props.load(new FileInputStream(propertyFile));],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,printProperties,254-260,[        Enumeration keyEnum = xmlproperties.keys();,         while (keyEnum.hasMoreElements()) {,             String currentKey = keyEnum.nextElement().toString();,             System.out.println(currentKey + " = ",                                + xmlproperties.get(currentKey));,         },     }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,accept,344-344,[                            file.getPath().toLowerCase().endsWith(".xml") );],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/tools/ant/taskdefs/XmlPropertyTest.java,accept,343-343,[                    return (file.getPath().indexOf("taskdefs") > 0 &&],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/taskdefs/Zip.java,executeMain,681-681,[                    ((ZipScanner) ds).setEncoding(encoding);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/Zip.java,setFallBackToUTF8,543-544,[        fallBackToUTF8 = b;,     }],,setFallbackToUTF8,392-393,[        fallbackToUTF8 = b;,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Zip.java,,1600-1604,[            Collections.sort(dirs, new Comparator() {,                     public int compare(Object o1, Object o2) {,                         Resource r1 = (Resource) o1;,                         Resource r2 = (Resource) o2;,                         return r1.getName().compareTo(r2.getName());],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/Zip.java,,2032-2034,[                               new ResourceSelector() {,                                    public boolean isSelected(Resource r) {,                                        return r.isDirectory();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/Zip.java,getResourcesToAdd,2119-2119,[            return resourcesToAdd;],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/ZipExtraFieldTest.java,testPreservesExtraFields,41-41,[        f.delete();],,testPreservesExtraFields,87-87,[                f.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/ZipExtraFieldTest.java,,46-63,[            final ZipResource r = new ZipResource() {,                     public String getName() {,                         return "x";,                     },                     public boolean isExists() {,                         return true;,                     },                     public boolean isDirectory() {,                         return false;,                     },                     public long getLastModified() {,                         return 1;,                     },                     public InputStream getInputStream() {,                         return new ByteArrayInputStream(new byte[0]);,                     },                     public ZipExtraField[] getExtraFields() {,                         return new ZipExtraField[] {],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/ZipTest.java,tearDown,69-69,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/ZipTest.java,testZipgroupfileset,92-92,[        ZipFile zipFile = new ZipFile(new File(getProjectDir(), "zipgroupfileset.zip"));],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/taskdefs/compilers/AptCompilerAdapter.java,getApt,95-95,[        return (Apt) getJavac();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/taskdefs/compilers/AptExternalCompilerAdapter.java,getApt,41-41,[        return (Apt) getJavac();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/compilers/DefaultCompilerAdapter.java,executeExternalCompile,485-485,[                    out = new BufferedWriter(new FileWriter(tmpFile));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/compilers/DefaultCompilerAdapter.java,executeExternalCompile,530-530,[                tmpFile.delete();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/compilers/Javac13.java,execute,60-60,[        } catch (Exception ex) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/condition/Contains.java,eval,74-74,[            : string.toLowerCase().indexOf(subString.toLowerCase()) > -1;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/condition/IsLastModified.java,getMillis,141-141,[        if (pe != null) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/condition/IsLastModified.java,,71-76,[        dfFactory = new Touch.DateFormatFactory() {,             public DateFormat getPrimaryFormat() {,                 return new SimpleDateFormat(pattern);,             },             public DateFormat getFallbackFormat() {,                 return null;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/condition/IsReachable.java,eval,182-182,[            params[0] = new Integer(timeout * SECOND);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/condition/IsReachableTest.java,NotestFile,72-75,[        expectBuildExceptionContaining("testFile",,                 "error on file URL",,                 IsReachable.ERROR_NO_HOST_IN_URL);,     }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/condition/IsSigned.java,isSigned,90-90,[                        + name.toUpperCase()],,isSigned,96-96,[                    + name.substring(0, SHORT_SIG_LIMIT).toUpperCase()],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/condition/Matches.java,setMultiline,91-92,[        multiLine = b;,     }],,setMultiLine,100-101,[        multiLine = b;,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/condition/ParserSupportsTest.java,NotestPropertyInvalid,65-66,[        executeTarget("testPropertyInvalid");,     }],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/condition/ParserSupportsTest.java,NotestXercesProperty,68-69,[        executeTarget("testXercesProperty");,     }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,eval,155-155,[                contents = contents.toLowerCase();],,eval,156-156,[                sub = sub.toLowerCase();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,eval,151-151,[            reader = new BufferedReader(new InputStreamReader(resource.getInputStream()));],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,,114-114,[        this.casesensitive = casesensitive;],,,154-154,[            if (!casesensitive) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,,66-66,[        this.resource = new FileResource(new File(r));],,,118-118,[        if (resource != null && refid != null) {],,,121-121,[        if (resource == null && refid != null) {],,,124-124,[        if (resource == null || substring == null) {],,,145-145,[        if (resource.getSize() == 0) {],,,151-151,[            reader = new BufferedReader(new InputStreamReader(resource.getInputStream()));],,,160-160,[            throw new BuildException("There was a problem accessing resource : " + resource);],,,95-95,[            this.resource = (Resource) o;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,,106-106,[        this.substring = substring;],,,124-124,[        if (resource == null || substring == null) {],,,138-138,[        if (substring.length() == 0) {],,,153-153,[            String sub = substring;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/condition/ResourceContains.java,eval,138-138,[        if (substring.length() == 0) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/condition/ResourceExists.java,eval,54-54,[        return resource.isExists();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/cvslib/CVSEntry.java,getDate,69-69,[        return date;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/cvslib/CVSEntry.java,<init>,40-40,[        this.date = date;],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogParser.java,parseDate,302-302,[                return CVS1129_INPUT_DATE.parse(date);],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogParser.java,parseDate,299-299,[            return INPUT_DATE.parse(date);],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java,setEnd,171-171,[        this.endDate = endDate;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java,setStart,161-161,[        this.startDate = start;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java,loadUserlist,387-387,[                userList.load(new FileInputStream(usersFile));],,loadUserlist,390-390,[            }],,loadUserlist,392-392,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java,loadUserlist,387-387,[                userList.load(new FileInputStream(usersFile));],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogWriter.java,printEntry,91-91,[                                   OUTPUT_DATE.format(entry.getDate()));],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogWriter.java,printEntry,93-93,[                                   OUTPUT_TIME.format(entry.getDate()));],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/taskdefs/cvslib/ChangeLogWriterTest.java,characters,69-69,[            String debug = new String(ch, start, length);],,
STYLE,UC_USELESS_VOID_METHOD,org/apache/tools/ant/taskdefs/cvslib/ChangeLogWriterTest.java,characters,70-70,[        }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/cvslib/CvsTagDiff.java,parseRDiff,301-301,[            reader = new BufferedReader(new FileReader(tmpFile));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/cvslib/CvsTagDiff.java,execute,283-283,[                tmpFile.delete();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/cvslib/CvsUser.java,getDisplayname,69-69,[        return displayName;],,getDisplayName,224-224,[        return displayName;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/cvslib/CvsVersion.java,execute,118-118,[        String output = bos.toString();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/email/EmailTask.java,setIncludefilenames,409-410,[        this.includeFileNames = includeFileNames;,     }],,setIncludeFileNames,221-222,[        this.includeFileNames = b;,     }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/email/EmailTask.java,execute,589-589,[        } catch (Exception e) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/email/Mailer.java,,37-37,[    protected boolean SSL = false;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/email/Mailer.java,,35-35,[    protected String password = null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/email/Mailer.java,,34-34,[    protected String user = null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/email/PlainMailer.java,send,45-45,[            mailMessage.from(from.toString());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/email/PlainMailer.java,send,91-91,[            if (message.getCharset() != null) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/email/Message.java,print,125-125,[                FileReader freader = new FileReader(messageSource);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/email/Message.java,print,120-120,[            out],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/email/Message.java,print,128-128,[                    BufferedReader in = new BufferedReader(freader);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/email/MessageTest.java,testPrintStreamDoesNotGetClosed,45-45,[            ms.print(new PrintStream(fis));],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/email/PlainMailer.java,attach,152-152,[            BufferedInputStream in = new BufferedInputStream(finstr, buf.length);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/AbstractXSLTLiaisonTest.java,testEncoding,91-91,[            out.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/AbstractXSLTLiaisonTest.java,testTransform,74-74,[            out.delete();],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/taskdefs/optional/AbstractXSLTLiaisonTest.java,getFile,56-56,[        URL url = getClass().getResource(name);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/Cab.java,createListFile,184-184,[            writer = new BufferedWriter(new FileWriter(listFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/Cab.java,execute,282-282,[                out.write(sb.toString().getBytes());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/Cab.java,execute,345-345,[                    outFile.delete();],,execute,348-348,[                listFile.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/Cab.java,execute,260-260,[            sb.append("\n").append(cabFile.getAbsolutePath()).append("\n");],,execute,248-248,[        log("Building " + archiveType + ": " + cabFile.getAbsolutePath());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/Cab.java,isUpToDate,161-161,[                    > cabFile.lastModified()) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/EchoProperties.java,execute,331-331,[                log(os.toString(), Project.MSG_INFO);],,
BAD_PRACTICE,DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS,org/apache/tools/ant/taskdefs/optional/EchoProperties.java,entrySet,404-404,[                    t.addAll(result);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/optional/EchoProperties.java,getValues,248-248,[            return formats;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/tools/ant/taskdefs/optional/EchoProperties.java,compareTo,443-444,[            Tuple that = (Tuple) o;,             return key.compareTo(that.key);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/optional/EchoPropertiesTest.java,testEchoToGoodFileXml,131-131,[            } catch(IOException e) {}],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/EchoPropertiesTest.java,testEchoToGoodFileXml,117-117,[        FileReader fr = new FileReader( f );],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/EchoPropertiesTest.java,tearDown,60-60,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/EchoPropertiesTest.java,testEchoToGoodFileXml,119-119,[            BufferedReader br = new BufferedReader( fr );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/optional/Javah.java,,121-137,[        public ClassArgument() {,         }, ,         /**,          * Set the name attribute.,          * @param name the name attribute.,          */,         public void setName(String name) {,             this.name = name;,         }, ,         /**,          * Get the name attribute.,          * @return the name attribute.,          */,         public String getName() {,             return name;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/JavahTest.java,tearDown,37-37,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/JspcTest.java,tearDown,76-76,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/Native2AsciiTest.java,tearDown,40-40,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,readFile,180-180,[                    BufferedInputStream bis = new BufferedInputStream(fis);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,readFile,192-192,[                    out = new FileOutputStream(propertyfile.getAbsolutePath());],,readFile,174-174,[            if (propertyfile.exists()) {],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,getCalendarField,695-695,[            String key = getValue().toLowerCase();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,<init>,679-679,[            calendarFields.put(MILLISECOND,],,<init>,681-681,[            calendarFields.put(SECOND, new Integer(Calendar.SECOND));],,<init>,682-682,[            calendarFields.put(MINUTE, new Integer(Calendar.MINUTE));],,<init>,683-683,[            calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY));],,<init>,684-684,[            calendarFields.put(DAY, new Integer(Calendar.DATE));],,<init>,685-685,[            calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR));],,<init>,686-686,[            calendarFields.put(MONTH, new Integer(Calendar.MONTH));],,<init>,687-687,[            calendarFields.put(YEAR, new Integer(Calendar.YEAR));],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/optional/PropertyFile.java,getValues,702-702,[            return UNITS;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,tearDown,59-59,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,getTestProperties,158-158,[        FileInputStream propsFile = new FileInputStream(new File(System.getProperty("root"), testPropsFilePath));],,getTestProperties,159-159,[        testProps.load(propsFile);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,initBuildPropFile,188-188,[        FileOutputStream fos = new FileOutputStream(new File(System.getProperty("root"), buildPropsFilePath));],,initBuildPropFile,189-189,[        buildProps.store(fos, null);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,initTestPropFile,172-172,[        FileOutputStream fos = new FileOutputStream(new File(System.getProperty("root"), testPropsFilePath));],,initTestPropFile,173-173,[        testProps.store(fos, "defaults");],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,getTestProperties,158-158,[        FileInputStream propsFile = new FileInputStream(new File(System.getProperty("root"), testPropsFilePath));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,initBuildPropFile,188-188,[        FileOutputStream fos = new FileOutputStream(new File(System.getProperty("root"), buildPropsFilePath));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,initTestPropFile,172-172,[        FileOutputStream fos = new FileOutputStream(new File(System.getProperty("root"), testPropsFilePath));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,destroyTempFiles,196-196,[        tempFile.delete();],,destroyTempFiles,200-200,[        tempFile.delete();],,destroyTempFiles,204-204,[        tempFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/PropertyFileTest.java,testNonExistingFile,69-69,[        file.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java,doReplace,361-361,[                r = new FileReader(f);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java,doReplace,362-362,[                w = new FileWriter(temp);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ReplaceRegExp.java,doReplace,491-491,[                temp.delete();],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/ReplaceRegExpTest.java,tearDown,46-46,[    }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/Rpm.java,execute,156-156,[                    outputstream = new PrintStream(bos);],,execute,169-169,[                    errorstream = new PrintStream(bos);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/RpmTest.java,,52-57,[            return new Execute() {,                     public int execute() {,                         // 2 is != 0 and even, so it is considered,                         // failure on any platform currently supported,                         // by Execute#isFailure.,                         return 2;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/SchemaValidate.java,setNoNamespaceFile,198-198,[        this.anonymousSchema.setFile(defaultSchemaFile);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/SchemaValidate.java,setNoNamespaceURL,189-189,[        this.anonymousSchema.setUrl(defaultSchemaURL);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/TraXLiaison.java,configure,605-605,[        if (xmlCatalog != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/TraXLiaison.java,createTransformer,343-343,[                } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/TraXLiaison.java,getFactory,415-415,[            } catch (Exception e) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/TraXLiaison.java,readTemplates,296-296,[                = new BufferedInputStream(stylesheet.getInputStream());],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,testXalan2Redirect,57-57,[    	} catch (Exception exc) {],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,testSystemId,99-99,[            file = new File("/user/local/bin");],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,testSystemId,97-97,[            file = new File("d:\\jdk");],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,tearDown,43-43,[            f.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,testMultipleTransform,89-89,[                out.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,testXalan2Redirect,72-72,[            out.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/TraXLiaisonTest.java,,85-85,[                liaison.transform(in, out);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java,getMessage,651-651,[                    } catch (Exception ex) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java,,591-591,[        protected File currentFile = null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java,,592-592,[        protected String lastErrorMessage = null;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/XmlValidateCatalogTest.java,tearDown,59-59,[    }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/XmlValidateTest.java,tearDown,58-58,[    public void tearDown() {}],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/XsltTest.java,tearDown,58-58,[    }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ccm/CCMCreateTask.java,setProcessErrorStream,297-297,[        BufferedReader reader = new BufferedReader(new InputStreamReader(is));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ccm/CCMCreateTask.java,setProcessOutputStream,313-313,[            BufferedReader reader = new BufferedReader(new InputStreamReader(is));],,
CORRECTNESS,NM_VERY_CONFUSING,org/apache/tools/ant/taskdefs/optional/clearcase/CCLock.java,setObjselect,271-272,[        mObjselect = objselect;,     }],,setObjSelect,111-112,[        mobjSelect = objSelect;,     }],,
CORRECTNESS,NM_VERY_CONFUSING,org/apache/tools/ant/taskdefs/optional/clearcase/CCLock.java,getObjselect,280-280,[        return mObjselect;],,getObjSelect,120-120,[        return mobjSelect;],,
CORRECTNESS,NM_VERY_CONFUSING,org/apache/tools/ant/taskdefs/optional/clearcase/CCUnlock.java,getObjselect,194-194,[        return getObjSelect();],,getObjSelect,120-120,[        return mobjSelect;],,
CORRECTNESS,NM_VERY_CONFUSING,org/apache/tools/ant/taskdefs/optional/clearcase/CCUnlock.java,setObjselect,175-176,[        setObjSelect(objselect);,     }],,setObjSelect,111-112,[        mobjSelect = objSelect;,     }],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/clearcase/ClearCase.java,runS,148-148,[        String   outV  = "opts.cc.runS.output" + pcnt++;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/ClassFile.java,getClassRefs,93-93,[        for (int i = 0; i < constantPool.size(); ++i) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,readCachedDependencies,189-189,[            in = new BufferedReader(new FileReader(depFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,writeCachedDependencies,224-224,[                pw = new BufferedWriter(new FileWriter(depFile));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,execute,736-736,[        } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,deleteAffectedFiles,516-516,[            affectedClassInfo.absoluteFile.delete();],,deleteAffectedFiles,540-540,[                    topLevelClassInfo.absoluteFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,deleteAllAffectedFiles,477-477,[                    classInfo.absoluteFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,execute,715-715,[                cache.mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,writeCachedDependencies,221-221,[                cache.mkdirs();],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,isRmiStub,589-590,[        return isStub(affectedClass, className, DefaultRmicAdapter.RMI_STUB_SUFFIX),             || isStub(affectedClass, className, DefaultRmicAdapter.RMI_SKEL_SUFFIX)],,isRmiStub,590-592,[            || isStub(affectedClass, className, DefaultRmicAdapter.RMI_SKEL_SUFFIX),             || isStub(affectedClass, className, WLRmic.RMI_STUB_SUFFIX),             || isStub(affectedClass, className, WLRmic.RMI_SKEL_SUFFIX);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,getCheckClassPath,256-256,[        String[] destPathElements = destPath.list();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,determineOutOfDateClasses,643-643,[        for (int i = 0; i < srcPathList.length; i++) {],,determineOutOfDateClasses,644-644,[            File srcDir = getProject().resolveFile(srcPathList[i]);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/depend/Depend.java,findSourceFile,816-816,[        for (int i = 0; i < srcPathList.length; ++i) {],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/depend/DependTest.java,tearDown,47-47,[    }],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/DoubleCPInfo.java,read,45-45,[        setValue(new Double(cpStream.readDouble()));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/FloatCPInfo.java,read,43-43,[        setValue(new Float(cpStream.readFloat()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/IntegerCPInfo.java,read,43-43,[        setValue(new Integer(cpStream.readInt()));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/depend/constantpool/LongCPInfo.java,read,43-43,[        setValue(new Long(cpStream.readLong()));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,setProcessErrorStream,551-551,[        BufferedReader reader = new BufferedReader(new InputStreamReader(is));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,setProcessOutputStream,528-528,[            BufferedReader reader = new BufferedReader(new InputStreamReader(is));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,,210-223,[            new DescriptorHandler(getTask(), srcDir) {,                     protected void processElement() {,                         if (currentElement.equals("type-storage")) {,                             // Get the filename of vendor specific descriptor,                             String fileNameWithMETA = currentText;,                             //trim the META_INF\ off of the file name,                             String fileName,                                 = fileNameWithMETA.substring(META_DIR.length(),,                                     fileNameWithMETA.length());,                             File descriptorFile = new File(srcDir, fileName);, ,                             ejbFiles.put(fileNameWithMETA, descriptorFile);,                         },                     }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/optional/ejb/DescriptorHandler.java,getFiles,233-233,[        return (ejbFiles == null) ? new Hashtable() : ejbFiles;],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/taskdefs/optional/ejb/DescriptorHandler.java,registerDTD,156-156,[        if (getClass().getResource(location) != null) {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/ejb/EjbJar.java,setGenericjarsuffix,514-515,[        this.genericJarSuffix = inString;,     }],,setGenericJarSuffix,198-199,[        this.genericJarSuffix = inString;,     }],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,buildBorlandStubs,424-424,[        commandline.createArgument().setValue(getConfig().srcDir.getAbsolutePath());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/BorlandDeploymentTool.java,setProcessOutputStream,534-534,[                        getConfig().srcDir.getAbsolutePath().length() + 1);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,createAnalyzer,284-284,[                config.srcDir.getPath()));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,783-783,[            jarfile.createNewFile();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,780-780,[                jarfile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,782-782,[            jarfile.getParentFile().mkdirs();],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,793-793,[                    in = this.getClass().getResourceAsStream(defaultManifest);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/ejb/GenericDeploymentTool.java,writeJar,821-821,[                File entryFile = (File) files.get(entryName);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetDeploymentTool.java,,274-274,[        displayName    = ejbc.getDisplayName();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetDeploymentTool.java,getIasDescriptorName,380-380,[                endOfBaseName = descriptorName.lastIndexOf('.') - 1;],,getIasDescriptorName,360-360,[        int startOfFileName = descriptorName.lastIndexOf(File.separatorChar);],,getIasDescriptorName,386-386,[            basename = descriptorName.substring(startOfFileName + 1,],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,getEjbFiles,215-215,[        return ejbFiles;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,,155-155,[                    = (String[]) elements.toArray(new String[elements.size()]);],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,setBeantype,986-986,[            this.beantype = beantype.toLowerCase();],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,toString,1339-1339,[                s += "\n\r              CMP Descriptor: " + i.next();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,classesToGenerate,1282-1282,[            final String homePkg       = home.getPackageName() + ".";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,sourceClassesModified,1153-1153,[            homeFile = home.getClassFile(buildDir);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,classesToGenerate,1284-1284,[            final String implPkg       = implementation.getPackageName() + ".";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,sourceClassesModified,1187-1187,[            implFile = implementation.getClassFile(buildDir);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,classesToGenerate,1280-1280,[            final String remotePkg     = remote.getPackageName() + ".";],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,sourceClassesModified,1142-1142,[            remoteFile = remote.getClassFile(buildDir);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,,594-596,[        public EjbcException(String msg) {,             super(msg);,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/ejb/IPlanetEjbc.java,run,1474-1474,[            BufferedReader reader = new BufferedReader(],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,addAllFiles,821-821,[            for (int i = 0; i < files.length; i++) {],,addAllFiles,820-820,[            File[] files = file.listFiles();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,deleteAllFiles,797-797,[            for (int i = 0; i < someFiles.length; i++) {],,deleteAllFiles,795-795,[            File[] someFiles = aFile.listFiles();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,addGenICGeneratedFiles,660-660,[                genericJarFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,addGenICGeneratedFiles,561-561,[            f.getParentFile().mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,createTempDir,780-780,[        tmpDir.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,deleteAllFiles,801-801,[        aFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,writeJar,362-362,[            genericJarFile.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/ejb/JonasDeploymentTool.java,getJonasDescriptorName,443-443,[        baseName = descriptorName.substring(startOfFileName + 1, endOfBaseName + 1);],,getJonasDescriptorName,407-407,[        int startOfFileName = descriptorName.lastIndexOf(File.separatorChar);],,getJonasDescriptorName,434-434,[            endOfBaseName = descriptorName.lastIndexOf('.') - 1;],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,getWeblogicDescriptorHandler,436-436,[        handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, DEFAULT_WL51_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,getWeblogicDescriptorHandler,437-437,[        handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, DEFAULT_WL60_51_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,getWeblogicDescriptorHandler,438-438,[        handler.registerDTD(PUBLICID_WEBLOGIC_EJB600, DEFAULT_WL60_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,getWeblogicDescriptorHandler,439-439,[        handler.registerDTD(PUBLICID_WEBLOGIC_EJB700, DEFAULT_WL70_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,registerKnownDTDs,406-406,[        handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL51_EJB11_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,registerKnownDTDs,407-407,[        handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL60_EJB11_DTD_LOCATION);],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,registerKnownDTDs,409-409,[        handler.registerDTD(PUBLICID_EJB20, DEFAULT_WL60_EJB20_DTD_LOCATION);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,addVendorFiles,509-509,[            } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,buildWeblogicJar,637-637,[        } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,buildWeblogicJar,544-544,[                    sourceJar.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,isRebuildRequired,808-808,[                        newWLJarFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,writeJar,670-670,[            genericJarFile.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java,,420-433,[            new DescriptorHandler(getTask(), srcDir) {,                 protected void processElement() {,                     if (currentElement.equals("type-storage")) {,                         // Get the filename of vendor specific descriptor,                         String fileNameWithMETA = currentText;,                         //trim the META_INF\ off of the file name,                         String fileName,                              = fileNameWithMETA.substring(META_DIR.length(),,                             fileNameWithMETA.length());,                         File descriptorFile = new File(srcDir, fileName);, ,                         ejbFiles.put(fileNameWithMETA, descriptorFile);,                     },                 }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java,isRebuildRequired,774-774,[                        newwasJarFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java,writeJar,627-627,[                genericJarFile.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java,,390-392,[            new DescriptorHandler(getTask(), srcDir) {,                 protected void processElement() {,                 }],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/tools/ant/taskdefs/optional/extension/DeweyDecimal.java,,41-53,[        super(components);,     }, ,     /**,      * Construct a DeweyDecimal from string in DeweyDecimal format.,      *,      * @param string the string in dewey decimal format,      * @exception NumberFormatException if string is malformed,      */,     public DeweyDecimal(final String string),         throws NumberFormatException {,         super(string);,     }],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/extension/Extension.java,getAvailable,207-207,[            final Attributes attributes = (Attributes) entries.get(key);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/extension/Extension.java,getListed,581-581,[            final Attributes attributes = (Attributes) entries.get(key);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/extension/ExtensionUtil.java,getManifest,205-205,[            final JarFile jarFile = new JarFile(file);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/extension/ExtensionUtil.java,loadExtensions,134-134,[            final JarFile jarFile = new JarFile(file);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/extension/JarLibAvailableTask.java,execute,103-103,[        final Extension test = requiredExtension.toExtension();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/extension/JarLibManifestTask.java,execute,171-171,[            log("Generating manifest " + destFile.getAbsoluteFile(), Project.MSG_INFO);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/taskdefs/optional/extension/Specification.java,getSections,328-328,[            return null;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/extension/Specification.java,getSpecifications,179-179,[            final Attributes attributes = (Attributes) entries.get(key);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/extension/resolvers/AntResolver.java,resolve,75-75,[        ant.setAntfile(antfile.getName());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/extension/resolvers/URLResolver.java,getDest,91-91,[            final String file = url.getFile();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,processBundle,411-411,[            ins = new FileInputStream(propsFile);],,processBundle,412-412,[            loaded = true;],,processBundle,413-413,[            bundleLastModified[i] = propsFile.lastModified();],,processBundle,414-414,[            log("Using " + propsFile, Project.MSG_DEBUG);],,processBundle,415-415,[            loadResourceMap(ins);],,processBundle,424-424,[        }],,processBundle,425-425,[    }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,loadResourceMap,476-476,[            if (in != null) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,execute,318-318,[            toDir.mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,translate,509-509,[                            destDir.mkdirs();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,translateOneFile,612-612,[                                + line.substring(endIndex + endToken.length());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/i18n/Translate.java,translateOneFile,568-568,[                       && (startIndex + startToken.length()) <= line.length()) {],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/i18n/TranslateTest.java,tearDown,48-48,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/taskdefs/optional/i18n/TranslateTest.java,compareFiles,74-74,[            FileInputStream fis1 = new FileInputStream(file1);],,compareFiles,75-75,[            FileInputStream fis2 = new FileInputStream(file2);],,compareFiles,76-76,[            int index = 0;],,compareFiles,77-77,[            int read = 0;],,compareFiles,78-78,[            while ((read = fis1.read(buffer1)) != -1) {],,compareFiles,88-88,[            return true;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/i18n/TranslateTest.java,compareFiles,74-74,[            FileInputStream fis1 = new FileInputStream(file1);],,compareFiles,75-75,[            FileInputStream fis2 = new FileInputStream(file2);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/tools/ant/taskdefs/optional/i18n/TranslateTest.java,compareFiles,79-79,[                fis2.read(buffer2);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/j2ee/AbstractHotDeploymentTool.java,getUserName,151-151,[        return userName;],,getUsername,263-263,[        return sosUsername;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/j2ee/AbstractHotDeploymentTool.java,createClasspath,67-67,[            classpath = new Path(task.getProject());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/j2ee/AbstractHotDeploymentTool.java,validateAttributes,91-91,[        if (task.getAction() == null) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/taskdefs/optional/j2ee/JonasHotDeploymentTool.java,,40-248,[public class JonasHotDeploymentTool extends GenericHotDeploymentTool implements HotDeploymentTool {, ,     /**,      *  Description of the Field,      */,     protected static final String DEFAULT_ORB = "RMI";, ,     /**,      *  The classname of the tool to run *,      */,     private static final String JONAS_DEPLOY_CLASS_NAME = "org.objectweb.jonas.adm.JonasAdmin";, ,     /**,      *  All the valid actions that weblogic.deploy permits *,      */,     private static final String[] VALID_ACTIONS,         = {ACTION_DELETE, ACTION_DEPLOY, ACTION_LIST, ACTION_UNDEPLOY, ACTION_UPDATE};, ,     /**,      *  Description of the Field,      */,     private File jonasroot;, ,     /**,      *  Description of the Field,      */,     private String orb = null;, ,     /**,      *  Description of the Field,      */,     private String davidHost;, ,     /**,      *  Description of the Field,      */,     private int davidPort;, , ,     /**,      *  Set the host for the David ORB; required if,      *  ORB==david.,      *,      *@param  inValue  The new davidhost value,      */,     public void setDavidhost(final String inValue) {,         davidHost = inValue;,     }, , ,     /**,      *  Set the port for the David ORB; required if,      *  ORB==david.,      *,      *@param  inValue  The new davidport value,      */,     public void setDavidport(final int inValue) {,         davidPort = inValue;,     }, , ,     /**,      *  set the jonas root directory (-Dinstall.root=). This,      *  element is required.,      *,      *@param  inValue  The new jonasroot value,      */,     public void setJonasroot(final File inValue) {,         jonasroot = inValue;,     }, , ,     /**,      *,      * Choose your ORB : RMI, JEREMIE, DAVID, ...; optional.,      * If omitted, it defaults,      * to the one present in classpath. The corresponding JOnAS JAR is,      * automatically added to the classpath. If your orb is DAVID (RMI/IIOP) you must,      * specify davidhost and davidport properties.,      *,      *@param  inValue  RMI, JEREMIE, DAVID,...,      */,     public void setOrb(final String inValue) {,         orb = inValue;,     }, , ,     /**,      *  gets the classpath field.,      *,      *@return    A Path representing the "classpath" attribute.,      */,     public Path getClasspath() {, ,         Path aClassPath = super.getClasspath();, ,         if (aClassPath == null) {,             aClassPath = new Path(getTask().getProject());,         },         if (orb != null) {,             String aOrbJar = new File(jonasroot, "lib/" + orb + "_jonas.jar").toString();,             String aConfigDir = new File(jonasroot, "config/").toString();,             Path aJOnASOrbPath = new Path(aClassPath.getProject(),,                     aOrbJar + File.pathSeparator + aConfigDir);,             aClassPath.append(aJOnASOrbPath);,         },         return aClassPath;,     }, , ,     /**,      *  Validates the passed in attributes. <p>,      *,      *  The rules are:,      *  <ol>,      *    <li> If action is "deploy" or "update" the "application",      *    and "source" attributes must be supplied.,      *    <li> If action is "delete" or "undeploy" the,      *    "application" attribute must be supplied.,      *,      *@exception  BuildException                       Description,      *      of Exception,      */,     public void validateAttributes() throws BuildException {,         // super.validateAttributes(); // don't want to call this method, ,         Java java = getJava();, ,         String action = getTask().getAction();,         if (action == null) {,             throw new BuildException("The \"action\" attribute must be set");,         }, ,         if (!isActionValid()) {,             throw new BuildException("Invalid action \"" + action + "\" passed");,         }, ,         if (getClassName() == null) {,             setClassName(JONAS_DEPLOY_CLASS_NAME);,         }, ,         if (jonasroot == null || jonasroot.isDirectory()) {,             java.createJvmarg().setValue("-Dinstall.root=" + jonasroot);,             java.createJvmarg().setValue("-Djava.security.policy=" + jonasroot,                 + "/config/java.policy");, ,             if ("DAVID".equals(orb)) {,                 java.createJvmarg().setValue("-Dorg.omg.CORBA.ORBClass",                     + "=org.objectweb.david.libs.binding.orbs.iiop.IIOPORB");,                 java.createJvmarg().setValue("-Dorg.omg.CORBA.ORBSingletonClass=",                     + "org.objectweb.david.libs.binding.orbs.ORBSingletonClass");,                 java.createJvmarg().setValue("-Djavax.rmi.CORBA.StubClass=",                     + "org.objectweb.david.libs.stub_factories.rmi.StubDelegate");,                 java.createJvmarg().setValue("-Djavax.rmi.CORBA.PortableRemoteObjectClass=",                     + "org.objectweb.david.libs.binding.rmi.ORBPortableRemoteObjectDelegate");,                 java.createJvmarg().setValue("-Djavax.rmi.CORBA.UtilClass=",                     + "org.objectweb.david.libs.helpers.RMIUtilDelegate");,                 java.createJvmarg().setValue("-Ddavid.CosNaming.default_method=0");,                 java.createJvmarg().setValue("-Ddavid.rmi.ValueHandlerClass=",                     + "com.sun.corba.se.internal.io.ValueHandlerImpl");,                 if (davidHost != null) {,                     java.createJvmarg().setValue("-Ddavid.CosNaming.default_host=",                         + davidHost);,                 },                 if (davidPort != 0) {,                     java.createJvmarg().setValue("-Ddavid.CosNaming.default_port=",                         + davidPort);,                 },             },         }, ,         if (getServer() != null) {,             java.createArg().setLine("-n " + getServer());,         }, ,         if (action.equals(ACTION_DEPLOY),             || action.equals(ACTION_UPDATE),             || action.equals("redeploy")) {,             java.createArg().setLine("-a " + getTask().getSource());,         } else if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {,             java.createArg().setLine("-r " + getTask().getSource());,         } else if (action.equals(ACTION_LIST)) {,             java.createArg().setValue("-l");,         },     }, , ,     /**,      *  Determines if the action supplied is valid. <p>,      *,      *  Valid actions are contained in the static array,      *  VALID_ACTIONS,      *,      *@return    true if the action attribute is valid, false if,      *      not.,      */,     protected boolean isActionValid() {,         boolean valid = false;, ,         String action = getTask().getAction();, ,         for (int i = 0; i < VALID_ACTIONS.length; i++) {,             if (action.equals(VALID_ACTIONS[i])) {,                 valid = true;,                 break;,             },         }, ,         return valid;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/taskdefs/optional/j2ee/WebLogicHotDeploymentTool.java,,37-246,[public class WebLogicHotDeploymentTool extends AbstractHotDeploymentTool,                                        implements HotDeploymentTool {,     private static final int STRING_BUFFER_SIZE = 1024;,     /** The classname of the tool to run **/,     private static final String WEBLOGIC_DEPLOY_CLASS_NAME = "weblogic.deploy";, ,     /** All the valid actions that weblogic.deploy permits **/,     private static final String[] VALID_ACTIONS,         = {ACTION_DELETE, ACTION_DEPLOY, ACTION_LIST, ACTION_UNDEPLOY, ACTION_UPDATE};, ,     /** Represents the "-debug" flag from weblogic.deploy **/,     private boolean debug;, ,     /** The application name that is being deployed **/,     private String application;, ,     /** The component name:target(s) for the "-component" argument of weblogic.deploy **/,     private String component;, ,     /**,      *  Perform the actual deployment.,      *  For this implementation, a JVM is spawned and the weblogic.deploy,      *  tools is executed.,      *  @exception org.apache.tools.ant.BuildException if the attributes are invalid or incomplete.,      */,     public void deploy() {,         Java java = new Java(getTask());,         java.setFork(true);,         java.setFailonerror(true);,         java.setClasspath(getClasspath());, ,         java.setClassname(WEBLOGIC_DEPLOY_CLASS_NAME);,         java.createArg().setLine(getArguments());,         java.execute();,     }, ,     /**,      *  Validates the passed in attributes.,      *  <p>The rules are:,      *  <ol><li>If action is "deploy" or "update" the "application" and "source",      *  attributes must be supplied.,      *  <li>If action is "delete" or "undeploy" the "application" attribute must,      *  be supplied.,      *  @exception org.apache.tools.ant.BuildException if the attributes are invalid or incomplete,      */,     public void validateAttributes() throws BuildException {,         super.validateAttributes();, ,         String action = getTask().getAction();, ,         // check that the password has been set,         if ((getPassword() == null)) {,             throw new BuildException("The password attribute must be set.");,         }, ,         // check for missing application on deploy & update,         if ((action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE)),             && application == null) {,             throw new BuildException("The application attribute must be set ",                 + "if action = " + action);,         }, ,         // check for missing source on deploy & update,         if ((action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE)),             && getTask().getSource() == null) {,             throw new BuildException("The source attribute must be set if ",                 + "action = " + action);,         }, ,         // check for missing application on delete & undeploy,         if ((action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)),             && application == null) {,             throw new BuildException("The application attribute must be set if ",                 + "action = " + action);,         },     }, ,     /**,      *  Builds the arguments to pass to weblogic.deploy according to the,      *  supplied action.,      *  @return A String containing the arguments for the weblogic.deploy tool.,      * @throws BuildException if there is an error.,      */,     public String getArguments() throws BuildException {,         String action = getTask().getAction();,         String args = null;, ,         if (action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE)) {,             args = buildDeployArgs();,         } else if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {,             args = buildUndeployArgs();,         } else if (action.equals(ACTION_LIST)) {,             args = buildListArgs();,         }, ,         return args;,     }, ,     /**,      *  Determines if the action supplied is valid.,      *  <p>Valid actions are contained in the static array VALID_ACTIONS,      *  @return true if the action attribute is valid, false if not.,      */,     protected boolean isActionValid() {,         boolean valid = false;, ,         String action = getTask().getAction();, ,         for (int i = 0; i < VALID_ACTIONS.length; i++) {,             if (action.equals(VALID_ACTIONS[i])) {,                 valid = true;,                 break;,             },         }, ,         return valid;,     }, ,     /**,      *  Builds the prefix arguments to pass to weblogic.deploy.,      *  These arguments are generic across all actions.,      *  @return A StringBuffer containing the prefix arguments.,      *  The action-specific build methods will append to this StringBuffer.,      */,     protected StringBuffer buildArgsPrefix() {,         ServerDeploy task = getTask();,         // constructs the "-url <url> -debug <action> <password>" portion,         // of the commmand line,         return new StringBuffer(STRING_BUFFER_SIZE),                 .append((getServer() != null),                     ? "-url " + getServer(),                     : ""),                 .append(" "),                 .append(debug ? "-debug " : ""),                 .append((getUserName() != null),                     ? "-username " + getUserName(),                     : ""),                 .append(" "),                 .append(task.getAction()).append(" "),                 .append(getPassword()).append(" ");,     }, ,     /**,      *  Builds the arguments to pass to weblogic.deploy for deployment actions,      *  ("deploy" and "update").,      *  @return A String containing the full argument string for weblogic.deploy.,      */,     protected String buildDeployArgs() {,         String args = buildArgsPrefix(),                 .append(application).append(" "),                 .append(getTask().getSource()),                 .toString();, ,         if (component != null) {,             args = "-component " + component + " " + args;,         }, ,         return args;,     }, ,     /**,      *  Builds the arguments to pass to weblogic.deploy for undeployment actions,      *  ("undeploy" and "delete").,      *  @return A String containing the full argument string for weblogic.deploy.,      */,     protected String buildUndeployArgs() {,         return buildArgsPrefix(),                 .append(application).append(" "),                 .toString();,     }, ,     /**,      *  Builds the arguments to pass to weblogic.deploy for the list action,      *  @return A String containing the full argument string for weblogic.deploy.,      */,     protected String buildListArgs() {,         return buildArgsPrefix(),                 .toString();,     }, ,     /**,      *  If set to true, additional information will be,      *  printed during the deployment process; optional.,      *  @param debug A boolean representing weblogic.deploy "-debug" flag.,      */,     public void setDebug(boolean debug) {,         this.debug = debug;,     }, ,     /**,      *  The name of the application being deployed; required.,      *  @param application A String representing the application portion of the,      *  weblogic.deploy command line.,      */,     public void setApplication(String application) {,         this.application = application;,     }, ,     /**,      * the component string for the deployment targets; optional.,      * It is in the form <code>&lt;component&gt;:&lt;target1&gt;,&lt;target2&gt;...</code>,      * Where component is the archive name (minus the .jar, .ear, .war,      * extension).  Targets are the servers where the components will be deployed, ,      *  @param component A String representing the value of the "-component",      *  argument of the weblogic.deploy command line argument.,      */,     public void setComponent(String component) {,         this.component = component;,     }],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/taskdefs/optional/javacc/JavaCC.java,,80-80,[    protected static final String[] ARCHIVE_LOCATIONS =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/taskdefs/optional/javacc/JavaCC.java,,88-88,[    protected static final int[] ARCHIVE_LOCATIONS_VS_MAJOR_VERSION =],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,67-68,[                values[i] = new Integer(data.readInt());,                 break;],,<init>,93-94,[                values[i] = new Integer(data.readInt());,                 break;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,80-80,[                values[i] = new Double(data.readDouble());],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,71-71,[                values[i] = new Float(data.readFloat());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,67-67,[                values[i] = new Integer(data.readInt());],,<init>,86-86,[                values[i] = new Integer(data.readUnsignedShort());],,<init>,93-93,[                values[i] = new Integer(data.readInt());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/jlink/ClassNameReader.java,<init>,75-75,[                values[i] = new Long(data.readLong());],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/tools/ant/taskdefs/optional/jlink/jlink.java,,46-452,[public class jlink {,     private static final int BUFFER_SIZE = 8192;,     private static final int VECTOR_INIT_SIZE = 10;, ,     private String outfile = null;, ,     private Vector mergefiles = new Vector(VECTOR_INIT_SIZE);, ,     private Vector addfiles = new Vector(VECTOR_INIT_SIZE);, ,     private boolean compression = false;, ,     // CheckStyle:VisibilityModifier OFF - bc, ,     byte[] buffer = new byte[BUFFER_SIZE];, ,     // CheckStyle:VisibilityModifier OFF - bc, ,     /** The file that will be created by this instance of jlink.,      * @param outfile the file to create.,      */,     public void setOutfile(String outfile) {,         if (outfile == null) {,             return;,         },         this.outfile = outfile;,     }, , ,     /**,      * Adds a file to be merged into the output.,      * @param fileToMerge the file to merge into the output.,      */,     public void addMergeFile(String fileToMerge) {,         if (fileToMerge == null) {,             return;,         },         mergefiles.addElement(fileToMerge);,     }, , ,     /** Adds a file to be added into the output.,      * @param fileToAdd the file to add to the output.,      */,     public void addAddFile(String fileToAdd) {,         if (fileToAdd == null) {,             return;,         },         addfiles.addElement(fileToAdd);,     }, , ,     /**,      * Adds several files to be merged into the output.,      * @param filesToMerge an array of files to merge into the output.,      */,     public void addMergeFiles(String[] filesToMerge) {,         if (filesToMerge == null) {,             return;,         },         for (int i = 0; i < filesToMerge.length; i++) {,             addMergeFile(filesToMerge[i]);,         },     }, , ,     /**,      * Adds several file to be added into the output.,      * @param filesToAdd an array of files to add to the output.,      */,     public void addAddFiles(String[] filesToAdd) {,         if (filesToAdd == null) {,             return;,         },         for (int i = 0; i < filesToAdd.length; i++) {,             addAddFile(filesToAdd[i]);,         },     }, , ,     /**,      * Determines whether output will be compressed.,      * @param compress if true use compression.,      */,     public void setCompression(boolean compress) {,         this.compression = compress;,     }, , ,     /**,      * Performs the linking of files. Addfiles are added to the output as-is.,      * For example, a jar file is added to the output as a jar file. However,,      * mergefiles are first examined for their type. If it is a jar or zip,      * file, the contents will be extracted from the mergefile and entered,      * into the output. If a zip or jar file is encountered in a subdirectory,      * it will be added, not merged. If a directory is encountered, it becomes,      * the root entry of all the files below it. Thus, you can provide,      * multiple, disjoint directories, as addfiles: they will all be added in,      * a rational manner to outfile.,      * @throws Exception on error.,      */,     public void link() throws Exception {,         ZipOutputStream output = new ZipOutputStream(new FileOutputStream(outfile));, ,         if (compression) {,             output.setMethod(ZipOutputStream.DEFLATED);,             output.setLevel(Deflater.DEFAULT_COMPRESSION);,         } else {,             output.setMethod(ZipOutputStream.STORED);,         }, ,         Enumeration merges = mergefiles.elements();, ,         while (merges.hasMoreElements()) {,             String path = (String) merges.nextElement();,             File f = new File(path);, ,             if (f.getName().endsWith(".jar") || f.getName().endsWith(".zip")) {,                 //Do the merge,                 mergeZipJarContents(output, f);,             } else {,                 //Add this file to the addfiles Vector and add it,                 //later at the top level of the output file.,                 addAddFile(path);,             },         }, ,         Enumeration adds = addfiles.elements();, ,         while (adds.hasMoreElements()) {,             String name = (String) adds.nextElement();,             File f = new File(name);, ,             if (f.isDirectory()) {,                 //System.out.println("in jlink: adding directory contents of " + f.getPath());,                 addDirContents(output, f, f.getName() + '/', compression);,             } else {,                 addFile(output, f, "", compression);,             },         },         FileUtils.close(output);,     }, , ,     /**,      * The command line entry point for jlink.,      * @param args an array of arguments,      */,     public static void main(String[] args) {,         // jlink output input1 ... inputN,         if (args.length < 2) {,             System.out.println("usage: jlink output input1 ... inputN");,             System.exit(1);,         },         jlink linker = new jlink();, ,         linker.setOutfile(args[0]);,         // To maintain compatibility with the command-line version,,         // we will only add files to be merged.,         for (int i = 1; i < args.length; i++) {,             linker.addMergeFile(args[i]);,         },         try {,             linker.link();,         } catch (Exception ex) {,             System.err.print(ex.getMessage());,         },     }, , ,     /*,      * Actually performs the merging of f into the output.,      * f should be a zip or jar file.,      */,     private void mergeZipJarContents(ZipOutputStream output, File f) throws IOException {,         //Check to see that the file with name "name" exists.,         if (!f.exists()) {,             return;,         },         ZipFile zipf = new ZipFile(f);,         Enumeration entries = zipf.entries();, ,         while (entries.hasMoreElements()) {,             ZipEntry inputEntry = (ZipEntry) entries.nextElement();,             //Ignore manifest entries.  They're bound to cause conflicts between,             //files that are being merged.  User should supply their own,             //manifest file when doing the merge.,             String inputEntryName = inputEntry.getName();,             int index = inputEntryName.indexOf("META-INF");, ,             if (index < 0) {,                 //META-INF not found in the name of the entry. Go ahead and process it.,                 try {,                     output.putNextEntry(processEntry(zipf, inputEntry));,                 } catch (ZipException ex) {,                     //If we get here, it could be because we are trying to put a,                     //directory entry that already exists.,                     //For example, we're trying to write "com", but a previous,                     //entry from another mergefile was called "com".,                     //In that case, just ignore the error and go on to the,                     //next entry.,                     String mess = ex.getMessage();, ,                     if (mess.indexOf("duplicate") >= 0) {,                         //It was the duplicate entry.,                         continue;,                     } else {,                         // I hate to admit it, but we don't know what happened,                         // here.  Throw the Exception.,                         throw ex;,                     },                 }, ,                 InputStream in = zipf.getInputStream(inputEntry);,                 int len = buffer.length;,                 int count = -1;, ,                 while ((count = in.read(buffer, 0, len)) > 0) {,                     output.write(buffer, 0, count);,                 },                 in.close();,                 output.closeEntry();,             },         },         zipf.close();,     }, , ,     /*,      * Adds contents of a directory to the output.,      */,     private void addDirContents(ZipOutputStream output, File dir, String prefix,,                                 boolean compress) throws IOException {,         String[] contents = dir.list();, ,         for (int i = 0; i < contents.length; ++i) {,             String name = contents[i];,             File file = new File(dir, name);, ,             if (file.isDirectory()) {,                 addDirContents(output, file, prefix + name + '/', compress);,             } else {,                 addFile(output, file, prefix, compress);,             },         },     }, , ,     /*,      * Gets the name of an entry in the file.  This is the real name,      * which for a class is the name of the package with the class,      * name appended.,      */,     private String getEntryName(File file, String prefix) {,         String name = file.getName();, ,         if (!name.endsWith(".class")) {,             // see if the file is in fact a .class file, and determine its actual name.,             InputStream input = null;,             try {,                 input = new FileInputStream(file);,                 String className = ClassNameReader.getClassName(input);, ,                 if (className != null) {,                     return className.replace('.', '/') + ".class";,                 },             } catch (IOException ioe) {,                 //do nothing,             } finally {,                 if (input != null) {,                     try {,                         input.close();,                     } catch (IOException e) {,                         //do nothing,                     },                 },             },         },         System.out.println("From " + file.getPath() + " and prefix " + prefix,                            + ", creating entry " + prefix + name);,         return (prefix + name);,     }, , ,     /*,      * Adds a file to the output stream.,      */,     private void addFile(ZipOutputStream output, File file, String prefix,,                          boolean compress) throws IOException {,         //Make sure file exists,         if (!file.exists()) {,             return;,         },         ZipEntry entry = new ZipEntry(getEntryName(file, prefix));, ,         entry.setTime(file.lastModified());,         entry.setSize(file.length());,         if (!compress) {,             entry.setCrc(calcChecksum(file));,         },         FileInputStream input = new FileInputStream(file);, ,         addToOutputStream(output, input, entry);,     }, , ,     /*,      * A convenience method that several other methods might call.,      */,     private void addToOutputStream(ZipOutputStream output, InputStream input,,                                    ZipEntry ze) throws IOException {,         try {,             output.putNextEntry(ze);,         } catch (ZipException zipEx) {,             //This entry already exists. So, go with the first one.,             input.close();,             return;,         }, ,         int numBytes = -1;, ,         while ((numBytes = input.read(buffer)) > 0) {,             output.write(buffer, 0, numBytes);,         },         output.closeEntry();,         input.close();,     }, , ,     /*,      * A method that does the work on a given entry in a mergefile.,      * The big deal is to set the right parameters in the ZipEntry,      * on the output stream.,      */,     private ZipEntry processEntry(ZipFile zip, ZipEntry inputEntry) {,         /*,           First, some notes.,           On MRJ 2.2.2, getting the size, compressed size, and CRC32 from the,           ZipInputStream does not work for compressed (deflated) files.  Those calls return -1.,           For uncompressed (stored) files, those calls do work.,           However, using ZipFile.getEntries() works for both compressed and,           uncompressed files., ,           Now, from some simple testing I did, it seems that the value of CRC-32 is,           independent of the compression setting. So, it should be easy to pass this,           information on to the output entry.,         */,         String name = inputEntry.getName();, ,         if (!(inputEntry.isDirectory() || name.endsWith(".class"))) {,             try {,                 InputStream input = zip.getInputStream(zip.getEntry(name));,                 String className = ClassNameReader.getClassName(input);, ,                 input.close();,                 if (className != null) {,                     name = className.replace('.', '/') + ".class";,                 },             } catch (IOException ioe) {,                 //do nothing,             },         },         ZipEntry outputEntry = new ZipEntry(name);, ,         outputEntry.setTime(inputEntry.getTime());,         outputEntry.setExtra(inputEntry.getExtra());,         outputEntry.setComment(inputEntry.getComment());,         outputEntry.setTime(inputEntry.getTime());,         if (compression) {,             outputEntry.setMethod(ZipEntry.DEFLATED);,             //Note, don't need to specify size or crc for compressed files.,         } else {,             outputEntry.setMethod(ZipEntry.STORED);,             outputEntry.setCrc(inputEntry.getCrc());,             outputEntry.setSize(inputEntry.getSize());,         },         return outputEntry;,     }, , ,     /*,      * Necessary in the case where you add a entry that,      * is not compressed.,      */,     private long calcChecksum(File f) throws IOException {,         BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));, ,         return calcChecksum(in);,     }, , ,     /*,      * Necessary in the case where you add a entry that,      * is not compressed.,      */,     private long calcChecksum(InputStream in) throws IOException {,         CRC32 crc = new CRC32();,         int len = buffer.length;,         int count = -1;,         int haveRead = 0;, ,         while ((count = in.read(buffer, 0, len)) > 0) {,             haveRead += count;,             crc.update(buffer, 0, count);,         },         in.close();,         return crc.getValue();],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/jlink/jlink.java,addDirContents,281-281,[        for (int i = 0; i < contents.length; ++i) {],,addDirContents,279-279,[        String[] contents = dir.list();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/taskdefs/optional/jlink/jlink.java,addFile,346-346,[        FileInputStream input = new FileInputStream(file);],,addFile,348-348,[        addToOutputStream(output, input, entry);],,addFile,349-349,[    }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/jsp/JspC.java,deleteEmptyJavaFiles,672-672,[                    file.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/jsp/JspC.java,getActualDestDir,532-532,[            String path = destDir.getPath() + File.separatorChar],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/taskdefs/optional/jsp/JspNameMangler.java,,36-36,[    public static final String[] keywords = {],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/optional/jsp/JspNameMangler.java,mapJspToBaseName,80-80,[                className += "%";],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java,replaceString,328-328,[            localString += test;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java,execute,107-107,[        if (!destinationDirectory.isDirectory()) {],,execute,153-153,[        args[j++] = destinationDirectory.getAbsolutePath().trim();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java,execute,112-112,[        if (!sourceDirectory.isDirectory()) {],,execute,155-155,[        args[j++] = sourceDirectory.getAbsolutePath().trim();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,,125-125,[       dbfactory = privateDBFactory;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,setXmlfile,179-179,[        } catch (Exception e) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,transform,240-240,[            String tempFileProperty = getClass().getName() + String.valueOf(counter++);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,,160-160,[        this.document = doc;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,,125-125,[       dbfactory = privateDBFactory;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/AggregateTransformer.java,transform,261-261,[        paramx.setExpression(toDir.getAbsolutePath());],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/junit/BaseTest.java,,34-34,[    protected String ifProperty = null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/ant/taskdefs/optional/junit/BaseTest.java,,35-35,[    protected String unlessProperty = null;],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/tools/ant/taskdefs/optional/junit/BatchTestTest.java,assertEquals,135-135,[                                        actual.toString());],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/tools/ant/taskdefs/optional/junit/BatchTestTest.java,assertEquals,134-134,[                                        expected.toString(),],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/tools/ant/taskdefs/optional/junit/BatchTestTest.java,assertEquals,132-132,[        if (expected.length != actual.length) {],,assertEquals,129-129,[        if ((expected == null) && (actual == null)) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/BriefJUnitResultFormatter.java,setOutput,94-94,[        output = new BufferedWriter(new java.io.OutputStreamWriter(out));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/taskdefs/optional/junit/DOMUtilTest.java,,41-46,[    public class FooNodeFilter implements DOMUtil.NodeFilter {,         public boolean accept(Node node) {,             if (node.getNodeName().equals("foo")) {,                 return true;,             },             return false;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java,writeJavaClass,255-255,[            writer = new BufferedWriter(new FileWriter(sourceFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitReportTest.java,testStackTraceLineBreaks,101-101,[            r = new FileReader(new File(System.getProperty("root"),],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/junit/JUnitReportTest.java,tearDown,45-45,[    }],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,checkForkedPath,1190-1190,[            } catch (Exception ex) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,execute,883-883,[            writer = new BufferedWriter(new FileWriter(casesFile));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,execute,887-887,[            PrintStream logWriter =],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,executeAsForked,1069-1069,[                    br = new BufferedReader(new FileReader(vmWatcher));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,executeAsForked,1024-1024,[            FileOutputStream outstream = new FileOutputStream(propsFile);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,logVmExit,1655-1655,[                    if (formatter != null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,checkForkedPath,1190-1190,[            } catch (Exception ex) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,createMirror,740-740,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/JUnitTask.java,executeAsForked,1077-1077,[            } catch (Exception e) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskMirrorImpl.java,,43-43,[        this.task = task;],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskMirrorImpl.java,,81-104,[        VmExitErrorTest(String aMessage, JUnitTest anOriginalTest, String aTestCase) {,             message = aMessage;,             test = anOriginalTest;,             testCase = aTestCase;,         }, ,         public int countTestCases() {,             return 1;,         }, ,         public void run(TestResult r) {,             throw new AssertionFailedError(message);,         }, ,         public String getName() {,             return testCase;,         }, ,         String getClassName() {,             return test.getName();,         }, ,         public String toString() {,             return test.getName() + ":" + testCase;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskTest.java,assertOutput,257-257,[                                          .resolveFile("testlog.txt"));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskTest.java,tearDown,50-50,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/taskdefs/optional/junit/JUnitTaskTest.java,assertOutput,258-258,[        BufferedReader reader = new BufferedReader(inner);],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestListenerTest.java,tearDown,45-45,[    }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,createEmptyStream,306-306,[        return new PrintStream(],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,createTeePrint,314-314,[        return new PrintStream(new TeeOutputStream(ps1, ps2));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,main,853-853,[                java.io.BufferedReader reader =],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,registerNonCrash,1064-1064,[                out = new FileWriter(crashFile);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,registerTestCase,1078-1078,[                    out = new FileWriter(crashFile);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,run,547-547,[                sendOutAndErr(new String(outStrm.toByteArray()),],,run,548-548,[                              new String(errStrm.toByteArray()));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,setupIOStreams,319-319,[        systemOut = new PrintStream(o);],,setupIOStreams,320-320,[        systemError = new PrintStream(e);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,filterStack,1021-1021,[        } catch (Exception e) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,<init>,292-292,[        JUnitTestRunner.filtertrace = filtertrace; // XXX clumsy, should use instance field somehow],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java,,307-309,[            new OutputStream() {,                 public void write(int b) {,                 }],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunnerTest.java,,180-181,[            super(name);,             throw new NullPointerException("thrown on purpose");],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/junit/JUnitVersionHelper.java,getTestCaseName,102-102,[                if (getNameMethod != null],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/taskdefs/optional/junit/JUnitVersionHelperTest.java,,86-87,[    public static class Foo5 extends TestCase {,         public String getName() {return "overridden getName";}],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/PlainJUnitResultFormatter.java,endTestSuite,152-152,[                out.write(sb.toString().getBytes());],,endTestSuite,154-154,[                out.write(inner.toString().getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/PlainJUnitResultFormatter.java,startTestSuite,107-107,[            out.write(sb.toString().getBytes());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/junit/PlainJUnitResultFormatter.java,startTest,173-173,[        testStarts.put(t, new Long(System.currentTimeMillis()));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/SummaryJUnitResultFormatter.java,endTestSuite,165-165,[            out.write(sb.toString().getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/SummaryJUnitResultFormatter.java,startTestSuite,67-67,[            out.write(sb.toString().getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/junit/XMLFormatterWithCDATAOnSystemOut.java,testBuildfile,64-64,[                reader = new FileReader(f);],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/tools/ant/taskdefs/optional/junit/XMLFormatterWithCDATAOnSystemOut.java,testBuildfile,66-66,[                assertTrue(content.indexOf("</RESPONSE>&#x5d;&#x5d;&gt;"],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/junit/XMLFormatterWithCDATAOnSystemOut.java,testBuildfile,72-72,[                f.delete();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,startTest,196-196,[        testStarts.put(t, new Long(System.currentTimeMillis()));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,endTest,215-215,[            currentTest = doc.createElement(TESTCASE);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,formatError,274-274,[        Element nested = doc.createElement(type);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,formatOutput,296-296,[        Element nested = doc.createElement(type);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,endTest,223-223,[            rootElement.appendChild(currentTest);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,endTestSuite,161-161,[        rootElement.setAttribute(ATTR_TESTS, "" + suite.runCount());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,formatOutput,297-297,[        rootElement.appendChild(nested);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java,createFolders,301-301,[            in = new BufferedReader(new FileReader(file));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java,massagePCLI,359-359,[            inReader = new BufferedReader(new FileReader(in));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java,massagePCLI,360-360,[            outWriter = new BufferedWriter(new FileWriter(out));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java,execute,287-287,[                tmp.delete();],,execute,290-290,[                tmp2.delete();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/sos/SOS.java,getLocalPath,359-373,[        if (localPath == null) {,             return getProject().getBaseDir().getAbsolutePath();,         } else {,             // make sure localDir exists, create it if it doesn't,             File dir = getProject().resolveFile(localPath);,             if (!dir.exists()) {,                 boolean done = dir.mkdirs();,                 if (!done) {,                     String msg = "Directory " + localPath + " creation was not ",                         + "successful for an unknown reason";,                     throw new BuildException(msg, getLocation());,                 },                 getProject().log("Created dir: " + dir.getAbsolutePath());,             },             return dir.getAbsolutePath();],,getLocalpath,485-500,[        String lclPath = ""; //set to empty str if no local path return,         if (localPath != null) {,             //make sure m_LocalDir exists, create it if it doesn't,             File dir = getProject().resolveFile(localPath);,             if (!dir.exists()) {,                 boolean done = dir.mkdirs();,                 if (!done) {,                     String msg = "Directory " + localPath + " creation was not ",                             + "successful for an unknown reason";,                     throw new BuildException(msg, getLocation());,                 },                 getProject().log("Created dir: " + dir.getAbsolutePath());,             },             lclPath = FLAG_OVERRIDE_WORKING_DIR + localPath;,         },         return lclPath;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/sos/SOS.java,setLocalPath,167-168,[        localPath = path.toString();,     }],,setLocalpath,120-121,[        this.localPath = localPath.toString();,     }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/sos/SOSTest.java,tearDown,80-80,[    }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/sos/SOSTest.java,tearDown,78-78,[            file.delete();],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/taskdefs/optional/sound/SoundTask.java,getSource,169-169,[                this.source = nofile;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/sound/SoundTask.java,getSource,151-151,[                    for (int i = 0; i < entries.length; i++) {],,getSource,149-149,[                    String[] entries = source.list();],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java,init,77-77,[        JPanel pan = (JPanel) getContentPane();],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java,messageLogged,164-164,[                    int i = Math.min(new Integer(gr).intValue() * 2, MAX);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java,messageLogged,164-164,[                    int i = Math.min(new Integer(gr).intValue() * 2, MAX);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java,messageLogged,161-161,[            if (matcher != null && matcher.matches()) {],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/splash/SplashTask.java,execute,229-229,[                    splash = new SplashScreen(img, progressRegExp, displayText);],,execute,249-249,[                splash = new SplashScreen("Image Unavailable.", progressRegExp,],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/tools/ant/taskdefs/optional/splash/SplashTask.java,execute,149-149,[            splash = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/taskdefs/optional/unix/Symlink.java,loadLinks,579-579,[                lnks.list(new PrintStream(],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/taskdefs/optional/unix/Symlink.java,record,269-269,[                Vector linksInDir = (Vector) byDir.get(dir);],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/unix/SymlinkTest.java,tearDown,290-290,[    }],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/tools/ant/taskdefs/optional/vss/MSVSSTest.java,checkCommandLines,425-425,[                if (sGeneratedCmdLine[genIndex] == "") {],,checkCommandLines,442-442,[            if (sGeneratedCmdLine[i] == "") {],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/taskdefs/optional/vss/MSVSSTest.java,tearDown,86-86,[    }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/ant/taskdefs/optional/vss/MSVSSTest.java,testGetCommandLine,90-117,[        String[] sTestCmdLine = {MSVSS.SS_EXE, MSVSS.COMMAND_GET, DS_VSS_PROJECT_PATH,,                 MSVSS.FLAG_OVERRIDE_WORKING_DIR + project.getBaseDir().getAbsolutePath(),                  + File.separator + LOCAL_PATH, MSVSS.FLAG_AUTORESPONSE_DEF,,                 MSVSS.FLAG_RECURSION, MSVSS.FLAG_VERSION + VERSION, MSVSS.FLAG_LOGIN,                  + VSS_USERNAME + "," + VSS_PASSWORD, FLAG_FILETIME_UPDATED, FLAG_SKIP_WRITABLE};, ,         // Set up a VSSGet task,         MSVSSGET vssGet = new MSVSSGET();,         vssGet.setProject(project);,         vssGet.setRecursive(true);,         vssGet.setLocalpath(new Path(project, LOCAL_PATH));,         vssGet.setLogin(VSS_USERNAME + "," + VSS_PASSWORD);,         vssGet.setVersion(VERSION);,         vssGet.setQuiet(false);,         vssGet.setDate(DATE);,         vssGet.setLabel(SRC_LABEL);,         vssGet.setVsspath(VSS_PROJECT_PATH);,         MSVSS.CurrentModUpdated cmu = new MSVSS.CurrentModUpdated();,         cmu.setValue(TIME_UPDATED);,         vssGet.setFileTimeStamp(cmu);,         MSVSS.WritableFiles wf = new MSVSS.WritableFiles();,         wf.setValue(WRITABLE_SKIP);,         vssGet.setWritableFiles(wf);, ,         commandline = vssGet.buildCmdLine();, ,         checkCommandLines(sTestCmdLine, commandline.getCommandline());,     }],,testGetCommandline,57-95,[        CommandlineJava c = new CommandlineJava();,         c.createArgument().setValue("org.apache.tools.ant.CommandlineJavaTest");,         c.setClassname("junit.textui.TestRunner");,         c.createVmArgument().setValue("-Djava.compiler=NONE");,         String[] s = c.getCommandline();,         assertEquals("no classpath", 4, s.length);,         /*,          * After changing CommandlineJava to search for the java,          * executable, I don't know, how to tests the value returned,          * here without using the same logic as applied in the class,          * itself.,          *,          * assertTrue("no classpath", "java", s[0]);,          */,         assertEquals("no classpath", "-Djava.compiler=NONE", s[1]);,         assertEquals("no classpath", "junit.textui.TestRunner", s[2]);,         assertEquals("no classpath",,                      "org.apache.tools.ant.CommandlineJavaTest", s[3]);,         try {,             CommandlineJava c2 = (CommandlineJava) c.clone();,         } catch (NullPointerException ex) {,             fail("cloning should work without classpath specified");,         }, ,         c.createClasspath(project).setLocation(project.resolveFile("build.xml"));,         c.createClasspath(project).setLocation(project.resolveFile(,             System.getProperty(MagicNames.ANT_HOME)+"/lib/ant.jar"));,         s = c.getCommandline();,         assertEquals("with classpath", 6, s.length);,         //        assertEquals("with classpath", "java", s[0]);,         assertEquals("with classpath", "-Djava.compiler=NONE", s[1]);,         assertEquals("with classpath", "-classpath", s[2]);,         assertTrue("build.xml contained",,                s[3].indexOf("build.xml"+java.io.File.pathSeparator) >= 0);,         assertTrue("ant.jar contained", s[3].endsWith("ant.jar"));,         assertEquals("with classpath", "junit.textui.TestRunner", s[4]);,         assertEquals("with classpath",,                      "org.apache.tools.ant.CommandlineJavaTest", s[5]);,     }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/taskdefs/optional/vss/MSVSSTest.java,tearDown,84-84,[            file.delete();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/taskdefs/rmic/DefaultRmicAdapter.java,mapFileName,390-390,[                return null;],,mapFileName,399-399,[                return null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/AbstractFileSet.java,,112-112,[        if (dir != null || defaultPatterns.hasPatterns(getProject())) {],,,156-156,[        return dir;],,,526-526,[        ds.setBasedir(dir);],,,529-529,[        p.log(getDataTypeName() + ": Setup scanner in dir " + dir],,,133-133,[        this.dir = dir;],,,478-478,[                if (dir == null) {],,,482-482,[                if (!dir.exists() && errorOnMissingDir) {],,,487-487,[                if (!dir.isDirectory() && dir.exists()) {],,,483-483,[                    throw new BuildException(dir.getAbsolutePath()],,,488-488,[                    throw new BuildException(dir.getAbsolutePath()],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/AbstractFileSet.java,,64-927,[    private PatternSet defaultPatterns = new PatternSet();,     private Vector additionalPatterns = new Vector();,     private Vector selectors = new Vector();, ,     private File dir;,     private boolean useDefaultExcludes = true;,     private boolean caseSensitive = true;,     private boolean followSymlinks = true;,     private boolean errorOnMissingDir = true;,     private int maxLevelsOfSymlinks = DirectoryScanner.MAX_LEVELS_OF_SYMLINKS;, ,     /* cached DirectoryScanner instance for our own Project only */,     private DirectoryScanner directoryScanner = null;, ,     /**,      * Construct a new <code>AbstractFileSet</code>.,      */,     public AbstractFileSet() {,         super();,     }, ,     /**,      * Construct a new <code>AbstractFileSet</code>, shallowly cloned,      * from the specified <code>AbstractFileSet</code>.,      * @param fileset the <code>AbstractFileSet</code> to use as a template.,      */,     protected AbstractFileSet(AbstractFileSet fileset) {,         this.dir = fileset.dir;,         this.defaultPatterns = fileset.defaultPatterns;,         this.additionalPatterns = fileset.additionalPatterns;,         this.selectors = fileset.selectors;,         this.useDefaultExcludes = fileset.useDefaultExcludes;,         this.caseSensitive = fileset.caseSensitive;,         this.followSymlinks = fileset.followSymlinks;,         this.errorOnMissingDir = fileset.errorOnMissingDir;,         this.maxLevelsOfSymlinks = fileset.maxLevelsOfSymlinks;,         setProject(fileset.getProject());,     }, ,     /**,      * Makes this instance in effect a reference to another instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      * @param r the <code>Reference</code> to use.,      * @throws BuildException on error,      */,     public void setRefid(Reference r) throws BuildException {,         if (dir != null || defaultPatterns.hasPatterns(getProject())) {,             throw tooManyAttributes();,         },         if (!additionalPatterns.isEmpty()) {,             throw noChildrenAllowed();,         },         if (!selectors.isEmpty()) {,             throw noChildrenAllowed();,         },         super.setRefid(r);,     }, ,     /**,      * Sets the base-directory for this instance.,      * @param dir the directory's <code>File</code> instance.,      * @throws BuildException on error,      */,     public synchronized void setDir(File dir) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.dir = dir;,         directoryScanner = null;,     }, ,     /**,      * Retrieves the base-directory for this instance.,      * @return <code>File</code>.,      */,     public File getDir() {,         return getDir(getProject());,     }, ,     /**,      * Retrieves the base-directory for this instance.,      * @param p the <code>Project</code> against which the,      *          reference is resolved, if set.,      * @return <code>File</code>.,      */,     public synchronized File getDir(Project p) {,         if (isReference()) {,             return getRef(p).getDir(p);,         },         dieOnCircularReference();,         return dir;,     }, ,     /**,      * Creates a nested patternset.,      * @return <code>PatternSet</code>.,      */,     public synchronized PatternSet createPatternSet() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         PatternSet patterns = new PatternSet();,         additionalPatterns.addElement(patterns);,         directoryScanner = null;,         return patterns;,     }, ,     /**,      * Add a name entry to the include list.,      * @return <code>PatternSet.NameEntry</code>.,      */,     public synchronized PatternSet.NameEntry createInclude() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         directoryScanner = null;,         return defaultPatterns.createInclude();,     }, ,     /**,      * Add a name entry to the include files list.,      * @return <code>PatternSet.NameEntry</code>.,      */,     public synchronized PatternSet.NameEntry createIncludesFile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         directoryScanner = null;,         return defaultPatterns.createIncludesFile();,     }, ,     /**,      * Add a name entry to the exclude list.,      * @return <code>PatternSet.NameEntry</code>.,      */,     public synchronized PatternSet.NameEntry createExclude() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         directoryScanner = null;,         return defaultPatterns.createExclude();,     }, ,     /**,      * Add a name entry to the excludes files list.,      * @return <code>PatternSet.NameEntry</code>.,      */,     public synchronized PatternSet.NameEntry createExcludesFile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         directoryScanner = null;,         return defaultPatterns.createExcludesFile();,     }, ,     /**,      * Creates a single file fileset.,      * @param file the single <code>File</code> included in this,      *             <code>AbstractFileSet</code>.,      */,     public synchronized void setFile(File file) {,         if (isReference()) {,             throw tooManyAttributes();,         },         setDir(file.getParentFile());,         createInclude().setName(file.getName());,     }, ,     /**,      * Appends <code>includes</code> to the current list of include,      * patterns.,      *,      * <p>Patterns may be separated by a comma or a space.</p>,      *,      * @param includes the <code>String</code> containing the include patterns.,      */,     public synchronized void setIncludes(String includes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         defaultPatterns.setIncludes(includes);,         directoryScanner = null;,     }, ,     /**,      * Appends <code>includes</code> to the current list of include,      * patterns.,      *,      * @param includes array containing the include patterns.,      * @since Ant 1.7,      */,     public synchronized void appendIncludes(String[] includes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (includes != null) {,             for (int i = 0; i < includes.length; i++) {,                 defaultPatterns.createInclude().setName(includes[i]);,             },             directoryScanner = null;,         },     }, ,     /**,      * Appends <code>excludes</code> to the current list of exclude,      * patterns.,      *,      * <p>Patterns may be separated by a comma or a space.</p>,      *,      * @param excludes the <code>String</code> containing the exclude patterns.,      */,     public synchronized void setExcludes(String excludes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         defaultPatterns.setExcludes(excludes);,         directoryScanner = null;,     }, ,     /**,      * Appends <code>excludes</code> to the current list of include,      * patterns.,      *,      * @param excludes array containing the exclude patterns.,      * @since Ant 1.7,      */,     public synchronized void appendExcludes(String[] excludes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (excludes != null) {,             for (int i = 0; i < excludes.length; i++) {,                 defaultPatterns.createExclude().setName(excludes[i]);,             },             directoryScanner = null;,         },     }, ,     /**,      * Sets the <code>File</code> containing the includes patterns.,      *,      * @param incl <code>File</code> instance.,      * @throws BuildException on error,      */,     public synchronized void setIncludesfile(File incl) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         defaultPatterns.setIncludesfile(incl);,         directoryScanner = null;,     }, ,     /**,      * Sets the <code>File</code> containing the excludes patterns.,      *,      * @param excl <code>File</code> instance.,      * @throws BuildException on error,      */,     public synchronized void setExcludesfile(File excl) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         defaultPatterns.setExcludesfile(excl);,         directoryScanner = null;,     }, ,     /**,      * Sets whether default exclusions should be used or not.,      *,      * @param useDefaultExcludes <code>boolean</code>.,      */,     public synchronized void setDefaultexcludes(boolean useDefaultExcludes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.useDefaultExcludes = useDefaultExcludes;,         directoryScanner = null;,     }, ,     /**,      * Whether default exclusions should be used or not.,      * @return the default exclusions value.,      * @since Ant 1.6.3,      */,     public synchronized boolean getDefaultexcludes() {,         if (isReference()) {,             return getRef(getProject()).getDefaultexcludes();,         },         dieOnCircularReference();,         return useDefaultExcludes;,     }, ,     /**,      * Sets case sensitivity of the file system.,      *,      * @param caseSensitive <code>boolean</code>.,      */,     public synchronized void setCaseSensitive(boolean caseSensitive) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.caseSensitive = caseSensitive;,         directoryScanner = null;,     }, ,     /**,      * Find out if the fileset is case sensitive.,      *,      * @return <code>boolean</code> indicating whether the fileset is,      * case sensitive.,      *,      * @since Ant 1.7,      */,     public synchronized boolean isCaseSensitive() {,         if (isReference()) {,             return getRef(getProject()).isCaseSensitive();,         },         dieOnCircularReference();,         return caseSensitive;,     }, ,     /**,      * Sets whether or not symbolic links should be followed.,      *,      * @param followSymlinks whether or not symbolic links should be followed.,      */,     public synchronized void setFollowSymlinks(boolean followSymlinks) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.followSymlinks = followSymlinks;,         directoryScanner = null;,     }, ,     /**,      * Find out if the fileset wants to follow symbolic links.,      *,      * @return <code>boolean</code> indicating whether symbolic links,      *         should be followed.,      *,      * @since Ant 1.6,      */,     public synchronized boolean isFollowSymlinks() {,         if (isReference()) {,             return getRef(getProject()).isCaseSensitive();,         },         dieOnCircularReference();,         return followSymlinks;,     }, ,     /**,      * The maximum number of times a symbolic link may be followed,      * during a scan.,      *,      * @since Ant 1.8.0,      */,     public void setMaxLevelsOfSymlinks(int max) {,         maxLevelsOfSymlinks = max;,     }, ,     /**,      * The maximum number of times a symbolic link may be followed,      * during a scan.,      *,      * @since Ant 1.8.0,      */,     public int getMaxLevelsOfSymlinks() {,         return maxLevelsOfSymlinks;,     }, ,     /**,      * Sets whether an error is thrown if a directory does not exist.,      *,      * @param errorOnMissingDir true if missing directories cause errors,,      *                        false if not.,      */,      public void setErrorOnMissingDir(boolean errorOnMissingDir) {,          this.errorOnMissingDir = errorOnMissingDir;,      }, ,     /**,      * Gets whether an error is/shold be thrown if the base directory,      * does not exist.,      * @since Ant 1.8.2,      */,      public boolean getErrorOnMissingDir() {,          return errorOnMissingDir;,      }, ,     /**,      * Returns the directory scanner needed to access the files to process.,      * @return a <code>DirectoryScanner</code> instance.,      */,     public DirectoryScanner getDirectoryScanner() {,         return getDirectoryScanner(getProject());,     }, ,     /**,      * Returns the directory scanner needed to access the files to process.,      * @param p the Project against which the DirectoryScanner should be configured.,      * @return a <code>DirectoryScanner</code> instance.,      */,     public DirectoryScanner getDirectoryScanner(Project p) {,         if (isReference()) {,             return getRef(p).getDirectoryScanner(p);,         },         dieOnCircularReference();,         DirectoryScanner ds = null;,         synchronized (this) {,             if (directoryScanner != null && p == getProject()) {,                 ds = directoryScanner;,             } else {,                 if (dir == null) {,                     throw new BuildException("No directory specified for ",                                              + getDataTypeName() + ".");,                 },                 if (!dir.exists() && errorOnMissingDir) {,                     throw new BuildException(dir.getAbsolutePath(),                                              + DirectoryScanner,                                              .DOES_NOT_EXIST_POSTFIX);,                 },                 if (!dir.isDirectory() && dir.exists()) {,                     throw new BuildException(dir.getAbsolutePath(),                                              + " is not a directory.");,                 },                 ds = new DirectoryScanner();,                 setupDirectoryScanner(ds, p);,                 ds.setFollowSymlinks(followSymlinks);,                 ds.setErrorOnMissingDir(errorOnMissingDir);,                 ds.setMaxLevelsOfSymlinks(maxLevelsOfSymlinks);,                 directoryScanner = (p == getProject()) ? ds : directoryScanner;,             },         },         ds.scan();,         return ds;,     }, ,     /**,      * Set up the specified directory scanner against this,      * AbstractFileSet's Project.,      * @param ds a <code>FileScanner</code> instance.,      */,     public void setupDirectoryScanner(FileScanner ds) {,         setupDirectoryScanner(ds, getProject());,     }, ,     /**,      * Set up the specified directory scanner against the specified project.,      * @param ds a <code>FileScanner</code> instance.,      * @param p an Ant <code>Project</code> instance.,      */,     public synchronized void setupDirectoryScanner(FileScanner ds, Project p) {,         if (isReference()) {,             getRef(p).setupDirectoryScanner(ds, p);,             return;,         },         dieOnCircularReference(p);,         if (ds == null) {,             throw new IllegalArgumentException("ds cannot be null");,         },         ds.setBasedir(dir);, ,         PatternSet ps = mergePatterns(p);,         p.log(getDataTypeName() + ": Setup scanner in dir " + dir,             + " with " + ps, Project.MSG_DEBUG);, ,         ds.setIncludes(ps.getIncludePatterns(p));,         ds.setExcludes(ps.getExcludePatterns(p));,         if (ds instanceof SelectorScanner) {,             SelectorScanner ss = (SelectorScanner) ds;,             ss.setSelectors(getSelectors(p));,         },         if (useDefaultExcludes) {,             ds.addDefaultExcludes();,         },         ds.setCaseSensitive(caseSensitive);,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced FileSet.,      * @param p the current project,      * @return the referenced FileSet,      */,     protected AbstractFileSet getRef(Project p) {,         return (AbstractFileSet) getCheckedRef(p);,     }, ,     // SelectorContainer methods, ,     /**,      * Indicates whether there are any selectors here.,      *,      * @return whether any selectors are in this container.,      */,     public synchronized boolean hasSelectors() {,         if (isReference()) {,             return getRef(getProject()).hasSelectors();,         },         dieOnCircularReference();,         return !(selectors.isEmpty());,     }, ,     /**,      * Indicates whether there are any patterns here.,      *,      * @return whether any patterns are in this container.,      */,     public synchronized boolean hasPatterns() {,         if (isReference() && getProject() != null) {,             return getRef(getProject()).hasPatterns();,         },         dieOnCircularReference();,         if (defaultPatterns.hasPatterns(getProject())) {,             return true;,         },         Enumeration e = additionalPatterns.elements();,         while (e.hasMoreElements()) {,             PatternSet ps = (PatternSet) e.nextElement();,             if (ps.hasPatterns(getProject())) {,                 return true;,             },         },         return false;,     }, ,     /**,      * Gives the count of the number of selectors in this container.,      *,      * @return the number of selectors in this container as an <code>int</code>.,      */,     public synchronized int selectorCount() {,         if (isReference()) {,             return getRef(getProject()).selectorCount();,         },         dieOnCircularReference();,         return selectors.size();,     }, ,     /**,      * Returns the set of selectors as an array.,      * @param p the current project,      * @return a <code>FileSelector[]</code> of the selectors in this container.,      */,     public synchronized FileSelector[] getSelectors(Project p) {,         if (isReference()) {,             return getRef(getProject()).getSelectors(p);,         },         dieOnCircularReference(p);,         return (FileSelector[]) (selectors.toArray(,             new FileSelector[selectors.size()]));,     }, ,     /**,      * Returns an enumerator for accessing the set of selectors.,      *,      * @return an <code>Enumeration</code> of selectors.,      */,     public synchronized Enumeration selectorElements() {,         if (isReference()) {,             return getRef(getProject()).selectorElements();,         },         dieOnCircularReference();,         return selectors.elements();,     }, ,     /**,      * Add a new selector into this container.,      *,      * @param selector the new <code>FileSelector</code> to add.,      */,     public synchronized void appendSelector(FileSelector selector) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         selectors.addElement(selector);,         directoryScanner = null;,         setChecked(false);,     }, ,     /* Methods below all add specific selectors */, ,     /**,      * Add a "Select" selector entry on the selector list.,      * @param selector the <code>SelectSelector</code> to add.,      */,     public void addSelector(SelectSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add an "And" selector entry on the selector list.,      * @param selector the <code>AndSelector</code> to add.,      */,     public void addAnd(AndSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add an "Or" selector entry on the selector list.,      * @param selector the <code>OrSelector</code> to add.,      */,     public void addOr(OrSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a "Not" selector entry on the selector list.,      * @param selector the <code>NotSelector</code> to add.,      */,     public void addNot(NotSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a "None" selector entry on the selector list.,      * @param selector the <code>NoneSelector</code> to add.,      */,     public void addNone(NoneSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a majority selector entry on the selector list.,      * @param selector the <code>MajoritySelector</code> to add.,      */,     public void addMajority(MajoritySelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a selector date entry on the selector list.,      * @param selector the <code>DateSelector</code> to add.,      */,     public void addDate(DateSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a selector size entry on the selector list.,      * @param selector the <code>SizeSelector</code> to add.,      */,     public void addSize(SizeSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a DifferentSelector entry on the selector list.,      * @param selector the <code>DifferentSelector</code> to add.,      */,     public void addDifferent(DifferentSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a selector filename entry on the selector list.,      * @param selector the <code>FilenameSelector</code> to add.,      */,     public void addFilename(FilenameSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a selector type entry on the selector list.,      * @param selector the <code>TypeSelector</code> to add.,      */,     public void addType(TypeSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add an extended selector entry on the selector list.,      * @param selector the <code>ExtendSelector</code> to add.,      */,     public void addCustom(ExtendSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a contains selector entry on the selector list.,      * @param selector the <code>ContainsSelector</code> to add.,      */,     public void addContains(ContainsSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a present selector entry on the selector list.,      * @param selector the <code>PresentSelector</code> to add.,      */,     public void addPresent(PresentSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a depth selector entry on the selector list.,      * @param selector the <code>DepthSelector</code> to add.,      */,     public void addDepth(DepthSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a depends selector entry on the selector list.,      * @param selector the <code>DependSelector</code> to add.,      */,     public void addDepend(DependSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add a regular expression selector entry on the selector list.,      * @param selector the <code>ContainsRegexpSelector</code> to add.,      */,     public void addContainsRegexp(ContainsRegexpSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Add the modified selector.,      * @param selector the <code>ModifiedSelector</code> to add.,      * @since ant 1.6,      */,     public void addModified(ModifiedSelector selector) {,         appendSelector(selector);,     }, ,     public void addReadable(ReadableSelector r) {,         appendSelector(r);,     }, ,     public void addWritable(WritableSelector w) {,         appendSelector(w);,     }, ,     /**,      * Add an arbitary selector.,      * @param selector the <code>FileSelector</code> to add.,      * @since Ant 1.6,      */,     public void add(FileSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * Returns included files as a list of semicolon-separated filenames.,      *,      * @return a <code>String</code> of included filenames.,      */,     public String toString() {,         if (isReference()) {,             return getRef(getProject()).toString();,         },         dieOnCircularReference();,         DirectoryScanner ds = getDirectoryScanner(getProject());,         String[] files = ds.getIncludedFiles();,         StringBuffer sb = new StringBuffer();, ,         for (int i = 0; i < files.length; i++) {,             if (i > 0) {,                 sb.append(';');,             },             sb.append(files[i]);,         },         return sb.toString();,     }, ,     /**,      * Creates a deep clone of this instance, except for the nested,      * selectors (the list of selectors is a shallow clone of this,      * instance's list).,      * @return the cloned object,      * @since Ant 1.6,      */,     public synchronized Object clone() {,         if (isReference()) {,             return (getRef(getProject())).clone();,         } else {,             try {,                 AbstractFileSet fs = (AbstractFileSet) super.clone();,                 fs.defaultPatterns = (PatternSet) defaultPatterns.clone();,                 fs.additionalPatterns = new Vector(additionalPatterns.size());,                 Enumeration e = additionalPatterns.elements();,                 while (e.hasMoreElements()) {,                     fs.additionalPatterns,                         .addElement(((PatternSet) e.nextElement()).clone());,                 },                 fs.selectors = new Vector(selectors);,                 return fs;,             } catch (CloneNotSupportedException e) {,                 throw new BuildException(e);,             },         },     }, ,     /**,      * Get the merged include patterns for this AbstractFileSet.,      * @param p the project to use.,      * @return the include patterns of the default pattern set and all,      * nested patternsets.,      *,      * @since Ant 1.7,      */,     public String[] mergeIncludes(Project p) {,         return mergePatterns(p).getIncludePatterns(p);,     }, ,     /**,      * Get the merged exclude patterns for this AbstractFileSet.,      * @param p the project to use.,      * @return the exclude patterns of the default pattern set and all,      * nested patternsets.,      *,      * @since Ant 1.7,      */,     public String[] mergeExcludes(Project p) {,         return mergePatterns(p).getExcludePatterns(p);,     }, ,     /**,      * Get the merged patterns for this AbstractFileSet.,      * @param p the project to use.,      * @return the default patternset merged with the additional sets,      * in a new PatternSet instance.,      *,      * @since Ant 1.7,      */,     public synchronized PatternSet mergePatterns(Project p) {,         if (isReference()) {,             return getRef(p).mergePatterns(p);,         },         dieOnCircularReference();,         PatternSet ps = (PatternSet) defaultPatterns.clone();,         final int count = additionalPatterns.size();,         for (int i = 0; i < count; i++) {,             Object o = additionalPatterns.elementAt(i);,             ps.append((PatternSet) o, p);,         },         return ps;,     }, ,     protected synchronized void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             for (Iterator i = selectors.iterator(); i.hasNext(); ) {,                 Object o = i.next();,                 if (o instanceof DataType) {,                     pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);,                 },             },             for (Iterator i = additionalPatterns.iterator(); i.hasNext(); ) {,                 PatternSet ps = (PatternSet) i.next();,                 pushAndInvokeCircularReferenceCheck(ps, stk, p);,             },             setChecked(true);,         },     }],,
MT_CORRECTNESS,UG_SYNC_SET_UNSYNC_GET,org/apache/tools/ant/types/AbstractFileSet.java,getDir,142-142,[        return getDir(getProject());],,setDir,130-135,[        if (isReference()) {,             throw tooManyAttributes();,         },         this.dir = dir;,         directoryScanner = null;,     }],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/AbstractFileSetTest.java,testEmptyElementIfIsReference,103-103,[            f.setIncludesfile(new File("/a"));],,testEmptyElementIfIsReference,121-121,[            f.setExcludesfile(new File("/a"));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/AbstractFileSetTest.java,testCircularReferenceCheck,187-187,[        project.addReference("dummy", f);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/AbstractFileSetTest.java,testEmptyElementIfIsReference,130-130,[            f.setDir(project.resolveFile("."));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/AddTypeTest.java,eval,135-135,[            project.log("My Condition eval");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/AddTypeTest.java,execute,139-139,[            project.log("My Condition execution");],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/AntFilterReader.java,,29-176,[public final class AntFilterReader,     extends DataType implements Cloneable {, ,     private String className;, ,     private final Vector parameters = new Vector();, ,     private Path classpath;, ,     /**,      * Set the className attribute.,      *,      * @param className a <code>String</code> value,      */,     public void setClassName(final String className) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.className = className;,     }, ,     /**,      * Get the className attribute.,      *,      * @return a <code>String</code> value,      */,     public String getClassName() {,         if (isReference()) {,             return ((AntFilterReader) getCheckedRef()).getClassName();,         },         dieOnCircularReference();,         return className;,     }, ,     /**,      * Add a Parameter.,      *,      * @param param a <code>Parameter</code> value,      */,     public void addParam(final Parameter param) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         parameters.addElement(param);,     }, ,     /**,      * Set the classpath to load the FilterReader through (attribute).,      * @param classpath a classpath,      */,     public void setClasspath(Path classpath) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (this.classpath == null) {,             this.classpath = classpath;,         } else {,             this.classpath.append(classpath);,         },         setChecked(false);,     }, ,     /**,      * Set the classpath to load the FilterReader through (nested element).,      * @return a classpath to be configured,      */,     public Path createClasspath() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (this.classpath == null) {,             this.classpath = new Path(getProject());,         },         setChecked(false);,         return this.classpath.createPath();,     }, ,     /**,      * Get the classpath.,      * @return the classpath,      */,     public Path getClasspath() {,         if (isReference()) {,             ((AntFilterReader) getCheckedRef()).getClasspath();,         },         dieOnCircularReference();,         return classpath;,     }, ,     /**,      * Set the classpath to load the FilterReader through via,      * reference (attribute).,      * @param r a reference to a classpath,      */,     public void setClasspathRef(Reference r) {,         if (isReference()) {,             throw tooManyAttributes();,         },         createClasspath().setRefid(r);,     }, ,     /**,      * The parameters for this filter.,      *,      * @return a <code>Parameter[]</code> value,      */,     public Parameter[] getParams() {,         if (isReference()) {,             ((AntFilterReader) getCheckedRef()).getParams();,         },         dieOnCircularReference();,         Parameter[] params = new Parameter[parameters.size()];,         parameters.copyInto(params);,         return params;,     }, ,     /**,      * Makes this instance in effect a reference to another AntFilterReader,      * instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      *,      * @param r the reference to which this instance is associated,      * @exception BuildException if this instance already has been configured.,      */,     public void setRefid(Reference r) throws BuildException {,         if (!parameters.isEmpty() || className != null,                 || classpath != null) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     protected synchronized void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (classpath != null) {,                 pushAndInvokeCircularReferenceCheck(classpath, stk, p);,             },             setChecked(true);,         },     }],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/types/ArchiveFileSet.java,iterator,318-318,[        ArchiveScanner as = (ArchiveScanner) getDirectoryScanner(getProject());],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/types/ArchiveFileSet.java,size,334-334,[        ArchiveScanner as = (ArchiveScanner) getDirectoryScanner(getProject());],,
BAD_PRACTICE,NP_TOSTRING_COULD_RETURN_NULL,org/apache/tools/ant/types/ArchiveFileSet.java,toString,493-493,[        return src == null ? null : src.getName();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/ArchiveScanner.java,scanme,323-323,[        if (!src.isExists() && !errorOnMissingArchive) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/Assertions.java,,69-258,[public class Assertions extends DataType implements Cloneable {, ,     /**,      * enable/disable sys assertions; null means undefined,      */,     private Boolean enableSystemAssertions;, ,     /**,      * list of type BaseAssertion,      */,     private ArrayList assertionList = new ArrayList();, , ,     /**,      * enable assertions,      * @param assertion an enable assertion nested element,      */,     public void addEnable(EnabledAssertion assertion) {,         checkChildrenAllowed();,         assertionList.add(assertion);,     }, ,     /**,      * disable assertions,      * @param assertion a disable assertion nested element,      */,     public void addDisable(DisabledAssertion assertion) {,         checkChildrenAllowed();,         assertionList.add(assertion);,     }, ,     /**,      * enable or disable system assertions.,      * Default is not set (neither -enablesystemassersions or -disablesytemassertions,      * are used on the command line).,      * @param enableSystemAssertions if true enable system assertions,      */,     public void setEnableSystemAssertions(Boolean enableSystemAssertions) {,         checkAttributesAllowed();,         this.enableSystemAssertions = enableSystemAssertions;,     }, ,     /**,      * Set the value of the refid attribute.,      *,      * <p>Subclasses may need to check whether any other attributes,      * have been set as well or child elements have been created and,      * thus override this method. if they do the must call,      * <code>super.setRefid</code>.</p>,      * @param ref the reference to use,      */,     public void setRefid(Reference ref) {,         if (assertionList.size() > 0 || enableSystemAssertions != null) {,             throw tooManyAttributes();,         },         super.setRefid(ref);,     }, ,     /**,      * get whatever we are referencing to. This could be ourself.,      * @return the object that contains the assertion info,      */,     private Assertions getFinalReference() {,         if (getRefid() == null) {,             return this;,         } else {,             Object o = getRefid().getReferencedObject(getProject());,             if (!(o instanceof Assertions)) {,                 throw new BuildException("reference is of wrong type");,             },             return (Assertions) o;,         },     }, ,     /**,      * how many assertions are made...will resolve references before returning,      * @return total # of commands to make,      */,     public int size() {,         Assertions clause = getFinalReference();,         return clause.getFinalSize();,     }, , ,     /**,      * what is the final size of this object,      * @return,      */,     private int getFinalSize() {,         return assertionList.size() + (enableSystemAssertions != null ? 1 : 0);,     }, ,     /**,      * add the assertions to a list in a format suitable,      * for adding to a command line,      * @param commandList the command line to format,      */,     public void applyAssertions(List commandList) {,         getProject().log("Applying assertions", Project.MSG_DEBUG);,         Assertions clause = getFinalReference();,         //do the system assertions,         if (Boolean.TRUE.equals(clause.enableSystemAssertions)) {,             getProject().log("Enabling system assertions", Project.MSG_DEBUG);,             commandList.add("-enablesystemassertions");,         } else if (Boolean.FALSE.equals(clause.enableSystemAssertions)) {,             getProject().log("disabling system assertions", Project.MSG_DEBUG);,             commandList.add("-disablesystemassertions");,         }, ,         //now any inner assertions,         Iterator it = clause.assertionList.iterator();,         while (it.hasNext()) {,             BaseAssertion assertion = (BaseAssertion) it.next();,             String arg = assertion.toCommand();,             getProject().log("adding assertion " + arg, Project.MSG_DEBUG);,             commandList.add(arg);,         },     }, ,     /**,      * apply all the assertions to the command.,      * @param command the command line to format,      */,     public void applyAssertions(CommandlineJava command) {,         Assertions clause = getFinalReference();,         //do the system assertions,         if (Boolean.TRUE.equals(clause.enableSystemAssertions)) {,             addVmArgument(command, "-enablesystemassertions");,         } else if (Boolean.FALSE.equals(clause.enableSystemAssertions)) {,             addVmArgument(command, "-disablesystemassertions");,         }, ,         //now any inner assertions,         Iterator it = clause.assertionList.iterator();,         while (it.hasNext()) {,             BaseAssertion assertion = (BaseAssertion) it.next();,             String arg = assertion.toCommand();,             addVmArgument(command, arg);,         },     }, ,     /**,      * add the assertions to a list in a format suitable,      * for adding to a command line,      * @param commandIterator list of commands,      */,     public void applyAssertions(final ListIterator commandIterator) {,         getProject().log("Applying assertions", Project.MSG_DEBUG);,         Assertions clause = getFinalReference();,         //do the system assertions,         if (Boolean.TRUE.equals(clause.enableSystemAssertions)) {,             getProject().log("Enabling system assertions", Project.MSG_DEBUG);,             commandIterator.add("-enablesystemassertions");,         } else if (Boolean.FALSE.equals(clause.enableSystemAssertions)) {,             getProject().log("disabling system assertions", Project.MSG_DEBUG);,             commandIterator.add("-disablesystemassertions");,         }, ,         //now any inner assertions,         Iterator it = clause.assertionList.iterator();,         while (it.hasNext()) {,             BaseAssertion assertion = (BaseAssertion) it.next();,             String arg = assertion.toCommand();,             getProject().log("adding assertion " + arg, Project.MSG_DEBUG);,             commandIterator.add(arg);,         },     }, ,     /**,      * helper method to add a string JVM argument to a command,      * @param command,      * @param arg,      */,     private static void addVmArgument(CommandlineJava command, String arg) {,         Commandline.Argument argument;,         argument = command.createVmArgument();,         argument.setValue(arg);,     }, ,     /**,      * clone the objects.,      * This is not a full depth clone; the list of assertions is cloned,,      * but it does not clone the underlying assertions.,      * @return a cli,      * @throws CloneNotSupportedException if the super class does not support cloning,      */,     public Object clone() throws CloneNotSupportedException {,         Assertions that = (Assertions) super.clone();,         that.assertionList = (ArrayList) assertionList.clone();,         return that;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/types/AssertionsTest.java,tearDown,37-37,[    }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/Commandline.java,translateCommandline,84-84,[        if (tmp != null && tmp.length > 0) {],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/Commandline.java,getParts,193-193,[                return parts;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/CommandlineJava.java,getVariables,96-96,[                return null;],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/tools/ant/types/CommandlineJava.java,setSystem,143-143,[                    String value = sys.getProperty(name);],,setSystem,144-144,[                    if (name != null && value != null) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/types/CommandlineJavaTest.java,testGetCommandline,76-76,[            CommandlineJava c2 = (CommandlineJava) c.clone();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/CommandlineJavaTest.java,testGetCommandline,81-81,[        c.createClasspath(project).setLocation(project.resolveFile("build.xml"));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/CommandlineJavaTest.java,testSysproperties,121-121,[        project.setProperty("key2", "value2");],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/types/CommandlineTest.java,testTokenizer,117-117,[            s = Commandline.translateCommandline("a \"b c");],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/Comparison.java,getValues,77-77,[        return VALUES;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/DataType.java,,40-356,[public abstract class DataType extends ProjectComponent implements Cloneable {,     // CheckStyle:VisibilityModifier OFF, ,     /**,      * Value to the refid attribute.,      *,      * @deprecated since 1.7.,      *             The user should not be directly referencing,      *             variable. Please use {@link #getRefid} instead.,      */,     protected Reference ref;, ,     /**,      * Are we sure we don't hold circular references?,      *,      * <p>Subclasses are responsible for setting this value to false,      * if we'd need to investigate this condition (usually because a,      * child element has been added that is a subclass of,      * DataType).</p>,      *,      * @deprecated since 1.7.,      *             The user should not be directly referencing,      *             variable. Please use {@link #setChecked} or,      *             {@link #isChecked} instead.,      */,     protected boolean checked = true;,     // CheckStyle:VisibilityModifier ON, ,     /**,      * Has the refid attribute of this element been set?,      * @return true if the refid attribute has been set,      */,     public boolean isReference() {,         return ref != null;,     }, ,     /**,      * Set the value of the refid attribute.,      *,      * <p>Subclasses may need to check whether any other attributes,      * have been set as well or child elements have been created and,      * thus override this method. if they do the must call,      * <code>super.setRefid</code>.</p>,      * @param ref the reference to use,      */,     public void setRefid(final Reference ref) {,         this.ref = ref;,         checked = false;,     }, ,     /**,      * Gets as descriptive as possible a name used for this datatype instance.,      * @return <code>String</code> name.,      */,     protected String getDataTypeName() {,         return ComponentHelper.getElementName(getProject(), this, true);,     }, ,     /**,      * Convenience method.,      * @since Ant 1.7,      */,     protected void dieOnCircularReference() {,         dieOnCircularReference(getProject());,     }, ,     /**,      * Convenience method.,      * @param p the Ant Project instance against which to resolve references.,      * @since Ant 1.7,      */,     protected void dieOnCircularReference(Project p) {,         if (checked || !isReference()) {,             return;,         },         dieOnCircularReference(new IdentityStack(this), p);,     }, ,     /**,      * Check to see whether any DataType we hold references to is,      * included in the Stack (which holds all DataType instances that,      * directly or indirectly reference this instance, including this,      * instance itself).,      *,      * <p>If one is included, throw a BuildException created by {@link,      * #circularReference circularReference}.</p>,      *,      * <p>This implementation is appropriate only for a DataType that,      * cannot hold other DataTypes as children.</p>,      *,      * <p>The general contract of this method is that it shouldn't do,      * anything if {@link #checked <code>checked</code>} is true and,      * set it to true on exit.</p>,      * @param stack the stack of references to check.,      * @param project the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected void dieOnCircularReference(final Stack stack,,                                           final Project project),         throws BuildException {, ,         if (checked || !isReference()) {,             return;,         },         Object o = ref.getReferencedObject(project);, ,         if (o instanceof DataType) {,             IdentityStack id = IdentityStack.getInstance(stack);, ,             if (id.contains(o)) {,                 throw circularReference();,             } else {,                 id.push(o);,                 ((DataType) o).dieOnCircularReference(id, project);,                 id.pop();,             },         },         checked = true;,     }, ,     /**,      * Allow DataTypes outside org.apache.tools.ant.types to indirectly call,      * dieOnCircularReference on nested DataTypes.,      * @param dt the DataType to check.,      * @param stk the stack of references to check.,      * @param p the project to use to dereference the references.,      * @throws BuildException on error.,      * @since Ant 1.7,      */,     public static void invokeCircularReferenceCheck(DataType dt, Stack stk,,                                                     Project p) {,         dt.dieOnCircularReference(stk, p);,     }, ,     /**,      * Allow DataTypes outside org.apache.tools.ant.types to indirectly call,      * dieOnCircularReference on nested DataTypes.,      *,      * <p>Pushes dt on the stack, runs dieOnCircularReference and pops,      * it again.</p>,      * @param dt the DataType to check.,      * @param stk the stack of references to check.,      * @param p the project to use to dereference the references.,      * @throws BuildException on error.,      * @since Ant 1.8.0,      */,     public static void pushAndInvokeCircularReferenceCheck(DataType dt,,                                                            Stack stk,,                                                            Project p) {,         stk.push(dt);,         dt.dieOnCircularReference(stk, p);,         stk.pop();,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced object.,      * @return the dereferenced object.,      * @throws BuildException if the reference is invalid (circular ref, wrong class, etc).,      * @since Ant 1.7,      */,     protected Object getCheckedRef() {,         return getCheckedRef(getProject());,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced object.,      * @param p the Ant Project instance against which to resolve references.,      * @return the dereferenced object.,      * @throws BuildException if the reference is invalid (circular ref, wrong class, etc).,      * @since Ant 1.7,      */,     protected Object getCheckedRef(Project p) {,         return getCheckedRef(getClass(), getDataTypeName(), p);,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced object.,      * @param requiredClass the class that this reference should be a subclass of.,      * @param dataTypeName  the name of the datatype that the reference should be,      *                      (error message use only).,      * @return the dereferenced object.,      * @throws BuildException if the reference is invalid (circular ref, wrong class, etc).,      */,     protected Object getCheckedRef(final Class requiredClass,,                                    final String dataTypeName) {,         return getCheckedRef(requiredClass, dataTypeName, getProject());,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced object.  This version allows the fallback Project instance to be specified.,      * @param requiredClass the class that this reference should be a subclass of.,      * @param dataTypeName  the name of the datatype that the reference should be,      *                      (error message use only).,      * @param project       the fallback Project instance for dereferencing.,      * @return the dereferenced object.,      * @throws BuildException if the reference is invalid (circular ref, wrong class, etc),,      *                        or if <code>project</code> is <code>null</code>.,      * @since Ant 1.7,      */,     protected Object getCheckedRef(final Class requiredClass,,                                    final String dataTypeName, final Project project) {,         if (project == null) {,             throw new BuildException("No Project specified");,         },         dieOnCircularReference(project);,         Object o = ref.getReferencedObject(project);,         if (!(requiredClass.isAssignableFrom(o.getClass()))) {,             log("Class " + o.getClass() + " is not a subclass of " + requiredClass,,                     Project.MSG_VERBOSE);,             String msg = ref.getRefId() + " doesn\'t denote a " + dataTypeName;,             throw new BuildException(msg);,         },         return o;,     }, ,     /**,      * Creates an exception that indicates that refid has to be the,      * only attribute if it is set.,      * @return the exception to throw,      */,     protected BuildException tooManyAttributes() {,         return new BuildException("You must not specify more than one ",             + "attribute when using refid");,     }, ,     /**,      * Creates an exception that indicates that this XML element must,      * not have child elements if the refid attribute is set.,      * @return the exception to throw,      */,     protected BuildException noChildrenAllowed() {,         return new BuildException("You must not specify nested elements ",             + "when using refid");,     }, ,     /**,      * Creates an exception that indicates the user has generated a,      * loop of data types referencing each other.,      * @return the exception to throw,      */,     protected BuildException circularReference() {,         return new BuildException("This data type contains a circular ",             + "reference.");,     }, ,     /**,      * The flag that is used to indicate that circular references have been checked.,      * @return true if circular references have been checked,      */,     protected boolean isChecked() {,         return checked;,     }, ,     /**,      * Set the flag that is used to indicate that circular references have been checked.,      * @param checked if true, if circular references have been checked,      */,     protected void setChecked(final boolean checked) {,         this.checked = checked;,     }, ,     /**,      * get the reference set on this object,      * @return the reference or null,      */,     public Reference getRefid() {,         return ref;,     }, ,     /**,      * check that it is ok to set attributes, i.e that no reference is defined,      * @since Ant 1.6,      * @throws BuildException if not allowed,      */,     protected void checkAttributesAllowed() {,         if (isReference()) {,             throw tooManyAttributes();,         },     }, ,     /**,      * check that it is ok to add children, i.e that no reference is defined,      * @since Ant 1.6,      * @throws BuildException if not allowed,      */,     protected void checkChildrenAllowed() {,         if (isReference()) {,             throw noChildrenAllowed();,         },     }, ,     /**,      * Basic DataType toString().,      * @return this DataType formatted as a String.,      */,     public String toString() {,         String d = getDescription();,         return d == null ? getDataTypeName() : getDataTypeName() + " " + d;,     }, ,     /**,      * @since Ant 1.7,      * @return a shallow copy of this DataType.,      * @throws CloneNotSupportedException if there is a problem.,      */,     public Object clone() throws CloneNotSupportedException {,         DataType dt = (DataType) super.clone();,         dt.setDescription(getDescription());,         if (getRefid() != null) {,             dt.setRefid(getRefid());,         },         dt.setChecked(isChecked());,         return dt;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/DataType.java,dieOnCircularReference,144-144,[        Object o = ref.getReferencedObject(project);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/DataType.java,getCheckedRef,249-249,[        Object o = ref.getReferencedObject(project);],,getCheckedRef,253-253,[            String msg = ref.getRefId() + " doesn\'t denote a " + dataTypeName;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/Description.java,findElementInTarget,94-94,[        if (tasks == null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/Description.java,concatDescriptions,104-104,[            if (descComp != null) {],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/types/DescriptionTest.java,tearDown,37-37,[    }],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/DirSetTest.java,testToString,68-68,[            tmp.delete();],,testToString,83-83,[            new File(tmp, "a/x").delete();],,testToString,84-84,[            new File(tmp, "a").delete();],,testToString,85-85,[            new File(tmp, "b/c/x").delete();],,testToString,86-86,[            new File(tmp, "b/c").delete();],,testToString,87-87,[            new File(tmp, "b/x").delete();],,testToString,88-88,[            new File(tmp, "b").delete();],,testToString,89-89,[            tmp.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/DirSetTest.java,testToString,70-70,[            a.mkdirs();],,testToString,73-73,[            bc.mkdirs();],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/types/EnumeratedAttributeTest.java,testContains,41-41,[            assertTrue(expected[i].toUpperCase()+" is in TestNormal",],,testContains,42-42,[                   !t1.containsValue(expected[i].toUpperCase()));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/EnumeratedAttributeTest.java,getValues,92-92,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/Environment.java,getVariables,158-158,[            return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/Environment.java,getContent,117-117,[            StringBuffer sb = new StringBuffer(key.trim());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/Environment.java,getContent,118-118,[            sb.append("=").append(value.trim());],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/FilterChain.java,,48-415,[public class FilterChain extends DataType,     implements Cloneable {, ,     private Vector filterReaders = new Vector();, ,     /**,      * Add an AntFilterReader filter.,      *,      * @param filterReader an <code>AntFilterReader</code> value,      */,     public void addFilterReader(final AntFilterReader filterReader) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filterReader);,     }, ,     /**,      * Return the filters.,      *,      * @return a <code>Vector</code> value containing the filters,      */,     public Vector getFilterReaders() {,         if (isReference()) {,             return ((FilterChain) getCheckedRef()).getFilterReaders();,         },         dieOnCircularReference();,         return filterReaders;,     }, ,     /**,      * Add a ClassConstants filter.,      *,      * @param classConstants a <code>ClassConstants</code> value,      */,     public void addClassConstants(final ClassConstants classConstants) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(classConstants);,     }, ,     /**,      * Add an ExpandProperties filter.,      *,      * @param expandProperties an <code>ExpandProperties</code> value,      */,     public void addExpandProperties(final ExpandProperties expandProperties) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(expandProperties);,     }, ,     /**,      * Add a HeadFilter filter.,      *,      * @param headFilter a <code>HeadFilter</code> value,      */,     public void addHeadFilter(final HeadFilter headFilter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(headFilter);,     }, ,     /**,      * Add a LineContains filter.,      *,      * @param lineContains a <code>LineContains</code> value,      */,     public void addLineContains(final LineContains lineContains) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(lineContains);,     }, ,     /**,      * Add a LineContainsRegExp filter.,      *,      * @param lineContainsRegExp a <code>LineContainsRegExp</code> value,      */,     public void addLineContainsRegExp(final LineContainsRegExp,                                                 lineContainsRegExp) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(lineContainsRegExp);,     }, ,     /**,      * Add a PrefixLines filter.,      *,      * @param prefixLines a <code>PrefixLines</code> value,      */,     public void addPrefixLines(final PrefixLines prefixLines) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(prefixLines);,     }, ,     /**,      * Add a SuffixLines filter.,      *,      * @param suffixLines a <code>SuffixLines</code> value,      * @since Ant 1.8.0,      */,     public void addSuffixLines(final SuffixLines suffixLines) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(suffixLines);,     }, ,     /**,      * Add a ReplaceTokens filter.,      *,      * @param replaceTokens a <code>ReplaceTokens</code> value,      */,     public void addReplaceTokens(final ReplaceTokens replaceTokens) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(replaceTokens);,     }, ,     /**,      * Add a StripJavaCommands filter.,      *,      * @param stripJavaComments a <code>StripJavaComments</code> value,      */,     public void addStripJavaComments(final StripJavaComments,                                                 stripJavaComments) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(stripJavaComments);,     }, ,     /**,      * Add a StripLineBreaks filter.,      *,      * @param stripLineBreaks a <code>StripLineBreaks</code> value,      */,     public void addStripLineBreaks(final StripLineBreaks,                                                 stripLineBreaks) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(stripLineBreaks);,     }, ,     /**,      * Add a StripLineComments filter.,      *,      * @param stripLineComments a <code>StripLineComments</code> value,      */,     public void addStripLineComments(final StripLineComments,                                                 stripLineComments) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(stripLineComments);,     }, ,     /**,      * Add a TabsToSpaces filter.,      *,      * @param tabsToSpaces a <code>TabsToSpaces</code> value,      */,     public void addTabsToSpaces(final TabsToSpaces tabsToSpaces) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(tabsToSpaces);,     }, ,     /**,      * Add a TailFilter filter.,      *,      * @param tailFilter a <code>TailFilter</code> value,      */,     public void addTailFilter(final TailFilter tailFilter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(tailFilter);,     }, ,     /**,      * Add an EscapeUnicode filter.,      *,      * @param escapeUnicode an <code>EscapeUnicode</code> value,      * @since Ant 1.6,      */,     public void addEscapeUnicode(final EscapeUnicode escapeUnicode) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(escapeUnicode);,     }, ,     /**,      * Add a TokenFilter filter.,      *,      * @param tokenFilter a <code>TokenFilter</code> value,      * @since Ant 1.6,      */,     public void addTokenFilter(final TokenFilter tokenFilter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(tokenFilter);,     }, ,     /**,      * Add a delete characters filter.,      *,      * @param filter a <code>TokenFilter.DeleteCharacters</code> value,      * @since Ant 1.6,      */,     public void addDeleteCharacters(TokenFilter.DeleteCharacters filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add a containsregex filter.,      *,      * @param filter a <code>TokenFilter.ContainsRegex</code> value,      * @since Ant 1.6,      */,     public void addContainsRegex(TokenFilter.ContainsRegex filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add a replaceregex filter.,      *,      * @param filter a <code>TokenFilter.ReplaceRegex</code> value,      */,     public void addReplaceRegex(TokenFilter.ReplaceRegex filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add a trim filter.,      *,      * @param filter a <code>TokenFilter.Trim</code> value,      * @since Ant 1.6,      */,     public void addTrim(TokenFilter.Trim filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add a replacestring filter.,      *,      * @param filter a <code>TokenFilter.ReplaceString</code> value,      * @since Ant 1.6,      */,     public void addReplaceString(,         TokenFilter.ReplaceString filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     /**,      * Add an ignoreBlank filter.,      *,      * @param filter a <code>TokenFilter.IgnoreBlank</code> value,      * @since Ant 1.6,      */,     public void addIgnoreBlank(,         TokenFilter.IgnoreBlank filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, , ,     /**,      * Makes this instance in effect a reference to another FilterChain,      * instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      *,      * @param r the reference to which this instance is associated,      * @exception BuildException if this instance already has been configured.,      */,     public void setRefid(Reference r) throws BuildException {,         if (!filterReaders.isEmpty()) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Add a chainfilter filter.,      *,      * @param filter a <code>ChainableReader</code> value,      * @since Ant 1.6,      */, ,     public void add(ChainableReader filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         filterReaders.addElement(filter);,     }, ,     protected synchronized void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             for (Iterator i = filterReaders.iterator(); i.hasNext(); ) {,                 Object o = i.next();,                 if (o instanceof DataType) {,                     pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);,                 },             },             setChecked(true);,         },     }],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/FilterSet.java,getFilterHash,261-261,[        return filterHash;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/FilterSet.java,readFiltersFromFile,377-377,[           } catch (Exception ex) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/FilterSet.java,,38-624,[public class FilterSet extends DataType implements Cloneable {, ,     /**,      * Individual filter component of filterset.,      *,      */,     public static class Filter {,         // CheckStyle:VisibilityModifier OFF - bc,         /** Token which will be replaced in the filter operation. */,         String token;, ,         /** The value which will replace the token in the filtering operation. */,         String value;,         // CheckStyle:VisibilityModifier ON, ,         /**,          * Constructor for the Filter object.,          *,          * @param token  The token which will be replaced when filtering.,          * @param value  The value which will replace the token when filtering.,          */,         public Filter(String token, String value) {,            setToken(token);,            setValue(value);,         }, ,         /**,          * No-argument conmstructor.,          */,         public Filter() {,         }, ,         /**,          * Sets the Token attribute of the Filter object.,          *,          * @param token  The new Token value.,          */,         public void setToken(String token) {,            this.token = token;,         }, ,         /**,          * Sets the Value attribute of the Filter object.,          *,          * @param value  The new Value value.,          */,         public void setValue(String value) {,            this.value = value;,         }, ,         /**,          * Gets the Token attribute of the Filter object.,          *,          * @return   The Token value.,          */,         public String getToken() {,            return token;,         }, ,         /**,          * Gets the Value attribute of the Filter object.,          *,          * @return   The Value value.,          */,         public String getValue() {,            return value;,         },      }, ,     /**,      * The filtersfile nested element.,      *,      */,     public class FiltersFile {, ,         /**,          * Constructor for the FiltersFile object.,          */,         public FiltersFile() {,         }, ,         /**,          * Sets the file from which filters will be read.,          *,          * @param file the file from which filters will be read.,          */,         public void setFile(File file) {,            filtersFiles.add(file);,         },     }, ,     /**,      * EnumeratedAttribute to set behavior WRT missing filtersfiles:,      * "fail" (default), "warn", "ignore".,      * @since Ant 1.7,      */,     public static class OnMissing extends EnumeratedAttribute {,         private static final String[] VALUES,             = new String[] {"fail", "warn", "ignore"};, ,         /** Fail value */,         public static final OnMissing FAIL = new OnMissing("fail");,         /** Warn value */,         public static final OnMissing WARN = new OnMissing("warn");,         /** Ignore value */,         public static final OnMissing IGNORE = new OnMissing("ignore");, ,         private static final int FAIL_INDEX = 0;,         private static final int WARN_INDEX = 1;,         private static final int IGNORE_INDEX = 2;, ,         /**,          * Default constructor.,          */,         public OnMissing() {,         }, ,         /**,          * Convenience constructor.,          * @param value the value to set.,          */,         public OnMissing(String value) {,             setValue(value);,         }, ,         //inherit doc,         /** {@inheritDoc}. */,         public String[] getValues() {,             return VALUES;,         },     }, ,     /** The default token start string */,     public static final String DEFAULT_TOKEN_START = "@";, ,     /** The default token end string */,     public static final String DEFAULT_TOKEN_END = "@";, ,     private String startOfToken = DEFAULT_TOKEN_START;,     private String endOfToken = DEFAULT_TOKEN_END;, ,     /** Contains a list of parsed tokens */,     private Vector passedTokens;,     /** if a duplicate token is found, this is set to true */,     private boolean duplicateToken = false;, ,     private boolean recurse = true;,     private Hashtable filterHash = null;,     private Vector filtersFiles = new Vector();,     private OnMissing onMissingFiltersFile = OnMissing.FAIL;,     private boolean readingFiles = false;, ,     private int recurseDepth = 0;, ,     /**,      * List of ordered filters and filter files.,      */,     private Vector filters = new Vector();, ,     /**,      * Default constructor.,      */,     public FilterSet() {,     }, ,     /**,      * Create a Filterset from another filterset.,      *,      * @param filterset the filterset upon which this filterset will be based.,      */,     protected FilterSet(FilterSet filterset) {,         super();,         this.filters = (Vector) filterset.getFilters().clone();,     }, ,     /**,      * Get the filters in the filter set.,      *,      * @return a Vector of Filter instances.,      */,     protected synchronized Vector getFilters() {,         if (isReference()) {,             return getRef().getFilters();,         },         dieOnCircularReference();,         //silly hack to avoid stack overflow...,         if (!readingFiles) {,             readingFiles = true;,             for (int i = 0, sz = filtersFiles.size(); i < sz; i++) {,                 readFiltersFromFile((File) filtersFiles.get(i));,             },             filtersFiles.clear();,             readingFiles = false;,         },         return filters;,     }, ,     /**,      * Get the referenced filter set.,      *,      * @return the filterset from the reference.,      */,     protected FilterSet getRef() {,         return (FilterSet) getCheckedRef(FilterSet.class, "filterset");,     }, ,     /**,      * Gets the filter hash of the FilterSet.,      *,      * @return   The hash of the tokens and values for quick lookup.,      */,     public synchronized Hashtable getFilterHash() {,         if (isReference()) {,             return getRef().getFilterHash();,         },         dieOnCircularReference();,         if (filterHash == null) {,             filterHash = new Hashtable(getFilters().size());,             for (Enumeration e = getFilters().elements(); e.hasMoreElements();) {,                Filter filter = (Filter) e.nextElement();,                filterHash.put(filter.getToken(), filter.getValue());,             },         },         return filterHash;,     }, ,     /**,      * Set the file containing the filters for this filterset.,      *,      * @param filtersFile sets the filter file from which to read filters,      *        for this filter set.,      * @throws BuildException if there is an error.,      */,     public void setFiltersfile(File filtersFile) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         filtersFiles.add(filtersFile);,     }, ,     /**,      * Set the string used to id the beginning of a token.,      *,      * @param startOfToken  The new Begintoken value.,      */,     public void setBeginToken(String startOfToken) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (startOfToken == null || "".equals(startOfToken)) {,             throw new BuildException("beginToken must not be empty");,         },         this.startOfToken = startOfToken;,     }, ,     /**,      * Get the begin token for this filterset.,      *,      * @return the filter set's begin token for filtering.,      */,     public String getBeginToken() {,         if (isReference()) {,             return getRef().getBeginToken();,         },         return startOfToken;,     }, ,     /**,      * Set the string used to id the end of a token.,      *,      * @param endOfToken  The new Endtoken value.,      */,     public void setEndToken(String endOfToken) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (endOfToken == null || "".equals(endOfToken)) {,             throw new BuildException("endToken must not be empty");,         },         this.endOfToken = endOfToken;,     }, ,     /**,      * Get the end token for this filterset.,      *,      * @return the filter set's end token for replacement delimiting.,      */,     public String getEndToken() {,         if (isReference()) {,             return getRef().getEndToken();,         },         return endOfToken;,     }, ,     /**,      * Set whether recursive token expansion is enabled.,      * @param recurse <code>boolean</code> whether to recurse.,      */,     public void setRecurse(boolean recurse) {,         this.recurse = recurse;,     }, ,     /**,      * Get whether recursive token expansion is enabled.,      * @return <code>boolean</code> whether enabled.,      */,     public boolean isRecurse() {,         return recurse;,     }, ,     /**,      * Read the filters from the given file.,      *,      * @param filtersFile        the file from which filters are read.,      * @exception BuildException when the file cannot be read.,      */,     public synchronized void readFiltersFromFile(File filtersFile) throws BuildException {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (!filtersFile.exists()) {,            handleMissingFile("Could not read filters from file ",                                      + filtersFile + " as it doesn't exist.");,         },         if (filtersFile.isFile()) {,            log("Reading filters from " + filtersFile, Project.MSG_VERBOSE);,            FileInputStream in = null;,            try {,               Properties props = new Properties();,               in = new FileInputStream(filtersFile);,               props.load(in);, ,               Enumeration e = props.propertyNames();,               Vector filts = getFilters();,               while (e.hasMoreElements()) {,                  String strPropName = (String) e.nextElement();,                  String strValue = props.getProperty(strPropName);,                  filts.addElement(new Filter(strPropName, strValue));,               },            } catch (Exception ex) {,               throw new BuildException("Could not read filters from file: ",                   + filtersFile, ex);,            } finally {,               FileUtils.close(in);,            },         } else {,            handleMissingFile(,                "Must specify a file rather than a directory in ",                + "the filtersfile attribute:" + filtersFile);,         },         filterHash = null;,     }, ,     /**,      * Does replacement on the given string with token matching.,      * This uses the defined begintoken and endtoken values which default,      * to @ for both.,      * This resets the passedTokens and calls iReplaceTokens to,      * do the actual replacements.,      *,      * @param line  The line in which to process embedded tokens.,      * @return      The input string after token replacement.,      */,     public synchronized String replaceTokens(String line) {,         return iReplaceTokens(line);,     }, ,     /**,      * Add a new filter.,      *,      * @param filter the filter to be added.,      */,     public synchronized void addFilter(Filter filter) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         filters.addElement(filter);,         filterHash = null;,     }, ,     /**,      * Create a new FiltersFile.,      *,      * @return The filtersfile that was created.,      */,     public FiltersFile createFiltersfile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return new FiltersFile();,     }, ,     /**,      * Add a new filter made from the given token and value.,      *,      * @param token The token for the new filter.,      * @param value The value for the new filter.,      */,     public synchronized void addFilter(String token, String value) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         addFilter(new Filter(token, value));,     }, ,     /**,      * Add a Filterset to this filter set.,      *,      * @param filterSet the filterset to be added to this filterset,      */,     public synchronized void addConfiguredFilterSet(FilterSet filterSet) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         for (Enumeration e = filterSet.getFilters().elements(); e.hasMoreElements();) {,             addFilter((Filter) e.nextElement());,         },     }, ,     /**,     * Test to see if this filter set has filters.,     *,     * @return Return true if there are filters in this set.,     */,     public synchronized boolean hasFilters() {,         return getFilters().size() > 0;,     }, ,     /**,      * Clone the filterset.,      *,      * @return a deep clone of this filterset.,      *,      * @throws BuildException if the clone cannot be performed.,      */,     public synchronized Object clone() throws BuildException {,         if (isReference()) {,             return ((FilterSet) getRef()).clone();,         },         try {,             FilterSet fs = (FilterSet) super.clone();,             fs.filters = (Vector) getFilters().clone();,             fs.setProject(getProject());,             return fs;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Set the behavior WRT missing filtersfiles.,      * @param onMissingFiltersFile the OnMissing describing the behavior.,      */,     public void setOnMissingFiltersFile(OnMissing onMissingFiltersFile) {,         this.onMissingFiltersFile = onMissingFiltersFile;,     }, ,     /**,      * Get the onMissingFiltersFile setting.,      * @return the OnMissing instance.,      */,     public OnMissing getOnMissingFiltersFile() {,         return onMissingFiltersFile;,     }, ,     /**,      * Does replacement on the given string with token matching.,      * This uses the defined begintoken and endtoken values which default,      * to @ for both.,      *,      * @param line  The line to process the tokens in.,      * @return      The string with the tokens replaced.,      */,     private synchronized String iReplaceTokens(String line) {,         String beginToken = getBeginToken();,         String endToken = getEndToken();,         int index = line.indexOf(beginToken);, ,         if (index > -1) {,             Hashtable tokens = getFilterHash();,             try {,                 StringBuffer b = new StringBuffer();,                 int i = 0;,                 String token = null;,                 String value = null;, ,                 while (index > -1) {,                     //can't have zero-length token,                     int endIndex = line.indexOf(endToken,,                         index + beginToken.length() + 1);,                     if (endIndex == -1) {,                         break;,                     },                     token,                         = line.substring(index + beginToken.length(), endIndex);,                     b.append(line.substring(i, index));,                     if (tokens.containsKey(token)) {,                         value = (String) tokens.get(token);,                         if (recurse && !value.equals(token)) {,                             // we have another token, let's parse it.,                             value = replaceTokens(value, token);,                         },                         log("Replacing: " + beginToken + token + endToken,                             + " -> " + value, Project.MSG_VERBOSE);,                         b.append(value);,                         i = index + beginToken.length() + token.length(),                             + endToken.length();,                     } else {,                         // just append first character of beginToken,                         // and search further,                         // we can't skip the complete beginToken since,                         // it may contain the start of another,                         // candidate begin token (Bugzilla 45094),                         b.append(beginToken.charAt(0));,                         i = index + 1;,                     },                     index = line.indexOf(beginToken, i);,                 }, ,                 b.append(line.substring(i));,                 return b.toString();,             } catch (StringIndexOutOfBoundsException e) {,                 return line;,             },         } else {,            return line;,         },     }, ,     /**,      * This parses tokens which point to tokens.,      * It also maintains a list of currently used tokens, so we cannot,      * get into an infinite loop.,      * @param line the value / token to parse.,      * @param parent the parent token (= the token it was parsed from).,      */,     private synchronized String replaceTokens(String line, String parent),         throws BuildException {,         String beginToken = getBeginToken();,         String endToken = getEndToken();,         if (recurseDepth == 0) {,             passedTokens = new VectorSet();,         },         recurseDepth++;,         if (passedTokens.contains(parent) && !duplicateToken) {,             duplicateToken = true;,             System.out.println(,                 "Infinite loop in tokens. Currently known tokens : ",                 + passedTokens.toString() + "\nProblem token : " + beginToken,                 + parent + endToken + " called from " + beginToken,                 + passedTokens.lastElement().toString() + endToken);,             recurseDepth--;,             return parent;,         },         passedTokens.addElement(parent);,         String value = iReplaceTokens(line);,         if (value.indexOf(beginToken) == -1 && !duplicateToken,                 && recurseDepth == 1) {,             passedTokens = null;,         } else if (duplicateToken) {,             // should always be the case...,             if (passedTokens.size() > 0) {,                 value = (String) passedTokens.remove(passedTokens.size() - 1);,                 if (passedTokens.size() == 0) {,                     value = beginToken + value + endToken;,                     duplicateToken = false;,                 },             },         } else if (passedTokens.size() > 0) {,             // remove last seen token when crawling out of recursion ,             passedTokens.remove(passedTokens.size() - 1);,         },         recurseDepth--;,         return value;,     }, ,     private void handleMissingFile(String message) {,         switch (onMissingFiltersFile.getIndex()) {,         case OnMissing.IGNORE_INDEX:,             return;,         case OnMissing.FAIL_INDEX:,             throw new BuildException(message);,         case OnMissing.WARN_INDEX:,             log(message, Project.MSG_WARN);,             return;,         default:,             throw new BuildException("Invalid value for onMissingFiltersFile");],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/FilterSet.java,getValues,166-166,[            return VALUES;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/types/FilterSetTest.java,tearDown,46-46,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/types/FilterSetTest.java,compareFiles,200-200,[            FileInputStream fis1 = new FileInputStream(file1);],,compareFiles,201-201,[            FileInputStream fis2 = new FileInputStream(file2);],,compareFiles,202-202,[            int index = 0;],,compareFiles,203-203,[            int read = 0;],,compareFiles,204-204,[            while ((read = fis1.read(buffer1)) != -1) {],,compareFiles,214-214,[            return true;],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/types/FilterSetTest.java,compareFiles,200-200,[            FileInputStream fis1 = new FileInputStream(file1);],,compareFiles,201-201,[            FileInputStream fis2 = new FileInputStream(file2);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/tools/ant/types/FilterSetTest.java,compareFiles,205-205,[                fis2.read(buffer2);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/FlexIntegerTest.java,execute,71-71,[        taskProject.setNewProperty(propName, value.toString());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/Mapper.java,getImplementation,212-212,[            String od = o == null ? "null" : o.getClass().getName();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/Mapper.java,,35-278,[    protected MapperType type = null;,     protected String classname = null;,     protected Path classpath = null;,     protected String from = null;,     protected String to = null;, ,     // CheckStyle:VisibilityModifier ON, ,     private ContainerMapper container = null;, ,     /**,      * Construct a new <code>Mapper</code> element.,      * @param p   the owning Ant <code>Project</code>.,      */,     public Mapper(Project p) {,         setProject(p);,     }, ,     /**,      * Set the type of <code>FileNameMapper</code> to use.,      * @param type   the <code>MapperType</code> enumerated attribute.,      */,     public void setType(MapperType type) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.type = type;,     }, ,     /**,      * Cannot mix add and addconfigured in same type, so,      * provide this to override the add method.,      * @param fileNameMapper   the <code>FileNameMapper</code> to add.,      */,     public void addConfigured(FileNameMapper fileNameMapper) {,         add(fileNameMapper);,     }, ,     /**,      * Add a nested <code>FileNameMapper</code>.,      * @param fileNameMapper   the <code>FileNameMapper</code> to add.,      */,     public void add(FileNameMapper fileNameMapper) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (container == null) {,             if (type == null && classname == null) {,                 container = new CompositeMapper();,             } else {,                 FileNameMapper m = getImplementation();,                 if (m instanceof ContainerMapper) {,                     container = (ContainerMapper) m;,                 } else {,                     throw new BuildException(String.valueOf(m),                         + " mapper implementation does not support nested mappers!");,                 },             },         },         container.add(fileNameMapper);,         setChecked(false);,     }, ,     /**,      * Add a Mapper,      * @param mapper the mapper to add,      */,     public void addConfiguredMapper(Mapper mapper) {,         add(mapper.getImplementation());,     }, ,     /**,      * Set the class name of the FileNameMapper to use.,      * @param classname the name of the class,      */,     public void setClassname(String classname) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.classname = classname;,     }, ,     /**,      * Set the classpath to load the FileNameMapper through (attribute).,      * @param classpath the classpath,      */,     public void setClasspath(Path classpath) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (this.classpath == null) {,             this.classpath = classpath;,         } else {,             this.classpath.append(classpath);,         },     }, ,     /**,      * Set the classpath to load the FileNameMapper through (nested element).,      * @return a path object to be configured,      */,     public Path createClasspath() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (this.classpath == null) {,             this.classpath = new Path(getProject());,         },         setChecked(false);,         return this.classpath.createPath();,     }, ,     /**,      * Set the classpath to load the FileNameMapper through via,      * reference (attribute).,      * @param ref the reference to the FileNameMapper,      */,     public void setClasspathRef(Reference ref) {,         if (isReference()) {,             throw tooManyAttributes();,         },         createClasspath().setRefid(ref);,     }, ,     /**,      * Set the argument to FileNameMapper.setFrom,      * @param from the from attribute to pass to the FileNameMapper,      */,     public void setFrom(String from) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.from = from;,     }, ,     /**,      * Set the argument to FileNameMapper.setTo,      * @param to the to attribute to pass to the FileNameMapper,      */,     public void setTo(String to) {,         if (isReference()) {,             throw tooManyAttributes();,         },         this.to = to;,     }, ,     /**,      * Make this Mapper instance a reference to another Mapper.,      *,      * <p>You must not set any other attribute if you make it a,      * reference.</p>,      * @param r the reference to another mapper,      * @throws BuildException if other attributes are set,      */,     public void setRefid(Reference r) throws BuildException {,         if (type != null || from != null || to != null) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Returns a fully configured FileNameMapper implementation.,      * @return a FileNameMapper object to be configured,      * @throws BuildException on error,      */,     public FileNameMapper getImplementation() throws BuildException {,         if (isReference()) {,             dieOnCircularReference();,             Reference r = getRefid();,             Object o = r.getReferencedObject(getProject());,             if (o instanceof FileNameMapper) {,                 return (FileNameMapper) o;,             },             if (o instanceof Mapper) {,                 return ((Mapper) o).getImplementation();,             },             String od = o == null ? "null" : o.getClass().getName();,             throw new BuildException(od + " at reference '",                 + r.getRefId() + "' is not a valid mapper reference.");,         }, ,         if (type == null && classname == null && container == null) {,             throw new BuildException(,                 "nested mapper or ",                 + "one of the attributes type or classname is required");,         }, ,         if (container != null) {,             return container;,         }, ,         if (type != null && classname != null) {,             throw new BuildException(,                 "must not specify both type and classname attribute");,         }, ,         try {,             FileNameMapper m,                 = (FileNameMapper) (getImplementationClass().newInstance());,             final Project p = getProject();,             if (p != null) {,                 p.setProjectReference(m);,             },             m.setFrom(from);,             m.setTo(to);, ,             return m;,         } catch (BuildException be) {,             throw be;,         } catch (Throwable t) {,             throw new BuildException(t);,         },     }, ,      /**,      * Gets the Class object associated with the mapper implementation.,      * @return <code>Class</code>.,      * @throws ClassNotFoundException if the class cannot be found,      */,     protected Class getImplementationClass() throws ClassNotFoundException {, ,         String cName = this.classname;,         if (type != null) {,             cName = type.getImplementation();,         }, ,         ClassLoader loader = (classpath == null),             ? getClass().getClassLoader(),             // Memory leak in line below,             : getProject().createClassLoader(classpath);, ,         return Class.forName(cName, true, loader);,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced Mapper.,      * @deprecated since Ant 1.7.1 because a mapper might ref a,      *             FileNameMapper implementation directly.,      * @return the referenced Mapper,      */,     protected Mapper getRef() {,         return (Mapper) getCheckedRef();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/MapperTest.java,testCircularReferenceCheck,96-96,[        project.addReference("dummy", m);],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/types/MapperTest.java,tearDown,240-240,[        }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/MapperTest.java,,230-244,[        TaskdefForCopyTest(String name) {,             super(name);,         }, ,         public void setUp() {,             configureProject("src/etc/testcases/types/mapper.xml");,         }, ,         public void tearDown() {,             executeTarget("cleanup");,         }, ,         public void test1() {,             executeTarget("test1");,         }],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/types/Path.java,,79-79,[        new Path(null, System.getProperty("sun.boot.class.path"));],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/types/Path.java,,70-70,[        new Path(null, System.getProperty("java.class.path"));],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/Path.java,delegateIteratorToList,756-756,[        } catch (Exception e) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/Path.java,,69-775,[    public static Path systemClasspath =,         new Path(null, System.getProperty("java.class.path"));, , ,     /**,      * The system bootclasspath as a Path object.,      *,      * @since Ant 1.6.2,      */,     public static Path systemBootClasspath =,         new Path(null, System.getProperty("sun.boot.class.path"));, ,     private static final Iterator EMPTY_ITERATOR,         = Collections.EMPTY_SET.iterator();, ,     // CheckStyle:VisibilityModifier OFF - bc, ,     /**,      * Helper class, holds the nested <code>&lt;pathelement&gt;</code> values.,      */,     public class PathElement implements ResourceCollection {,         private String[] parts;, ,         /**,          * Set the location.,          *,          * @param loc a <code>File</code> value,          */,         public void setLocation(File loc) {,             parts = new String[] {translateFile(loc.getAbsolutePath())};,         }, ,         /**,          * Set the path.,          *,          * @param path a <code>String</code> value,          */,         public void setPath(String path) {,             parts = Path.translatePath(getProject(), path);,         }, ,         /**,          * Return the converted pathelements.,          *,          * @return a <code>String[]</code> value,          */,         public String[] getParts() {,             return parts;,         }, ,         /**,          * Create an iterator.,          * @return an iterator.,          */,         public Iterator iterator() {,             return new FileResourceIterator(getProject(), null, parts);,         }, ,         /**,          * Check if this resource is only for filesystems.,          * @return true.,          */,         public boolean isFilesystemOnly() {,             return true;,         }, ,         /**,          * Get the number of resources.,          * @return the number of parts.,          */,         public int size() {,             return parts == null ? 0 : parts.length;,         }, ,     }, ,     private Boolean preserveBC;, ,     private Union union = null;,     private boolean cache = false;, ,     /**,      * Invoked by IntrospectionHelper for <code>setXXX(Path p)</code>,      * attribute setters.,      * @param p the <code>Project</code> for this path.,      * @param path the <code>String</code> path definition.,      */,     public Path(Project p, String path) {,         this(p);,         createPathElement().setPath(path);,     }, ,     /**,      * Construct an empty <code>Path</code>.,      * @param project the <code>Project</code> for this path.,      */,     public Path(Project project) {,         setProject(project);,     }, ,     /**,      * Adds a element definition to the path.,      * @param location the location of the element to add (must not be,      * <code>null</code> nor empty.,      * @throws BuildException on error,      */,     public void setLocation(File location) throws BuildException {,         checkAttributesAllowed();,         createPathElement().setLocation(location);,     }, ,     /**,      * Parses a path definition and creates single PathElements.,      * @param path the <code>String</code> path definition.,      * @throws BuildException on error,      */,     public void setPath(String path) throws BuildException {,         checkAttributesAllowed();,         createPathElement().setPath(path);,     }, ,     /**,      * Makes this instance in effect a reference to another Path instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      * @param r the reference to another Path,      * @throws BuildException on error,      */,     public void setRefid(Reference r) throws BuildException {,         if (union != null) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Creates the nested <code>&lt;pathelement&gt;</code> element.,      * @return the <code>PathElement</code> to be configured,      * @throws BuildException on error,      */,     public PathElement createPathElement() throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         PathElement pe = new PathElement();,         add(pe);,         return pe;,     }, ,     /**,      * Adds a nested <code>&lt;fileset&gt;</code> element.,      * @param fs a <code>FileSet</code> to be added to the path,      * @throws BuildException on error,      */,     public void addFileset(FileSet fs) throws BuildException {,         if (fs.getProject() == null) {,             fs.setProject(getProject());,         },         add(fs);,     }, ,     /**,      * Adds a nested <code>&lt;filelist&gt;</code> element.,      * @param fl a <code>FileList</code> to be added to the path,      * @throws BuildException on error,      */,     public void addFilelist(FileList fl) throws BuildException {,         if (fl.getProject() == null) {,             fl.setProject(getProject());,         },         add(fl);,     }, ,     /**,      * Adds a nested <code>&lt;dirset&gt;</code> element.,      * @param dset a <code>DirSet</code> to be added to the path,      * @throws BuildException on error,      */,     public void addDirset(DirSet dset) throws BuildException {,         if (dset.getProject() == null) {,             dset.setProject(getProject());,         },         add(dset);,     }, ,     /**,      * Adds a nested path,      * @param path a <code>Path</code> to be added to the path,      * @throws BuildException on error,      * @since Ant 1.6,      */,     public void add(Path path) throws BuildException {,         if (path == this) {,             throw circularReference();,         },         if (path.getProject() == null) {,             path.setProject(getProject());,         },         add((ResourceCollection) path);,     }, ,     /**,      * Add a nested <code>ResourceCollection</code>.,      * @param c the ResourceCollection to add.,      * @since Ant 1.7,      */,     public void add(ResourceCollection c) {,         checkChildrenAllowed();,         if (c == null) {,             return;,         },         if (union == null) {,             union = new Union();,             union.setProject(getProject());,             union.setCache(cache);,         },         union.add(c);,         setChecked(false);,     }, ,     /**,      * Creates a nested <code>&lt;path&gt;</code> element.,      * @return a <code>Path</code> to be configured,      * @throws BuildException on error,      */,     public Path createPath() throws BuildException {,         Path p = new Path(getProject());,         add(p);,         return p;,     }, ,     /**,      * Append the contents of the other Path instance to this.,      * @param other a <code>Path</code> to be added to the path,      */,     public void append(Path other) {,         if (other == null) {,             return;,         },         add(other);,     }, ,     /**,      * Adds the components on the given path which exist to this,      * Path. Components that don't exist aren't added.,      *,      * @param source - source path whose components are examined for existence,      */,      public void addExisting(Path source) {,          addExisting(source, false);,      }, ,     /**,      * Same as addExisting, but support classpath behavior if tryUserDir,      * is true. Classpaths are relative to user dir, not the project base.,      * That used to break jspc test,      *,      * @param source the source path,      * @param tryUserDir  if true try the user directory if the file is not present,      */,     public void addExisting(Path source, boolean tryUserDir) {,         String[] list = source.list();,         File userDir = (tryUserDir) ? new File(System.getProperty("user.dir")),                 : null;, ,         for (int i = 0; i < list.length; i++) {,             File f = resolveFile(getProject(), list[i]);, ,             // probably not the best choice, but it solves the problem of,             // relative paths in CLASSPATH,             if (tryUserDir && !f.exists()) {,                 f = new File(userDir, list[i]);,             },             if (f.exists()) {,                 setLocation(f);,             } else if (f.getParentFile() != null && f.getParentFile().exists(),                        && containsWildcards(f.getName())) {,                 setLocation(f);,                 log("adding " + f + " which contains wildcards and may not",                     + " do what you intend it to do depending on your OS or",                     + " version of Java", Project.MSG_VERBOSE);,             } else {,                 log("dropping " + f + " from path as it doesn't exist",,                     Project.MSG_VERBOSE);,             },         },     }, ,     /**,      * Whether to cache the current path.,      * @since Ant 1.8.0,      */,     public void setCache(boolean b) {,         checkAttributesAllowed();,         cache = b;,         if (union != null) {,             union.setCache(b);,         },     }, ,     /**,      * Returns all path elements defined by this and nested path objects.,      * @return list of path elements.,      */,     public String[] list() {,         if (isReference()) {,             return ((Path) getCheckedRef()).list();,         },         return assertFilesystemOnly(union) == null,             ? new String[0] : union.list();,     }, ,     /**,      * Returns a textual representation of the path, which can be used as,      * CLASSPATH or PATH environment variable definition.,      * @return a textual representation of the path.,      */,     public String toString() {,         return isReference() ? getCheckedRef().toString(),             : union == null ? "" : union.toString();,     }, ,     /**,      * Splits a PATH (with : or ; as separators) into its parts.,      * @param project the project to use,      * @param source a <code>String</code> value,      * @return an array of strings, one for each path element,      */,     public static String[] translatePath(Project project, String source) {,         final Vector result = new Vector();,         if (source == null) {,             return new String[0];,         },         PathTokenizer tok = new PathTokenizer(source);,         StringBuffer element = new StringBuffer();,         while (tok.hasMoreTokens()) {,             String pathElement = tok.nextToken();,             try {,                 element.append(resolveFile(project, pathElement).getPath());,             } catch (BuildException e) {,                 project.log("Dropping path element " + pathElement,                     + " as it is not valid relative to the project",,                     Project.MSG_VERBOSE);,             },             for (int i = 0; i < element.length(); i++) {,                 translateFileSep(element, i);,             },             result.addElement(element.toString());,             element = new StringBuffer();,         },         String[] res = new String[result.size()];,         result.copyInto(res);,         return res;,     }, ,     /**,      * Returns its argument with all file separator characters,      * replaced so that they match the local OS conventions.,      * @param source the path to convert,      * @return the converted path,      */,     public static String translateFile(String source) {,         if (source == null) {,           return "";,         },         final StringBuffer result = new StringBuffer(source);,         for (int i = 0; i < result.length(); i++) {,             translateFileSep(result, i);,         },         return result.toString();,     }, ,     /**,      * Translates occurrences at a position of / or \ to correct separator of the,      * current platform and returns whether it had to do a,      * replacement.,      * @param buffer a buffer containing a string,      * @param pos the position in the string buffer to convert,      * @return true if the character was a / or \,      */,     protected static boolean translateFileSep(StringBuffer buffer, int pos) {,         if (buffer.charAt(pos) == '/' || buffer.charAt(pos) == '\\') {,             buffer.setCharAt(pos, File.separatorChar);,             return true;,         },         return false;,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return number of elements as int.,      */,     public synchronized int size() {,         if (isReference()) {,             return ((Path) getCheckedRef()).size();,         },         dieOnCircularReference();,         return union == null ? 0 : assertFilesystemOnly(union).size();,     }, ,     /**,      * Clone this Path.,      * @return Path with shallowly cloned Resource children.,      */,     public Object clone() {,         try {,             Path result = (Path) super.clone();,             result.union = union == null ? union : (Union) union.clone();,             return result;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected synchronized void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (union != null) {,                 pushAndInvokeCircularReferenceCheck(union, stk, p);,             },             setChecked(true);,         },     }, ,     /**,      * Resolve a filename with Project's help - if we know one that is.,      */,     private static File resolveFile(Project project, String relativeName) {,         return FileUtils.getFileUtils().resolveFile(,             (project == null) ? null : project.getBaseDir(), relativeName);,     }, ,     /**,      * Concatenates the system class path in the order specified by,      * the ${build.sysclasspath} property - using &quot;last&quot; as,      * default value.,      * @return the concatenated path,      */,     public Path concatSystemClasspath() {,         return concatSystemClasspath("last");,     }, ,     /**,      * Concatenates the system class path in the order specified by,      * the ${build.sysclasspath} property - using the supplied value,      * if ${build.sysclasspath} has not been set.,      * @param defValue the order ("first", "last", "only"),      * @return the concatenated path,      */,     public Path concatSystemClasspath(String defValue) {,         return concatSpecialPath(defValue, Path.systemClasspath);,     }, ,     /**,      * Concatenates the system boot class path in the order specified,      * by the ${build.sysclasspath} property - using the supplied,      * value if ${build.sysclasspath} has not been set.,      * @param defValue the order ("first", "last", "only"),      * @return the concatenated path,      */,     public Path concatSystemBootClasspath(String defValue) {,         return concatSpecialPath(defValue, Path.systemBootClasspath);,     }, ,     /**,      * Concatenates a class path in the order specified by the,      * ${build.sysclasspath} property - using the supplied value if,      * ${build.sysclasspath} has not been set.,      */,     private Path concatSpecialPath(String defValue, Path p) {,         Path result = new Path(getProject());, ,         String order = defValue;,         if (getProject() != null) {,             String o = getProject().getProperty("build.sysclasspath");,             if (o != null) {,                 order = o;,             },         },         if (order.equals("only")) {,             // only: the developer knows what (s)he is doing,             result.addExisting(p, true);, ,         } else if (order.equals("first")) {,             // first: developer could use a little help,             result.addExisting(p, true);,             result.addExisting(this);, ,         } else if (order.equals("ignore")) {,             // ignore: don't trust anyone,             result.addExisting(this);, ,         } else {,             // last: don't trust the developer,             if (!order.equals("last")) {,                 log("invalid value for build.sysclasspath: " + order,,                     Project.MSG_WARN);,             },             result.addExisting(this);,             result.addExisting(p, true);,         },         return result;,     }, ,     /**,      * Add the Java Runtime classes to this Path instance.,      */,     public void addJavaRuntime() {,         if (JavaEnvUtils.isKaffe()) {,             // newer versions of Kaffe (1.1.1+) won't have this,,             // but this will be sorted by FileSet anyway.,             File kaffeShare = new File(System.getProperty("java.home"),                                        + File.separator + "share",                                        + File.separator + "kaffe");,             if (kaffeShare.isDirectory()) {,                 FileSet kaffeJarFiles = new FileSet();,                 kaffeJarFiles.setDir(kaffeShare);,                 kaffeJarFiles.setIncludes("*.jar");,                 addFileset(kaffeJarFiles);,             },         } else if ("GNU libgcj".equals(System.getProperty("java.vm.name"))) {,             addExisting(systemBootClasspath);,         }, ,         if (System.getProperty("java.vendor").toLowerCase(Locale.ENGLISH).indexOf("microsoft") >= 0) {,             // XXX is this code still necessary? is there any 1.2+ port?,             // Pull in *.zip from packages directory,             FileSet msZipFiles = new FileSet();,             msZipFiles.setDir(new File(System.getProperty("java.home"),                 + File.separator + "Packages"));,             msZipFiles.setIncludes("*.ZIP");,             addFileset(msZipFiles);,         } else {,             // JDK 1.2+ seems to set java.home to the JRE directory.,             addExisting(new Path(null,,                                  System.getProperty("java.home"),                                  + File.separator + "lib",                                  + File.separator + "rt.jar"));,             // Just keep the old version as well and let addExisting,             // sort it out.,             addExisting(new Path(null,,                                  System.getProperty("java.home"),                                  + File.separator + "jre",                                  + File.separator + "lib",                                  + File.separator + "rt.jar"));, ,             // Sun's and Apple's 1.4 have JCE and JSSE in separate jars.,             String[] secJars = {"jce", "jsse"};,             for (int i = 0; i < secJars.length; i++) {,                 addExisting(new Path(null,,                                      System.getProperty("java.home"),                                      + File.separator + "lib",                                      + File.separator + secJars[i] + ".jar"));,                 addExisting(new Path(null,,                                      System.getProperty("java.home"),                                      + File.separator + "..",                                      + File.separator + "Classes",                                      + File.separator + secJars[i] + ".jar"));,             }, ,             // IBM's 1.4 has rt.jar split into 4 smaller jars and a combined,             // JCE/JSSE in security.jar.,             String[] ibmJars,                 = {"core", "graphics", "security", "server", "xml"};,             for (int i = 0; i < ibmJars.length; i++) {,                 addExisting(new Path(null,,                                      System.getProperty("java.home"),                                      + File.separator + "lib",                                      + File.separator + ibmJars[i] + ".jar"));,             }, ,             // Added for MacOS X,             addExisting(new Path(null,,                                  System.getProperty("java.home"),                                  + File.separator + "..",                                  + File.separator + "Classes",                                  + File.separator + "classes.jar"));,             addExisting(new Path(null,,                                  System.getProperty("java.home"),                                  + File.separator + "..",                                  + File.separator + "Classes",                                  + File.separator + "ui.jar"));,         },     }, ,     /**,      * Emulation of extdirs feature in java >= 1.2.,      * This method adds all files in the given,      * directories (but not in sub-directories!) to the classpath,,      * so that you don't have to specify them all one by one.,      * @param extdirs - Path to append files to,      */,     public void addExtdirs(Path extdirs) {,         if (extdirs == null) {,             String extProp = System.getProperty("java.ext.dirs");,             if (extProp != null) {,                 extdirs = new Path(getProject(), extProp);,             } else {,                 return;,             },         }, ,         String[] dirs = extdirs.list();,         for (int i = 0; i < dirs.length; i++) {,             File dir = resolveFile(getProject(), dirs[i]);,             if (dir.exists() && dir.isDirectory()) {,                 FileSet fs = new FileSet();,                 fs.setDir(dir);,                 fs.setIncludes("*");,                 addFileset(fs);,             },         },     }, ,     /**,      * Fulfill the ResourceCollection contract. The Iterator returned,      * will throw ConcurrentModificationExceptions if ResourceCollections,      * are added to this container while the Iterator is in use.,      * @return a "fail-fast" Iterator.,      */,     public final synchronized Iterator iterator() {,         if (isReference()) {,             return ((Path) getCheckedRef()).iterator();,         },         dieOnCircularReference();,         if (getPreserveBC()) {,             return new FileResourceIterator(getProject(), null, list());,         },         return union == null ? EMPTY_ITERATOR,             : assertFilesystemOnly(union).iterator();,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return whether this is a filesystem-only resource collection.,      */,     public synchronized boolean isFilesystemOnly() {,         if (isReference()) {,             return ((Path) getCheckedRef()).isFilesystemOnly();,         },         dieOnCircularReference();,         assertFilesystemOnly(union);,         return true;,     }, ,     /**,      * Verify the specified ResourceCollection is filesystem-only.,      * @param rc the ResourceCollection to check.,      * @throws BuildException if <code>rc</code> is not filesystem-only.,      * @return the passed in ResourceCollection.,      */,     protected ResourceCollection assertFilesystemOnly(ResourceCollection rc) {,         if (rc != null && !(rc.isFilesystemOnly())) {,             throw new BuildException(getDataTypeName(),                 + " allows only filesystem resources.");,         },         return rc;,     }, ,     /**,      * Helps determine whether to preserve BC by calling <code>list()</code> on subclasses.,      * The default behavior of this method is to return <code>true</code> for any subclass,      * that implements <code>list()</code>; this can, of course, be avoided by overriding,      * this method to return <code>false</code>. It is not expected that the result of this,      * method should change over time, thus it is called only once.,      * @return <code>true</code> if <code>iterator()</code> should delegate to <code>list()</code>.,      */,     protected boolean delegateIteratorToList() {,         if (getClass().equals(Path.class)) {,             return false;,         },         try {,             Method listMethod = getClass().getMethod("list", (Class[]) null);,             return !listMethod.getDeclaringClass().equals(Path.class);,         } catch (Exception e) {,             //shouldn't happen, but,             return false;,         },     }, ,     private synchronized boolean getPreserveBC() {,         if (preserveBC == null) {,             preserveBC = delegateIteratorToList() ? Boolean.TRUE : Boolean.FALSE;,         },         return preserveBC.booleanValue();,     }, ,     /**,      * Does the given file name contain wildcards?,      * @since Ant 1.8.2,      */,     private static boolean containsWildcards(String path) {,         return path != null,             && (path.indexOf("*") > -1 || path.indexOf("?") > -1);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/Path.java,getParts,116-116,[            return parts;],,
STYLE,DB_DUPLICATE_BRANCHES,org/apache/tools/ant/types/PathTest.java,testRelativePathUnixStyle,80-82,[           assertTrue("test resolved relative to src/etc",,                  l[0].endsWith("\\src"));,            assertTrue("test resolved relative to src/etc",],,testRelativePathUnixStyle,85-87,[           assertTrue("test resolved relative to src/etc",,                  l[0].endsWith("\\src"));,            assertTrue("test resolved relative to src/etc",],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PathTest.java,testAppending,339-339,[        p.setLocation(new File("/c"));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PathTest.java,testAppending,348-348,[        p.createPath().setLocation(new File("/g"));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PathTest.java,testCircularReferenceCheck,503-503,[        p3.setLocation(new File("/a"));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PathTest.java,testEmptyElementIfIsReference,398-398,[        p.setLocation(new File("/a"));],,testEmptyElementIfIsReference,412-412,[            p.setLocation(new File("/a"));],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/types/PathTest.java,,38-38,[    public static boolean isNetWare = Os.isFamily("netware");],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/tools/ant/types/PathTest.java,,37-37,[    public static boolean isUnixStyle = File.pathSeparatorChar == ':';],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/PatternSet.java,readPatterns,363-363,[            patternReader = new BufferedReader(new FileReader(patternfile));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/PatternSet.java,makeArray,463-463,[            return null;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/PatternSet.java,,40-546,[    private Vector includeList = new Vector();,     private Vector excludeList = new Vector();,     private Vector includesFileList = new Vector();,     private Vector excludesFileList = new Vector();, ,     /**,      * inner class to hold a name on list.  "If" and "Unless" attributes,      * may be used to invalidate the entry based on the existence of a,      * property (typically set thru the use of the Available task),      * or value of an expression.,      */,     public class NameEntry {,         private String name;,         private Object ifCond;,         private Object unlessCond;, ,         /**,          * Sets the name pattern.,          *,          * @param name The pattern string.,          */,         public void setName(String name) {,             this.name = name;,         }, ,         /**,          * Sets the if attribute. This attribute and the "unless",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to false or no property of,          *             its value is present, the name is invalid.,          * @since Ant 1.8.0,          */,         public void setIf(Object cond) {,             ifCond = cond;,         }, ,         /**,          * Sets the if attribute. This attribute and the "unless",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to false or no property of,          *             its value is present, the name is invalid.,          */,         public void setIf(String cond) {,             setIf((Object) cond);,         }, ,         /**,          * Sets the unless attribute. This attribute and the "if",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to true or a property of,          *             its value is present, the name is invalid.,          * @since Ant 1.8.0,          */,         public void setUnless(Object cond) {,             unlessCond = cond;,         }, ,         /**,          * Sets the unless attribute. This attribute and the "if",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to true or a property of,          *             its value is present, the name is invalid.,          */,         public void setUnless(String cond) {,             setUnless((Object) cond);,         }, ,         /**,          * @return the name attribute.,          */,         public String getName() {,             return name;,         }, ,         /**,          * This validates the name - checks the if and unless,          * properties.,          *,          * @param p the current project, used to check the presence or,          *          absence of a property.,          * @return  the name attribute or null if the "if" or "unless",          *          properties are not/are set.,          */,         public String evalName(Project p) {,             return valid(p) ? name : null;,         }, ,         private boolean valid(Project p) {,             PropertyHelper ph = PropertyHelper.getPropertyHelper(p);,             return ph.testIfCondition(ifCond),                 && ph.testUnlessCondition(unlessCond);,         }, ,         /**,          * @return a printable form of this object.,          */,         public String toString() {,             StringBuffer buf = new StringBuffer();,             if (name == null) {,                 buf.append("noname");,             } else {,                 buf.append(name);,             },             if ((ifCond != null) || (unlessCond != null)) {,                 buf.append(":");,                 String connector = "";, ,                 if (ifCond != null) {,                     buf.append("if->");,                     buf.append(ifCond);,                     connector = ";";,                 },                 if (unlessCond != null) {,                     buf.append(connector);,                     buf.append("unless->");,                     buf.append(unlessCond);,                 },             },             return buf.toString();,         },     }, ,     private static final class InvertedPatternSet extends PatternSet {,         private InvertedPatternSet(PatternSet p) {,             setProject(p.getProject());,             addConfiguredPatternset(p);,         },         public String[] getIncludePatterns(Project p) {,             return super.getExcludePatterns(p);,         },         public String[] getExcludePatterns(Project p) {,             return super.getIncludePatterns(p);,         },     }, ,     /**,      * Creates a new <code>PatternSet</code> instance.,      */,     public PatternSet() {,         super();,     }, ,     /**,      * Makes this instance in effect a reference to another PatternSet,      * instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.</p>,      * @param r the reference to another patternset.,      * @throws BuildException on error.,      */,     public void setRefid(Reference r) throws BuildException {,         if (!includeList.isEmpty() || !excludeList.isEmpty()) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * This is a patternset nested element.,      *,      * @param p a configured patternset nested element.,      */,     public void addConfiguredPatternset(PatternSet p) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         String[] nestedIncludes = p.getIncludePatterns(getProject());,         String[] nestedExcludes = p.getExcludePatterns(getProject());, ,         if (nestedIncludes != null) {,             for (int i = 0; i < nestedIncludes.length; i++) {,                 createInclude().setName(nestedIncludes[i]);,             },         },         if (nestedExcludes != null) {,             for (int i = 0; i < nestedExcludes.length; i++) {,                 createExclude().setName(nestedExcludes[i]);,             },         },     }, ,     /**,      * add a name entry on the include list,      * @return a nested include element to be configured.,      */,     public NameEntry createInclude() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return addPatternToList(includeList);,     }, ,     /**,      * add a name entry on the include files list,      * @return a nested includesfile element to be configured.,      */,     public NameEntry createIncludesFile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return addPatternToList(includesFileList);,     }, ,     /**,      * add a name entry on the exclude list,      * @return a nested exclude element to be configured.,      */,     public NameEntry createExclude() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return addPatternToList(excludeList);,     }, ,     /**,      * add a name entry on the exclude files list,      * @return a nested excludesfile element to be configured.,      */,     public NameEntry createExcludesFile() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         return addPatternToList(excludesFileList);,     }, ,     /**,      * Appends <code>includes</code> to the current list of include patterns.,      * Patterns may be separated by a comma or a space.,      *,      * @param includes the string containing the include patterns,      */,     public void setIncludes(String includes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (includes != null && includes.length() > 0) {,             StringTokenizer tok = new StringTokenizer(includes, ", ", false);,             while (tok.hasMoreTokens()) {,                 createInclude().setName(tok.nextToken());,             },         },     }, ,     /**,      * Appends <code>excludes</code> to the current list of exclude patterns.,      * Patterns may be separated by a comma or a space.,      *,      * @param excludes the string containing the exclude patterns,      */,     public void setExcludes(String excludes) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (excludes != null && excludes.length() > 0) {,             StringTokenizer tok = new StringTokenizer(excludes, ", ", false);,             while (tok.hasMoreTokens()) {,                 createExclude().setName(tok.nextToken());,             },         },     }, ,     /**,      * add a name entry to the given list,      */,     private NameEntry addPatternToList(Vector list) {,         NameEntry result = new NameEntry();,         list.addElement(result);,         return result;,     }, ,     /**,      * Sets the name of the file containing the includes patterns.,      *,      * @param includesFile The file to fetch the include patterns from.,      * @throws BuildException on error.,      */,      public void setIncludesfile(File includesFile) throws BuildException {,          if (isReference()) {,              throw tooManyAttributes();,          },          createIncludesFile().setName(includesFile.getAbsolutePath());,      }, ,     /**,      * Sets the name of the file containing the excludes patterns.,      *,      * @param excludesFile The file to fetch the exclude patterns from.,      * @throws BuildException on error.,      */,      public void setExcludesfile(File excludesFile) throws BuildException {,          if (isReference()) {,              throw tooManyAttributes();,          },          createExcludesFile().setName(excludesFile.getAbsolutePath());,      }, ,     /**,      *  Reads path matching patterns from a file and adds them to the,      *  includes or excludes list (as appropriate).,      */,     private void readPatterns(File patternfile, Vector patternlist, Project p),             throws BuildException {, ,         BufferedReader patternReader = null;,         try {,             // Get a FileReader,             patternReader = new BufferedReader(new FileReader(patternfile));, ,             // Create one NameEntry in the appropriate pattern list for each,             // line in the file.,             String line = patternReader.readLine();,             while (line != null) {,                 if (line.length() > 0) {,                     line = p.replaceProperties(line);,                     addPatternToList(patternlist).setName(line);,                 },                 line = patternReader.readLine();,             },         } catch (IOException ioe)  {,             throw new BuildException("An error occurred while reading from pattern file: ",                     + patternfile, ioe);,         } finally {,             FileUtils.close(patternReader);,         },     }, ,     /**,      * Adds the patterns of the other instance to this set.,      * @param other the other PatternSet instance.,      * @param p the current project.,      */,     public void append(PatternSet other, Project p) {,         if (isReference()) {,             throw new BuildException("Cannot append to a reference");,         },         dieOnCircularReference(p);,         String[] incl = other.getIncludePatterns(p);,         if (incl != null) {,             for (int i = 0; i < incl.length; i++) {,                 createInclude().setName(incl[i]);,             },         },         String[] excl = other.getExcludePatterns(p);,         if (excl != null) {,             for (int i = 0; i < excl.length; i++) {,                 createExclude().setName(excl[i]);,             },         },     }, ,     /**,      * Returns the filtered include patterns.,      * @param p the current project.,      * @return the filtered included patterns.,      */,     public String[] getIncludePatterns(Project p) {,         if (isReference()) {,             return getRef(p).getIncludePatterns(p);,         },         dieOnCircularReference(p);,         readFiles(p);,         return makeArray(includeList, p);,     }, ,     /**,      * Returns the filtered include patterns.,      * @param p the current project.,      * @return the filtered excluded patterns.,      */,     public String[] getExcludePatterns(Project p) {,         if (isReference()) {,             return getRef(p).getExcludePatterns(p);,         },         dieOnCircularReference(p);,         readFiles(p);,         return makeArray(excludeList, p);,     }, ,     /**,      * Helper for FileSet classes.,      * Check if there are patterns defined.,      * @param p the current project.,      * @return true if there are patterns.,      */,     public boolean hasPatterns(Project p) {,         if (isReference()) {,             return getRef(p).hasPatterns(p);,         },         dieOnCircularReference(p);,         return includesFileList.size() > 0 || excludesFileList.size() > 0,                 || includeList.size() > 0 || excludeList.size() > 0;,     }, ,     /**,      * Performs the check for circular references and returns the,      * referenced PatternSet.,      */,     private PatternSet getRef(Project p) {,         return (PatternSet) getCheckedRef(p);,     }, ,     /**,      * Convert a vector of NameEntry elements into an array of Strings.,      */,     private String[] makeArray(Vector list, Project p) {,         if (list.size() == 0) {,             return null;,         },         Vector tmpNames = new Vector();,         for (Enumeration e = list.elements(); e.hasMoreElements();) {,             NameEntry ne = (NameEntry) e.nextElement();,             String pattern = ne.evalName(p);,             if (pattern != null && pattern.length() > 0) {,                 tmpNames.addElement(pattern);,             },         },         String[] result = new String[tmpNames.size()];,         tmpNames.copyInto(result);,         return result;,     }, ,     /**,      * Read includesfile ot excludesfile if not already done so.,      */,     private void readFiles(Project p) {,         if (includesFileList.size() > 0) {,             Enumeration e = includesFileList.elements();,             while (e.hasMoreElements()) {,                 NameEntry ne = (NameEntry) e.nextElement();,                 String fileName = ne.evalName(p);,                 if (fileName != null) {,                     File inclFile = p.resolveFile(fileName);,                     if (!inclFile.exists()) {,                         throw new BuildException("Includesfile " + inclFile.getAbsolutePath(),                                 + " not found.");,                     },                     readPatterns(inclFile, includeList, p);,                 },             },             includesFileList.removeAllElements();,         },         if (excludesFileList.size() > 0) {,             Enumeration e = excludesFileList.elements();,             while (e.hasMoreElements()) {,                 NameEntry ne = (NameEntry) e.nextElement();,                 String fileName = ne.evalName(p);,                 if (fileName != null) {,                     File exclFile = p.resolveFile(fileName);,                     if (!exclFile.exists()) {,                         throw new BuildException("Excludesfile " + exclFile.getAbsolutePath(),                                 + " not found.");,                     },                     readPatterns(exclFile, excludeList, p);,                 },             },             excludesFileList.removeAllElements();,         },     }, ,     /**,      * @return a printable form of this object.,      */,     public String toString() {,         return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }";,     }, ,     /**,      * @since Ant 1.6,      * @return a clone of this patternset.,      */,     public Object clone() {,         try {,             PatternSet ps = (PatternSet) super.clone();,             ps.includeList = (Vector) includeList.clone();,             ps.excludeList = (Vector) excludeList.clone();,             ps.includesFileList = (Vector) includesFileList.clone();,             ps.excludesFileList = (Vector) excludesFileList.clone();,             return ps;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Add an inverted patternset.,      * @param p the pattern to invert and add.,      */,     public void addConfiguredInvert(PatternSet p) {,         addConfiguredPatternset(new InvertedPatternSet(p));,     }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/PatternSet.java,,51-174,[    public class NameEntry {,         private String name;,         private Object ifCond;,         private Object unlessCond;, ,         /**,          * Sets the name pattern.,          *,          * @param name The pattern string.,          */,         public void setName(String name) {,             this.name = name;,         }, ,         /**,          * Sets the if attribute. This attribute and the "unless",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to false or no property of,          *             its value is present, the name is invalid.,          * @since Ant 1.8.0,          */,         public void setIf(Object cond) {,             ifCond = cond;,         }, ,         /**,          * Sets the if attribute. This attribute and the "unless",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to false or no property of,          *             its value is present, the name is invalid.,          */,         public void setIf(String cond) {,             setIf((Object) cond);,         }, ,         /**,          * Sets the unless attribute. This attribute and the "if",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to true or a property of,          *             its value is present, the name is invalid.,          * @since Ant 1.8.0,          */,         public void setUnless(Object cond) {,             unlessCond = cond;,         }, ,         /**,          * Sets the unless attribute. This attribute and the "if",          * attribute are used to validate the name, based on the,          * existence of the property or the value of the evaluated,          * property expression.,          *,          * @param cond A property name or expression.  If the,          *             expression evaluates to true or a property of,          *             its value is present, the name is invalid.,          */,         public void setUnless(String cond) {,             setUnless((Object) cond);,         }, ,         /**,          * @return the name attribute.,          */,         public String getName() {,             return name;,         }, ,         /**,          * This validates the name - checks the if and unless,          * properties.,          *,          * @param p the current project, used to check the presence or,          *          absence of a property.,          * @return  the name attribute or null if the "if" or "unless",          *          properties are not/are set.,          */,         public String evalName(Project p) {,             return valid(p) ? name : null;,         }, ,         private boolean valid(Project p) {,             PropertyHelper ph = PropertyHelper.getPropertyHelper(p);,             return ph.testIfCondition(ifCond),                 && ph.testUnlessCondition(unlessCond);,         }, ,         /**,          * @return a printable form of this object.,          */,         public String toString() {,             StringBuffer buf = new StringBuffer();,             if (name == null) {,                 buf.append("noname");,             } else {,                 buf.append(name);,             },             if ((ifCond != null) || (unlessCond != null)) {,                 buf.append(":");,                 String connector = "";, ,                 if (ifCond != null) {,                     buf.append("if->");,                     buf.append(ifCond);,                     connector = ";";,                 },                 if (unlessCond != null) {,                     buf.append(connector);,                     buf.append("unless->");,                     buf.append(unlessCond);,                 },             },             return buf.toString();],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/types/PatternSetTest.java,testEmptyElementIfIsReference,72-72,[            p.setIncludesfile(new File("/a"));],,testEmptyElementIfIsReference,86-86,[            p.setExcludesfile(new File("/a"));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/PatternSetTest.java,testCircularReferenceCheck,124-124,[        project.addReference("dummy", p);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/Permissions.java,,207-207,[            if (active) {],,,173-173,[        active = false;],,,103-103,[        active = true;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/Permissions.java,,218-218,[                    if (!permOK && origSm != null) {],,,219-219,[                        origSm.checkPermission(perm);],,,174-174,[        System.setSecurityManager(origSm);],,,100-100,[        origSm = System.getSecurityManager();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/Permissions.java,createPermission,162-162,[        } catch (Exception e) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/Permissions.java,matches,307-307,[            if (!className.equals(perm.getClass().getName())) {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/types/PermissionsTest.java,testOther,126-126,[            String s = System.setProperty("line.separator",ls);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/Quantifier.java,getValues,113-113,[        return VALUES;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/RedirectorElement.java,toFileArray,554-554,[            return null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/Resource.java,<clinit>,48-48,[    protected static final int MAGIC = getMagicNumber("Resource".getBytes());],,<clinit>,50-50,[    private static final int NULL_NAME = getMagicNumber("null name".getBytes());],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/Resource.java,,48-440,[    protected static final int MAGIC = getMagicNumber("Resource".getBytes());, ,     private static final int NULL_NAME = getMagicNumber("null name".getBytes());, ,     /**,      * Create a "magic number" for use in hashCode calculations.,      * @param seed byte[] to seed with.,      * @return a magic number as int.,      */,     protected static int getMagicNumber(byte[] seed) {,         return new BigInteger(seed).intValue();,     }, ,     private String name = null;,     private Boolean exists = null;,     private Long lastmodified = null;,     private Boolean directory = null;,     private Long size = null;, ,     /**,      * Default constructor.,      */,     public Resource() {,     }, ,     /**,      * Only sets the name.,      *,      * <p>This is a dummy, used for not existing resources.</p>,      *,      * @param name relative path of the resource.  Expects,      * &quot;/&quot; to be used as the directory separator.,      */,     public Resource(String name) {,         this(name, false, 0, false);,     }, ,     /**,      * Sets the name, lastmodified flag, and exists flag.,      *,      * @param name relative path of the resource.  Expects,      * &quot;/&quot; to be used as the directory separator.,      * @param exists if true, this resource exists.,      * @param lastmodified the last modification time of this resource.,      */,     public Resource(String name, boolean exists, long lastmodified) {,         this(name, exists, lastmodified, false);,     }, ,     /**,      * Sets the name, lastmodified flag, exists flag, and directory flag.,      *,      * @param name relative path of the resource.  Expects,      * &quot;/&quot; to be used as the directory separator.,      * @param exists if true the resource exists,      * @param lastmodified the last modification time of the resource,      * @param directory    if true, this resource is a directory,      */,     public Resource(String name, boolean exists, long lastmodified, boolean directory) {,         this(name, exists, lastmodified, directory, UNKNOWN_SIZE);,     }, ,     /**,      * Sets the name, lastmodified flag, exists flag, directory flag, and size.,      *,      * @param name relative path of the resource.  Expects,      * &quot;/&quot; to be used as the directory separator.,      * @param exists if true the resource exists,      * @param lastmodified the last modification time of the resource,      * @param directory    if true, this resource is a directory,      * @param size the size of this resource.,      */,     public Resource(String name, boolean exists, long lastmodified, boolean directory, long size) {,         this.name = name;,         setName(name);,         setExists(exists);,         setLastModified(lastmodified);,         setDirectory(directory);,         setSize(size);,     }, ,     /**,      * Name attribute will contain the path of a file relative to the,      * root directory of its fileset or the recorded path of a zip,      * entry.,      *,      * <p>example for a file with fullpath /var/opt/adm/resource.txt,      * in a file set with root dir /var/opt it will be,      * adm/resource.txt.</p>,      *,      * <p>&quot;/&quot; will be used as the directory separator.</p>,      * @return the name of this resource.,      */,     public String getName() {,         return isReference() ? ((Resource) getCheckedRef()).getName() : name;,     }, ,     /**,      * Set the name of this Resource.,      * @param name relative path of the resource.  Expects,      * &quot;/&quot; to be used as the directory separator.,      */,     public void setName(String name) {,         checkAttributesAllowed();,         this.name = name;,     }, ,     /**,      * The exists attribute tells whether a resource exists.,      * @return true if this resource exists.,      */,     public boolean isExists() {,         if (isReference()) {,             return ((Resource) getCheckedRef()).isExists();,         },         //default true:,         return exists == null || exists.booleanValue();,     }, ,     /**,      * Set the exists attribute.,      * @param exists if true, this resource exists.,      */,     public void setExists(boolean exists) {,         checkAttributesAllowed();,         this.exists = exists ? Boolean.TRUE : Boolean.FALSE;,     }, ,     /**,      * Tells the modification time in milliseconds since 01.01.1970 (the "epoch").,      *,      * @return the modification time, if that is meaningful,      *            (e.g. for a file resource which exists);,      *         0 if the resource does not exist, to mirror the behavior,      *         of {@link java.io.File#lastModified};,      *         or 0 if the notion of modification time is meaningless for this class,      *           of resource (e.g. an inline string),      */,     public long getLastModified() {,         if (isReference()) {,             return ((Resource) getCheckedRef()).getLastModified();,         },         if (!isExists() || lastmodified == null) {,             return UNKNOWN_DATETIME;,         },         long result = lastmodified.longValue();,         return result < UNKNOWN_DATETIME ? UNKNOWN_DATETIME : result;,     }, ,     /**,      * Set the last modification attribute.,      * @param lastmodified the modification time in milliseconds since 01.01.1970.,      */,     public void setLastModified(long lastmodified) {,         checkAttributesAllowed();,         this.lastmodified = new Long(lastmodified);,     }, ,     /**,      * Tells if the resource is a directory.,      * @return boolean flag indicating if the resource is a directory.,      */,     public boolean isDirectory() {,         if (isReference()) {,             return ((Resource) getCheckedRef()).isDirectory();,         },         //default false:,         return directory != null && directory.booleanValue();,     }, ,     /**,      * Set the directory attribute.,      * @param directory if true, this resource is a directory.,      */,     public void setDirectory(boolean directory) {,         checkAttributesAllowed();,         this.directory = directory ? Boolean.TRUE : Boolean.FALSE;,     }, ,     /**,      * Set the size of this Resource.,      * @param size the size, as a long.,      * @since Ant 1.6.3,      */,     public void setSize(long size) {,         checkAttributesAllowed();,         this.size = new Long(size > UNKNOWN_SIZE ? size : UNKNOWN_SIZE);,     }, ,     /**,      * Get the size of this Resource.,      * @return the size, as a long, 0 if the Resource does not exist (for,      *         compatibility with java.io.File), or UNKNOWN_SIZE if not known.,      * @since Ant 1.6.3,      */,     public long getSize() {,         if (isReference()) {,             return ((Resource) getCheckedRef()).getSize();,         },         return isExists(),             ? (size != null ? size.longValue() : UNKNOWN_SIZE),             : 0L;,     }, ,     /**,      * Clone this Resource.,      * @return copy of this.,      */,     public Object clone() {,         try {,             return super.clone();,         } catch (CloneNotSupportedException e) {,             throw new UnsupportedOperationException(,                     "CloneNotSupportedException for a Resource caught. ",                     + "Derived classes must support cloning.");,         },     }, ,     /**,      * Delegates to a comparison of names.,      * @param other the object to compare to.,      * @return a negative integer, zero, or a positive integer as this Resource,      *         is less than, equal to, or greater than the specified Resource.,      * @since Ant 1.6,      */,     public int compareTo(Object other) {,         if (isReference()) {,             return ((Comparable) getCheckedRef()).compareTo(other);,         },         if (!(other instanceof Resource)) {,             throw new IllegalArgumentException(,                 "Can only be compared with Resources");,         },         return toString().compareTo(other.toString());,     }, ,     /**,      * Implement basic Resource equality.,      * @param other the object to check against.,      * @return true if the specified Object is equal to this Resource.,      * @since Ant 1.7,      */,     public boolean equals(Object other) {,         if (isReference()) {,             return getCheckedRef().equals(other);,         },         return other.getClass().equals(getClass()) && compareTo(other) == 0;,     }, ,     /**,      * Get the hash code for this Resource.,      * @return hash code as int.,      * @since Ant 1.7,      */,     public int hashCode() {,         if (isReference()) {,             return getCheckedRef().hashCode();,         },         String name = getName();,         return MAGIC * (name == null ? NULL_NAME : name.hashCode());,     }, ,     /**,      * Get an InputStream for the Resource.,      * @return an InputStream containing this Resource's content.,      * @throws IOException if unable to provide the content of this,      *         Resource as a stream.,      * @throws UnsupportedOperationException if InputStreams are not,      *         supported for this Resource type.,      * @since Ant 1.7,      */,     public InputStream getInputStream() throws IOException {,         if (isReference()) {,             return ((Resource) getCheckedRef()).getInputStream();,         },         throw new UnsupportedOperationException();,     }, ,     /**,      * Get an OutputStream for the Resource.,      * @return an OutputStream to which content can be written.,      * @throws IOException if unable to provide the content of this,      *         Resource as a stream.,      * @throws UnsupportedOperationException if OutputStreams are not,      *         supported for this Resource type.,      * @since Ant 1.7,      */,     public OutputStream getOutputStream() throws IOException {,         if (isReference()) {,             return ((Resource) getCheckedRef()).getOutputStream();,         },         throw new UnsupportedOperationException();,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return an Iterator of Resources.,      * @since Ant 1.7,      */,     public Iterator iterator() {,         return isReference() ? ((Resource) getCheckedRef()).iterator(),             : new Iterator() {,             private boolean done = false;,             public boolean hasNext() {,                 return !done;,             },             public Object next() {,                 if (done) {,                     throw new NoSuchElementException();,                 },                 done = true;,                 return Resource.this;,             },             public void remove() {,                 throw new UnsupportedOperationException();,             },         };,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return the size of this ResourceCollection.,      * @since Ant 1.7,      */,     public int size() {,         return isReference() ? ((Resource) getCheckedRef()).size() : 1;,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return whether this Resource is a FileProvider.,      * @since Ant 1.7,      */,     public boolean isFilesystemOnly() {,         return (isReference() && ((Resource) getCheckedRef()).isFilesystemOnly()),             || this.as(FileProvider.class) != null;,     }, ,     /**,      * Get the string representation of this Resource.,      * @return this Resource formatted as a String.,      * @since Ant 1.7,      */,     public String toString() {,         if (isReference()) {,             return getCheckedRef().toString();,         },         String n = getName();,         return n == null ? "(anonymous)" : n;,     }, ,     /**,      * Get a long String representation of this Resource.,      * This typically should be the value of <code>toString()</code>,      * prefixed by a type description.,      * @return this Resource formatted as a long String.,      * @since Ant 1.7,      */,     public final String toLongString() {,         return isReference() ? ((Resource) getCheckedRef()).toLongString(),             : getDataTypeName() + " \"" + toString() + '"';,     }, ,     /**,      * Overrides the base version.,      * @param r the Reference to set.,      */,     public void setRefid(Reference r) {,         if (name != null,             || exists != null,             || lastmodified != null,             || directory != null,             || size != null) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Returns a view of this resource that implements the interface,      * given as the argument or null if there is no such view.,      *,      * <p>This allows extension interfaces to be added to resources,      * without growing the number of permutations of interfaces,      * decorators/adapters need to implement.</p>,      *,      * <p>This implementation of the method will return the current,      * instance itself if it can be assigned to the given class.</p>,      *,      * @since Ant 1.8.0,      */,     public Object as(Class clazz) {,         return clazz.isAssignableFrom(getClass()) ? this : null;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/TimeComparison.java,getValues,62-62,[        return VALUES;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/XMLCatalog.java,,120-791,[public class XMLCatalog extends DataType,     implements Cloneable, EntityResolver, URIResolver {, ,     /** helper for some File.toURL connversions */,     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();, ,     //-- Fields ----------------------------------------------------------------, ,     /** Holds dtd/entity objects until needed. */,     private Vector elements = new Vector();, ,     /**,      * Classpath in which to attempt to resolve resources.,      */,     private Path classpath;, ,     /**,      * Path listing external catalog files to search when resolving entities,      */,     private Path catalogPath;, ,     /**,      * The name of the bridge to the Apache xml-commons resolver,      * class, used to determine whether resolver.jar is present in the,      * classpath.,      */,     public static final String APACHE_RESOLVER,         = "org.apache.tools.ant.types.resolver.ApacheCatalogResolver";, ,     /**,      * Resolver base class,      */,     public static final String CATALOG_RESOLVER,         = "org.apache.xml.resolver.tools.CatalogResolver";, ,         //-- Methods ---------------------------------------------------------------, ,     /**,      * Default constructor,      */,     public XMLCatalog() {,         setChecked(false);,     }, ,     /**,      * Returns the elements of the catalog - ResourceLocation objects.,      *,      * @return the elements of the catalog - ResourceLocation objects,      */,     private Vector getElements() {,         return getRef().elements;,     }, ,     /**,      * Returns the classpath in which to attempt to resolve resources.,      *,      * @return the classpath,      */,     private Path getClasspath() {,         return getRef().classpath;,     }, ,     /**,      * Allows nested classpath elements. Not allowed if this catalog,      * is itself a reference to another catalog -- that is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * other attributes.,      *,      * @return a Path instance to be configured.,      */,     public Path createClasspath() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (this.classpath == null) {,             this.classpath = new Path(getProject());,         },         setChecked(false);,         return this.classpath.createPath();,     }, ,     /**,      * Allows simple classpath string.  Not allowed if this catalog is,      * itself a reference to another catalog -- that is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * other attributes.,      *,      * @param classpath the classpath to use to look up entities.,      */,     public void setClasspath(Path classpath) {,         if (isReference()) {,             throw tooManyAttributes();,         },         if (this.classpath == null) {,             this.classpath = classpath;,         } else {,             this.classpath.append(classpath);,         },         setChecked(false);,     }, ,     /**,      * Allows classpath reference.  Not allowed if this catalog is,      * itself a reference to another catalog -- that is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * other attributes.,      *,      * @param r an Ant reference containing a classpath.,      */,     public void setClasspathRef(Reference r) {,         if (isReference()) {,             throw tooManyAttributes();,         },         createClasspath().setRefid(r);,         setChecked(false);,     }, ,     /** Creates a nested <code>&lt;catalogpath&gt;</code> element.,      * Not allowed if this catalog is itself a reference to another,      * catalog -- that is, a catalog cannot both refer to another,      * <em>and</em> contain elements or other attributes.,      *,      * @return a path to be configured as the catalog path.,      * @exception BuildException,      * if this is a reference and no nested elements are allowed.,      */,     public Path createCatalogPath() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (this.catalogPath == null) {,             this.catalogPath = new Path(getProject());,         },         setChecked(false);,         return this.catalogPath.createPath();,     }, ,     /**,      * Allows catalogpath reference.  Not allowed if this catalog is,      * itself a reference to another catalog -- that is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * other attributes.,      *,      * @param r an Ant reference containing a classpath to be used as,      * the catalog path.,      */,     public void setCatalogPathRef(Reference r) {,         if (isReference()) {,             throw tooManyAttributes();,         },         createCatalogPath().setRefid(r);,         setChecked(false);,     }, , ,     /**,      * Returns the catalog path in which to attempt to resolve DTDs.,      *,      * @return the catalog path,      */,     public Path getCatalogPath() {,         return getRef().catalogPath;,     }, , ,     /**,      * Creates the nested <code>&lt;dtd&gt;</code> element.  Not,      * allowed if this catalog is itself a reference to another,      * catalog -- that is, a catalog cannot both refer to another,      * <em>and</em> contain elements or other attributes.,      *,      * @param dtd the information about the PUBLIC resource mapping to,      *            be added to the catalog,      * @exception BuildException if this is a reference and no nested,      *       elements are allowed.,      */,     public void addDTD(ResourceLocation dtd) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         }, ,         getElements().addElement(dtd);,         setChecked(false);,     }, ,     /**,      * Creates the nested <code>&lt;entity&gt;</code> element.    Not,      * allowed if this catalog is itself a reference to another,      * catalog -- that is, a catalog cannot both refer to another,      * <em>and</em> contain elements or other attributes.,      *,      * @param entity the information about the URI resource mapping to be,      *       added to the catalog.,      * @exception BuildException if this is a reference and no nested,      *       elements are allowed.,      */,     public void addEntity(ResourceLocation entity) throws BuildException {,         addDTD(entity);,     }, ,     /**,      * Loads a nested <code>&lt;xmlcatalog&gt;</code> into our,      * definition.  Not allowed if this catalog is itself a reference,      * to another catalog -- that is, a catalog cannot both refer to,      * another <em>and</em> contain elements or other attributes.,      *,      * @param catalog Nested XMLCatalog,      */,     public void addConfiguredXMLCatalog(XMLCatalog catalog) {,         if (isReference()) {,             throw noChildrenAllowed();,         }, ,         // Add all nested elements to our catalog,         Vector newElements = catalog.getElements();,         Vector ourElements = getElements();,         Enumeration e = newElements.elements();,         while (e.hasMoreElements()) {,             ourElements.addElement(e.nextElement());,         }, ,         // Append the classpath of the nested catalog,         Path nestedClasspath = catalog.getClasspath();,         createClasspath().append(nestedClasspath);, ,         // Append the catalog path of the nested catalog,         Path nestedCatalogPath = catalog.getCatalogPath();,         createCatalogPath().append(nestedCatalogPath);,         setChecked(false);,     }, ,     /**,      * Makes this instance in effect a reference to another XMLCatalog,      * instance.,      *,      * <p>You must not set another attribute or nest elements inside,      * this element if you make it a reference.  That is, a catalog,      * cannot both refer to another <em>and</em> contain elements or,      * attributes.</p>,      *,      * @param r the reference to which this catalog instance is associated,      * @exception BuildException if this instance already has been configured.,      */,     public void setRefid(Reference r) throws BuildException {,         if (!elements.isEmpty()) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Implements the EntityResolver.resolveEntity() interface method.,      * @param publicId the public id to resolve.,      * @param systemId the system id to resolve.,      * @throws SAXException if there is a parsing problem.,      * @throws IOException if there is an IO problem.,      * @return the resolved entity.,      * @see org.xml.sax.EntityResolver#resolveEntity,      */,     public InputSource resolveEntity(String publicId, String systemId),         throws SAXException, IOException {, ,         if (isReference()) {,             return getRef().resolveEntity(publicId, systemId);,         }, ,         dieOnCircularReference();, ,         log("resolveEntity: '" + publicId + "': '" + systemId + "'",,             Project.MSG_DEBUG);, ,         InputSource inputSource =,             getCatalogResolver().resolveEntity(publicId, systemId);, ,         if (inputSource == null) {,             log("No matching catalog entry found, parser will use: '",                 + systemId + "'", Project.MSG_DEBUG);,         }, ,         return inputSource;,     }, ,     /**,      * Implements the URIResolver.resolve() interface method.,      * @param href an href attribute.,      * @param base the base URI.,      * @return a Source object, or null if href cannot be resolved.,      * @throws TransformerException if an error occurs.,      * @see javax.xml.transform.URIResolver#resolve,      */,     public Source resolve(String href, String base),         throws TransformerException {, ,         if (isReference()) {,             return getRef().resolve(href, base);,         }, ,         dieOnCircularReference();, ,         SAXSource source = null;, ,         String uri = removeFragment(href);, ,         log("resolve: '" + uri + "' with base: '" + base + "'", Project.MSG_DEBUG);, ,         source = (SAXSource) getCatalogResolver().resolve(uri, base);, ,         if (source == null) {,             log("No matching catalog entry found, parser will use: '",                 + href + "'", Project.MSG_DEBUG);,             //,             // Cannot return a null source, because we have to call,             // setEntityResolver (see setEntityResolver javadoc comment),             //,             source = new SAXSource();,             URL baseURL = null;,             try {,                 if (base == null) {,                     baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());,                 } else {,                     baseURL = new URL(base);,                 },                 URL url = (uri.length() == 0 ? baseURL : new URL(baseURL, uri));,                 source.setInputSource(new InputSource(url.toString()));,             } catch (MalformedURLException ex) {,                 // At this point we are probably in failure mode, but,                 // try to use the bare URI as a last gasp,                 source.setInputSource(new InputSource(uri));,             },         }, ,         setEntityResolver(source);,         return source;,     }, ,     protected synchronized void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (classpath != null) {,                 pushAndInvokeCircularReferenceCheck(classpath, stk, p);,             },             if (catalogPath != null) {,                 pushAndInvokeCircularReferenceCheck(catalogPath, stk, p);,             },             setChecked(true);,         },     }, ,     /**,      * @since Ant 1.6,      */,     private XMLCatalog getRef() {,         if (!isReference()) {,             return this;,         },         return (XMLCatalog) getCheckedRef(XMLCatalog.class, "xmlcatalog");,     }, ,     /**,      * The instance of the CatalogResolver strategy to use.,      */,     private CatalogResolver catalogResolver = null;, ,     /**,      * Factory method for creating the appropriate CatalogResolver,      * strategy implementation.,      * <p> Until we query the classpath, we don't know whether the Apache,      * resolver (Norm Walsh's library from xml-commons) is available or not.,      * This method determines whether the library is available and creates the,      * appropriate implementation of CatalogResolver based on the answer.</p>,      * <p>This is an application of the Gang of Four Strategy Pattern,      * combined with Template Method.</p>,      */,     private CatalogResolver getCatalogResolver() {, ,         if (catalogResolver == null) {, ,             AntClassLoader loader = null;,             // Memory-Leak in line below,             loader = getProject().createClassLoader(Path.systemClasspath);, ,             try {,                 Class clazz = Class.forName(APACHE_RESOLVER, true, loader);, ,                 // The Apache resolver is present - Need to check if it can,                 // be seen by the catalog resolver class. Start by getting,                 // the actual loader,                 ClassLoader apacheResolverLoader = clazz.getClassLoader();, ,                 // load the base class through this loader.,                 Class baseResolverClass,                     = Class.forName(CATALOG_RESOLVER, true, apacheResolverLoader);, ,                 // and find its actual loader,                 ClassLoader baseResolverLoader,                     = baseResolverClass.getClassLoader();, ,                 // We have the loader which is being used to load the,                 // CatalogResolver. Can it see the ApacheResolver? The,                 // base resolver will only be able to create the ApacheResolver,                 // if it can see it - doesn't use the context loader.,                 clazz = Class.forName(APACHE_RESOLVER, true, baseResolverLoader);, ,                 Object obj  = clazz.newInstance();,                 //,                 // Success!  The xml-commons resolver library is,                 // available, so use it.,                 //,                 catalogResolver = new ExternalResolver(clazz, obj);,             } catch (Throwable ex) {,                 //,                 // The xml-commons resolver library is not,                 // available, so we can't use it.,                 //,                 catalogResolver = new InternalResolver();,                 if (getCatalogPath() != null,                     && getCatalogPath().list().length != 0) {,                         log("Warning: XML resolver not found; external catalogs",                             + " will be ignored", Project.MSG_WARN);,                     },                 log("Failed to load Apache resolver: " + ex, Project.MSG_DEBUG);,             },         },         return catalogResolver;,     }, ,     /**,      * <p>This is called from the URIResolver to set an EntityResolver,      * on the SAX parser to be used for new XML documents that are,      * encountered as a result of the document() function, xsl:import,,      * or xsl:include.  This is done because the XSLT processor calls,      * out to the SAXParserFactory itself to create a new SAXParser to,      * parse the new document.  The new parser does not automatically,      * inherit the EntityResolver of the original (although arguably,      * it should).  See below:</p>,      *,      * <tt>"If an application wants to set the ErrorHandler or,      * EntityResolver for an XMLReader used during a transformation,,      * it should use a URIResolver to return the SAXSource which,      * provides (with getXMLReader) a reference to the XMLReader"</tt>,      *,      * <p>...quoted from page 118 of the Java API for XML,      * Processing 1.1 specification</p>,      *,      */,     private void setEntityResolver(SAXSource source) throws TransformerException {, ,         XMLReader reader = source.getXMLReader();,         if (reader == null) {,             SAXParserFactory spFactory = SAXParserFactory.newInstance();,             spFactory.setNamespaceAware(true);,             try {,                 reader = spFactory.newSAXParser().getXMLReader();,             } catch (ParserConfigurationException ex) {,                 throw new TransformerException(ex);,             } catch (SAXException ex) {,                 throw new TransformerException(ex);,             },         },         reader.setEntityResolver(this);,         source.setXMLReader(reader);,     }, ,     /**,      * Find a ResourceLocation instance for the given publicId.,      *,      * @param publicId the publicId of the Resource for which local information,      *        is required.,      * @return a ResourceLocation instance with information on the local location,      *         of the Resource or null if no such information is available.,      */,     private ResourceLocation findMatchingEntry(String publicId) {,         Enumeration e = getElements().elements();,         ResourceLocation element = null;,         while (e.hasMoreElements()) {,             Object o = e.nextElement();,             if (o instanceof ResourceLocation) {,                 element = (ResourceLocation) o;,                 if (element.getPublicId().equals(publicId)) {,                     return element;,                 },             },         },         return null;,     }, ,     /**,      * Utility method to remove trailing fragment from a URI.,      * For example,,      * <code>http://java.sun.com/index.html#chapter1</code>,      * would return <code>http://java.sun.com/index.html</code>.,      *,      * @param uri The URI to process.  It may or may not contain a,      *            fragment.,      * @return The URI sans fragment.,      */,     private String removeFragment(String uri) {,         String result = uri;,         int hashPos = uri.indexOf("#");,         if (hashPos >= 0) {,             result = uri.substring(0, hashPos);,         },         return result;,     }, ,     /**,      * Utility method to lookup a ResourceLocation in the filesystem.,      *,      * @return An InputSource for reading the file, or <code>null</code>,      *     if the file does not exist or is not readable.,      */,     private InputSource filesystemLookup(ResourceLocation matchingEntry) {, ,         String uri = matchingEntry.getLocation();,         // the following line seems to be necessary on Windows under JDK 1.2,         uri = uri.replace(File.separatorChar, '/');,         URL baseURL = null;, ,         //,         // The ResourceLocation may specify a relative path for its,         // location attribute.  This is resolved using the appropriate,         // base.,         //,         if (matchingEntry.getBase() != null) {,             baseURL = matchingEntry.getBase();,         } else {,             try {,                 baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());,             } catch (MalformedURLException ex) {,                 throw new BuildException("Project basedir cannot be converted to a URL");,             },         }, ,         InputSource source = null;,         URL url = null;,         try {,             url = new URL(baseURL, uri);,         } catch (MalformedURLException ex) {,             // this processing is useful under Windows when the location of the DTD,             // has been given as an absolute path,             // see Bugzilla Report 23913,             File testFile = new File(uri);,             if (testFile.exists() && testFile.canRead()) {,                 log("uri : '",                     + uri + "' matches a readable file", Project.MSG_DEBUG);,                 try {,                     url = FILE_UTILS.getFileURL(testFile);,                 } catch (MalformedURLException ex1) {,                     throw new BuildException(,                         "could not find an URL for :" + testFile.getAbsolutePath());,                 },             } else {,                 log("uri : '",                     + uri + "' does not match a readable file", Project.MSG_DEBUG);, ,             },         }, ,         if (url != null && url.getProtocol().equals("file")) {,             String fileName = FILE_UTILS.fromURI(url.toString());,             if (fileName != null) {,                 log("fileName " + fileName, Project.MSG_DEBUG);,                 File resFile = new File(fileName);,                 if (resFile.exists() && resFile.canRead()) {,                     try {,                         source = new InputSource(new FileInputStream(resFile));,                         String sysid = JAXPUtils.getSystemId(resFile);,                         source.setSystemId(sysid);,                         log("catalog entry matched a readable file: '",                             + sysid + "'", Project.MSG_DEBUG);,                     } catch (IOException ex) {,                         // ignore,                     },                 },             },         },         return source;,     }, ,     /**,      * Utility method to lookup a ResourceLocation in the classpath.,      *,      * @return An InputSource for reading the resource, or <code>null</code>,      *    if the resource does not exist in the classpath or is not readable.,      */,     private InputSource classpathLookup(ResourceLocation matchingEntry) {, ,         InputSource source = null;, ,         AntClassLoader loader = null;,         Path cp = classpath;,         if (cp != null) {,             cp = classpath.concatSystemClasspath("ignore");,         } else {,             cp = (new Path(getProject())).concatSystemClasspath("last");,         },         loader = getProject().createClassLoader(cp);, ,         //,         // for classpath lookup we ignore the base directory,         //,         InputStream is,             = loader.getResourceAsStream(matchingEntry.getLocation());, ,         if (is != null) {,             source = new InputSource(is);,             URL entryURL = loader.getResource(matchingEntry.getLocation());,             String sysid = entryURL.toExternalForm();,             source.setSystemId(sysid);,             log("catalog entry matched a resource in the classpath: '",                 + sysid + "'", Project.MSG_DEBUG);,         }, ,         return source;,     }, ,     /**,      * Utility method to lookup a ResourceLocation in URL-space.,      *,      * @return An InputSource for reading the resource, or <code>null</code>,      *    if the resource does not identify a valid URL or is not readable.,      */,     private InputSource urlLookup(ResourceLocation matchingEntry) {, ,         String uri = matchingEntry.getLocation();,         URL baseURL = null;, ,         //,         // The ResourceLocation may specify a relative url for its,         // location attribute.  This is resolved using the appropriate,         // base.,         //,         if (matchingEntry.getBase() != null) {,             baseURL = matchingEntry.getBase();,         } else {,             try {,                 baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());,             } catch (MalformedURLException ex) {,                 throw new BuildException("Project basedir cannot be converted to a URL");,             },         }, ,         InputSource source = null;,         URL url = null;, ,         try {,             url = new URL(baseURL, uri);,         } catch (MalformedURLException ex) {,             // ignore,         }, ,         if (url != null) {,             try {,                 InputStream is = url.openStream();,                 if (is != null) {,                     source = new InputSource(is);,                     String sysid = url.toExternalForm();,                     source.setSystemId(sysid);,                     log("catalog entry matched as a URL: '",                         + sysid + "'", Project.MSG_DEBUG);,                 },             } catch (IOException ex) {,                 // ignore,             },         }, ,         return source;],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/types/XMLCatalogBuildFileTest.java,tearDown,39-39,[    }],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/ant/types/XMLCatalogTest.java,testCircularReferenceCheck,181-181,[            InputSource result = catalog.resolveEntity("PUBLIC ID ONE",],,testCircularReferenceCheck,204-204,[            InputSource result = catalog1.resolveEntity("PUBLIC ID ONE",],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/XMLCatalogTest.java,testAbsolutePath,232-232,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/XMLCatalogTest.java,testClasspath,414-414,[        } catch (Exception e) {],,testClasspath,423-423,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/XMLCatalogTest.java,testEmptyCatalog,97-97,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/XMLCatalogTest.java,testEntryReference,305-305,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/XMLCatalogTest.java,testNestedCatalog,348-348,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/XMLCatalogTest.java,testNonExistentEntry,142-142,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/XMLCatalogTest.java,testResolverBase,376-376,[        } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/XMLCatalogTest.java,testSimpleEntry,253-253,[        } catch (Exception e) {],,
STYLE,UC_USELESS_OBJECT,org/apache/tools/ant/types/XMLCatalogTest.java,testNonExistentEntry,121-121,[        ResourceLocation dtd = new ResourceLocation();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/mappers/CutDirsMapper.java,mapFileName,71-71,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/mappers/FilterMapper.java,mapFileName,78-78,[                return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/ScriptMapper.java,mapFileName,88-88,[            return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/optional/ScriptMapper.java,addMappedName,65-65,[        files.add(mapping);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/optional/ScriptMapper.java,mapFileName,87-87,[        if (files.size() == 0) {],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/tools/ant/types/optional/depend/ClassfileSet.java,clone,163-164,[        return new ClassfileSet(isReference(),             ? (ClassfileSet) (getRef(getProject())) : this);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/optional/depend/DependScanner.java,,87-87,[            files[i] = (String) included.elementAt(i);],,,106-106,[        included = new Vector();],,,140-140,[                included.addElement(filename);],,,94-94,[        if (included == null) {],,,97-97,[        return included.size();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/depend/DependScanner.java,getExcludedDirectories,156-156,[        return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/depend/DependScanner.java,getExcludedFiles,164-164,[        return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/depend/DependScanner.java,getNotIncludedDirectories,188-188,[        return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/types/optional/depend/DependScanner.java,getNotIncludedFiles,196-196,[        return null;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/optional/depend/DependScanner.java,getIncludedFiles,87-87,[            files[i] = (String) included.elementAt(i);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/types/optional/depend/DependScanner.java,scan,122-122,[        for (Enumeration e = rootClasses.elements(); e.hasMoreElements();) {],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/types/resources/AbstractClasspathResource.java,isExists,161-161,[            FileUtils.close(is);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/resources/AbstractResourceCollectionWrapper.java,,35-207,[public abstract class AbstractResourceCollectionWrapper,     extends DataType implements ResourceCollection, Cloneable {,     private static final String ONE_NESTED_MESSAGE,         = " expects exactly one nested resource collection.";, ,     private ResourceCollection rc;,     private boolean cache = true;, ,     /**,      * Set whether to cache collections.,      * @param b boolean cache flag.,      */,     public synchronized void setCache(boolean b) {,         cache = b;,     }, ,     /**,      * Learn whether to cache collections. Default is <code>true</code>.,      * @return boolean cache flag.,      */,     public synchronized boolean isCache() {,         return cache;,     }, ,     /**,      * Add a ResourceCollection to the container.,      * @param c the ResourceCollection to add.,      * @throws BuildException on error.,      */,     public synchronized void add(ResourceCollection c) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (c == null) {,             return;,         },         if (rc != null) {,             throw oneNested();,         },         rc = c;,         if (Project.getProject(rc) == null) {,             Project p = getProject();,             if (p != null) {,                 p.setProjectReference(rc);,             },         },         setChecked(false);,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return an Iterator of Resources.,      */,     public final synchronized Iterator iterator() {,         if (isReference()) {,             return ((AbstractResourceCollectionWrapper) getCheckedRef()).iterator();,         },         dieOnCircularReference();,         return new FailFast(this, createIterator());,     }, ,     /**,      * Do create an iterator on the resource collection. The creation,      * of the iterator is allowed to not be thread safe whereas the iterator,      * itself should. The returned iterator will be wrapped into the FailFast,      * one.,      * ,      * @return the iterator on the resource collection,      */,     protected abstract Iterator createIterator();, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return number of elements as int.,      */,     public synchronized int size() {,         if (isReference()) {,             return ((AbstractResourceCollectionWrapper) getCheckedRef()).size();,         },         dieOnCircularReference();,         return getSize();,     }, ,     /**,      * Do compute the size of the resource collection. The implementation of,      * this function is allowed to be not thread safe.,      * ,      * @return size of resource collection.,      */,     protected abstract int getSize();, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return whether this is a filesystem-only resource collection.,      */,     public synchronized boolean isFilesystemOnly() {,         if (isReference()) {,             return ((BaseResourceCollectionContainer) getCheckedRef()).isFilesystemOnly();,         },         dieOnCircularReference();, ,         if (rc == null || rc.isFilesystemOnly()) {,             return true;,         },         /* now check each Resource in case the child only,            lets through files from any children IT may have: */,         for (Iterator i = createIterator(); i.hasNext();) {,             Resource r = (Resource) i.next();,             if (r.as(FileProvider.class) == null) {,                 return false;,             },         },         return true;,     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected synchronized void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (rc instanceof DataType) {,                 pushAndInvokeCircularReferenceCheck((DataType) rc, stk, p);,             },             setChecked(true);,         },     }, ,     /**,      * Get the nested ResourceCollection.,      * @return a ResourceCollection.,      * @throws BuildException if no nested ResourceCollection has been provided.,      */,     protected final synchronized ResourceCollection getResourceCollection() {,         dieOnCircularReference();,         if (rc == null) {,             throw oneNested();,         },         return rc;,     }, ,     /**,      * Format this BaseResourceCollectionWrapper as a String.,      * @return a descriptive <code>String</code>.,      */,     public synchronized String toString() {,         if (isReference()) {,             return getCheckedRef().toString();,         },         if (getSize() == 0) {,             return "";,         },         StringBuffer sb = new StringBuffer();,         for (Iterator i = createIterator(); i.hasNext();) {,             if (sb.length() > 0) {,                 sb.append(File.pathSeparatorChar);,             },             sb.append(i.next());,         },         return sb.toString();,     }, ,     private BuildException oneNested() {,         return new BuildException(super.toString() + ONE_NESTED_MESSAGE);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/ArchiveResource.java,<clinit>,35-35,[        = Resource.getMagicNumber("null archive".getBytes());],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/resources/Archives.java,,41-190,[public class Archives extends DataType,     implements ResourceCollection, Cloneable {, ,     private Union zips = new Union();,     private Union tars = new Union();, ,     /**,      * Wrapper to identify nested resource collections as ZIP,      * archives.,      */,     public Union createZips() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         return zips;,     }, ,     /**,      * Wrapper to identify nested resource collections as ZIP,      * archives.,      */,     public Union createTars() {,         if (isReference()) {,             throw noChildrenAllowed();,         },         setChecked(false);,         return tars;,     }, ,     /**,      * Sums the sizes of nested archives.,      */,     public int size() {,         if (isReference()) {,             return ((Archives) getCheckedRef()).size();,         },         dieOnCircularReference();,         int total = 0;,         for (Iterator i = grabArchives(); i.hasNext(); ) {,             total += ((ResourceCollection) i.next()).size();,         },         return total;,     }, ,     /**,      * Merges the nested collections.,      */,     public Iterator iterator() {,         if (isReference()) {,             return ((Archives) getCheckedRef()).iterator();,         },         dieOnCircularReference();,         List l = new LinkedList();,         for (Iterator i = grabArchives(); i.hasNext(); ) {,             l.addAll(CollectionUtils,                      .asCollection(((ResourceCollection) i.next()).iterator()));,         },         return l.iterator();,     }, ,     /**,      * @return false,      */,     public boolean isFilesystemOnly() {,         if (isReference()) {,             return ((Archives) getCheckedRef()).isFilesystemOnly();,         },         dieOnCircularReference();,         return false;,     }, ,     /**,      * Overrides the base version.,      * @param r the Reference to set.,      */,     public void setRefid(Reference r) {,         if (zips.getResourceCollections().size() > 0,             || tars.getResourceCollections().size() > 0) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Implement clone.  The nested resource collections are cloned as,      * well.,      * @return a cloned instance.,      */,     public Object clone() {,         try {,             Archives a = (Archives) super.clone();,             a.zips = (Union) zips.clone();,             a.tars = (Union) tars.clone();,             return a;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     // TODO this is a pretty expensive operation and so the result,     // should be cached.,     /**,      * Turns all nested resources into corresponding ArchiveFileSets,      * and returns an iterator over the collected archives.,      */,     protected Iterator/*<ArchiveFileset>*/ grabArchives() {,         List l = new LinkedList();,         for (Iterator iter = zips.iterator(); iter.hasNext(); ) {,             l.add(configureArchive(new ZipFileSet(),,                                    (Resource) iter.next()));,         },         for (Iterator iter = tars.iterator(); iter.hasNext(); ) {,             l.add(configureArchive(new TarFileSet(),,                                    (Resource) iter.next()));,         },         return l.iterator();,     }, ,     /**,      * Configures the archivefileset based on this type's settings,,      * set the source.,      */,     protected ArchiveFileSet configureArchive(ArchiveFileSet afs,,                                               Resource src) {,         afs.setProject(getProject());,         afs.setSrcResource(src);,         return afs;,     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected synchronized void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             pushAndInvokeCircularReferenceCheck(zips, stk, p);,             pushAndInvokeCircularReferenceCheck(tars, stk, p);,             setChecked(true);,         },     }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/resources/BaseResourceCollectionContainer.java,,40-267,[    private List rc = new ArrayList();,     private Collection coll = null;,     private boolean cache = true;, ,     /**,      * Create a new BaseResourceCollectionContainer.,      */,     public BaseResourceCollectionContainer() {,         // TODO Auto-generated constructor stub,     },     ,     /**,      * Create a new BaseResourceCollectionContainer.,      * @since Ant 1.8,      */,     public BaseResourceCollectionContainer(Project project) {,         setProject(project);,     }, ,     /**,      * Set whether to cache collections.,      * @param b boolean cache flag.,      */,     public synchronized void setCache(boolean b) {,         cache = b;,     }, ,     /**,      * Learn whether to cache collections. Default is <code>true</code>.,      * @return boolean cache flag.,      */,     public synchronized boolean isCache() {,         return cache;,     }, ,     /**,      * Clear the container.,      * @throws BuildException on error.,      */,     public synchronized void clear() throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         rc.clear();,         FailFast.invalidate(this);,         coll = null;,         setChecked(false);,     }, ,     /**,      * Add a ResourceCollection to the container.,      * @param c the ResourceCollection to add.,      * @throws BuildException on error.,      */,     public synchronized void add(ResourceCollection c) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (c == null) {,             return;,         },         if (Project.getProject(c) == null) {,             Project p = getProject();,             if (p != null) {,                 p.setProjectReference(c);,             },         },         rc.add(c);,         FailFast.invalidate(this);,         coll = null;,         setChecked(false);,     }, ,     /**,      * Add the Collection of ResourceCollections to the container.,      * @param c the Collection whose elements to add.,      * @throws BuildException on error.,      */,     public synchronized void addAll(Collection c) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         try {,             for (Iterator i = c.iterator(); i.hasNext();) {,                 add((ResourceCollection) i.next());,             },         } catch (ClassCastException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Fulfill the ResourceCollection contract. The Iterator returned,      * will throw ConcurrentModificationExceptions if ResourceCollections,      * are added to this container while the Iterator is in use.,      * @return a "fail-fast" Iterator.,      */,     public final synchronized Iterator iterator() {,         if (isReference()) {,             return ((BaseResourceCollectionContainer) getCheckedRef()).iterator();,         },         dieOnCircularReference();,         return new FailFast(this, cacheCollection().iterator());,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return number of elements as int.,      */,     public synchronized int size() {,         if (isReference()) {,             return ((BaseResourceCollectionContainer) getCheckedRef()).size();,         },         dieOnCircularReference();,         return cacheCollection().size();,     }, ,     /**,      * Fulfill the ResourceCollection contract.,      * @return whether this is a filesystem-only resource collection.,      */,     public synchronized boolean isFilesystemOnly() {,         if (isReference()) {,             return ((BaseResourceCollectionContainer) getCheckedRef()).isFilesystemOnly();,         },         dieOnCircularReference();,         //first the easy way, if all children are filesystem-only, return true:,         boolean goEarly = true;,         for (Iterator i = rc.iterator(); goEarly && i.hasNext();) {,             goEarly = ((ResourceCollection) i.next()).isFilesystemOnly();,         },         if (goEarly) {,             return true;,         },         /* now check each Resource in case the child only,            lets through files from any children IT may have: */,         for (Iterator i = cacheCollection().iterator(); i.hasNext();) {,             Resource r = (Resource) i.next();,             if (r.as(FileProvider.class) == null) {,                 return false;,             },         },         return true;,     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected synchronized void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             for (Iterator i = rc.iterator(); i.hasNext();) {,                 Object o = i.next();,                 if (o instanceof DataType) {,                     pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);,                 },             },             setChecked(true);,         },     }, ,     /**,      * Get the nested ResourceCollections.,      * @return List.,      */,     public final synchronized List getResourceCollections() {,         dieOnCircularReference();,         return Collections.unmodifiableList(rc);,     }, ,     /**,      * Template method for subclasses to return a Collection object of Resources.,      * @return Collection.,      */,     protected abstract Collection getCollection();, ,     /**,      * Implement clone.  The set of nested resource,      * collections is shallowly cloned.,      * @return a cloned instance.,      */,     public Object clone() {,         try {,             BaseResourceCollectionContainer c,                 = (BaseResourceCollectionContainer) super.clone();,             c.rc = new ArrayList(rc);,             c.coll = null;,             return c;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Format this BaseResourceCollectionContainer as a String.,      * @return a descriptive <code>String</code>.,      */,     public synchronized String toString() {,         if (isReference()) {,             return getCheckedRef().toString();,         },         if (cacheCollection().size() == 0) {,             return "";,         },         StringBuffer sb = new StringBuffer();,         for (Iterator i = coll.iterator(); i.hasNext();) {,             if (sb.length() > 0) {,                 sb.append(File.pathSeparatorChar);,             },             sb.append(i.next());,         },         return sb.toString();,     }, ,     private synchronized Collection cacheCollection() {,         if (coll == null || !isCache()) {,             coll = getCollection();,         },         return coll;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/FileResource.java,<clinit>,43-43,[        = Resource.getMagicNumber("null file".getBytes());],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/resources/FileResource.java,getOutputStream,238-238,[                f.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/resources/FileResource.java,getOutputStream,243-243,[                p.mkdirs();],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/tools/ant/types/resources/LazyResourceCollectionTest.java,next,61-65,[            if (cursor < 3) {,                 cursor++;,                 return new StringResource("r" + cursor);,             },             return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/resources/LazyResourceCollectionTest.java,,53-69,[    private class StringResourceIterator implements Iterator {,         int cursor = 0;, ,         public void remove() {,             throw new UnsupportedOperationException();,         }, ,         public Object next() {,             if (cursor < 3) {,                 cursor++;,                 return new StringResource("r" + cursor);,             },             return null;,         }, ,         public boolean hasNext() {,             return cursor < 3;],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/tools/ant/types/Resource.java,equals,291-294,[        if (isReference()) {,             return getCheckedRef().equals(other);,         },         return other.getClass().equals(getClass()) && compareTo(other) == 0;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,116-116,[        this.cache = cache;],,,216-216,[        if (cachedColl == null || !cache) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,83-83,[        cachedColl = null;],,,216-216,[        if (cachedColl == null || !cache) {],,,219-219,[        return cachedColl;],,,217-217,[            cachedColl = getCollection();],,,64-64,[        cachedColl = null;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,77-77,[        if (mapper != null) {],,,82-82,[        mapper = new Mapper(getProject());],,,84-84,[        return mapper;],,,158-158,[        if (nested != null || mapper != null) {],,,197-197,[            if (mapper != null) {],,,198-198,[                pushAndInvokeCircularReferenceCheck(mapper, stk, p);],,,224-224,[        FileNameMapper m =],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,158-158,[        if (nested != null || mapper != null) {],,,208-208,[        if (nested == null) {],,,200-200,[            if (nested instanceof DataType) {],,,201-201,[                pushAndInvokeCircularReferenceCheck((DataType) nested, stk, p);],,,58-58,[        if (nested != null) {],,,65-65,[        nested = c;],,,226-226,[        for (Iterator iter = nested.iterator(); iter.hasNext(); ) {],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/resources/MappedResourceCollection.java,,40-241,[public class MappedResourceCollection,         extends DataType implements ResourceCollection, Cloneable {, ,     private ResourceCollection nested = null;,     private Mapper mapper = null;,     private boolean enableMultipleMappings = false;,     private boolean cache = false;,     private Collection cachedColl = null;, ,     /**,      * Adds the required nested ResourceCollection.,      * @param c the ResourceCollection to add.,      * @throws BuildException on error.,      */,     public synchronized void add(ResourceCollection c) throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (nested != null) {,             throw new BuildException("Only one resource collection can be",                                      + " nested into mappedresources",,                                      getLocation());,         },         setChecked(false);,         cachedColl = null;,         nested = c;,     }, ,     /**,      * Define the mapper to map source to destination files.,      * @return a mapper to be configured.,      * @exception BuildException if more than one mapper is defined.,      */,     public Mapper createMapper() throws BuildException {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (mapper != null) {,             throw new BuildException("Cannot define more than one mapper",,                                      getLocation());,         },         setChecked(false);,         mapper = new Mapper(getProject());,         cachedColl = null;,         return mapper;,     }, ,     /**,      * Add a nested filenamemapper.,      * @param fileNameMapper the mapper to add.,      * @since Ant 1.6.3,      */,     public void add(FileNameMapper fileNameMapper) {,         createMapper().add(fileNameMapper);,     }, ,     /**,      * Set method of handling mappers that return multiple,      * mappings for a given source path.,      * @param enableMultipleMappings If true the type will,      *        use all the mappings for a given source path, if,      *        false, only the first mapped name is,      *        processed.,      *        By default, this setting is false to provide backward,      *        compatibility with earlier releases.,      * @since Ant 1.8.1,      */,     public void setEnableMultipleMappings(boolean enableMultipleMappings) {,         this.enableMultipleMappings = enableMultipleMappings;,     }, ,     /**,      * Set whether to cache collections.,      * @since Ant 1.8.1,      */,     public void setCache(boolean cache) {,         this.cache = cache;,     }, ,     /**,      * {@inheritDoc},      */,     public boolean isFilesystemOnly() {,         if (isReference()) {,             return ((MappedResourceCollection) getCheckedRef()),                 .isFilesystemOnly();,         },         checkInitialized();,         return false;,     }, ,     /**,      * {@inheritDoc},      */,     public int size() {,         if (isReference()) {,             return ((MappedResourceCollection) getCheckedRef()).size();,         },         checkInitialized();,         return cacheCollection().size();,     }, ,     /**,      * {@inheritDoc},      */,     public Iterator iterator() {,         if (isReference()) {,             return ((MappedResourceCollection) getCheckedRef()).iterator();,         },         checkInitialized();,         return cacheCollection().iterator();,     }, ,     /**,      * Overrides the base version.,      * @param r the Reference to set.,      */,     public void setRefid(Reference r) {,         if (nested != null || mapper != null) {,             throw tooManyAttributes();,         },         super.setRefid(r);,     }, ,     /**,      * Implement clone.  The nested resource collection and mapper are copied.,      * @return a cloned instance.,      */,     public Object clone() {,         try {,             MappedResourceCollection c =,                 (MappedResourceCollection) super.clone();,             c.nested = nested;,             c.mapper = mapper;,             c.cachedColl = null;,             return c;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);,         },     }, ,     /**,      * Overrides the version of DataType to recurse on all DataType,      * child elements that may have been added.,      * @param stk the stack of data types to use (recursively).,      * @param p   the project to use to dereference the references.,      * @throws BuildException on error.,      */,     protected synchronized void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             checkInitialized();,             if (mapper != null) {,                 pushAndInvokeCircularReferenceCheck(mapper, stk, p);,             },             if (nested instanceof DataType) {,                 pushAndInvokeCircularReferenceCheck((DataType) nested, stk, p);,             },             setChecked(true);,         },     }, ,     private void checkInitialized() {,         if (nested == null) {,             throw new BuildException("A nested resource collection element is",                                      + " required", getLocation());,         },         dieOnCircularReference();,     }, ,     private synchronized Collection cacheCollection() {,         if (cachedColl == null || !cache) {,             cachedColl = getCollection();,         },         return cachedColl;,     }, ,     private Collection getCollection() {,         Collection collected = new ArrayList();,         FileNameMapper m =,             mapper != null ? mapper.getImplementation() : new IdentityMapper();,         for (Iterator iter = nested.iterator(); iter.hasNext(); ) {,             Resource r = (Resource) iter.next();,             if (enableMultipleMappings) {,                 String[] n = m.mapFileName(r.getName());,                 if (n != null) {,                     for (int i = 0; i < n.length; i++) {,                         collected.add(new MappedResource(r,,                                                          new MergingMapper(n[i])),                                       );,                     },                 },             } else {,                 collected.add(new MappedResource(r, m));,             },         },         return collected;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/PropertyResource.java,<clinit>,39-39,[        = Resource.getMagicNumber("PropertyResource".getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/PropertyResource.java,getInputStream,159-159,[        return o == null ? UNSET : new ByteArrayInputStream(String.valueOf(o).getBytes());],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/tools/ant/types/resources/ResourceDecorator.java,hashCode,185-185,[        return (getClass().hashCode() << 4) | getResource().hashCode();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/ResourceList.java,read,193-193,[                input = new InputStreamReader(bis);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/types/resources/ResourceList.java,read,201-201,[            BufferedReader reader = new BufferedReader(crh.getAssembledReader());],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/types/resources/ResourceListTest.java,tearDown,33-33,[    }],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/Resources.java,,84-84,[                if (cache) {],,,138-138,[        cache = b;],,
STYLE,BC_UNCONFIRMED_CAST_OF_RETURN_VALUE,org/apache/tools/ant/types/resources/Sort.java,getCollection,56-56,[        List result = (List) CollectionUtils.asCollection(iter);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/StringResource.java,<clinit>,40-40,[        = Resource.getMagicNumber("StringResource".getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/StringResource.java,getInputStream,189-189,[                ? content.getBytes() : content.getBytes(encoding));],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/tools/ant/types/Resource.java,equals,291-294,[        if (isReference()) {,             return getCheckedRef().equals(other);,         },         return other.getClass().equals(getClass()) && compareTo(other) == 0;],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/tools/ant/types/resources/StringResource.java,hashCode,156-159,[        if (isReference()) {,             return getCheckedRef().hashCode();,         },         return super.hashCode() * STRING_MAGIC;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/StringResource.java,,215-215,[        if (encoding != null) {],,,130-130,[        encoding = s;],,,138-138,[        return encoding;],,,188-188,[        return new ByteArrayInputStream(encoding == null],,,189-189,[                ? content.getBytes() : content.getBytes(encoding));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/StringResource.java,close,255-255,[                    ? baos.toString() : baos.toString(encoding);],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/types/resources/TarResourceTest.java,tearDown,37-37,[    }],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/types/resources/Tokens.java,dieOnCircularReference,126-126,[                pushAndInvokeCircularReferenceCheck((DataType) tokenizer, stk,],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/Tokens.java,getCollection,63-63,[            rdr = new InputStreamReader(cat);],,
PERFORMANCE,DMI_BLOCKING_METHODS_ON_URL,org/apache/tools/ant/types/resources/URLResource.java,equals,307-307,[            : getURL().equals(otheru.getURL());],,
PERFORMANCE,DMI_BLOCKING_METHODS_ON_URL,org/apache/tools/ant/types/resources/URLResource.java,hashCode,318-318,[        return MAGIC * ((getURL() == null) ? NULL_URL : getURL().hashCode());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/resources/URLResource.java,<clinit>,42-42,[        = Resource.getMagicNumber("null URL".getBytes());],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/resources/ZipResource.java,getExtraFields,184-184,[        return extras;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Content.java,,30-66,[public class Content extends ResourceComparator {, ,     private boolean binary = true;, ,     /**,      * Set binary mode for this Content ResourceComparator. If this,      * attribute is set to false, Resource content will be compared,      * ignoring platform line-ending conventions.,      * Default is <code>true</code>.,      * @param b whether to compare content in binary mode.,      */,     public void setBinary(boolean b) {,         binary = b;,     }, ,     /**,      * Learn whether this Content ResourceComparator is operating in binary mode.,      * @return boolean binary flag.,      */,     public boolean isBinary() {,         return binary;,     }, ,     /**,      * Compare two Resources by content.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      * @throws BuildException if I/O errors occur.,      * @see org.apache.tools.ant.util.ResourceUtils#compareContent(Resource, Resource, boolean).,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         try {,             return ResourceUtils.compareContent(foo, bar, !binary);,         } catch (IOException e) {,             throw new BuildException(e);],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Date.java,,26-41,[public class Date extends ResourceComparator {,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         long diff = foo.getLastModified() - bar.getLastModified();,         if (diff > 0) {,             return +1;,         } else if (diff < 0) {,             return -1;,         } else {,             return 0;],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/types/resources/comparators/DelegatedResourceComparator.java,,70-70,[        Vector ov = ((DelegatedResourceComparator) o).v;],,,113-113,[            if (!(v == null || v.isEmpty())) {],,,114-114,[                for (Iterator i = v.iterator(); i.hasNext();) {],,,71-71,[        return v == null ? ov == null : v.equals(ov);],,,88-88,[        if (v == null || v.isEmpty()) {],,,92-92,[        for (Iterator i = v.iterator(); result == 0 && i.hasNext();) {],,,49-49,[        v = (v == null) ? new Vector() : v;],,,50-50,[        v.add(c);],,,82-82,[        return v == null ? 0 : v.hashCode();],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/DelegatedResourceComparator.java,,34-124,[public class DelegatedResourceComparator extends ResourceComparator {, ,     private Vector v = null;, ,     /**,      * Add a delegate ResourceComparator.,      * @param c the next delegate ResourceComparator.,      */,     public synchronized void add(ResourceComparator c) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         if (c == null) {,             return;,         },         v = (v == null) ? new Vector() : v;,         v.add(c);,         setChecked(false);,     }, ,     /**,      * Equality method based on the vector of resources,,      * or if a reference, the referredto object.,      * @param o the object to check against.,      * @return true if there is equality.,      */,     public synchronized boolean equals(Object o) {,         if (o == this) {,             return true;,         },         if (isReference()) {,             return getCheckedRef().equals(o);,         },         if (!(o instanceof DelegatedResourceComparator)) {,             return false;,         },         Vector ov = ((DelegatedResourceComparator) o).v;,         return v == null ? ov == null : v.equals(ov);,     }, ,     /**,      * Hashcode based on the rules for equality.,      * @return a hashcode.,      */,     public synchronized int hashCode() {,         if (isReference()) {,             return getCheckedRef().hashCode();,         },         return v == null ? 0 : v.hashCode();,     }, ,     /** {@inheritDoc} */,     protected synchronized int resourceCompare(Resource foo, Resource bar) {,         //if no nested, natural order:,         if (v == null || v.isEmpty()) {,             return foo.compareTo(bar);,         },         int result = 0;,         for (Iterator i = v.iterator(); result == 0 && i.hasNext();) {,             result = ((ResourceComparator) i.next()).resourceCompare(foo, bar);,         },         return result;,     }, ,     /**,      * Overrides the version from DataType to recurse on nested ResourceSelector, s.,      * @param stk the Stack of references.,      * @param p   the Project to resolve against.,      * @throws BuildException on error.,      */,     protected void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (!(v == null || v.isEmpty())) {,                 for (Iterator i = v.iterator(); i.hasNext();) {,                     Object o = i.next();,                     if (o instanceof DataType) {,                         pushAndInvokeCircularReferenceCheck((DataType) o, stk,,                                                             p);,                     },                 },             },             setChecked(true);,         },     }],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Exists.java,,26-40,[public class Exists extends ResourceComparator {, ,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         boolean f = foo.isExists();,         if (f == bar.isExists()) {,             return 0;,         },         return f ? 1 : -1;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/FileSystem.java,,29-56,[public class FileSystem extends ResourceComparator {,     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();, ,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      * @throws ClassCastException if either resource is not an instance of FileResource.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         FileProvider fooFP = (FileProvider) foo.as(FileProvider.class);,         if (fooFP == null) {,             throw new ClassCastException(foo.getClass(),                                          + " doesn't provide files");,         },         File foofile = fooFP.getFile();,         FileProvider barFP = (FileProvider) bar.as(FileProvider.class);,         if (barFP == null) {,             throw new ClassCastException(bar.getClass(),                                          + " doesn't provide files");,         },         File barfile = barFP.getFile();,         return foofile.equals(barfile) ? 0,             : FILE_UTILS.isLeadingPath(foofile, barfile) ? -1,             : FILE_UTILS.normalize(foofile.getAbsolutePath()).compareTo(,                 FILE_UTILS.normalize(barfile.getAbsolutePath()));],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Name.java,,26-35,[public class Name extends ResourceComparator {,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         return foo.getName().compareTo(bar.getName());],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/tools/ant/types/resources/comparators/Reverse.java,dieOnCircularReference,83-83,[            if (nested instanceof DataType) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Reverse.java,,40-89,[    public Reverse() {,     }, ,     /**,      * Construct a new Reverse, supplying the ResourceComparator to be reversed.,      * @param c the ResourceComparator to reverse.,      */,     public Reverse(ResourceComparator c) {,         add(c);,     }, ,     /**,      * Add the ResourceComparator to reverse.,      * @param c the ResourceComparator to add.,      */,     public void add(ResourceComparator c) {,         if (nested != null) {,             throw new BuildException(ONE_NESTED);,         },         nested = c;,         setChecked(false);,     }, ,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is greater than, equal to, or less than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         return -1 * (nested == null,             ? foo.compareTo(bar) : nested.compare(foo, bar));,     }, ,     protected void dieOnCircularReference(Stack stk, Project p),         throws BuildException {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             if (nested instanceof DataType) {,                 pushAndInvokeCircularReferenceCheck((DataType) nested, stk,,                                                     p);,             },             setChecked(true);,         },     }],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Size.java,,26-35,[public class Size extends ResourceComparator {,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         return (int) (foo.getSize() - bar.getSize());],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/resources/comparators/Type.java,,27-41,[public class Type extends ResourceComparator {, ,     /**,      * Compare two Resources.,      * @param foo the first Resource.,      * @param bar the second Resource.,      * @return a negative integer, zero, or a positive integer as the first,      *         argument is less than, equal to, or greater than the second.,      */,     protected int resourceCompare(Resource foo, Resource bar) {,         boolean f = foo.isDirectory();,         if (f == bar.isDirectory()) {,             return 0;,         },         return f ? 1 : -1;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/types/resources/selectors/Date.java,setMillis,54-54,[        millis = new Long(m);],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/types/resources/selectors/Type.java,getValues,68-68,[            return VALUES;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/ant/types/selectors/AbstractSelectorContainer.java,,37-352,[public abstract class AbstractSelectorContainer extends DataType,     implements Cloneable, SelectorContainer {, ,     private Vector selectorsList = new Vector();, ,     /**,      * Indicates whether there are any selectors here.,      * @return true if there are selectors,      */,     public boolean hasSelectors() {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef()).hasSelectors();,         },         dieOnCircularReference();,         return !(selectorsList.isEmpty());,     }, ,     /**,      * Gives the count of the number of selectors in this container,      * @return the number of selectors,      */,     public int selectorCount() {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef()).selectorCount();,         },         dieOnCircularReference();,         return selectorsList.size();,     }, ,     /**,      * Returns the set of selectors as an array.,      * @param p the current project,      * @return an array of selectors,      */,     public FileSelector[] getSelectors(Project p) {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef(p)),                 .getSelectors(p);,         },         dieOnCircularReference(p);,         FileSelector[] result = new FileSelector[selectorsList.size()];,         selectorsList.copyInto(result);,         return result;,     }, ,     /**,      * Returns an enumerator for accessing the set of selectors.,      * @return an enumerator for the selectors,      */,     public Enumeration selectorElements() {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef()),                 .selectorElements();,         },         dieOnCircularReference();,         return selectorsList.elements();,     }, ,     /**,      * Convert the Selectors within this container to a string. This will,      * just be a helper class for the subclasses that put their own name,      * around the contents listed here.,      *,      * @return comma separated list of Selectors contained in this one,      */,     public String toString() {,         StringBuffer buf = new StringBuffer();,         Enumeration e = selectorElements();,         if (e.hasMoreElements()) {,             while (e.hasMoreElements()) {,                 buf.append(e.nextElement().toString());,                 if (e.hasMoreElements()) {,                     buf.append(", ");,                 },             },         }, ,         return buf.toString();,     }, ,     /**,      * Add a new selector into this container.,      *,      * @param selector the new selector to add,      */,     public void appendSelector(FileSelector selector) {,         if (isReference()) {,             throw noChildrenAllowed();,         },         selectorsList.addElement(selector);,         setChecked(false);,     }, ,     /**,      * <p>,      * This validates each contained selector,      * provided that the selector implements the validate interface.,      * </p>,      * <p>Ordinarily, this will validate all the elements of a selector,      * container even if the isSelected() method of some elements is,      * never called. This has two effects:</p>,      * <ul>,      * <li>Validation will often occur twice.,      * <li>Since it is not required that selectors derive from,      * BaseSelector, there could be selectors in the container whose,      * error conditions are not detected if their isSelected() call,      * is never made.,      * </ul>,      */,     public void validate() {,         if (isReference()) {,             ((AbstractSelectorContainer) getCheckedRef()).validate();,         },         dieOnCircularReference();,         Enumeration e = selectorElements();,         while (e.hasMoreElements()) {,             Object o = e.nextElement();,             if (o instanceof BaseSelector) {,                 ((BaseSelector) o).validate();,             },         },     }, , ,     /* Methods below all add specific selectors */, ,     /**,      * add a "Select" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addSelector(SelectSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add an "And" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addAnd(AndSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add an "Or" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addOr(OrSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a "Not" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addNot(NotSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a "None" selector entry on the selector list,      * @param selector the selector to add,      */,     public void addNone(NoneSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a majority selector entry on the selector list,      * @param selector the selector to add,      */,     public void addMajority(MajoritySelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a selector date entry on the selector list,      * @param selector the selector to add,      */,     public void addDate(DateSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a selector size entry on the selector list,      * @param selector the selector to add,      */,     public void addSize(SizeSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a selector filename entry on the selector list,      * @param selector the selector to add,      */,     public void addFilename(FilenameSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add an extended selector entry on the selector list,      * @param selector the selector to add,      */,     public void addCustom(ExtendSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a contains selector entry on the selector list,      * @param selector the selector to add,      */,     public void addContains(ContainsSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a present selector entry on the selector list,      * @param selector the selector to add,      */,     public void addPresent(PresentSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a depth selector entry on the selector list,      * @param selector the selector to add,      */,     public void addDepth(DepthSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a depends selector entry on the selector list,      * @param selector the selector to add,      */,     public void addDepend(DependSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * adds a different selector to the selector list,      * @param selector the selector to add,      */,     public void addDifferent(DifferentSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * adds a type selector to the selector list,      * @param selector the selector to add,      */,     public void addType(TypeSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add a regular expression selector entry on the selector list,      * @param selector the selector to add,      */,     public void addContainsRegexp(ContainsRegexpSelector selector) {,         appendSelector(selector);,     }, ,     /**,      * add the modified selector,      * @param selector the selector to add,      * @since ant 1.6,      */,     public void addModified(ModifiedSelector selector) {,         appendSelector(selector);,     }, ,     public void addReadable(ReadableSelector r) {,         appendSelector(r);,     }, ,     public void addWritable(WritableSelector w) {,         appendSelector(w);,     }, ,     /**,      * add an arbitary selector,      * @param selector the selector to add,      * @since Ant 1.6,      */,     public void add(FileSelector selector) {,         appendSelector(selector);,     }, ,     protected synchronized void dieOnCircularReference(Stack stk, Project p) {,         if (isChecked()) {,             return;,         },         if (isReference()) {,             super.dieOnCircularReference(stk, p);,         } else {,             for (Iterator i = selectorsList.iterator(); i.hasNext(); ) {,                 Object o = i.next();,                 if (o instanceof DataType) {,                     pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);,                 },             },             setChecked(true);,         },     }, ,     public synchronized Object clone() {,         if (isReference()) {,             return ((AbstractSelectorContainer) getCheckedRef()).clone();,         },         try {,             AbstractSelectorContainer sc =,                 (AbstractSelectorContainer) super.clone();,             sc.selectorsList = new Vector(selectorsList);,             return sc;,         } catch (CloneNotSupportedException e) {,             throw new BuildException(e);],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/tools/ant/types/selectors/AbstractSelectorContainer.java,toString,105-105,[        if (e.hasMoreElements()) {],,toString,106-106,[            while (e.hasMoreElements()) {],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/types/selectors/BaseExtendSelector.java,setParameters,57-57,[        this.parameters = parameters;],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/tools/ant/types/selectors/BaseSelectorContainer.java,toString,98-98,[        if (e.hasMoreElements()) {],,toString,99-99,[            while (e.hasMoreElements()) {],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/types/selectors/BaseSelectorTest.java,,262-284,[        TaskdefForMakingBed(String name) {,             super(name);,         }, ,         public void setUp() {,             configureProject("src/etc/testcases/types/selectors.xml");,         }, ,         public void tearDown() {,             executeTarget("cleanup");,         }, ,         public void makeTestbed() {,             executeTarget("setupfiles");,         }, ,         public void makeMirror() {,             executeTarget("mirrorfiles");,         }, ,         public void deleteMirror() {,             executeTarget("cleanup.mirrorfiles");,         }],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/types/selectors/BaseSelectorTest.java,tearDown,272-272,[        }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/selectors/BaseSelectorTest.java,,262-284,[        TaskdefForMakingBed(String name) {,             super(name);,         }, ,         public void setUp() {,             configureProject("src/etc/testcases/types/selectors.xml");,         }, ,         public void tearDown() {,             executeTarget("cleanup");,         }, ,         public void makeTestbed() {,             executeTarget("setupfiles");,         }, ,         public void makeMirror() {,             executeTarget("mirrorfiles");,         }, ,         public void deleteMirror() {,             executeTarget("cleanup.mirrorfiles");,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/selectors/ContainsRegexpSelector.java,isSelected,187-187,[            in = new BufferedReader(new InputStreamReader(r.getInputStream()));],,
CORRECTNESS,IJU_TEARDOWN_NO_SUPER,org/apache/tools/ant/types/selectors/ContainsRegexpTest.java,tearDown,64-64,[        }],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/ant/types/selectors/ContainsRegexpTest.java,test,75-75,[            filecount = files.length;],,test,74-74,[            files = dir.listFiles();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/selectors/ContainsRegexpTest.java,,54-81,[        TaskdefForRegexpTest(String name) {,             super(name);,         }, ,         public void setUp() {,             configureProject("src/etc/testcases/types/selectors.xml");,         }, ,         public void tearDown() {,             executeTarget("cleanupregexp");,         }, ,         public void test() {,             File dir = null;,             File[] files = null;,             int filecount;, ,             executeTarget("containsregexp");, 	,             dir = new File(getProjectDir() + "/regexpseltestdest/");,             files = dir.listFiles();,             filecount = files.length;, 	,             if (filecount != 1),                 assertEquals("ContainsRegexp test should have copied 1 file",,                              1, files.length);, 	,         }],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/types/selectors/ContainsSelector.java,isSelected,172-172,[            userstr = contains.toLowerCase();],,isSelected,188-188,[                    teststr = teststr.toLowerCase();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/selectors/ContainsSelector.java,isSelected,179-179,[            in = new BufferedReader(new InputStreamReader(r.getInputStream()));],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/selectors/MockComparator.java,,23-30,[public class MockComparator implements Comparator {, ,     public int compare(Object o1, Object o2) {,         return 0;,     }, ,     public String toString() {,         return "MockComparator";],,
PERFORMANCE,DM_STRING_CTOR,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,doTest,624-624,[        Object o1 = new String("string1");],,doTest,625-625,[        Object o2 = new String("string2");],,doTest,626-626,[        Object o3 = new String("string2"); // really "2"],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,<init>,824-824,[            if (bft!=null) bft.deletePropertiesfile();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,testCreatePropertiesCacheViaCustomSelector,409-409,[            if (cachefile!=null) cachefile.delete();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,testCreatePropertiesCacheViaModifiedSelector,373-373,[            if (cachefile!=null) cachefile.delete();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,testSeldirs,667-667,[            if (s!=null) s.getCache().delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,_testScenario2,823-823,[            (new java.io.File(cachefile)).delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,doScenarioTest,868-868,[            cachefile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,testCreatePropertiesCacheViaCustomSelector,409-409,[            if (cachefile!=null) cachefile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,testCreatePropertiesCacheViaModifiedSelector,373-373,[            if (cachefile!=null) cachefile.delete();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,doDelayUpdateTest,271-274,[        switch (kind) {,             case 1 : project.fireTaskFinished();   break;,             case 2 : project.fireTargetFinished(); break;,             case 3 : project.fireBuildFinished();  break;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,writeProperties,940-940,[                    new java.io.FileWriter(file.getAbsolutePath(), true);],,
CORRECTNESS,IJU_NO_TESTS,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,,896-966,[        String buildfile = "src/etc/testcases/types/selectors.xml";, ,         BFT() { super("nothing"); },         BFT(String name) {,             super(name);,         }, ,         String propfile = "ModifiedSelectorTest.properties";, ,         boolean isConfigured = false;, ,         public void setUp() {,             configureProject(buildfile);,             isConfigured = true;,         }, , ,         /**,          * This stub teardown is here because the outer class needs to call the,          * tearDown method, and in the superclass it is protected.,          */,         public void tearDown() {,             try {,                 super.tearDown();,             } catch (Exception e) {,                 // ignore,             },         }, ,         public void doTarget(String target) {,             if (!isConfigured) setUp();,             executeTarget(target);,         }, ,         public String getProperty(String property) {,             return project.getProperty(property);,         }, ,         public void writeProperties(String line) {,             if (!isConfigured) setUp();,             File dir = getProject().getBaseDir();,             File file = new File(dir, propfile);,             try {,                 java.io.FileWriter out =,                     new java.io.FileWriter(file.getAbsolutePath(), true);,                 out.write(line);,                 out.write(System.getProperty("line.separator"));,                 out.flush();,                 out.close();,             } catch (Exception e) {,                 e.printStackTrace();,             },         }, ,         public void deletePropertiesfile() {,             if (!isConfigured) setUp();,             new File(getProject().getBaseDir(), propfile).delete();,         }, ,         public void deleteCachefile() {,             File basedir = new File(buildfile).getParentFile();,             File cacheFile = new File(basedir, "cache.properties");,             cacheFile.delete();,         }, ,         public String getBuildfile() {,             return buildfile;,         },         public void setBuildfile(String buildfile) {,             this.buildfile = buildfile;,         }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,writeProperties,940-940,[                    new java.io.FileWriter(file.getAbsolutePath(), true);],,writeProperties,941-941,[                out.write(line);],,writeProperties,945-945,[            } catch (Exception e) {],,writeProperties,946-946,[                e.printStackTrace();],,writeProperties,948-948,[        }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,writeProperties,939-939,[                java.io.FileWriter out =],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,deleteCachefile,958-958,[            cacheFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,deletePropertiesfile,952-952,[            new File(getProject().getBaseDir(), propfile).delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,,896-966,[        String buildfile = "src/etc/testcases/types/selectors.xml";, ,         BFT() { super("nothing"); },         BFT(String name) {,             super(name);,         }, ,         String propfile = "ModifiedSelectorTest.properties";, ,         boolean isConfigured = false;, ,         public void setUp() {,             configureProject(buildfile);,             isConfigured = true;,         }, , ,         /**,          * This stub teardown is here because the outer class needs to call the,          * tearDown method, and in the superclass it is protected.,          */,         public void tearDown() {,             try {,                 super.tearDown();,             } catch (Exception e) {,                 // ignore,             },         }, ,         public void doTarget(String target) {,             if (!isConfigured) setUp();,             executeTarget(target);,         }, ,         public String getProperty(String property) {,             return project.getProperty(property);,         }, ,         public void writeProperties(String line) {,             if (!isConfigured) setUp();,             File dir = getProject().getBaseDir();,             File file = new File(dir, propfile);,             try {,                 java.io.FileWriter out =,                     new java.io.FileWriter(file.getAbsolutePath(), true);,                 out.write(line);,                 out.write(System.getProperty("line.separator"));,                 out.flush();,                 out.close();,             } catch (Exception e) {,                 e.printStackTrace();,             },         }, ,         public void deletePropertiesfile() {,             if (!isConfigured) setUp();,             new File(getProject().getBaseDir(), propfile).delete();,         }, ,         public void deleteCachefile() {,             File basedir = new File(buildfile).getParentFile();,             File cacheFile = new File(basedir, "cache.properties");,             cacheFile.delete();,         }, ,         public String getBuildfile() {,             return buildfile;,         },         public void setBuildfile(String buildfile) {,             this.buildfile = buildfile;,         }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/tools/ant/types/selectors/ModifiedSelectorTest.java,,978-1008,[        public MockProject() {,             task = new Task(){,                 public void execute() {,                 },             };,             task.setTaskName("testTask");,             target = new Target();,             target.setName("testTarget");,             target.setProject(this);,             target.addTask(task);,             task.setOwningTarget(target);,         }, ,         public void fireBuildFinished() {,             super.fireBuildFinished(null);,         },         public void fireSubBuildFinished() {,             super.fireSubBuildFinished(null);,         },         public void fireTargetStarted() {,             super.fireTargetStarted(target);,         },         public void fireTargetFinished() {,             super.fireTargetFinished(target, null);,         },         public void fireTaskStarted() {,             super.fireTaskStarted(task);,         },         public void fireTaskFinished() {,             super.fireTaskFinished(task, null);,         }],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/modifiedselector/ChecksumAlgorithm.java,getValue,125-125,[                 BufferedInputStream in = new BufferedInputStream(check);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/ChecksumAlgorithm.java,getValue,132-132,[        } catch (Exception e) {],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/tools/ant/types/selectors/modifiedselector/DigestAlgorithm.java,getValue,173-173,[                fis = null;],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/modifiedselector/DigestAlgorithm.java,getValue,166-166,[                DigestInputStream dis = new DigestInputStream(fis,],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/DigestAlgorithm.java,getValue,185-185,[            } catch (Exception e) {],,getValue,188-188,[        } catch (Exception e) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/tools/ant/types/selectors/modifiedselector/EqualComparator.java,,33-56,[public class EqualComparator implements Comparator {, ,     /**,      * Implements Comparator.compare().,      * @param o1 the first object,      * @param o2 the second object,      * @return 0, if both are equal, otherwise 1,      */,     public int compare(Object o1, Object o2) {,         if (o1 == null) {,             if (o2 == null) {,                 return 1;,             },             return 0;,         },         return (o1.equals(o2)) ? 0 : 1;,     }, ,     /**,      * Override Object.toString().,      * @return information about this comparator,      */,     public String toString() {,         return "EqualComparator";],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/types/selectors/modifiedselector/HashvalueAlgorithm.java,getValue,60-60,[            r = new FileReader(file);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/HashvalueAlgorithm.java,getValue,63-63,[        } catch (Exception e) {],,
STYLE,BC_UNCONFIRMED_CAST,org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java,isSelected,440-440,[            FileResource fileResource = (FileResource) resource;],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java,configure,307-307,[            if (par.getName().indexOf(".") > 0) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/modifiedselector/ModifiedSelector.java,isSelected,456-456,[                tmpFile.delete();],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,load,135-135,[                BufferedInputStream bis = new BufferedInputStream(],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,save,161-161,[                BufferedOutputStream bos = new BufferedOutputStream(],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,load,139-139,[            } catch (Exception e) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,save,166-166,[            } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/types/selectors/modifiedselector/PropertiesfileCache.java,delete,176-176,[        cachefile.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/Base64Converter.java,encode,62-62,[        return encode(s.getBytes());],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/ant/util/Base64Converter.java,,52-52,[    public static final char[] alphabet = ALPHABET;],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/tools/ant/util/ClasspathUtilsTest.java,testOnlyOneInstance,62-62,[            list = list + " " + enumeration.nextElement();],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/util/ConcatFileInputStream.java,<init>,51-51,[        this.file = file;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/ant/util/DateUtils.java,formatElapsedTime,140-140,[        Object[] args = {new Long(minutes), new Long(seconds % ONE_MINUTE)};],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/tools/ant/util/FileUtils.java,close,1534-1534,[                    jf = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/FileUtils.java,getDefaultEncoding,1698-1698,[        InputStreamReader is = new InputStreamReader(],,
PERFORMANCE,DM_GC,org/apache/tools/ant/util/FileUtils.java,tryHardToDelete,1566-1566,[                System.gc();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/FileUtils.java,createNewFile,1117-1117,[            parent.mkdirs();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/FileUtils.java,delete,1551-1551,[            file.delete();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/util/FileUtils.java,,1699-1701,[            new InputStream() {,                 public int read() {,                     return -1;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,219-219,[            } catch (Exception e) {],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,217-217,[                 FILE_UTILS.normalize("/").getPath();],,testNormalize,212-212,[                         FILE_UTILS.normalize("/").getPath());],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,234-234,[                 FILE_UTILS.normalize(driveSpec).getPath();],,testNormalize,285-285,[                             FILE_UTILS.normalize(driveSpec).getPath());],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,457-457,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,440-440,[            assertEquals(FILE_UTILS.normalize("/bar").getAbsolutePath(),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,423-423,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("/foo"),],,testRemoveLeadingPath,440-440,[            assertEquals(FILE_UTILS.normalize("/bar").getAbsolutePath(),],,testRemoveLeadingPath,442-442,[            assertEquals(FILE_UTILS.normalize("/foobar").getAbsolutePath(),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,425-425,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("/foo/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,423-423,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("/foo"),],,testRemoveLeadingPath,425-425,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("/foo/"),],,testRemoveLeadingPath,446-446,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar"),],,testRemoveLeadingPath,448-448,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar"),],,testRemoveLeadingPath,452-452,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar/"),],,testRemoveLeadingPath,457-457,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,448-448,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar"),],,testRemoveLeadingPath,450-450,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar/"),],,testRemoveLeadingPath,452-452,[        assertEquals("", FILE_UTILS.removeLeadingPath(new File("/foo/bar/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,442-442,[            assertEquals(FILE_UTILS.normalize("/foobar").getAbsolutePath(),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,459-459,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("c:/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,431-431,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:/foo"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,433-433,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:/foo/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,431-431,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:/foo"),],,testRemoveLeadingPath,433-433,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:/foo/"),],,testRemoveLeadingPath,459-459,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("c:/"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,461-461,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("c:\\"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,435-435,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:\\foo"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,437-437,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:\\foo\\"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testRemoveLeadingPath,435-435,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:\\foo"),],,testRemoveLeadingPath,437-437,[        assertEquals("bar", FILE_UTILS.removeLeadingPath(new File("c:\\foo\\"),],,testRemoveLeadingPath,461-461,[        assertEquals(expected, FILE_UTILS.removeLeadingPath(new File("c:\\"),],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,485-485,[            assertEquals("file:/foo", removeExtraneousAuthority(FILE_UTILS.toURI("/foo")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,488-488,[            assertEquals("file:/" + dosRoot + "foo%20bar", removeExtraneousAuthority(FILE_UTILS.toURI("/foo bar")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,489-489,[            assertEquals("file:/" + dosRoot + "foo%23bar", removeExtraneousAuthority(FILE_UTILS.toURI("/foo#bar")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,500-500,[        assertEquals("file:/" + dosRoot + "%C3%A4nt", removeExtraneousAuthority(FILE_UTILS.toURI("/\u00E4nt")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testToURI,479-479,[            assertEquals("file:/c:/foo", removeExtraneousAuthority(FILE_UTILS.toURI("c:\\foo")));],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/FileUtilsTest.java,testCreateTempFile,370-370,[        File parent = new File((new File("/tmp")).getAbsolutePath());],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/util/FileUtilsTest.java,setUp,46-46,[        root = new File(File.separator).getAbsolutePath().toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/util/FileUtilsTest.java,testHasErrorInCase,571-571,[        String s = wellcased.getName().toUpperCase();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/util/FileUtilsTest.java,testSetLastModified,70-70,[        FileOutputStream fos = new FileOutputStream(removeThis);],,testSetLastModified,71-71,[        fos.write(new byte[0]);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/util/FileUtilsTest.java,testSetLastModified,70-70,[        FileOutputStream fos = new FileOutputStream(removeThis);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,236-236,[            } catch (Exception e) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/FileUtilsTest.java,testCreateTempFile,354-354,[        tmp1.delete();],,testCreateTempFile,367-367,[        tmp2.delete();],,testCreateTempFile,368-368,[        dir2.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/FileUtilsTest.java,testCreateTempFile,357-357,[        dir2.mkdir();],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/tools/ant/util/FileUtilsTest.java,testNormalize,217-217,[                 FILE_UTILS.normalize("/").getPath();],,testNormalize,222-222,[                 FILE_UTILS.normalize("\\").getPath();],,testNormalize,234-234,[                 FILE_UTILS.normalize(driveSpec).getPath();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/util/FirstMatchMapper.java,mapFileName,41-41,[        return null;],,
I18N,DM_CONVERT_CASE,org/apache/tools/ant/util/GlobPatternMapper.java,modifyName,185-185,[            name = name.toLowerCase();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/util/GlobPatternMapper.java,mapFileName,158-158,[            return null;],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/JAXPUtilsTest.java,testGetSystemId,37-37,[            file = new File("/user/local/bin");],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/JAXPUtilsTest.java,testGetSystemId,35-35,[            file = new File("d:\\jdk");],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/JavaEnvUtils.java,createVmsJavaOptionFile,493-493,[            out = new BufferedWriter(new FileWriter(script));],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/tools/ant/util/JavaEnvUtils.java,buildJrePackages,377-380,[                jrePackages.addElement("com.sun.org.apache");,                 //fall through.,             case VERSION_1_4:,                 if (javaVersionNumber == VERSION_1_4) {],,buildJrePackages,388-391,[                jrePackages.addElement("org.xml.sax");,                 // fall through,             case VERSION_1_3:,                 jrePackages.addElement("org.omg");],,buildJrePackages,399-402,[                jrePackages.addElement("sunw.util");,                 // fall through,             case VERSION_1_2:,                 jrePackages.addElement("com.sun.java");],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/tools/ant/util/JavaEnvUtils.java,getJrePackageTestCases,427-431,[                tests.addElement(,                     "com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl ");,                 // Fall tru,             case VERSION_1_4:,                 tests.addElement("sun.audio.AudioPlayer");],,getJrePackageTestCases,440-443,[                tests.addElement("org.xml.sax.XMLReader");,                 // fall through,             case VERSION_1_3:,                 tests.addElement("org.omg.CORBA.Any");],,getJrePackageTestCases,450-453,[                tests.addElement("sunw.util.EventListener");,                 // fall through,             case VERSION_1_2:,                 tests.addElement("javax.accessibility.Accessible");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/tools/ant/util/JavaEnvUtils.java,buildJrePackages,372-403,[        switch(javaVersionNumber) {,             case VERSION_1_7:,             case VERSION_1_6:,             case VERSION_1_5:,                 //In Java1.5, the apache stuff moved.,                 jrePackages.addElement("com.sun.org.apache");,                 //fall through.,             case VERSION_1_4:,                 if (javaVersionNumber == VERSION_1_4) {,                     jrePackages.addElement("org.apache.crimson");,                     jrePackages.addElement("org.apache.xalan");,                     jrePackages.addElement("org.apache.xml");,                     jrePackages.addElement("org.apache.xpath");,                 },                 jrePackages.addElement("org.ietf.jgss");,                 jrePackages.addElement("org.w3c.dom");,                 jrePackages.addElement("org.xml.sax");,                 // fall through,             case VERSION_1_3:,                 jrePackages.addElement("org.omg");,                 jrePackages.addElement("com.sun.corba");,                 jrePackages.addElement("com.sun.jndi");,                 jrePackages.addElement("com.sun.media");,                 jrePackages.addElement("com.sun.naming");,                 jrePackages.addElement("com.sun.org.omg");,                 jrePackages.addElement("com.sun.rmi");,                 jrePackages.addElement("sunw.io");,                 jrePackages.addElement("sunw.util");,                 // fall through,             case VERSION_1_2:,                 jrePackages.addElement("com.sun.java");,                 jrePackages.addElement("com.sun.image");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/tools/ant/util/JavaEnvUtils.java,getJrePackageTestCases,423-455,[        switch(javaVersionNumber) {,             case VERSION_1_7:,             case VERSION_1_6:,             case VERSION_1_5:,                 tests.addElement(,                     "com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl ");,                 // Fall tru,             case VERSION_1_4:,                 tests.addElement("sun.audio.AudioPlayer");,                 if (javaVersionNumber == VERSION_1_4) {,                     tests.addElement("org.apache.crimson.parser.ContentModel");,                     tests.addElement("org.apache.xalan.processor.ProcessorImport");,                     tests.addElement("org.apache.xml.utils.URI");,                     tests.addElement("org.apache.xpath.XPathFactory");,                 },                 tests.addElement("org.ietf.jgss.Oid");,                 tests.addElement("org.w3c.dom.Attr");,                 tests.addElement("org.xml.sax.XMLReader");,                 // fall through,             case VERSION_1_3:,                 tests.addElement("org.omg.CORBA.Any");,                 tests.addElement("com.sun.corba.se.internal.corba.AnyImpl");,                 tests.addElement("com.sun.jndi.ldap.LdapURL");,                 tests.addElement("com.sun.media.sound.Printer");,                 tests.addElement("com.sun.naming.internal.VersionHelper");,                 tests.addElement("com.sun.org.omg.CORBA.Initializer");,                 tests.addElement("sunw.io.Serializable");,                 tests.addElement("sunw.util.EventListener");,                 // fall through,             case VERSION_1_2:,                 tests.addElement("javax.accessibility.Accessible");,                 tests.addElement("sun.misc.BASE64Encoder");,                 tests.addElement("com.sun.image.codec.jpeg.JPEGCodec");],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/KeepAliveOutputStream.java,wrap,82-82,[        return new PrintStream(new KeepAliveOutputStream(ps));],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/tools/ant/util/LayoutPreservingProperties.java,requiresContinuation,426-426,[        return tb % 2 == 1;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/tools/ant/util/LayoutPreservingProperties.java,saveAs,248-248,[        FileOutputStream fos = new FileOutputStream(dest);],,saveAs,249-249,[        store(fos, null);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/util/LayoutPreservingProperties.java,saveAs,248-248,[        FileOutputStream fos = new FileOutputStream(dest);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/tools/ant/util/LayoutPreservingProperties.java,,81-617,[    private String LS = StringUtils.LINE_SEP;, ,     /**,      * Logical lines have escaping and line continuation taken care,      * of. Comments and blank lines are logical lines; they are not,      * removed.,      */,     private ArrayList logicalLines = new ArrayList();, ,     /**,      * Position in the <code>logicalLines</code> list, keyed by property name.,      */,     private HashMap keyedPairLines = new HashMap();, ,     /**,      * Flag to indicate that, when we remove a property from the file, we,      * also want to remove the comments that precede it.,      */,     private boolean removeComments;, ,     /**,      * Create a new, empty, Properties collection, with no defaults.,      */,     public LayoutPreservingProperties() {,         super();,     }, ,     /**,      * Create a new, empty, Properties collection, with the specified defaults.,      * @param defaults the default property values,      */,     public LayoutPreservingProperties(Properties defaults) {,         super(defaults);,     }, ,     /**,      * Returns <code>true</code> if comments are removed along with,      * properties, or <code>false</code> otherwise. If,      * <code>true</code>, then when a property is removed, the comment,      * preceding it in the original file is removed also.,      * @return <code>true</code> if leading comments are removed when,      * a property is removed; <code>false</code> otherwise,      */,     public boolean isRemoveComments() {,         return removeComments;,     }, ,     /**,      * Sets the behaviour for comments accompanying properties that,      * are being removed. If <code>true</code>, then when a property,      * is removed, the comment preceding it in the original file is,      * removed also.,      * @param val <code>true</code> if leading comments are to be,      * removed when a property is removed; <code>false</code>,      * otherwise,      */,     public void setRemoveComments(boolean val) {,         removeComments = val;,     }, ,     public void load(InputStream inStream) throws IOException {,         String s = readLines(inStream);,         byte[] ba = s.getBytes(ResourceUtils.ISO_8859_1);,         ByteArrayInputStream bais = new ByteArrayInputStream(ba);,         super.load(bais);,     }, ,     public Object put(Object key, Object value) throws NullPointerException {,         Object obj = super.put(key, value);,         // the above call will have failed if key or value are null,         innerSetProperty(key.toString(), value.toString());,         return obj;,     }, ,     public Object setProperty(String key, String value),         throws NullPointerException {,         Object obj = super.setProperty(key, value);,         // the above call will have failed if key or value are null,         innerSetProperty(key, value);,         return obj;,     }, ,     /**,      * Store a new key-value pair, or add a new one. The normal,      * functionality is taken care of by the superclass in the call to,      * {@link #setProperty}; this method takes care of this classes,      * extensions.,      * @param key the key of the property to be stored,      * @param value the value to be stored,      */,     private void innerSetProperty(String key, String value) {,         value = escapeValue(value);, ,         if (keyedPairLines.containsKey(key)) {,             Integer i = (Integer) keyedPairLines.get(key);,             Pair p = (Pair) logicalLines.get(i.intValue());,             p.setValue(value);,         } else {,             key = escapeName(key);,             Pair p = new Pair(key, value);,             p.setNew(true);,             keyedPairLines.put(key, new Integer(logicalLines.size()));,             logicalLines.add(p);,         },     }, ,     public void clear() {,         super.clear();,         keyedPairLines.clear();,         logicalLines.clear();,     }, ,     public Object remove(Object key) {,         Object obj = super.remove(key);,         Integer i = (Integer) keyedPairLines.remove(key);,         if (null != i) {,             if (removeComments) {,                 removeCommentsEndingAt(i.intValue());,             },             logicalLines.set(i.intValue(), null);,         },         return obj;,     }, ,     public Object clone() {,         LayoutPreservingProperties dolly =,             (LayoutPreservingProperties) super.clone();,         dolly.keyedPairLines = (HashMap) this.keyedPairLines.clone();,         dolly.logicalLines = (ArrayList) this.logicalLines.clone();,         for (int j = 0; j < dolly.logicalLines.size(); j++) {,             LogicalLine line = (LogicalLine) dolly.logicalLines.get(j);,             if (line instanceof Pair) {,                 Pair p = (Pair) line;,                 dolly.logicalLines.set(j, p.clone());,             },             // no reason to clone other lines are they are immutable,         },         return dolly;,     }, ,     /**,      * Echo the lines of the properties (including blanks and comments) to the,      * stream.,      * @param out the stream to write to,      */,     public void listLines(PrintStream out) {,         out.println("-- logical lines --");,         Iterator i = logicalLines.iterator();,         while (i.hasNext()) {,             LogicalLine line = (LogicalLine) i.next();,             if (line instanceof Blank) {,                 out.println("blank:   \"" + line + "\"");,             },             else if (line instanceof Comment) {,                 out.println("comment: \"" + line + "\"");,             },             else if (line instanceof Pair) {,                 out.println("pair:    \"" + line + "\"");,             },         },     }, ,     /**,      * Save the properties to a file.,      * @param dest the file to write to,      */,     public void saveAs(File dest) throws IOException {,         FileOutputStream fos = new FileOutputStream(dest);,         store(fos, null);,         fos.close();,     }, ,     public void store(OutputStream out, String header) throws IOException {,         OutputStreamWriter osw = new OutputStreamWriter(out, ResourceUtils.ISO_8859_1);, ,         int skipLines = 0;,         int totalLines = logicalLines.size();, ,         if (header != null) {,             osw.write("#" + header + LS);,             if (totalLines > 0,                 && logicalLines.get(0) instanceof Comment,                 && header.equals(logicalLines.get(0).toString().substring(1))) {,                 skipLines = 1;,             },         }, ,         // we may be updatiung a file written by this class, replace,         // the date comment instead of adding a new one and preserving,         // the one written last time,         if (totalLines > skipLines,             && logicalLines.get(skipLines) instanceof Comment) {,             try {,                 DateUtils.parseDateFromHeader(logicalLines,                                               .get(skipLines),                                               .toString().substring(1));,                 skipLines++;,             } catch (java.text.ParseException pe) {,                 // not an existing date comment,             },         },         osw.write("#" + DateUtils.getDateForHeader() + LS);, ,         boolean writtenSep = false;,         for (Iterator i = logicalLines.subList(skipLines, totalLines).iterator();,              i.hasNext(); ) {,             LogicalLine line = (LogicalLine) i.next();,             if (line instanceof Pair) {,                 if (((Pair)line).isNew()) {,                     if (!writtenSep) {,                         osw.write(LS);,                         writtenSep = true;,                     },                 },                 osw.write(line.toString() + LS);,             },             else if (line != null) {,                 osw.write(line.toString() + LS);,             },         },         osw.close();,     }, ,     /**,      * Reads a properties file into an internally maintained,      * collection of logical lines (possibly spanning physcial lines),,      * which make up the comments, blank lines and properties of the,      * file.,      * @param is the stream from which to read the data,      */,     private String readLines(InputStream is) throws IOException {,         InputStreamReader isr = new InputStreamReader(is, ResourceUtils.ISO_8859_1);,         PushbackReader pbr = new PushbackReader(isr, 1);, ,         if (logicalLines.size() > 0) {,             // we add a blank line for spacing,             logicalLines.add(new Blank());,         }, ,         String s = readFirstLine(pbr);,         BufferedReader br = new BufferedReader(pbr);, ,         boolean continuation = false;,         boolean comment = false;,         StringBuffer fileBuffer = new StringBuffer();,         StringBuffer logicalLineBuffer = new StringBuffer();,         while (s != null) {,             fileBuffer.append(s).append(LS);, ,             if (continuation) {,                 // put in the line feed that was removed,                 s = "\n" + s;,             } else {,                 // could be a comment, if first non-whitespace is a # or !,                 comment = s.matches("^( |\t|\f)*(#|!).*");,             }, ,             // continuation if not a comment and the line ends is an,             // odd number of backslashes,             if (!comment) {,                 continuation = requiresContinuation(s);,             }, ,             logicalLineBuffer.append(s);, ,             if (!continuation) {,                 LogicalLine line = null;,                 if (comment) {,                     line = new Comment(logicalLineBuffer.toString());,                 } else if (logicalLineBuffer.toString().trim().length() == 0) {,                     line = new Blank();,                 } else {,                     line = new Pair(logicalLineBuffer.toString());,                     String key = unescape(((Pair)line).getName());,                     if (keyedPairLines.containsKey(key)) {,                         // this key is already present, so we remove it and add,                         // the new one,                         remove(key);,                     },                     keyedPairLines.put(key, new Integer(logicalLines.size()));,                 },                 logicalLines.add(line);,                 logicalLineBuffer.setLength(0);,             },             s = br.readLine();,         },         return fileBuffer.toString();,     }, ,     /**,      * Reads the first line and determines the EOL-style of the file,      * (relies on the style to be consistent, of course).,      *,      * <p>Sets LS as a side-effect.</p>,      *,      * @return the first line without any line separator, leaves the,      * reader positioned after the first line separator,      *,      * @since Ant 1.8.2,      */,     private String readFirstLine(PushbackReader r) throws IOException {,         StringBuffer sb = new StringBuffer(80);,         int ch = r.read();,         boolean hasCR = false;,         // when reaching EOF before the first EOL, assume native line,         // feeds,         LS = StringUtils.LINE_SEP;, ,         while (ch >= 0) {,             if (hasCR && ch != '\n') {,                 // line feed is sole CR,                 r.unread(ch);,                 break;,             }, ,             if (ch == '\r') {,                 LS = "\r";,                 hasCR = true;,             } else if (ch == '\n') {,                 LS = hasCR ? "\r\n" : "\n";,                 break;,             } else {,                 sb.append((char) ch);,             },             ch = r.read();,         },         return sb.toString();,     }, ,     /**,      * Returns <code>true</code> if the line represented by,      * <code>s</code> is to be continued on the next line of the file,,      * or <code>false</code> otherwise.,      * @param s the contents of the line to examine,      * @return <code>true</code> if the line is to be continued,,      * <code>false</code> otherwise,      */,     private boolean requiresContinuation(String s) {,         char[] ca = s.toCharArray();,         int i = ca.length - 1;,         while (i > 0 && ca[i] == '\\') {,             i--;,         },         // trailing backslashes,         int tb = ca.length - i - 1;,         return tb % 2 == 1;,     }, ,     /**,      * Unescape the string according to the rules for a Properites,      * file, as laid out in the docs for <a,      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.,      * @param s the string to unescape (coming from the source file),      * @return the unescaped string,      */,     private String unescape(String s) {,         /*,          * The following combinations are converted:,          * \n  newline,          * \r  carraige return,          * \f  form feed,          * \t  tab,          * \\  backslash,          * \u0000  unicode character,          * Any other slash is ignored, so,          * \b  becomes 'b'.,          */, ,         char[] ch = new char[s.length() + 1];,         s.getChars(0, s.length(), ch, 0);,         ch[s.length()] = '\n';,         StringBuffer buffy = new StringBuffer(s.length());,         for (int i = 0; i < ch.length; i++) {,             char c = ch[i];,             if (c == '\n') {,                 // we have hit out end-of-string marker,                 break;,             },             else if (c == '\\') {,                 // possibly an escape sequence,                 c = ch[++i];,                 if (c == 'n'),                     buffy.append('\n');,                 else if (c == 'r'),                     buffy.append('\r');,                 else if (c == 'f'),                     buffy.append('\f');,                 else if (c == 't'),                     buffy.append('\t');,                 else if (c == 'u') {,                     // handle unicode escapes,                     c = unescapeUnicode(ch, i+1);,                     i += 4;,                     buffy.append(c);,                 },                 else,                     buffy.append(c);,             },             else {,                 buffy.append(c);,             },         },         return buffy.toString();,     }, ,     /**,      * Retrieve the unicode character whose code is listed at position,      * <code>i</code> in the character array <code>ch</code>.,      * @param ch the character array containing the unicode character code,      * @return the character extracted,      */,     private char unescapeUnicode(char[] ch, int i) {,         String s = new String(ch, i, 4);,         return (char) Integer.parseInt(s, 16);,     }, ,     /**,      * Escape the string <code>s</code> according to the rules in the,      * docs for <a,      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.,      * @param s the string to escape,      * @return the escaped string,      */,     private String escapeValue(String s) {,         return escape(s, false);,     }, ,     /**,      * Escape the string <code>s</code> according to the rules in the,      * docs for <a,      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.,      * This method escapes all the whitespace, not just the stuff at,      * the beginning.,      * @param s the string to escape,      * @return the escaped string,      */,     private String escapeName(String s) {,         return escape(s, true);,     }, ,     /**,      * Escape the string <code>s</code> according to the rules in the,      * docs for <a,      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.,      * @param s the string to escape,      * @param escapeAllSpaces if <code>true</code> the method escapes,      * all the spaces, if <code>false</code>, it escapes only the,      * leading whitespace,      * @return the escaped string,      */,     private String escape(String s, boolean escapeAllSpaces) {,         if (s == null) {,             return null;,         }, ,         char[] ch = new char[s.length()];,         s.getChars(0, s.length(), ch, 0);,         String forEscaping = "\t\f\r\n\\:=#!";,         String escaped = "tfrn\\:=#!";,         StringBuffer buffy = new StringBuffer(s.length());,         boolean leadingSpace = true;,         for (int i = 0; i < ch.length; i++) {,             char c = ch[i];,             if (c == ' ') {,                 if (escapeAllSpaces || leadingSpace) {,                     buffy.append("\\");,                 },             } else {,                 leadingSpace = false;,             },             int p = forEscaping.indexOf(c);,             if (p != -1) {,                 buffy.append("\\").append(escaped.substring(p,p+1));,             } else if (c < 0x0020 || c > 0x007e) {,                 buffy.append(escapeUnicode(c));,             } else {,                 buffy.append(c);,             },         },         return buffy.toString();,     }, ,     /**,      * Return the unicode escape sequence for a character, in the form,      * \u005CuNNNN.,      * @param ch the character to encode,      * @return the unicode escape sequence,      */,     private String escapeUnicode(char ch) {,         StringBuffer buffy = new StringBuffer("\\u");,         String hex = Integer.toHexString((int)ch);,         buffy.append("0000".substring(4-hex.length()));,         buffy.append(hex);,         return buffy.toString();,     }, ,     /**,      * Remove the comments in the leading up the {@link logicalLines},      * list leading up to line <code>pos</code>.,      * @param pos the line number to which the comments lead,      */,     private void removeCommentsEndingAt(int pos) {,         /* We want to remove comments preceding this position. Step,          * back counting blank lines (call this range B1) until we hit,          * something non-blank. If what we hit is not a comment, then,          * exit. If what we hit is a comment, then step back counting,          * comment lines (call this range C1). Nullify lines in C1 and,          * B1.,          */, ,         int end = pos - 1;, ,         // step pos back until it hits something non-blank,         for (pos = end; pos > 0; pos--) {,             if (!(logicalLines.get(pos) instanceof Blank)) {,                 break;,             },         }, ,         // if the thing it hits is not a comment, then we have nothing,         // to remove,         if (!(logicalLines.get(pos) instanceof Comment)) {,             return;,         }, ,         // step back until we hit the start of the comment,         for (; pos >= 0; pos--) {,             if (!(logicalLines.get(pos) instanceof Comment)) {,                 break;,             },         }, ,         // now we want to delete from pos+1 to end,         for (pos++ ;pos <= end; pos++) {,             logicalLines.set(pos, null);,         },     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,readFile,301-301,[        InputStreamReader isr = new InputStreamReader(fis);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testClear,156-156,[        FileInputStream fis = new FileInputStream(simple);],,testClear,157-157,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testClear,158-158,[        lpf.load(fis);],,testClear,160-160,[        lpf.clear();],,testClear,162-162,[        File tmp = File.createTempFile("tmp", "props");],,testClear,163-163,[        tmp.deleteOnExit();],,testClear,164-164,[        lpf.saveAs(tmp);],,testClear,167-167,[        String s = readFile(tmp);],,testClear,169-169,[        assertTrue("should have had no properties ",],,testClear,170-170,[                   s.indexOf("prop.alpha") == -1);],,testClear,171-171,[        assertTrue("should have had no properties ",],,testClear,172-172,[                   s.indexOf("prop.beta") == -1);],,testClear,173-173,[        assertTrue("should have had no properties ",],,testClear,174-174,[                   s.indexOf("prop.gamma") == -1);],,testClear,176-176,[        assertTrue("should have had no comments",],,testClear,177-177,[                   s.indexOf("# a comment") == -1);],,testClear,178-178,[        assertTrue("should have had no comments",],,testClear,179-179,[                   s.indexOf("! more comment") == -1);],,testClear,180-180,[        assertTrue("should have had no comments",],,testClear,181-181,[                   s.indexOf("# now a line wrapping one") == -1);],,testClear,182-182,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testClone,233-233,[        FileInputStream fis = new FileInputStream(simple);],,testClone,234-234,[        LayoutPreservingProperties lpf1 = new LayoutPreservingProperties();],,testClone,235-235,[        lpf1.load(fis);],,testClone,237-237,[        LayoutPreservingProperties lpf2 =],,testClone,238-238,[            (LayoutPreservingProperties) lpf1.clone();],,testClone,240-240,[        lpf2.setProperty("prop.new", "a new property");],,testClone,241-241,[        lpf2.setProperty("prop.beta", "a new value for beta");],,testClone,243-243,[        assertEquals("size of original is wrong", 3, lpf1.size());],,testClone,244-244,[        assertEquals("size of clone is wrong", 4, lpf2.size());],,testClone,246-246,[        File tmp1 = File.createTempFile("tmp", "props");],,testClone,247-247,[        tmp1.deleteOnExit();],,testClone,248-248,[        lpf1.saveAs(tmp1);],,testClone,249-249,[        String s1 = readFile(tmp1);],,testClone,251-251,[        File tmp2 = File.createTempFile("tmp", "props");],,testClone,252-252,[        tmp2.deleteOnExit();],,testClone,253-253,[        lpf2.saveAs(tmp2);],,testClone,254-254,[        String s2 = readFile(tmp2);],,testClone,257-257,[        assertTrue("should have had 'simple'", s1.indexOf("simple") > -1);],,testClone,258-258,[        assertTrue("should not have had prop.new", s1.indexOf("prop.new") == -1);],,testClone,261-261,[        assertTrue("should have had 'a new value for beta'",],,testClone,262-262,[                   s2.indexOf("a new value for beta") > -1);],,testClone,263-263,[        assertTrue("should have had prop.new", s2.indexOf("prop.new") > -1);],,testClone,264-264,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testOverwrite,110-110,[        FileInputStream fis = new FileInputStream(unusual);],,testOverwrite,111-111,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testOverwrite,112-112,[        lpf.load(fis);],,testOverwrite,114-114,[        lpf.setProperty(" prop one ", "new one");],,testOverwrite,115-115,[        lpf.setProperty("prop\ttwo", "new two");],,testOverwrite,116-116,[        lpf.setProperty("prop\nthree", "new three");],,testOverwrite,118-118,[        File tmp = File.createTempFile("tmp", "props");],,testOverwrite,119-119,[        tmp.deleteOnExit();],,testOverwrite,120-120,[        lpf.saveAs(tmp);],,testOverwrite,123-123,[        String s = readFile(tmp);],,testOverwrite,125-125,[        assertTrue(s.indexOf("\\ prop\\ one\\ =\\ \\ leading and"],,testOverwrite,127-127,[        assertTrue(s.indexOf("\\ prop\\ one\\ =new one") > -1);],,testOverwrite,128-128,[        assertTrue(s.indexOf("prop\\ttwo=contains\\ttab") == -1);],,testOverwrite,129-129,[        assertTrue(s.indexOf("prop\\ttwo=new two") > -1);],,testOverwrite,130-130,[        assertTrue(s.indexOf("prop\\nthree=contains\\nnewline") == -1);],,testOverwrite,131-131,[        assertTrue(s.indexOf("prop\\nthree=new three") > -1);],,testOverwrite,132-132,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testPreserve,42-42,[        FileInputStream fis = new FileInputStream(simple);],,testPreserve,43-43,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testPreserve,44-44,[        lpf.load(fis);],,testPreserve,46-46,[        File tmp = File.createTempFile("tmp", "props");],,testPreserve,47-47,[        tmp.deleteOnExit();],,testPreserve,48-48,[        lpf.saveAs(tmp);],,testPreserve,51-51,[        Properties originalProps = new Properties();],,testPreserve,52-52,[        originalProps.load(new FileInputStream(simple));],,testPreserve,54-54,[        Properties tmpProps = new Properties();],,testPreserve,55-55,[        tmpProps.load(new FileInputStream(tmp));],,testPreserve,57-57,[        assertEquals("properties corrupted", originalProps, tmpProps);],,testPreserve,60-60,[        String s = readFile(tmp);],,testPreserve,61-61,[        assertTrue("missing comment", s.indexOf("# a comment") > -1);],,testPreserve,62-62,[        assertTrue("missing comment", s.indexOf("! more comment") > -1);],,testPreserve,63-63,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testPreserveEscapeName,270-270,[        FileInputStream fis = new FileInputStream(unusual);],,testPreserveEscapeName,271-271,[        lpf.load(fis);],,testPreserveEscapeName,273-273,[        lpf.setProperty("prop:seven", "new value for seven");],,testPreserveEscapeName,274-274,[        lpf.setProperty("prop=eight", "new value for eight");],,testPreserveEscapeName,275-275,[        lpf.setProperty("prop eleven", "new value for eleven");],,testPreserveEscapeName,277-277,[        lpf.setProperty("alpha", "new value for alpha");],,testPreserveEscapeName,278-278,[        lpf.setProperty("beta", "new value for beta");],,testPreserveEscapeName,280-280,[        File tmp = File.createTempFile("tmp", "props");],,testPreserveEscapeName,281-281,[        tmp.deleteOnExit();],,testPreserveEscapeName,282-282,[        lpf.saveAs(tmp);],,testPreserveEscapeName,285-285,[        String s = readFile(tmp);],,testPreserveEscapeName,287-287,[        assertTrue(s.indexOf("prop\\:seven=new value for seven") > -1);],,testPreserveEscapeName,288-288,[        assertTrue(s.indexOf("prop\\=eight=new value for eight") > -1);],,testPreserveEscapeName,289-289,[        assertTrue(s.indexOf("prop\\ eleven=new value for eleven") > -1);],,testPreserveEscapeName,290-290,[        assertTrue(s.indexOf("alpha=new value for alpha") > -1);],,testPreserveEscapeName,291-291,[        assertTrue(s.indexOf("beta=new value for beta") > -1);],,testPreserveEscapeName,293-293,[        assertTrue(s.indexOf("prop\\:seven=contains\\:colon") == -1);],,testPreserveEscapeName,294-294,[        assertTrue(s.indexOf("prop\\=eight=contains\\=equals") == -1);],,testPreserveEscapeName,295-295,[        assertTrue(s.indexOf("alpha:set with a colon") == -1);],,testPreserveEscapeName,296-296,[        assertTrue(s.indexOf("beta set with a space") == -1);],,testPreserveEscapeName,297-297,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testRemove,187-187,[        FileInputStream fis = new FileInputStream(simple);],,testRemove,188-188,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testRemove,189-189,[        lpf.load(fis);],,testRemove,191-191,[        lpf.remove("prop.beta");],,testRemove,193-193,[        File tmp = File.createTempFile("tmp", "props");],,testRemove,194-194,[        tmp.deleteOnExit();],,testRemove,195-195,[        lpf.saveAs(tmp);],,testRemove,198-198,[        String s = readFile(tmp);],,testRemove,200-200,[        assertTrue("should not have had prop.beta",],,testRemove,201-201,[                   s.indexOf("prop.beta") == -1);],,testRemove,202-202,[        assertTrue("should have had prop.beta's comment",],,testRemove,203-203,[                   s.indexOf("! more comment") > -1);],,testRemove,204-204,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testRemoveWithComment,209-209,[        FileInputStream fis = new FileInputStream(simple);],,testRemoveWithComment,210-210,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testRemoveWithComment,211-211,[        lpf.load(fis);],,testRemoveWithComment,213-213,[        lpf.setRemoveComments(true);],,testRemoveWithComment,215-215,[        lpf.remove("prop.beta");],,testRemoveWithComment,217-217,[        File tmp = File.createTempFile("tmp", "props");],,testRemoveWithComment,218-218,[        tmp.deleteOnExit();],,testRemoveWithComment,219-219,[        lpf.saveAs(tmp);],,testRemoveWithComment,222-222,[        String s = readFile(tmp);],,testRemoveWithComment,224-224,[        assertTrue("should not have had prop.beta",],,testRemoveWithComment,225-225,[                   s.indexOf("prop.beta") == -1);],,testRemoveWithComment,226-226,[        assertTrue("should not have had prop.beta's comment",],,testRemoveWithComment,227-227,[                   s.indexOf("! more comment") == -1);],,testRemoveWithComment,228-228,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testStoreWithHeader,137-137,[        FileInputStream fis = new FileInputStream(simple);],,testStoreWithHeader,138-138,[        LayoutPreservingProperties lpf = new LayoutPreservingProperties();],,testStoreWithHeader,139-139,[        lpf.load(fis);],,testStoreWithHeader,141-141,[        File tmp = File.createTempFile("tmp", "props");],,testStoreWithHeader,142-142,[        tmp.deleteOnExit();],,testStoreWithHeader,143-143,[        FileOutputStream fos = new FileOutputStream(tmp);],,testStoreWithHeader,144-144,[        lpf.store(fos, "file-header");],,testStoreWithHeader,145-145,[        fos.close();],,testStoreWithHeader,148-148,[        String s = readFile(tmp);],,testStoreWithHeader,150-150,[        assertTrue("should have had header ", s.startsWith("#file-header"));],,testStoreWithHeader,151-151,[    }],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testPreserve,52-52,[        originalProps.load(new FileInputStream(simple));],,testPreserve,55-55,[        tmpProps.load(new FileInputStream(tmp));],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,readFile,301-301,[        InputStreamReader isr = new InputStreamReader(fis);],,
BAD_PRACTICE,OS_OPEN_STREAM_EXCEPTION_PATH,org/apache/tools/ant/util/LayoutPreservingPropertiesTest.java,testStoreWithHeader,143-143,[        FileOutputStream fos = new FileOutputStream(tmp);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/ant/util/LazyFileOutputStreamTest.java,tearDown,43-43,[            f.delete();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/tools/ant/util/LazyHashtable.java,,33-115,[    protected boolean initAllDone = false;,     // CheckStyle:VisibilityModifier OFF - bc, ,     /** No arg constructor. */,     public LazyHashtable() {,         super();,     }, ,     /** Used to be part of init. It must be done once - but,      * we delay it until we do need _all_ tasks. Otherwise we,      * just get the tasks that we need, and avoid costly init.,      */,     protected void initAll() {,         if (initAllDone) {,             return;,         },         initAllDone = true;,     }, , ,     /**,      * Get a enumeration over the elements.,      * @return an enumeration.,      */,     public Enumeration elements() {,         initAll();,         return super.elements();,     }, ,     /**,      * Check if the table is empty.,      * @return true if it is.,      */,     public boolean isEmpty() {,         initAll();,         return super.isEmpty();,     }, ,     /**,      * Get the size of the table.,      * @return the size.,      */,     public int size() {,         initAll();,         return super.size();,     }, ,     /**,      * Check if the table contains a particular value.,      * @param value the value to look for.,      * @return true if the table contains the value.,      */,     public boolean contains(Object value) {,         initAll();,         return super.contains(value);,     }, ,     /**,      * Check if the table contains a particular key.,      * @param value the key to look for.,      * @return true if the table contains key.,      */,     public boolean containsKey(Object value) {,         initAll();,         return super.containsKey(value);,     }, ,     /**,      * Delegates to {@link #contains contains}.,      * @param value the value to look for.,      * @return true if the table contains the value.,      */,     public boolean containsValue(Object value) {,         return contains(value);,     }, ,     /**,      * Get an enumeration over the keys.,      * @return an enumeration.,      */,     public Enumeration keys() {,         initAll();,         return super.keys();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LineOrientedOutputStream.java,processBuffer,82-82,[            processLine(buffer.toString());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LineOrientedOutputStreamTest.java,writeByteArray,111-111,[        stream.write(LINE.getBytes(), 0, LINE.length());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/LineOrientedOutputStreamTest.java,writeSingleBytes,115-115,[        byte[] b = LINE.getBytes();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/ant/util/LineOrientedOutputStreamTest.java,,125-135,[    private class DummyStream extends LineOrientedOutputStream {,         private boolean invoked;,         protected void processLine(String line) {,             assertFalse("Only one line", invoked);,             assertEquals(LINE, line);,             invoked = true;,         }, ,         private void assertInvoked() {,             assertTrue("At least one line", invoked);,         }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/tools/ant/util/LinkedHashtable.java,,43-128,[    public LinkedHashtable() {,         map = new LinkedHashMap();,     }, ,     public LinkedHashtable(int initialCapacity) {,         map = new LinkedHashMap(initialCapacity);,     }, ,     public LinkedHashtable(int initialCapacity, float loadFactor) {,         map = new LinkedHashMap(initialCapacity, loadFactor);,     }, ,     public LinkedHashtable(Map m) {,         map = new LinkedHashMap(m);,     }, ,     public synchronized void clear() {,         map.clear();,     }, ,     public boolean contains(Object value) {,         return containsKey(value);,     }, ,     public synchronized boolean containsKey(Object value) {,         return map.containsKey(value);,     }, ,     public synchronized boolean containsValue(Object value) {,         return map.containsValue(value);,     }, ,     public Enumeration elements() {,         return CollectionUtils.asEnumeration(values().iterator());,     }, ,     public synchronized Set entrySet() {,         return map.entrySet();,     }, ,     public synchronized boolean equals(Object o) {,         return map.equals(o);,     }, ,     public synchronized Object get(Object k) {,         return map.get(k);,     }, ,     public synchronized int hashCode() {,         return map.hashCode();,     }, ,     public synchronized boolean isEmpty() {,         return map.isEmpty();,     }, ,     public Enumeration keys() {,         return CollectionUtils.asEnumeration(keySet().iterator());,     }, ,     public synchronized Set keySet() {,         return map.keySet();,     }, ,     public synchronized Object put(Object k, Object v) {,         return map.put(k, v);,     }, ,     public synchronized void putAll(Map m) {,         map.putAll(m);,     }, ,     public synchronized Object remove(Object k) {,         return map.remove(k);,     }, ,     public synchronized int size() {,         return map.size();,     }, ,     public synchronized String toString() {,         return map.toString();,     }, ,     public synchronized Collection values() {,         return map.values();],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/ant/util/MergingMapper.java,mapFileName,64-64,[        return mergedFile;],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/tools/ant/util/OutputStreamFunneler.java,release,147-147,[                        wait(timeoutMillis);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/PropertyOutputStream.java,close,63-63,[            String s = new String(toByteArray());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ReaderInputStreamTest.java,testReadZero,69-69,[        assertEquals("abc".getBytes().length, readin);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/tools/ant/util/ReaderInputStreamTest.java,testReadZero,65-65,[        r.read(bytes, 0, 0);],,
STYLE,UC_USELESS_OBJECT,org/apache/tools/ant/util/ReaderInputStreamTest.java,testSimpleAbc16,43-43,[        byte[] bytes = new byte[40];],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/tools/ant/util/ReflectUtil.java,getField,150-150,[            field.setAccessible(true);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/util/ReflectUtil.java,invoke,109-109,[        } catch (Exception t) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/util/ReflectUtil.java,invoke,133-133,[        } catch (Exception t) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/tools/ant/util/ReflectWrapper.java,<init>,43-43,[        } catch (Exception t) {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/ant/util/RegexpPatternMapper.java,mapFileName,123-123,[            return null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ResourceUtils.java,copyResource,418-418,[                    isr = new InputStreamReader(source.getInputStream());],,copyResource,469-469,[                    isr = new InputStreamReader(source.getInputStream());],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ResourceUtils.java,copyResource,427-427,[                    osw = new OutputStreamWriter(os);],,copyResource,478-478,[                    osw = new OutputStreamWriter(os);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ResourceUtils.java,textCompare,725-725,[            in1 = new BufferedReader(new InputStreamReader(r1.getInputStream()));],,textCompare,726-726,[            in2 = new BufferedReader(new InputStreamReader(r2.getInputStream()));],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/tools/ant/util/ResourceUtils.java,selectSources,195-195,[            srName = srName == null],,
STYLE,RV_DONT_JUST_NULL_CHECK_READLINE,org/apache/tools/ant/util/ResourceUtils.java,textCompare,739-739,[            return in2.readLine() == null ? 0 : -1;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ScriptRunnerBase.java,loadResource,242-242,[        readSource(new InputStreamReader(in), name);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/ScriptRunnerBase.java,setSrc,200-200,[            readSource(new FileReader(file), filename);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/tools/ant/util/ScriptRunnerBase.java,setSrc,200-200,[            readSource(new FileReader(file), filename);],,setSrc,204-204,[        }],,setSrc,205-205,[    }],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/tools/ant/util/ScriptRunnerBase.java,addBeans,74-74,[                Object val = dictionary.get(key);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/util/ScriptRunnerCreator.java,createRunner,113-113,[        if (!manager.equals(AUTO) && !manager.equals(checkManager)) {],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/tools/ant/util/ScriptRunnerHelper.java,,164-164,[        scriptLoader = loader;],,,168-168,[        if (scriptLoader != null) {],,,169-169,[            return scriptLoader;],,,175-175,[        scriptLoader = cpDelegate.getClassLoader();],,,176-176,[        return scriptLoader;],,,172-172,[            scriptLoader = getClass().getClassLoader();],,,173-173,[            return scriptLoader;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/ant/util/ScriptRunnerHelper.java,getRunner,190-190,[        return new ScriptRunnerCreator(projectComponent.getProject()).createRunner(],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/tools/ant/util/SourceFileScanner.java,,95-97,[            v.addElement(new FileResource(srcDir, name) {,                 public String getName() {,                     return name;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/ant/util/SplitClassLoader.java,<init>,40-40,[        this.splitClasses = splitClasses;],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/ant/util/SymlinkUtilsTest.java,testRootIsNoSymlink,30-30,[        assertFalse(SYMLINK_UTILS.isSymbolicLink("/"));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/ant/util/UUEncoder.java,encodeString,85-85,[        PrintStream writer = new PrintStream(out);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/tools/ant/util/VectorSet.java,,41-224,[    private final HashSet set = new HashSet();, ,     public VectorSet() { super(); }, ,     public VectorSet(int initialCapacity) { super(initialCapacity); }, ,     public VectorSet(int initialCapacity, int capacityIncrement) {,         super(initialCapacity, capacityIncrement);,     }, ,     public VectorSet(Collection c) {,         if (c != null) {,             for (Iterator i = c.iterator(); i.hasNext(); ) {,                 add(i.next());,             },         },     }, ,     public synchronized boolean add(Object o) {,         if (!set.contains(o)) {,             doAdd(size(), o);,             return true;,         },         return false;,     }, ,     /**,      * This implementation may not add the element at the given index,      * if it is already contained in the collection.,      */,     public void add(int index, Object o) {,         doAdd(index, o);,     }, ,     private synchronized void doAdd(int index, Object o) {,         // Vector.add seems to delegate to insertElementAt, but this,         // is not documented so we may better implement it ourselves,         if (set.add(o)) {,             int count = size();,             ensureCapacity(count + 1);,             if (index != count) {,                 System.arraycopy(elementData, index, elementData, index + 1,,                                  count - index);,             },             elementData[index] = o;,             elementCount++;,         },     }, ,     public synchronized void addElement(Object o) {,         doAdd(size(), o);,     }, ,     public synchronized boolean addAll(Collection c) {,         boolean changed = false;,         for (Iterator i = c.iterator(); i.hasNext(); ) {,             changed |= add(i.next());,         },         return changed;,     }, ,     /**,      * This implementation may not add all elements at the given index,      * if any of them are already contained in the collection.,      */,     public synchronized boolean addAll(int index, Collection c) {,         boolean changed = false;,         for (Iterator i = c.iterator(); i.hasNext(); ) {,             Object o = i.next();,             if (!set.contains(o)) {,                 doAdd(index++, o);,                 changed = true;,             },         },         return changed;,     }, ,     public synchronized void clear() {,         super.clear();,         set.clear();,     }, ,     public Object clone() {,         VectorSet vs = (VectorSet) super.clone();,         vs.set.addAll(set);,         return vs;,     }, ,     public synchronized boolean contains(Object o) {,         return set.contains(o);,     }, ,     public synchronized boolean containsAll(Collection c) {,         return set.containsAll(c);,     }, ,     public void insertElementAt(Object o, int index) {,         doAdd(index, o);,     }, ,     public synchronized Object remove(int index) {,         Object o = get(index);,         remove(o);,         return o;,     }, ,     public boolean remove(Object o) {,         return doRemove(o);,     }, ,     private synchronized boolean doRemove(Object o) {,         // again, remove seems to delegate to removeElement, but we,         // shouldn't trust it,         if (set.remove(o)) {,             int index = indexOf(o);,             if (index < elementData.length - 1) {,                 System.arraycopy(elementData, index + 1, elementData, index,,                                  elementData.length - index - 1);,             },             elementCount--;,             return true;,         },         return false;,     }, ,     public synchronized boolean removeAll(Collection c) {,         boolean changed = false;,         for (Iterator i = c.iterator(); i.hasNext(); ) {,             changed |= remove(i.next());,         },         return changed;,     }, ,     public synchronized void removeAllElements() {,         set.clear();,         super.removeAllElements();,     }, ,     public boolean removeElement(Object o) {,         return doRemove(o);,     }, ,     public synchronized void removeElementAt(int index) {,         remove(get(index));,     }, ,     public synchronized void removeRange(final int fromIndex, int toIndex) {,         while (toIndex > fromIndex) {,             remove(--toIndex);,         },     }, ,     public synchronized boolean retainAll(Collection c) {,         LinkedList l = new LinkedList();,         for (Iterator i = iterator(); i.hasNext(); ) {,             Object o = i.next();,             if (!c.contains(o)) {,                 l.addLast(o);,             },         },         if (!l.isEmpty()) {,             removeAll(l);,             return true;,         },         return false;,     }, ,     public synchronized Object set(int index, Object o) {,         Object orig = get(index);,         if (set.add(o)) {,             elementData[index] = o;,             set.remove(orig);,         } else {,             int oldIndexOfO = indexOf(o);,             remove(o);,             remove(orig);,             add(oldIndexOfO > index ? index : index - 1, o);,         },         return orig;,     }, ,     public void setElementAt(Object o, int index) {,         set(index, o);,     }],,
MT_CORRECTNESS,WA_NOT_IN_LOOP,org/apache/tools/ant/util/WorkerAnt.java,waitUntilFinished,122-122,[                notify.wait(timeout);],,
MALICIOUS_CODE,MS_OOI_PKGPROTECT,org/apache/tools/bzip2/BZip2Constants.java,,55-55,[    int[] rNums = {],,
STYLE,DLS_DEAD_LOCAL_STORE,org/apache/tools/bzip2/CBZip2StreamTest.java,testNullPointer,30-30,[            CBZip2InputStream cb = new CBZip2InputStream(new ByteArrayInputStream(new byte[0]));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/tools/mail/MailMessage.java,replyto,207-208,[      this.replyto.addElement(rto);,     }],,replyTo,705-706,[            replyToList.add(replyTo);,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessageTest.java,testAsciiCharset,484-484,[            baos1.toString(), baos2.toString() ); // order of headers cannot be guaranteed],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessageTest.java,testAsciiCharset,475-475,[        PrintStream bos1 = new PrintStream(baos1, true);],,testAsciiCharset,476-476,[        PrintStream bos2 = new PrintStream(baos2, true);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/tools/mail/MailMessageTest.java,,612-730,[    private class ClientThread implements Runnable {, ,         private MailMessage msg;,         private boolean fail = false;,         private String failMessage = null;, ,         protected String from = null;,         protected String subject = null;,         protected String message = null;, ,         protected Vector replyToList = new Vector();,         protected Vector toList = new Vector();,         protected Vector ccList = new Vector();,         protected Vector bccList = new Vector();, , ,         public void run() {,             for (int i = 9; i > 0; i--) {,                 try {,                     msg = new MailMessage("localhost", TEST_PORT);,                 } catch (java.net.ConnectException ce) {,                     try {,                         Thread.sleep(10 * 1000);,                     } catch (InterruptedException ie) {,                         // ignore,                     },                 } catch (IOException ioe) {,                     fail = true;,                     failMessage = "IOException: " + ioe;,                     return;,                 },                 if (msg != null) {,                     break;,                 },             }, ,             if (msg == null) {,                 fail = true;,                 failMessage = "java.net.ConnectException: Connection refused";,                 return;,             }, ,             try {,                 msg.from(from);, ,                 Enumeration e;, ,                 e = replyToList.elements();,                 while (e.hasMoreElements()) {,                     msg.replyto(e.nextElement().toString());,                 }, ,                 e = toList.elements();,                 while (e.hasMoreElements()) {,                     msg.to(e.nextElement().toString());,                 }, ,                 e = ccList.elements();,                 while (e.hasMoreElements()) {,                     msg.cc(e.nextElement().toString());,                 }, ,                 e = bccList.elements();,                 while (e.hasMoreElements()) {,                     msg.bcc(e.nextElement().toString());,                 }, ,                 if (subject != null) {,                     msg.setSubject(subject);,                 }, ,                 if (message != null ) {,                     PrintStream out = msg.getPrintStream();,                     out.println( message );,                 }, ,                 msg.sendAndClose();,             } catch (IOException ioe) {,                 fail = true;,                 failMessage = "IOException: " + ioe;,                 return;,             },         }, ,         public boolean isFailed() {,             return fail;,         }, ,         public String getFailMessage() {,             return failMessage;,         }, ,         public void replyTo(String replyTo) {,             replyToList.add(replyTo);,         }, ,         public void to(String to) {,             toList.add(to);,         }, ,         public void cc(String cc) {,             ccList.add(cc);,         }, ,         public void bcc(String bcc) {,             bccList.add(bcc);,         }, ,         public void setSubject(String subject) {,             this.subject = subject;,         }, ,         public void from(String from) {,             this.from = from;,         }, ,         public void setMessage(String message) {,             this.message = message;,         }],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessageTest.java,run,512-512,[                    sock.getInputStream()) );],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessageTest.java,run,514-514,[                    sock.getOutputStream() ) );],,
CORRECTNESS,IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD,org/apache/tools/mail/MailMessageTest.java,run,554-554,[                fail();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/MailMessage.java,<init>,490-490,[    super(out, true);  // deprecated, but email is byte-oriented],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/mail/SmtpResponseReader.java,<init>,45-45,[        reader = new BufferedReader(new InputStreamReader(in));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/tar/TarBuffer.java,readRecord,224-224,[                return null;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/tools/tar/TarEntry.java,getDirectoryEntries,540-540,[        TarEntry[] result = new TarEntry[list.length];],,getDirectoryEntries,539-539,[        String[]   list = file.list();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/tools/tar/TarEntry.java,normalizeFileName,630-630,[        if (osname != null) {],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/tools/tar/TarEntryTest.java,testFileConstructor,36-36,[        new TarEntry(new java.io.File("/foo"));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/tar/TarInputStream.java,getNextEntry,270-270,[                longName.append(new String(buf, 0, length));],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/tar/TarOutputStream.java,putNextEntry,185-185,[                write(entry.getName().getBytes());],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/tools/tar/TarOutputStream.java,,88-88,[        this.debug = false;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/zip/AbstractUnicodeExtraField.java,getCentralDirectoryData,123-123,[        return data;],,
MALICIOUS_CODE,EI_EXPOSE_REP,org/apache/tools/zip/AbstractUnicodeExtraField.java,getUnicodeName,108-108,[        return unicodeName;],,
MALICIOUS_CODE,EI_EXPOSE_REP2,org/apache/tools/zip/AbstractUnicodeExtraField.java,setUnicodeName,115-115,[        this.unicodeName = unicodeName;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/AsiExtraField.java,getLocalFileDataData,141-141,[        byte[] linkArray = getLinkedFile().getBytes();],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/AsiExtraField.java,getLocalFileDataLength,118-118,[                          + getLinkedFile().getBytes().length);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/AsiExtraField.java,parseFromLocalFileData,314-314,[            link = new String(linkArray);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/tools/zip/ExtraFieldUtils.java,parse,160-166,[                    v.add(field);,                     /*FALLTHROUGH*/,                 case UnparseableExtraField.SKIP_KEY:,                     // since we cannot parse the data we must assume,                     // the extra field consumes the whole rest of the,                     // available data,                     break LOOP;],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/FallbackZipEncoding.java,decode,89-89,[            return new String(data);],,
I18N,DM_DEFAULT_ENCODING,org/apache/tools/zip/FallbackZipEncoding.java,encode,77-77,[            return ByteBuffer.wrap(name.getBytes());],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/tools/zip/Simple8BitZipEncoding.java,compareTo,62-64,[            Simple8BitChar a = (Simple8BitChar) o;, ,             return this.unicode - a.unicode;],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/zip/UTF8ZipFilesTest.java,testFileRoundtrip,105-105,[                file.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/tools/zip/UTF8ZipFilesTest.java,testZipFileReadsUnicodeFields,90-90,[                file.delete();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/zip/UnrecognizedExtraField.java,getLocalFileDataLength,77-77,[        return new ZipShort(localData.length);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/tools/zip/ZipEntry.java,,55-516,[    private int internalAttributes = 0;,     private int platform = PLATFORM_FAT;,     private long externalAttributes = 0;,     private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;,     private UnparseableExtraFieldData unparseableExtra = null;,     private String name = null;, ,     /**,      * Creates a new zip entry with the specified name.,      * @param name the name of the entry,      * @since 1.1,      */,     public ZipEntry(String name) {,         super(name);,     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      * @param entry the entry to get fields from,      * @since 1.1,      * @throws ZipException on error,      */,     public ZipEntry(java.util.zip.ZipEntry entry) throws ZipException {,         super(entry);,         byte[] extra = entry.getExtra();,         if (extra != null) {,             setExtraFields(ExtraFieldUtils.parse(extra, true,,                                                  ExtraFieldUtils,                                                  .UnparseableExtraField.READ));,         } else {,             // initializes extra data to an empty byte array,             setExtra();,         },     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      * @param entry the entry to get fields from,      * @throws ZipException on error,      * @since 1.1,      */,     public ZipEntry(ZipEntry entry) throws ZipException {,         this((java.util.zip.ZipEntry) entry);,         setInternalAttributes(entry.getInternalAttributes());,         setExternalAttributes(entry.getExternalAttributes());,         setExtraFields(entry.getExtraFields(true));,     }, ,     /**,      * @since 1.9,      */,     protected ZipEntry() {,         super("");,     }, ,     /**,      * Overwrite clone.,      * @return a cloned copy of this ZipEntry,      * @since 1.1,      */,     public Object clone() {,         ZipEntry e = (ZipEntry) super.clone();, ,         e.setInternalAttributes(getInternalAttributes());,         e.setExternalAttributes(getExternalAttributes());,         e.setExtraFields(getExtraFields(true));,         return e;,     }, ,     /**,      * Retrieves the internal file attributes.,      *,      * @return the internal file attributes,      * @since 1.1,      */,     public int getInternalAttributes() {,         return internalAttributes;,     }, ,     /**,      * Sets the internal file attributes.,      * @param value an <code>int</code> value,      * @since 1.1,      */,     public void setInternalAttributes(int value) {,         internalAttributes = value;,     }, ,     /**,      * Retrieves the external file attributes.,      * @return the external file attributes,      * @since 1.1,      */,     public long getExternalAttributes() {,         return externalAttributes;,     }, ,     /**,      * Sets the external file attributes.,      * @param value an <code>long</code> value,      * @since 1.1,      */,     public void setExternalAttributes(long value) {,         externalAttributes = value;,     }, ,     /**,      * Sets Unix permissions in a way that is understood by Info-Zip's,      * unzip command.,      * @param mode an <code>int</code> value,      * @since Ant 1.5.2,      */,     public void setUnixMode(int mode) {,         // CheckStyle:MagicNumberCheck OFF - no point,         setExternalAttributes((mode << SHORT_SHIFT),                               // MS-DOS read-only attribute,                               | ((mode & 0200) == 0 ? 1 : 0),                               // MS-DOS directory flag,                               | (isDirectory() ? 0x10 : 0));,         // CheckStyle:MagicNumberCheck ON,         platform = PLATFORM_UNIX;,     }, ,     /**,      * Unix permission.,      * @return the unix permissions,      * @since Ant 1.6,      */,     public int getUnixMode() {,         return platform != PLATFORM_UNIX ? 0 :,             (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);,     }, ,     /**,      * Platform specification to put into the &quot;version made,      * by&quot; part of the central file header.,      *,      * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode},      * has been called, in which case PLATORM_UNIX will be returned.,      *,      * @since Ant 1.5.2,      */,     public int getPlatform() {,         return platform;,     }, ,     /**,      * Set the platform (UNIX or FAT).,      * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX,      * @since 1.9,      */,     protected void setPlatform(int platform) {,         this.platform = platform;,     }, ,     /**,      * Replaces all currently attached extra fields with the new array.,      * @param fields an array of extra fields,      * @since 1.1,      */,     public void setExtraFields(ZipExtraField[] fields) {,         extraFields = new LinkedHashMap();,         for (int i = 0; i < fields.length; i++) {,             if (fields[i] instanceof UnparseableExtraFieldData) {,                 unparseableExtra = (UnparseableExtraFieldData) fields[i];,             } else {,                 extraFields.put(fields[i].getHeaderId(), fields[i]);,             },         },         setExtra();,     }, ,     /**,      * Retrieves all extra fields that have been parsed successfully.,      * @return an array of the extra fields,      */,     public ZipExtraField[] getExtraFields() {,         return getExtraFields(false);,     }, ,     /**,      * Retrieves extra fields.,      * @param includeUnparseable whether to also return unparseable,      * extra fields as {@link UnparseableExtraFieldData} if such data,      * exists.,      * @return an array of the extra fields,      * @since 1.1,      */,     public ZipExtraField[] getExtraFields(boolean includeUnparseable) {,         if (extraFields == null) {,             return !includeUnparseable || unparseableExtra == null,                 ? new ZipExtraField[0],                 : new ZipExtraField[] { unparseableExtra };,         },         List result = new ArrayList(extraFields.values());,         if (includeUnparseable && unparseableExtra != null) {,             result.add(unparseableExtra);,         },         return (ZipExtraField[]) result.toArray(new ZipExtraField[0]);,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>If no extra field of the same type exists, the field will be,      * added as last field.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addExtraField(ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             if (extraFields == null) {,                 extraFields = new LinkedHashMap();,             },             extraFields.put(ze.getHeaderId(), ze);,         },         setExtra();,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>The new extra field will be the first one.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addAsFirstExtraField(ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             LinkedHashMap copy = extraFields;,             extraFields = new LinkedHashMap();,             extraFields.put(ze.getHeaderId(), ze);,             if (copy != null) {,                 copy.remove(ze.getHeaderId());,                 extraFields.putAll(copy);,             },         },         setExtra();,     }, ,     /**,      * Remove an extra field.,      * @param type the type of extra field to remove,      * @since 1.1,      */,     public void removeExtraField(ZipShort type) {,         if (extraFields == null) {,             throw new java.util.NoSuchElementException();,         },         if (extraFields.remove(type) == null) {,             throw new java.util.NoSuchElementException();,         },         setExtra();,     }, ,     /**,      * Removes unparseable extra field data.,      */,     public void removeUnparseableExtraFieldData() {,         if (unparseableExtra == null) {,             throw new java.util.NoSuchElementException();,         },         unparseableExtra = null;,         setExtra();,     }, ,     /**,      * Looks up an extra field by its header id.,      *,      * @return null if no such field exists.,      */,     public ZipExtraField getExtraField(ZipShort type) {,         if (extraFields != null) {,             return (ZipExtraField) extraFields.get(type);,         },         return null;,     }, ,     /**,      * Looks up extra field data that couldn't be parsed correctly.,      *,      * @return null if no such field exists.,      */,     public UnparseableExtraFieldData getUnparseableExtraFieldData() {,         return unparseableExtra;,     }, ,     /**,      * Parses the given bytes as extra field data and consumes any,      * unparseable data as an {@link UnparseableExtraFieldData},      * instance.,      * @param extra an array of bytes to be parsed into extra fields,      * @throws RuntimeException if the bytes cannot be parsed,      * @since 1.1,      * @throws RuntimeException on error,      */,     public void setExtra(byte[] extra) throws RuntimeException {,         try {,             ZipExtraField[] local =,                 ExtraFieldUtils.parse(extra, true,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(local, true);,         } catch (Exception e) {,             // actually this is not be possible as of Ant 1.8.1,             throw new RuntimeException("Error parsing extra fields for entry: ",                                        + getName() + " - " + e.getMessage(), e);,         },     }, ,     /**,      * Unfortunately {@link java.util.zip.ZipOutputStream,      * java.util.zip.ZipOutputStream} seems to access the extra data,      * directly, so overriding getExtra doesn't help - we need to,      * modify super's data directly.,      *,      * @since 1.1,      */,     protected void setExtra() {,         super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));,     }, ,     /**,      * Sets the central directory part of extra fields.,      */,     public void setCentralDirectoryExtra(byte[] b) {,         try {,             ZipExtraField[] central =,                 ExtraFieldUtils.parse(b, false,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(central, false);,         } catch (Exception e) {,             throw new RuntimeException(e.getMessage(), e);,         },     }, ,     /**,      * Retrieves the extra data for the local file data.,      * @return the extra data for local file,      * @since 1.1,      */,     public byte[] getLocalFileDataExtra() {,         byte[] extra = getExtra();,         return extra != null ? extra : new byte[0];,     }, ,     /**,      * Retrieves the extra data for the central directory.,      * @return the central directory extra data,      * @since 1.1,      */,     public byte[] getCentralDirectoryExtra() {,         return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));,     }, ,     /**,      * Make this class work in JDK 1.1 like a 1.2 class.,      *,      * <p>This either stores the size for later usage or invokes,      * setCompressedSize via reflection.</p>,      * @param size the size to use,      * @deprecated since 1.7.,      *             Use setCompressedSize directly.,      * @since 1.2,      */,     public void setComprSize(long size) {,         setCompressedSize(size);,     }, ,     /**,      * Get the name of the entry.,      * @return the entry name,      * @since 1.9,      */,     public String getName() {,         return name == null ? super.getName() : name;,     }, ,     /**,      * Is this entry a directory?,      * @return true if the entry is a directory,      * @since 1.10,      */,     public boolean isDirectory() {,         return getName().endsWith("/");,     }, ,     /**,      * Set the name of the entry.,      * @param name the name to use,      */,     protected void setName(String name) {,         this.name = name;,     }, ,     /**,      * Get the hashCode of the entry.,      * This uses the name as the hashcode.,      * @return a hashcode.,      * @since Ant 1.7,      */,     public int hashCode() {,         // this method has severe consequences on performance. We cannot rely,         // on the super.hashCode() method since super.getName() always return,         // the empty string in the current implemention (there's no setter),         // so it is basically draining the performance of a hashmap lookup,         return getName().hashCode();,     }, ,     /**,      * The equality method. In this case, the implementation returns 'this == o',      * which is basically the equals method of the Object class.,      * @param o the object to compare to,      * @return true if this object is the same as <code>o</code>,      * @since Ant 1.7,      */,     public boolean equals(Object o) {,         return (this == o);,     }, ,     /**,      * If there are no extra fields, use the given fields as new extra,      * data - otherwise merge the fields assuming the existing fields,      * and the new fields stem from different locations inside the,      * archive.,      * @param f the extra fields to merge,      * @param local whether the new fields originate from local data,      */,     private void mergeExtraFields(ZipExtraField[] f, boolean local),         throws ZipException {,         if (extraFields == null) {,             setExtraFields(f);,         } else {,             for (int i = 0; i < f.length; i++) {,                 ZipExtraField existing;,                 if (f[i] instanceof UnparseableExtraFieldData) {,                     existing = unparseableExtra;,                 } else {,                     existing = getExtraField(f[i].getHeaderId());,                 },                 if (existing == null) {,                     addExtraField(f[i]);,                 } else {,                     if (local,                         || !(existing,                              instanceof CentralDirectoryParsingZipExtraField)) {,                         byte[] b = f[i].getLocalFileDataData();,                         existing.parseFromLocalFileData(b, 0, b.length);,                     } else {,                         byte[] b = f[i].getCentralDirectoryData();,                         ((CentralDirectoryParsingZipExtraField) existing),                             .parseFromCentralDirectoryData(b, 0, b.length);,                     },                 },             },             setExtra();,         },     }],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/tools/zip/ZipEntry.java,,55-516,[    private int internalAttributes = 0;,     private int platform = PLATFORM_FAT;,     private long externalAttributes = 0;,     private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;,     private UnparseableExtraFieldData unparseableExtra = null;,     private String name = null;, ,     /**,      * Creates a new zip entry with the specified name.,      * @param name the name of the entry,      * @since 1.1,      */,     public ZipEntry(String name) {,         super(name);,     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      * @param entry the entry to get fields from,      * @since 1.1,      * @throws ZipException on error,      */,     public ZipEntry(java.util.zip.ZipEntry entry) throws ZipException {,         super(entry);,         byte[] extra = entry.getExtra();,         if (extra != null) {,             setExtraFields(ExtraFieldUtils.parse(extra, true,,                                                  ExtraFieldUtils,                                                  .UnparseableExtraField.READ));,         } else {,             // initializes extra data to an empty byte array,             setExtra();,         },     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      * @param entry the entry to get fields from,      * @throws ZipException on error,      * @since 1.1,      */,     public ZipEntry(ZipEntry entry) throws ZipException {,         this((java.util.zip.ZipEntry) entry);,         setInternalAttributes(entry.getInternalAttributes());,         setExternalAttributes(entry.getExternalAttributes());,         setExtraFields(entry.getExtraFields(true));,     }, ,     /**,      * @since 1.9,      */,     protected ZipEntry() {,         super("");,     }, ,     /**,      * Overwrite clone.,      * @return a cloned copy of this ZipEntry,      * @since 1.1,      */,     public Object clone() {,         ZipEntry e = (ZipEntry) super.clone();, ,         e.setInternalAttributes(getInternalAttributes());,         e.setExternalAttributes(getExternalAttributes());,         e.setExtraFields(getExtraFields(true));,         return e;,     }, ,     /**,      * Retrieves the internal file attributes.,      *,      * @return the internal file attributes,      * @since 1.1,      */,     public int getInternalAttributes() {,         return internalAttributes;,     }, ,     /**,      * Sets the internal file attributes.,      * @param value an <code>int</code> value,      * @since 1.1,      */,     public void setInternalAttributes(int value) {,         internalAttributes = value;,     }, ,     /**,      * Retrieves the external file attributes.,      * @return the external file attributes,      * @since 1.1,      */,     public long getExternalAttributes() {,         return externalAttributes;,     }, ,     /**,      * Sets the external file attributes.,      * @param value an <code>long</code> value,      * @since 1.1,      */,     public void setExternalAttributes(long value) {,         externalAttributes = value;,     }, ,     /**,      * Sets Unix permissions in a way that is understood by Info-Zip's,      * unzip command.,      * @param mode an <code>int</code> value,      * @since Ant 1.5.2,      */,     public void setUnixMode(int mode) {,         // CheckStyle:MagicNumberCheck OFF - no point,         setExternalAttributes((mode << SHORT_SHIFT),                               // MS-DOS read-only attribute,                               | ((mode & 0200) == 0 ? 1 : 0),                               // MS-DOS directory flag,                               | (isDirectory() ? 0x10 : 0));,         // CheckStyle:MagicNumberCheck ON,         platform = PLATFORM_UNIX;,     }, ,     /**,      * Unix permission.,      * @return the unix permissions,      * @since Ant 1.6,      */,     public int getUnixMode() {,         return platform != PLATFORM_UNIX ? 0 :,             (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);,     }, ,     /**,      * Platform specification to put into the &quot;version made,      * by&quot; part of the central file header.,      *,      * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode},      * has been called, in which case PLATORM_UNIX will be returned.,      *,      * @since Ant 1.5.2,      */,     public int getPlatform() {,         return platform;,     }, ,     /**,      * Set the platform (UNIX or FAT).,      * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX,      * @since 1.9,      */,     protected void setPlatform(int platform) {,         this.platform = platform;,     }, ,     /**,      * Replaces all currently attached extra fields with the new array.,      * @param fields an array of extra fields,      * @since 1.1,      */,     public void setExtraFields(ZipExtraField[] fields) {,         extraFields = new LinkedHashMap();,         for (int i = 0; i < fields.length; i++) {,             if (fields[i] instanceof UnparseableExtraFieldData) {,                 unparseableExtra = (UnparseableExtraFieldData) fields[i];,             } else {,                 extraFields.put(fields[i].getHeaderId(), fields[i]);,             },         },         setExtra();,     }, ,     /**,      * Retrieves all extra fields that have been parsed successfully.,      * @return an array of the extra fields,      */,     public ZipExtraField[] getExtraFields() {,         return getExtraFields(false);,     }, ,     /**,      * Retrieves extra fields.,      * @param includeUnparseable whether to also return unparseable,      * extra fields as {@link UnparseableExtraFieldData} if such data,      * exists.,      * @return an array of the extra fields,      * @since 1.1,      */,     public ZipExtraField[] getExtraFields(boolean includeUnparseable) {,         if (extraFields == null) {,             return !includeUnparseable || unparseableExtra == null,                 ? new ZipExtraField[0],                 : new ZipExtraField[] { unparseableExtra };,         },         List result = new ArrayList(extraFields.values());,         if (includeUnparseable && unparseableExtra != null) {,             result.add(unparseableExtra);,         },         return (ZipExtraField[]) result.toArray(new ZipExtraField[0]);,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>If no extra field of the same type exists, the field will be,      * added as last field.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addExtraField(ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             if (extraFields == null) {,                 extraFields = new LinkedHashMap();,             },             extraFields.put(ze.getHeaderId(), ze);,         },         setExtra();,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>The new extra field will be the first one.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addAsFirstExtraField(ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             LinkedHashMap copy = extraFields;,             extraFields = new LinkedHashMap();,             extraFields.put(ze.getHeaderId(), ze);,             if (copy != null) {,                 copy.remove(ze.getHeaderId());,                 extraFields.putAll(copy);,             },         },         setExtra();,     }, ,     /**,      * Remove an extra field.,      * @param type the type of extra field to remove,      * @since 1.1,      */,     public void removeExtraField(ZipShort type) {,         if (extraFields == null) {,             throw new java.util.NoSuchElementException();,         },         if (extraFields.remove(type) == null) {,             throw new java.util.NoSuchElementException();,         },         setExtra();,     }, ,     /**,      * Removes unparseable extra field data.,      */,     public void removeUnparseableExtraFieldData() {,         if (unparseableExtra == null) {,             throw new java.util.NoSuchElementException();,         },         unparseableExtra = null;,         setExtra();,     }, ,     /**,      * Looks up an extra field by its header id.,      *,      * @return null if no such field exists.,      */,     public ZipExtraField getExtraField(ZipShort type) {,         if (extraFields != null) {,             return (ZipExtraField) extraFields.get(type);,         },         return null;,     }, ,     /**,      * Looks up extra field data that couldn't be parsed correctly.,      *,      * @return null if no such field exists.,      */,     public UnparseableExtraFieldData getUnparseableExtraFieldData() {,         return unparseableExtra;,     }, ,     /**,      * Parses the given bytes as extra field data and consumes any,      * unparseable data as an {@link UnparseableExtraFieldData},      * instance.,      * @param extra an array of bytes to be parsed into extra fields,      * @throws RuntimeException if the bytes cannot be parsed,      * @since 1.1,      * @throws RuntimeException on error,      */,     public void setExtra(byte[] extra) throws RuntimeException {,         try {,             ZipExtraField[] local =,                 ExtraFieldUtils.parse(extra, true,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(local, true);,         } catch (Exception e) {,             // actually this is not be possible as of Ant 1.8.1,             throw new RuntimeException("Error parsing extra fields for entry: ",                                        + getName() + " - " + e.getMessage(), e);,         },     }, ,     /**,      * Unfortunately {@link java.util.zip.ZipOutputStream,      * java.util.zip.ZipOutputStream} seems to access the extra data,      * directly, so overriding getExtra doesn't help - we need to,      * modify super's data directly.,      *,      * @since 1.1,      */,     protected void setExtra() {,         super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));,     }, ,     /**,      * Sets the central directory part of extra fields.,      */,     public void setCentralDirectoryExtra(byte[] b) {,         try {,             ZipExtraField[] central =,                 ExtraFieldUtils.parse(b, false,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(central, false);,         } catch (Exception e) {,             throw new RuntimeException(e.getMessage(), e);,         },     }, ,     /**,      * Retrieves the extra data for the local file data.,      * @return the extra data for local file,      * @since 1.1,      */,     public byte[] getLocalFileDataExtra() {,         byte[] extra = getExtra();,         return extra != null ? extra : new byte[0];,     }, ,     /**,      * Retrieves the extra data for the central directory.,      * @return the central directory extra data,      * @since 1.1,      */,     public byte[] getCentralDirectoryExtra() {,         return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));,     }, ,     /**,      * Make this class work in JDK 1.1 like a 1.2 class.,      *,      * <p>This either stores the size for later usage or invokes,      * setCompressedSize via reflection.</p>,      * @param size the size to use,      * @deprecated since 1.7.,      *             Use setCompressedSize directly.,      * @since 1.2,      */,     public void setComprSize(long size) {,         setCompressedSize(size);,     }, ,     /**,      * Get the name of the entry.,      * @return the entry name,      * @since 1.9,      */,     public String getName() {,         return name == null ? super.getName() : name;,     }, ,     /**,      * Is this entry a directory?,      * @return true if the entry is a directory,      * @since 1.10,      */,     public boolean isDirectory() {,         return getName().endsWith("/");,     }, ,     /**,      * Set the name of the entry.,      * @param name the name to use,      */,     protected void setName(String name) {,         this.name = name;,     }, ,     /**,      * Get the hashCode of the entry.,      * This uses the name as the hashcode.,      * @return a hashcode.,      * @since Ant 1.7,      */,     public int hashCode() {,         // this method has severe consequences on performance. We cannot rely,         // on the super.hashCode() method since super.getName() always return,         // the empty string in the current implemention (there's no setter),         // so it is basically draining the performance of a hashmap lookup,         return getName().hashCode();,     }, ,     /**,      * The equality method. In this case, the implementation returns 'this == o',      * which is basically the equals method of the Object class.,      * @param o the object to compare to,      * @return true if this object is the same as <code>o</code>,      * @since Ant 1.7,      */,     public boolean equals(Object o) {,         return (this == o);,     }, ,     /**,      * If there are no extra fields, use the given fields as new extra,      * data - otherwise merge the fields assuming the existing fields,      * and the new fields stem from different locations inside the,      * archive.,      * @param f the extra fields to merge,      * @param local whether the new fields originate from local data,      */,     private void mergeExtraFields(ZipExtraField[] f, boolean local),         throws ZipException {,         if (extraFields == null) {,             setExtraFields(f);,         } else {,             for (int i = 0; i < f.length; i++) {,                 ZipExtraField existing;,                 if (f[i] instanceof UnparseableExtraFieldData) {,                     existing = unparseableExtra;,                 } else {,                     existing = getExtraField(f[i].getHeaderId());,                 },                 if (existing == null) {,                     addExtraField(f[i]);,                 } else {,                     if (local,                         || !(existing,                              instanceof CentralDirectoryParsingZipExtraField)) {,                         byte[] b = f[i].getLocalFileDataData();,                         existing.parseFromLocalFileData(b, 0, b.length);,                     } else {,                         byte[] b = f[i].getCentralDirectoryData();,                         ((CentralDirectoryParsingZipExtraField) existing),                             .parseFromCentralDirectoryData(b, 0, b.length);,                     },                 },             },             setExtra();,         },     }],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/tools/zip/ZipEntry.java,,55-516,[    private int internalAttributes = 0;,     private int platform = PLATFORM_FAT;,     private long externalAttributes = 0;,     private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;,     private UnparseableExtraFieldData unparseableExtra = null;,     private String name = null;, ,     /**,      * Creates a new zip entry with the specified name.,      * @param name the name of the entry,      * @since 1.1,      */,     public ZipEntry(String name) {,         super(name);,     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      * @param entry the entry to get fields from,      * @since 1.1,      * @throws ZipException on error,      */,     public ZipEntry(java.util.zip.ZipEntry entry) throws ZipException {,         super(entry);,         byte[] extra = entry.getExtra();,         if (extra != null) {,             setExtraFields(ExtraFieldUtils.parse(extra, true,,                                                  ExtraFieldUtils,                                                  .UnparseableExtraField.READ));,         } else {,             // initializes extra data to an empty byte array,             setExtra();,         },     }, ,     /**,      * Creates a new zip entry with fields taken from the specified zip entry.,      * @param entry the entry to get fields from,      * @throws ZipException on error,      * @since 1.1,      */,     public ZipEntry(ZipEntry entry) throws ZipException {,         this((java.util.zip.ZipEntry) entry);,         setInternalAttributes(entry.getInternalAttributes());,         setExternalAttributes(entry.getExternalAttributes());,         setExtraFields(entry.getExtraFields(true));,     }, ,     /**,      * @since 1.9,      */,     protected ZipEntry() {,         super("");,     }, ,     /**,      * Overwrite clone.,      * @return a cloned copy of this ZipEntry,      * @since 1.1,      */,     public Object clone() {,         ZipEntry e = (ZipEntry) super.clone();, ,         e.setInternalAttributes(getInternalAttributes());,         e.setExternalAttributes(getExternalAttributes());,         e.setExtraFields(getExtraFields(true));,         return e;,     }, ,     /**,      * Retrieves the internal file attributes.,      *,      * @return the internal file attributes,      * @since 1.1,      */,     public int getInternalAttributes() {,         return internalAttributes;,     }, ,     /**,      * Sets the internal file attributes.,      * @param value an <code>int</code> value,      * @since 1.1,      */,     public void setInternalAttributes(int value) {,         internalAttributes = value;,     }, ,     /**,      * Retrieves the external file attributes.,      * @return the external file attributes,      * @since 1.1,      */,     public long getExternalAttributes() {,         return externalAttributes;,     }, ,     /**,      * Sets the external file attributes.,      * @param value an <code>long</code> value,      * @since 1.1,      */,     public void setExternalAttributes(long value) {,         externalAttributes = value;,     }, ,     /**,      * Sets Unix permissions in a way that is understood by Info-Zip's,      * unzip command.,      * @param mode an <code>int</code> value,      * @since Ant 1.5.2,      */,     public void setUnixMode(int mode) {,         // CheckStyle:MagicNumberCheck OFF - no point,         setExternalAttributes((mode << SHORT_SHIFT),                               // MS-DOS read-only attribute,                               | ((mode & 0200) == 0 ? 1 : 0),                               // MS-DOS directory flag,                               | (isDirectory() ? 0x10 : 0));,         // CheckStyle:MagicNumberCheck ON,         platform = PLATFORM_UNIX;,     }, ,     /**,      * Unix permission.,      * @return the unix permissions,      * @since Ant 1.6,      */,     public int getUnixMode() {,         return platform != PLATFORM_UNIX ? 0 :,             (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);,     }, ,     /**,      * Platform specification to put into the &quot;version made,      * by&quot; part of the central file header.,      *,      * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode},      * has been called, in which case PLATORM_UNIX will be returned.,      *,      * @since Ant 1.5.2,      */,     public int getPlatform() {,         return platform;,     }, ,     /**,      * Set the platform (UNIX or FAT).,      * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX,      * @since 1.9,      */,     protected void setPlatform(int platform) {,         this.platform = platform;,     }, ,     /**,      * Replaces all currently attached extra fields with the new array.,      * @param fields an array of extra fields,      * @since 1.1,      */,     public void setExtraFields(ZipExtraField[] fields) {,         extraFields = new LinkedHashMap();,         for (int i = 0; i < fields.length; i++) {,             if (fields[i] instanceof UnparseableExtraFieldData) {,                 unparseableExtra = (UnparseableExtraFieldData) fields[i];,             } else {,                 extraFields.put(fields[i].getHeaderId(), fields[i]);,             },         },         setExtra();,     }, ,     /**,      * Retrieves all extra fields that have been parsed successfully.,      * @return an array of the extra fields,      */,     public ZipExtraField[] getExtraFields() {,         return getExtraFields(false);,     }, ,     /**,      * Retrieves extra fields.,      * @param includeUnparseable whether to also return unparseable,      * extra fields as {@link UnparseableExtraFieldData} if such data,      * exists.,      * @return an array of the extra fields,      * @since 1.1,      */,     public ZipExtraField[] getExtraFields(boolean includeUnparseable) {,         if (extraFields == null) {,             return !includeUnparseable || unparseableExtra == null,                 ? new ZipExtraField[0],                 : new ZipExtraField[] { unparseableExtra };,         },         List result = new ArrayList(extraFields.values());,         if (includeUnparseable && unparseableExtra != null) {,             result.add(unparseableExtra);,         },         return (ZipExtraField[]) result.toArray(new ZipExtraField[0]);,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>If no extra field of the same type exists, the field will be,      * added as last field.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addExtraField(ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             if (extraFields == null) {,                 extraFields = new LinkedHashMap();,             },             extraFields.put(ze.getHeaderId(), ze);,         },         setExtra();,     }, ,     /**,      * Adds an extra field - replacing an already present extra field,      * of the same type.,      *,      * <p>The new extra field will be the first one.</p>,      * @param ze an extra field,      * @since 1.1,      */,     public void addAsFirstExtraField(ZipExtraField ze) {,         if (ze instanceof UnparseableExtraFieldData) {,             unparseableExtra = (UnparseableExtraFieldData) ze;,         } else {,             LinkedHashMap copy = extraFields;,             extraFields = new LinkedHashMap();,             extraFields.put(ze.getHeaderId(), ze);,             if (copy != null) {,                 copy.remove(ze.getHeaderId());,                 extraFields.putAll(copy);,             },         },         setExtra();,     }, ,     /**,      * Remove an extra field.,      * @param type the type of extra field to remove,      * @since 1.1,      */,     public void removeExtraField(ZipShort type) {,         if (extraFields == null) {,             throw new java.util.NoSuchElementException();,         },         if (extraFields.remove(type) == null) {,             throw new java.util.NoSuchElementException();,         },         setExtra();,     }, ,     /**,      * Removes unparseable extra field data.,      */,     public void removeUnparseableExtraFieldData() {,         if (unparseableExtra == null) {,             throw new java.util.NoSuchElementException();,         },         unparseableExtra = null;,         setExtra();,     }, ,     /**,      * Looks up an extra field by its header id.,      *,      * @return null if no such field exists.,      */,     public ZipExtraField getExtraField(ZipShort type) {,         if (extraFields != null) {,             return (ZipExtraField) extraFields.get(type);,         },         return null;,     }, ,     /**,      * Looks up extra field data that couldn't be parsed correctly.,      *,      * @return null if no such field exists.,      */,     public UnparseableExtraFieldData getUnparseableExtraFieldData() {,         return unparseableExtra;,     }, ,     /**,      * Parses the given bytes as extra field data and consumes any,      * unparseable data as an {@link UnparseableExtraFieldData},      * instance.,      * @param extra an array of bytes to be parsed into extra fields,      * @throws RuntimeException if the bytes cannot be parsed,      * @since 1.1,      * @throws RuntimeException on error,      */,     public void setExtra(byte[] extra) throws RuntimeException {,         try {,             ZipExtraField[] local =,                 ExtraFieldUtils.parse(extra, true,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(local, true);,         } catch (Exception e) {,             // actually this is not be possible as of Ant 1.8.1,             throw new RuntimeException("Error parsing extra fields for entry: ",                                        + getName() + " - " + e.getMessage(), e);,         },     }, ,     /**,      * Unfortunately {@link java.util.zip.ZipOutputStream,      * java.util.zip.ZipOutputStream} seems to access the extra data,      * directly, so overriding getExtra doesn't help - we need to,      * modify super's data directly.,      *,      * @since 1.1,      */,     protected void setExtra() {,         super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));,     }, ,     /**,      * Sets the central directory part of extra fields.,      */,     public void setCentralDirectoryExtra(byte[] b) {,         try {,             ZipExtraField[] central =,                 ExtraFieldUtils.parse(b, false,,                                       ExtraFieldUtils.UnparseableExtraField.READ);,             mergeExtraFields(central, false);,         } catch (Exception e) {,             throw new RuntimeException(e.getMessage(), e);,         },     }, ,     /**,      * Retrieves the extra data for the local file data.,      * @return the extra data for local file,      * @since 1.1,      */,     public byte[] getLocalFileDataExtra() {,         byte[] extra = getExtra();,         return extra != null ? extra : new byte[0];,     }, ,     /**,      * Retrieves the extra data for the central directory.,      * @return the central directory extra data,      * @since 1.1,      */,     public byte[] getCentralDirectoryExtra() {,         return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));,     }, ,     /**,      * Make this class work in JDK 1.1 like a 1.2 class.,      *,      * <p>This either stores the size for later usage or invokes,      * setCompressedSize via reflection.</p>,      * @param size the size to use,      * @deprecated since 1.7.,      *             Use setCompressedSize directly.,      * @since 1.2,      */,     public void setComprSize(long size) {,         setCompressedSize(size);,     }, ,     /**,      * Get the name of the entry.,      * @return the entry name,      * @since 1.9,      */,     public String getName() {,         return name == null ? super.getName() : name;,     }, ,     /**,      * Is this entry a directory?,      * @return true if the entry is a directory,      * @since 1.10,      */,     public boolean isDirectory() {,         return getName().endsWith("/");,     }, ,     /**,      * Set the name of the entry.,      * @param name the name to use,      */,     protected void setName(String name) {,         this.name = name;,     }, ,     /**,      * Get the hashCode of the entry.,      * This uses the name as the hashcode.,      * @return a hashcode.,      * @since Ant 1.7,      */,     public int hashCode() {,         // this method has severe consequences on performance. We cannot rely,         // on the super.hashCode() method since super.getName() always return,         // the empty string in the current implemention (there's no setter),         // so it is basically draining the performance of a hashmap lookup,         return getName().hashCode();,     }, ,     /**,      * The equality method. In this case, the implementation returns 'this == o',      * which is basically the equals method of the Object class.,      * @param o the object to compare to,      * @return true if this object is the same as <code>o</code>,      * @since Ant 1.7,      */,     public boolean equals(Object o) {,         return (this == o);,     }, ,     /**,      * If there are no extra fields, use the given fields as new extra,      * data - otherwise merge the fields assuming the existing fields,      * and the new fields stem from different locations inside the,      * archive.,      * @param f the extra fields to merge,      * @param local whether the new fields originate from local data,      */,     private void mergeExtraFields(ZipExtraField[] f, boolean local),         throws ZipException {,         if (extraFields == null) {,             setExtraFields(f);,         } else {,             for (int i = 0; i < f.length; i++) {,                 ZipExtraField existing;,                 if (f[i] instanceof UnparseableExtraFieldData) {,                     existing = unparseableExtra;,                 } else {,                     existing = getExtraField(f[i].getHeaderId());,                 },                 if (existing == null) {,                     addExtraField(f[i]);,                 } else {,                     if (local,                         || !(existing,                              instanceof CentralDirectoryParsingZipExtraField)) {,                         byte[] b = f[i].getLocalFileDataData();,                         existing.parseFromLocalFileData(b, 0, b.length);,                     } else {,                         byte[] b = f[i].getCentralDirectoryData();,                         ((CentralDirectoryParsingZipExtraField) existing),                             .parseFromCentralDirectoryData(b, 0, b.length);,                     },                 },             },             setExtra();,         },     }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/zip/ZipLongTest.java,testEquals,71-71,[        assertTrue("non ZipLong handling", !zl.equals(new Integer(0x1234)));],,
CORRECTNESS,EC_UNRELATED_TYPES,org/apache/tools/zip/ZipLongTest.java,testEquals,71-71,[        assertTrue("non ZipLong handling", !zl.equals(new Integer(0x1234)));],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/zip/ZipOutputStream.java,,662-662,[    protected static final byte[] CFH_SIG = ZipLong.getBytes(0X02014B50L);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/zip/ZipOutputStream.java,,656-656,[    protected static final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/zip/ZipOutputStream.java,,668-668,[    protected static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/tools/zip/ZipOutputStream.java,,650-650,[    protected static final byte[] LFH_SIG = ZipLong.getBytes(0X04034B50L);],,
STYLE,NS_DANGEROUS_NON_SHORT_CIRCUIT,org/apache/tools/zip/ZipOutputStream.java,setEncoding,352-352,[        useUTF8Flag &= ZipEncodingHelper.isUTF8(encoding);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/tools/zip/ZipOutputStreamTest.java,testZipLong,65-65,[        assertEquals(test.getValue(), zl.getValue());],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/tools/zip/ZipShortTest.java,testEquals,69-69,[        assertTrue("non ZipShort handling", !zs.equals(new Integer(0x1234)));],,
CORRECTNESS,EC_UNRELATED_TYPES,org/apache/tools/zip/ZipShortTest.java,testEquals,69-69,[        assertTrue("non ZipShort handling", !zs.equals(new Integer(0x1234)));],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/tools/zip/ZipUtil.java,copy,35-35,[        return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/example/junit/ThreadedOutput.java,,35-38,[        Thread t = new Thread(new Runnable() {,                 public void run() {,                     System.out.println("foo");,                 }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/example/tasks/TaskdefTestSimpleTask.java,,26-29,[    public class Echo {,         Echo() {},         private String message = null;,         public void setMessage(String s) {message = s;}],,
